#![allow(dead_code, mutable_transmutes, non_camel_case_types, non_snake_case, non_upper_case_globals, unused_assignments, unused_mut)]
#![feature(c_variadic, extern_types)]
extern "C" {
    pub type _IO_wide_data;
    pub type _IO_codecvt;
    pub type _IO_marker;
    static mut stdout: *mut FILE;
    static mut stderr: *mut FILE;
    fn fclose(__stream: *mut FILE) -> libc::c_int;
    fn fflush(__stream: *mut FILE) -> libc::c_int;
    fn fopen(_: *const libc::c_char, _: *const libc::c_char) -> *mut FILE;
    fn fprintf(_: *mut FILE, _: *const libc::c_char, _: ...) -> libc::c_int;
    fn printf(_: *const libc::c_char, _: ...) -> libc::c_int;
    fn sprintf(_: *mut libc::c_char, _: *const libc::c_char, _: ...) -> libc::c_int;
    fn vfprintf(
        _: *mut FILE,
        _: *const libc::c_char,
        _: ::core::ffi::VaList,
    ) -> libc::c_int;
    fn getc(__stream: *mut FILE) -> libc::c_int;
    fn fputc(__c: libc::c_int, __stream: *mut FILE) -> libc::c_int;
    fn fputs(__s: *const libc::c_char, __stream: *mut FILE) -> libc::c_int;
    fn pclose(__stream: *mut FILE) -> libc::c_int;
    fn popen(__command: *const libc::c_char, __modes: *const libc::c_char) -> *mut FILE;
    fn strtol(
        _: *const libc::c_char,
        _: *mut *mut libc::c_char,
        _: libc::c_int,
    ) -> libc::c_long;
    fn malloc(_: libc::c_ulong) -> *mut libc::c_void;
    fn realloc(_: *mut libc::c_void, _: libc::c_ulong) -> *mut libc::c_void;
    fn free(_: *mut libc::c_void);
    fn abort() -> !;
    fn exit(_: libc::c_int) -> !;
    fn getenv(__name: *const libc::c_char) -> *mut libc::c_char;
    fn abs(_: libc::c_int) -> libc::c_int;
    fn lglinitopts(_: *mut LGL, _: *mut Opts);
    fn __ctype_b_loc() -> *mut *const libc::c_ushort;
    fn __ctype_tolower_loc() -> *mut *const __int32_t;
    fn __ctype_toupper_loc() -> *mut *const __int32_t;
    fn sqrt(_: libc::c_double) -> libc::c_double;
    fn memset(
        _: *mut libc::c_void,
        _: libc::c_int,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;
    fn strcpy(_: *mut libc::c_char, _: *const libc::c_char) -> *mut libc::c_char;
    fn memcpy(
        _: *mut libc::c_void,
        _: *const libc::c_void,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
    fn strcat(_: *mut libc::c_char, _: *const libc::c_char) -> *mut libc::c_char;
    fn strlen(_: *const libc::c_char) -> libc::c_ulong;
    fn getrusage(__who: __rusage_who_t, __usage: *mut rusage) -> libc::c_int;
    fn sleep(__seconds: libc::c_uint) -> libc::c_uint;
    fn getpid() -> __pid_t;
}
pub type __builtin_va_list = [__va_list_tag; 1];
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __va_list_tag {
    pub gp_offset: libc::c_uint,
    pub fp_offset: libc::c_uint,
    pub overflow_arg_area: *mut libc::c_void,
    pub reg_save_area: *mut libc::c_void,
}
pub type size_t = libc::c_ulong;
pub type __gnuc_va_list = __builtin_va_list;
pub type __int32_t = libc::c_int;
pub type __int64_t = libc::c_long;
pub type __uint64_t = libc::c_ulong;
pub type __off_t = libc::c_long;
pub type __off64_t = libc::c_long;
pub type __pid_t = libc::c_int;
pub type __time_t = libc::c_long;
pub type __suseconds_t = libc::c_long;
pub type __syscall_slong_t = libc::c_long;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _IO_FILE {
    pub _flags: libc::c_int,
    pub _IO_read_ptr: *mut libc::c_char,
    pub _IO_read_end: *mut libc::c_char,
    pub _IO_read_base: *mut libc::c_char,
    pub _IO_write_base: *mut libc::c_char,
    pub _IO_write_ptr: *mut libc::c_char,
    pub _IO_write_end: *mut libc::c_char,
    pub _IO_buf_base: *mut libc::c_char,
    pub _IO_buf_end: *mut libc::c_char,
    pub _IO_save_base: *mut libc::c_char,
    pub _IO_backup_base: *mut libc::c_char,
    pub _IO_save_end: *mut libc::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: libc::c_int,
    pub _flags2: libc::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: libc::c_ushort,
    pub _vtable_offset: libc::c_schar,
    pub _shortbuf: [libc::c_char; 1],
    pub _lock: *mut libc::c_void,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut libc::c_void,
    pub __pad5: size_t,
    pub _mode: libc::c_int,
    pub _unused2: [libc::c_char; 20],
}
pub type _IO_lock_t = ();
pub type FILE = _IO_FILE;
pub type va_list = __gnuc_va_list;
pub type int64_t = __int64_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct LGL {
    pub state: State,
    pub probing: libc::c_int,
    pub tid: libc::c_int,
    pub tids: libc::c_int,
    pub nvars: libc::c_int,
    pub szvars: libc::c_int,
    pub maxext: libc::c_int,
    pub szext: libc::c_int,
    pub changed: libc::c_int,
    pub mt: libc::c_int,
    pub repcntdown: libc::c_int,
    pub szdrail: libc::c_int,
    pub next: libc::c_int,
    pub next2: libc::c_int,
    pub flushed: libc::c_int,
    pub level: libc::c_int,
    pub alevel: libc::c_int,
    pub wait: libc::c_int,
    pub glag: libc::c_int,
    pub unassigned: libc::c_int,
    pub lrgluereasons: libc::c_int,
    pub failed: libc::c_int,
    pub assumed: libc::c_int,
    pub scinc: Flt,
    pub scincf: Flt,
    pub maxscore: Flt,
    pub minscore: Flt,
    pub scincinc: libc::c_int,
    pub cceing: libc::c_char,
    pub gaussing: libc::c_char,
    pub bcaing: libc::c_char,
    pub repforcehead: libc::c_char,
    pub quatres: libc::c_char,
    pub notrim: libc::c_char,
    pub searching: libc::c_char,
    pub simp: libc::c_char,
    pub allphaseset: libc::c_char,
    pub flushphases: libc::c_char,
    pub occs: libc::c_char,
    pub unhiding: libc::c_char,
    pub basicprobing: libc::c_char,
    pub simpleprobing: libc::c_char,
    pub treelooking: libc::c_char,
    pub setuponce: libc::c_char,
    pub eliminating: libc::c_char,
    pub donotsched: libc::c_char,
    pub blocking: libc::c_char,
    pub ternresing: libc::c_char,
    pub lkhd: libc::c_char,
    pub allfrozen: libc::c_char,
    pub blkall: libc::c_char,
    pub blkrem: libc::c_char,
    pub blkrtc: libc::c_char,
    pub elmall: libc::c_char,
    pub elmrem: libc::c_char,
    pub elmrtc: libc::c_char,
    pub sweeprtc: libc::c_char,
    pub decomposing: libc::c_char,
    pub frozen: libc::c_char,
    pub dense: libc::c_char,
    pub rmredbintrn: libc::c_char,
    pub notfullyconnected: libc::c_char,
    pub forcegc: libc::c_char,
    pub allowforce: libc::c_char,
    pub ccertc: libc::c_char,
    pub touching: libc::c_char,
    pub sweeping: libc::c_char,
    pub confatlastit: int64_t,
    pub parent: *mut LGL,
    pub forked: libc::c_int,
    pub conf: Conf,
    pub rng: RNG,
    pub mem: *mut Mem,
    pub opts: *mut Opts,
    pub stats: *mut Stats,
    pub times: *mut Times,
    pub timers: *mut Timers,
    pub limits: *mut Limits,
    pub ext: *mut Ext,
    pub i2e: *mut libc::c_int,
    pub doms: *mut libc::c_int,
    pub dvars: *mut DVar,
    pub qvars: *mut QVar,
    pub avars: *mut AVar,
    pub vals: *mut Val,
    pub jwh: *mut Flt,
    pub drail: *mut TD,
    pub red: *mut Stk,
    pub wchs: *mut Wchs,
    pub control: Ctk,
    pub clause: Stk,
    pub eclause: Stk,
    pub extend: Stk,
    pub irr: Stk,
    pub trail: Stk,
    pub frames: Stk,
    pub promote: Stk,
    pub eassume: Stk,
    pub assume: Stk,
    pub learned: Stk,
    pub dsched: Stk,
    pub queue: Queue,
    pub c2rust_unnamed: C2RustUnnamed_14,
    pub c2rust_unnamed_0: C2RustUnnamed_13,
    pub poisoned: Stk,
    pub seen: Stk,
    pub esched: Stk,
    pub minstk: Stk,
    pub resolvent: Stk,
    pub saved: C2RustUnnamed_12,
    pub evars: *mut EVar,
    pub dis: *mut Dis,
    pub wrk: *mut Wrk,
    pub repr: *mut libc::c_int,
    pub closeapitrace: libc::c_char,
    pub out: *mut FILE,
    pub apitrace: *mut FILE,
    pub trace: *mut FILE,
    pub prefix: *mut libc::c_char,
    pub cbs: *mut Cbs,
    pub clone: *mut LGL,
    pub fltstr: *mut FltStr,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct FltStr {
    pub current: libc::c_int,
    pub str_0: [[libc::c_char; 100]; 6],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Cbs {
    pub term: C2RustUnnamed_10,
    pub units: C2RustUnnamed_7,
    pub cls: C2RustUnnamed_3,
    pub eqs: C2RustUnnamed_0,
    pub msglock: C2RustUnnamed,
    pub getime: Option::<unsafe extern "C" fn() -> libc::c_double>,
    pub onabort: Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
    pub abortstate: *mut libc::c_void,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed {
    pub lock: Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
    pub unlock: Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
    pub state: *mut libc::c_void,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_0 {
    pub lock: C2RustUnnamed_2,
    pub unlock: C2RustUnnamed_1,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_1 {
    pub fun: Option::<
        unsafe extern "C" fn(*mut libc::c_void, libc::c_int, libc::c_int) -> (),
    >,
    pub state: *mut libc::c_void,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_2 {
    pub fun: Option::<unsafe extern "C" fn(*mut libc::c_void) -> *mut libc::c_int>,
    pub state: *mut libc::c_void,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_3 {
    pub produce: C2RustUnnamed_6,
    pub consume: C2RustUnnamed_5,
    pub consumed: C2RustUnnamed_4,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_4 {
    pub fun: Option::<unsafe extern "C" fn(*mut libc::c_void, libc::c_int) -> ()>,
    pub state: *mut libc::c_void,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_5 {
    pub fun: Option::<
        unsafe extern "C" fn(
            *mut libc::c_void,
            *mut *mut libc::c_int,
            *mut libc::c_int,
        ) -> (),
    >,
    pub state: *mut libc::c_void,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_6 {
    pub fun: Option::<
        unsafe extern "C" fn(*mut libc::c_void, *mut libc::c_int, libc::c_int) -> (),
    >,
    pub state: *mut libc::c_void,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_7 {
    pub produce: C2RustUnnamed_9,
    pub consumed: C2RustUnnamed_9,
    pub consume: C2RustUnnamed_8,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_8 {
    pub fun: Option::<
        unsafe extern "C" fn(
            *mut libc::c_void,
            *mut *mut libc::c_int,
            *mut *mut libc::c_int,
        ) -> (),
    >,
    pub state: *mut libc::c_void,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_9 {
    pub fun: Option::<unsafe extern "C" fn(*mut libc::c_void, libc::c_int) -> ()>,
    pub state: *mut libc::c_void,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_10 {
    pub fun: Option::<unsafe extern "C" fn(*mut libc::c_void) -> libc::c_int>,
    pub state: *mut libc::c_void,
    pub done: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Wrk {
    pub queue: Stk,
    pub count: libc::c_int,
    pub head: libc::c_int,
    pub size: libc::c_int,
    pub posonly: libc::c_int,
    pub fifo: libc::c_int,
    pub pos: *mut libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Stk {
    pub start: *mut libc::c_int,
    pub top: *mut libc::c_int,
    pub end: *mut libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Dis {
    pub red: C2RustUnnamed_11,
    pub irr: C2RustUnnamed_11,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_11 {
    pub bin: Stk,
    pub trn: Stk,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct EVar {
    pub occ: [libc::c_int; 2],
    pub pos: libc::c_int,
    pub score: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_12 {
    pub bin: Stk,
    pub trn: Stk,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_13 {
    pub lcaseen: Stk,
    pub sortstk: Stk,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_14 {
    pub elm: *mut Elm,
    pub sprb: *mut SPrb,
    pub tlk: *mut Tlk,
    pub gauss: *mut Gauss,
    pub cce: *mut CCE,
    pub bca: *mut BCA,
    pub card: *mut Card,
    pub swp: *mut SWP,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct SWP {
    pub partitions: libc::c_int,
    pub round: libc::c_int,
    pub query: libc::c_int,
    pub sat: libc::c_int,
    pub type_0: libc::c_int,
    pub partition: Stk,
    pub sumsize: C2RustUnnamed_17,
    pub decision: C2RustUnnamed_15,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_15 {
    pub count: libc::c_int,
    pub cached: C2RustUnnamed_16,
    pub stk: Stk,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_16 {
    pub a: libc::c_int,
    pub b: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_17 {
    pub classes: int64_t,
    pub envs: int64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Card {
    pub atmost1: Stk,
    pub atmost2: Stk,
    pub cards: Stk,
    pub elim: Stk,
    pub occs: *mut Stk,
    pub units: Stk,
    pub expam1: Stk,
    pub eliminated: *mut libc::c_char,
    pub lit2used: *mut libc::c_char,
    pub marked: *mut libc::c_char,
    pub count: *mut libc::c_schar,
    pub lit2count: *mut libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct BCA {
    pub covered: Stk,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CCE {
    pub cla: Stk,
    pub extend: Stk,
    pub clauses: Stk,
    pub rem: *mut libc::c_int,
    pub bin: libc::c_int,
    pub trn: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Gauss {
    pub xors: Stk,
    pub order: Stk,
    pub occs: *mut Stk,
    pub eliminated: *mut libc::c_schar,
    pub garbage: libc::c_int,
    pub next: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Tlk {
    pub stk: Stk,
    pub seen: Stk,
    pub tvars: *mut TVar,
    pub lkhd: *mut LKHD,
}
pub type LKHD = Flt;
pub type Flt = int64_t;
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct TVar {
    #[bitfield(name = "val", ty = "libc::c_int", bits = "0..=29")]
    #[bitfield(name = "mark", ty = "libc::c_uint", bits = "30..=31")]
    pub val_mark: [u8; 4],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct SPrb {
    pub units: Stk,
    pub impls: Stk,
    pub eqs: Stk,
    pub counted: Stk,
    pub marked: Stk,
    pub spes: *mut SPE,
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct SPE {
    #[bitfield(name = "count", ty = "libc::c_int", bits = "0..=30")]
    #[bitfield(name = "mark", ty = "libc::c_uint", bits = "31..=31")]
    pub count_mark: [u8; 4],
    pub sum: libc::c_uint,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Elm {
    pub oldsteps: int64_t,
    pub pivot: libc::c_int,
    pub negcls: libc::c_int,
    pub necls: libc::c_int,
    pub neglidx: libc::c_int,
    pub round: libc::c_int,
    pub oldelmd: libc::c_int,
    pub lits: Stk,
    pub next: Stk,
    pub clv: Stk,
    pub csigs: Stk,
    pub sizes: Stk,
    pub occs: Stk,
    pub noccs: Stk,
    pub mark: Stk,
    pub m2i: Stk,
    pub touched: C2RustUnnamed_18,
    pub bkwdocclim: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_18 {
    pub stk: Stk,
    pub pos: *mut libc::c_int,
    pub mt: libc::c_int,
    pub nvars: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Queue {
    pub stk: Stk,
    pub mt: libc::c_int,
    pub next: libc::c_int,
    pub sorted: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Ctk {
    pub start: *mut Ctr,
    pub top: *mut Ctr,
    pub end: *mut Ctr,
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct Ctr {
    #[bitfield(name = "decision", ty = "libc::c_int", bits = "0..=27")]
    #[bitfield(name = "used", ty = "libc::c_uint", bits = "28..=29")]
    #[bitfield(name = "used2", ty = "libc::c_uint", bits = "30..=31")]
    pub decision_used_used2: [u8; 4],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Wchs {
    pub stk: Stk,
    pub start: [libc::c_uint; 31],
    pub free: libc::c_int,
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct TD {
    #[bitfield(name = "level", ty = "libc::c_int", bits = "0..=29")]
    #[bitfield(name = "lrglue", ty = "libc::c_uint", bits = "30..=30")]
    #[bitfield(name = "irr", ty = "libc::c_uint", bits = "31..=31")]
    pub level_lrglue_irr: [u8; 4],
    pub rsn: [libc::c_int; 2],
}
pub type Val = libc::c_schar;
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct AVar {
    #[bitfield(name = "type_0", ty = "libc::c_uint", bits = "0..=3")]
    #[bitfield(name = "equiv", ty = "libc::c_uint", bits = "4..=4")]
    #[bitfield(name = "lcamark", ty = "libc::c_uint", bits = "5..=8")]
    #[bitfield(name = "phase", ty = "libc::c_int", bits = "9..=10")]
    #[bitfield(name = "bias", ty = "libc::c_int", bits = "11..=12")]
    #[bitfield(name = "fase", ty = "libc::c_int", bits = "13..=14")]
    #[bitfield(name = "inred", ty = "libc::c_uint", bits = "15..=16")]
    #[bitfield(name = "poisoned", ty = "libc::c_uint", bits = "17..=17")]
    #[bitfield(name = "assumed", ty = "libc::c_uint", bits = "18..=19")]
    #[bitfield(name = "failed", ty = "libc::c_uint", bits = "20..=21")]
    #[bitfield(name = "donotelm", ty = "libc::c_uint", bits = "22..=22")]
    #[bitfield(name = "donotblk", ty = "libc::c_uint", bits = "23..=23")]
    #[bitfield(name = "donoternres", ty = "libc::c_uint", bits = "24..=24")]
    #[bitfield(name = "donotbasicprobe", ty = "libc::c_uint", bits = "25..=25")]
    #[bitfield(name = "donotsimpleprobe", ty = "libc::c_uint", bits = "26..=26")]
    #[bitfield(name = "donotreelook", ty = "libc::c_uint", bits = "27..=27")]
    #[bitfield(name = "donotsweep", ty = "libc::c_uint", bits = "28..=28")]
    pub type_0_equiv_lcamark_phase_bias_fase_inred_poisoned_assumed_failed_donotelm_donotblk_donoternres_donotbasicprobe_donotsimpleprobe_donotreelook_donotsweep: [u8; 4],
    pub mark: libc::c_int,
    pub trail: libc::c_int,
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct QVar {
    pub score: Flt,
    #[bitfield(name = "enqueued", ty = "libc::c_uint", bits = "0..=0")]
    #[bitfield(name = "important", ty = "libc::c_uint", bits = "1..=1")]
    #[bitfield(name = "glag", ty = "libc::c_int", bits = "2..=31")]
    pub enqueued_important_glag: [u8; 4],
    pub pos: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct DVar {
    pub hts: [HTS; 2],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct HTS {
    pub offset: libc::c_uint,
    pub count: libc::c_uint,
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct Ext {
    #[bitfield(name = "equiv", ty = "libc::c_uint", bits = "0..=0")]
    #[bitfield(name = "melted", ty = "libc::c_uint", bits = "1..=1")]
    #[bitfield(name = "blocking", ty = "libc::c_uint", bits = "2..=3")]
    #[bitfield(name = "eliminated", ty = "libc::c_uint", bits = "4..=4")]
    #[bitfield(name = "tmpfrozen", ty = "libc::c_uint", bits = "5..=5")]
    #[bitfield(name = "imported", ty = "libc::c_uint", bits = "6..=6")]
    #[bitfield(name = "assumed", ty = "libc::c_uint", bits = "7..=8")]
    #[bitfield(name = "failed", ty = "libc::c_uint", bits = "9..=10")]
    #[bitfield(name = "aliased", ty = "libc::c_uint", bits = "11..=11")]
    #[bitfield(name = "important", ty = "libc::c_uint", bits = "12..=12")]
    #[bitfield(name = "val", ty = "libc::c_int", bits = "13..=14")]
    #[bitfield(name = "oldval", ty = "libc::c_int", bits = "15..=16")]
    pub equiv_melted_blocking_eliminated_tmpfrozen_imported_assumed_failed_aliased_important_val_oldval: [u8; 3],
    #[bitfield(padding)]
    pub c2rust_padding: [u8; 1],
    pub repr: libc::c_int,
    pub frozen: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Limits {
    pub lkhdpen: libc::c_int,
    pub randec: int64_t,
    pub randphase: int64_t,
    pub dfg: int64_t,
    pub inc: C2RustUnnamed_37,
    pub rescore: C2RustUnnamed_35,
    pub elm: C2RustUnnamed_34,
    pub blk: C2RustUnnamed_34,
    pub trd: C2RustUnnamed_33,
    pub unhd: C2RustUnnamed_33,
    pub ternres: C2RustUnnamed_33,
    pub quatres: C2RustUnnamed_33,
    pub cce: C2RustUnnamed_33,
    pub card: C2RustUnnamed_33,
    pub sweep: C2RustUnnamed_33,
    pub gauss: C2RustUnnamed_31,
    pub restart: C2RustUnnamed_30,
    pub prb: C2RustUnnamed_28,
    pub simp: C2RustUnnamed_27,
    pub sync: C2RustUnnamed_26,
    pub term: C2RustUnnamed_25,
    pub gc: C2RustUnnamed_24,
    pub bca: C2RustUnnamed_23,
    pub trep: C2RustUnnamed_22,
    pub locs: C2RustUnnamed_21,
    pub reduce: C2RustUnnamed_20,
    pub prune: C2RustUnnamed_19,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_19 {
    pub decisions: int64_t,
    pub inc: int64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_20 {
    pub redlarge: libc::c_int,
    pub reset: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_21 {
    pub confs: int64_t,
    pub inc: int64_t,
    pub vars: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_22 {
    pub steps: int64_t,
    pub time: int64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_23 {
    pub del: Del,
    pub steps: int64_t,
    pub added: int64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Del {
    pub cur: libc::c_int,
    pub rem: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_24 {
    pub fixed: int64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_25 {
    pub steps: int64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_26 {
    pub steps: int64_t,
    pub confs: int64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_27 {
    pub confs: int64_t,
    pub hard: int64_t,
    pub vars: int64_t,
    pub its: int64_t,
    pub bin: int64_t,
    pub trn: int64_t,
    pub cinc: libc::c_int,
    pub itinc: libc::c_int,
    pub binc: libc::c_int,
    pub tinc: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_28 {
    pub steps: int64_t,
    pub simple: C2RustUnnamed_29,
    pub basic: C2RustUnnamed_29,
    pub treelook: C2RustUnnamed_29,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_29 {
    pub pen: libc::c_int,
    pub del: Del,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_30 {
    pub confs: int64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_31 {
    pub pen: libc::c_int,
    pub del: Del,
    pub steps: C2RustUnnamed_32,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_32 {
    pub extr: int64_t,
    pub elim: int64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_33 {
    pub pen: libc::c_int,
    pub del: Del,
    pub steps: int64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_34 {
    pub pen: libc::c_int,
    pub del: Del,
    pub steps: int64_t,
    pub irrprgss: int64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_35 {
    pub vars: C2RustUnnamed_36,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_36 {
    pub otfs: int64_t,
    pub confs: int64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_37 {
    pub visits: int64_t,
    pub clauses: C2RustUnnamed_39,
    pub vars: C2RustUnnamed_38,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_38 {
    pub start: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_39 {
    pub add: int64_t,
    pub start: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Timers {
    pub stk: [Timer; 10],
    pub nest: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Timer {
    pub start: libc::c_double,
    pub idx: libc::c_int,
    pub ign: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Times {
    pub all: libc::c_double,
    pub search: libc::c_double,
    pub preprocessing: libc::c_double,
    pub inprocessing: libc::c_double,
    pub lookahead: libc::c_double,
    pub elim: libc::c_double,
    pub transred: libc::c_double,
    pub block: libc::c_double,
    pub unhide: libc::c_double,
    pub ternres: libc::c_double,
    pub gauss: libc::c_double,
    pub quatres: libc::c_double,
    pub card: libc::c_double,
    pub cce: libc::c_double,
    pub bca: libc::c_double,
    pub locs: libc::c_double,
    pub sweep: libc::c_double,
    pub showscoredist: libc::c_double,
    pub showfeatures: libc::c_double,
    pub prune: libc::c_double,
    pub probe: libc::c_double,
    pub prb: C2RustUnnamed_40,
    pub quatres1: libc::c_double,
    pub quatres2: libc::c_double,
    pub gc: libc::c_double,
    pub decompose: libc::c_double,
    pub queuesort: libc::c_double,
    pub phase: libc::c_double,
    pub backward: libc::c_double,
    pub restart: libc::c_double,
    pub defrag: libc::c_double,
    pub reduce: libc::c_double,
    pub analysis: libc::c_double,
    pub decide: libc::c_double,
    pub bump: libc::c_double,
    pub mincls: libc::c_double,
    pub druplig: libc::c_double,
    pub redcls: libc::c_double,
    pub queuedecision: libc::c_double,
    pub heapdecision: libc::c_double,
    pub subl: libc::c_double,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_40 {
    pub simple: libc::c_double,
    pub basic: libc::c_double,
    pub treelook: libc::c_double,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Stats {
    pub agility: int64_t,
    pub steps: int64_t,
    pub trims: int64_t,
    pub bins: int64_t,
    pub trns: int64_t,
    pub times: int64_t,
    pub defrags: libc::c_int,
    pub reported: libc::c_int,
    pub features: libc::c_int,
    pub repcntdown: libc::c_int,
    pub gcs: libc::c_int,
    pub decomps: libc::c_int,
    pub rescored: C2RustUnnamed_125,
    pub restarts: C2RustUnnamed_122,
    pub reduced: C2RustUnnamed_121,
    pub prune: C2RustUnnamed_119,
    pub prgss: int64_t,
    pub irrprgss: int64_t,
    pub enlwchs: int64_t,
    pub pshwchs: int64_t,
    pub dense: int64_t,
    pub sparse: int64_t,
    pub confs: int64_t,
    pub decisions: int64_t,
    pub hdecs: int64_t,
    pub qdecs: int64_t,
    pub randecs: int64_t,
    pub randphases: int64_t,
    pub uips: int64_t,
    pub decflipped: int64_t,
    pub glue: MACD,
    pub jlevel: MACD,
    pub tlevel: EMA,
    pub avglue: AVG,
    pub its: C2RustUnnamed_117,
    pub irr: C2RustUnnamed_115,
    pub calls: C2RustUnnamed_114,
    pub props: C2RustUnnamed_113,
    pub visits: C2RustUnnamed_113,
    pub bytes: C2RustUnnamed_112,
    pub red: C2RustUnnamed_111,
    pub hbr: C2RustUnnamed_110,
    pub fixed: C2RustUnnamed_109,
    pub equiv: C2RustUnnamed_109,
    pub ternres: C2RustUnnamed_108,
    pub blk: C2RustUnnamed_107,
    pub prb: C2RustUnnamed_102,
    pub trd: C2RustUnnamed_101,
    pub bindup: C2RustUnnamed_100,
    pub unhd: C2RustUnnamed_94,
    pub elm: C2RustUnnamed_92,
    pub bkwd: C2RustUnnamed_90,
    pub otfs: C2RustUnnamed_88,
    pub lits: C2RustUnnamed_87,
    pub clauses: C2RustUnnamed_85,
    pub lir: [C2RustUnnamed_84; 16],
    pub phase: C2RustUnnamed_83,
    pub simp: C2RustUnnamed_81,
    pub gauss: C2RustUnnamed_75,
    pub cce: C2RustUnnamed_73,
    pub card: C2RustUnnamed_66,
    pub moved: C2RustUnnamed_65,
    pub bca: C2RustUnnamed_64,
    pub sync: C2RustUnnamed_61,
    pub deco: C2RustUnnamed_59,
    pub mincls: C2RustUnnamed_56,
    pub redcls: C2RustUnnamed_53,
    pub drupped: int64_t,
    pub druplig: int64_t,
    pub subl: C2RustUnnamed_52,
    pub locs: C2RustUnnamed_51,
    pub sweep: C2RustUnnamed_47,
    pub setscincf: C2RustUnnamed_46,
    pub promote: C2RustUnnamed_45,
    pub quatres: C2RustUnnamed_44,
    pub queue: C2RustUnnamed_43,
    pub bump: C2RustUnnamed_42,
    pub stability: C2RustUnnamed_41,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_41 {
    pub count: int64_t,
    pub avg: EMA,
    pub changed: libc::c_int,
    pub level: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct EMA {
    pub shift: libc::c_int,
    pub count: libc::c_int,
    pub val: int64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_42 {
    pub count: int64_t,
    pub lits: int64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_43 {
    pub flushed: int64_t,
    pub sorted: int64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_44 {
    pub count: libc::c_int,
    pub quat: int64_t,
    pub self1: int64_t,
    pub self2: int64_t,
    pub dup: int64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_45 {
    pub tried: int64_t,
    pub locked: int64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_46 {
    pub count: int64_t,
    pub max: libc::c_int,
    pub min: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_47 {
    pub count: libc::c_int,
    pub failed: libc::c_int,
    pub impls: libc::c_int,
    pub equivs: libc::c_int,
    pub rounds: int64_t,
    pub steps: int64_t,
    pub cached: int64_t,
    pub sat: int64_t,
    pub unsat: int64_t,
    pub decs: int64_t,
    pub confs: int64_t,
    pub sumsize: C2RustUnnamed_50,
    pub queries: C2RustUnnamed_48,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_48 {
    pub total: int64_t,
    pub type_0: [C2RustUnnamed_49; 3],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_49 {
    pub count: int64_t,
    pub sat: int64_t,
    pub unsat: int64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_50 {
    pub classes: int64_t,
    pub envs: int64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_51 {
    pub count: libc::c_int,
    pub flips: int64_t,
    pub mems: int64_t,
    pub min: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_52 {
    pub count: int64_t,
    pub tried: int64_t,
    pub cands: int64_t,
    pub sub: int64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_53 {
    pub cls: C2RustUnnamed_55,
    pub lits: C2RustUnnamed_55,
    pub jlevel: C2RustUnnamed_54,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_54 {
    pub red: int64_t,
    pub sum: int64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_55 {
    pub tried: int64_t,
    pub red: int64_t,
    pub sat: int64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_56 {
    pub min: int64_t,
    pub bin: int64_t,
    pub size: int64_t,
    pub deco: int64_t,
    pub poison: C2RustUnnamed_58,
    pub usedtwice: C2RustUnnamed_57,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_57 {
    pub search: int64_t,
    pub hits: int64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_58 {
    pub search: int64_t,
    pub hits: int64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_59 {
    pub sum: C2RustUnnamed_60,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_60 {
    pub orig: int64_t,
    pub red: int64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_61 {
    pub cls: C2RustUnnamed_62,
    pub units: C2RustUnnamed_62,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_62 {
    pub produced: int64_t,
    pub consumed: C2RustUnnamed_63,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_63 {
    pub actual: int64_t,
    pub tried: int64_t,
    pub calls: int64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_64 {
    pub count: libc::c_int,
    pub added: int64_t,
    pub skipped: int64_t,
    pub steps: int64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_65 {
    pub bin: int64_t,
    pub trn: int64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_66 {
    pub count: libc::c_int,
    pub units: libc::c_int,
    pub expam1: libc::c_int,
    pub resched: libc::c_int,
    pub steps: int64_t,
    pub eliminated: int64_t,
    pub resolved: int64_t,
    pub subsumed: int64_t,
    pub found: C2RustUnnamed_69,
    pub used: C2RustUnnamed_67,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_67 {
    pub am1: C2RustUnnamed_68,
    pub am2: C2RustUnnamed_68,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_68 {
    pub sum: int64_t,
    pub cnt: int64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_69 {
    pub am1: C2RustUnnamed_70,
    pub am2: C2RustUnnamed_70,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_70 {
    pub total: C2RustUnnamed_72,
    pub last: C2RustUnnamed_71,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_71 {
    pub cnt: libc::c_int,
    pub max: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_72 {
    pub sum: int64_t,
    pub cnt: int64_t,
    pub max: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_73 {
    pub count: libc::c_int,
    pub eliminated: libc::c_int,
    pub ate: libc::c_int,
    pub abce: libc::c_int,
    pub failed: libc::c_int,
    pub lifted: libc::c_int,
    pub steps: int64_t,
    pub probed: int64_t,
    pub cache: C2RustUnnamed_74,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_74 {
    pub search: int64_t,
    pub hits: int64_t,
    pub cols: int64_t,
    pub ins: int64_t,
    pub rsz: int64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_75 {
    pub count: libc::c_int,
    pub gcs: libc::c_int,
    pub units: libc::c_int,
    pub equivs: libc::c_int,
    pub trneqs: libc::c_int,
    pub arity: C2RustUnnamed_78,
    pub steps: C2RustUnnamed_77,
    pub extracted: C2RustUnnamed_76,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_76 {
    pub total: int64_t,
    pub exactly1: int64_t,
    pub last: int64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_77 {
    pub extr: int64_t,
    pub elim: int64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_78 {
    pub max: C2RustUnnamed_80,
    pub sum: C2RustUnnamed_79,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_79 {
    pub total: int64_t,
    pub exactly1: int64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_80 {
    pub total: libc::c_int,
    pub last: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_81 {
    pub count: libc::c_int,
    pub limhit: C2RustUnnamed_82,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_82 {
    pub confs: libc::c_int,
    pub irr: libc::c_int,
    pub vars: libc::c_int,
    pub its: libc::c_int,
    pub bin: libc::c_int,
    pub trn: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_83 {
    pub count: libc::c_int,
    pub set: int64_t,
    pub pos: int64_t,
    pub neg: int64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_84 {
    pub clauses: libc::c_int,
    pub added: int64_t,
    pub reduced: int64_t,
    pub retired: int64_t,
    pub resolved: int64_t,
    pub forcing: int64_t,
    pub conflicts: int64_t,
    pub maxbytes: int64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_85 {
    pub learned: int64_t,
    pub glue: int64_t,
    pub realglue: int64_t,
    pub nonmaxglue: int64_t,
    pub scglue: int64_t,
    pub maxglue: C2RustUnnamed_86,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_86 {
    pub count: int64_t,
    pub kept: int64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_87 {
    pub nonmin: int64_t,
    pub learned: int64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_88 {
    pub sub: C2RustUnnamed_89,
    pub str_0: C2RustUnnamed_89,
    pub driving: int64_t,
    pub restarting: int64_t,
    pub total: int64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_89 {
    pub irr: int64_t,
    pub red: int64_t,
    pub bin: int64_t,
    pub trn: int64_t,
    pub lrg: int64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_90 {
    pub sub2: libc::c_int,
    pub sub3: libc::c_int,
    pub subl: libc::c_int,
    pub str2: libc::c_int,
    pub str3: libc::c_int,
    pub str3self: libc::c_int,
    pub strl: libc::c_int,
    pub strlself: libc::c_int,
    pub tried: C2RustUnnamed_91,
    pub steps: int64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_91 {
    pub lits: int64_t,
    pub clauses: int64_t,
    pub occs: int64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_92 {
    pub count: libc::c_int,
    pub elmd: libc::c_int,
    pub pure_0: libc::c_int,
    pub large: libc::c_int,
    pub sub: libc::c_int,
    pub str_0: libc::c_int,
    pub blkd: libc::c_int,
    pub rounds: libc::c_int,
    pub small: C2RustUnnamed_93,
    pub resolutions: int64_t,
    pub copies: int64_t,
    pub subchks: int64_t,
    pub strchks: int64_t,
    pub ipos: int64_t,
    pub steps: int64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_93 {
    pub elm: libc::c_int,
    pub tried: libc::c_int,
    pub failed: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_94 {
    pub count: libc::c_int,
    pub rounds: libc::c_int,
    pub stamp: C2RustUnnamed_99,
    pub failed: C2RustUnnamed_98,
    pub tauts: C2RustUnnamed_97,
    pub units: C2RustUnnamed_96,
    pub hbrs: C2RustUnnamed_95,
    pub str_0: C2RustUnnamed_95,
    pub steps: int64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_95 {
    pub trn: libc::c_int,
    pub lrg: libc::c_int,
    pub red: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_96 {
    pub bin: libc::c_int,
    pub trn: libc::c_int,
    pub lrg: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_97 {
    pub bin: libc::c_int,
    pub trn: libc::c_int,
    pub lrg: libc::c_int,
    pub red: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_98 {
    pub lits: libc::c_int,
    pub bin: libc::c_int,
    pub trn: libc::c_int,
    pub lrg: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_99 {
    pub trds: libc::c_int,
    pub failed: libc::c_int,
    pub sccs: libc::c_int,
    pub sumsccsizes: int64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_100 {
    pub removed: libc::c_int,
    pub red: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_101 {
    pub count: libc::c_int,
    pub red: libc::c_int,
    pub failed: libc::c_int,
    pub lits: int64_t,
    pub bins: int64_t,
    pub steps: int64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_102 {
    pub simple: C2RustUnnamed_106,
    pub basic: C2RustUnnamed_104,
    pub treelook: C2RustUnnamed_103,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_103 {
    pub count: libc::c_int,
    pub failed: libc::c_int,
    pub lifted: libc::c_int,
    pub probed: int64_t,
    pub steps: int64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_104 {
    pub count: libc::c_int,
    pub failed: libc::c_int,
    pub lifted: libc::c_int,
    pub probed: int64_t,
    pub steps: int64_t,
    pub lastate: int64_t,
    pub ate: C2RustUnnamed_105,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_105 {
    pub trnr: libc::c_int,
    pub lrg: libc::c_int,
    pub count: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_106 {
    pub count: libc::c_int,
    pub failed: libc::c_int,
    pub eqs: libc::c_int,
    pub probed: int64_t,
    pub steps: int64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_107 {
    pub count: libc::c_int,
    pub clauses: libc::c_int,
    pub lits: libc::c_int,
    pub pure_0: libc::c_int,
    pub res: int64_t,
    pub steps: int64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_108 {
    pub count: libc::c_int,
    pub bin: libc::c_int,
    pub trn: libc::c_int,
    pub steps: int64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_109 {
    pub current: libc::c_int,
    pub sum: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_110 {
    pub cnt: libc::c_int,
    pub simple: libc::c_int,
    pub trn: libc::c_int,
    pub lrg: libc::c_int,
    pub sub: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_111 {
    pub bin: libc::c_int,
    pub trn: libc::c_int,
    pub lrg: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_112 {
    pub current: size_t,
    pub max: size_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_113 {
    pub search: int64_t,
    pub simp: int64_t,
    pub lkhd: int64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_114 {
    pub sat: int64_t,
    pub mosat: int64_t,
    pub simp: int64_t,
    pub deref: int64_t,
    pub fixed: int64_t,
    pub freeze: int64_t,
    pub lkhd: int64_t,
    pub melt: int64_t,
    pub add: int64_t,
    pub assume: int64_t,
    pub cassume: int64_t,
    pub failed: int64_t,
    pub repr: int64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_115 {
    pub clauses: C2RustUnnamed_116,
    pub lits: C2RustUnnamed_116,
    pub maxbytes: int64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_116 {
    pub cur: libc::c_int,
    pub max: libc::c_int,
    pub add: int64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_117 {
    pub avg: MACD,
    pub count: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct MACD {
    pub fast: EMA,
    pub slow: EMA,
    pub diff: C2RustUnnamed_118,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_118 {
    pub actual: int64_t,
    pub smoothed: EMA,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct AVG {
    pub val: int64_t,
    pub count: int64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_119 {
    pub decs: int64_t,
    pub pure_0: int64_t,
    pub calls: int64_t,
    pub sat: int64_t,
    pub uns: int64_t,
    pub lim: int64_t,
    pub levels: int64_t,
    pub child: C2RustUnnamed_120,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_120 {
    pub confs: int64_t,
    pub decs: int64_t,
    pub props: int64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_121 {
    pub count: libc::c_int,
    pub arith: libc::c_int,
    pub memlim: libc::c_int,
    pub reset: libc::c_int,
    pub collected: int64_t,
    pub retired: int64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_122 {
    pub count: int64_t,
    pub checked: int64_t,
    pub skipped: int64_t,
    pub forced: int64_t,
    pub agile: int64_t,
    pub delayed: int64_t,
    pub blocked: int64_t,
    pub notforced: int64_t,
    pub reused: int64_t,
    pub delta: C2RustUnnamed_124,
    pub kept: C2RustUnnamed_123,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_123 {
    pub count: int64_t,
    pub sum: int64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_124 {
    pub count: int64_t,
    pub pen: int64_t,
    pub delta: int64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_125 {
    pub clauses: libc::c_int,
    pub vars: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Opts {
    pub beforefirst: Opt,
    pub abstime: Opt,
    pub activity: Opt,
    pub agility: Opt,
    pub agilitylim: Opt,
    pub bate: Opt,
    pub batewait: Opt,
    pub bca: Opt,
    pub bcaddlimldscale: Opt,
    pub bcamaxeff: Opt,
    pub bcaminuse: Opt,
    pub bcawait: Opt,
    pub bkwdocclim: Opt,
    pub bkwdresched: Opt,
    pub bkwdroundlim: Opt,
    pub bkwdscale: Opt,
    pub blkboost: Opt,
    pub blkboostvlim: Opt,
    pub blkclslim: Opt,
    pub blklarge: Opt,
    pub blkmaxeff: Opt,
    pub blkmineff: Opt,
    pub blkocclim1: Opt,
    pub blkocclim: Opt,
    pub blkocclim2: Opt,
    pub blkreleff: Opt,
    pub blkresched: Opt,
    pub blkrtc: Opt,
    pub blksmall: Opt,
    pub blksuccessmaxwortc: Opt,
    pub blksuccessrat: Opt,
    pub block: Opt,
    pub blockwait: Opt,
    pub boost: Opt,
    pub bumpreasonlits: Opt,
    pub bumpsimp: Opt,
    pub card: Opt,
    pub cardcut: Opt,
    pub cardexpam1: Opt,
    pub cardglue: Opt,
    pub cardignused: Opt,
    pub cardmaxeff: Opt,
    pub cardmaxlen: Opt,
    pub cardmineff: Opt,
    pub cardminlen: Opt,
    pub cardocclim1: Opt,
    pub cardocclim2: Opt,
    pub cardreleff: Opt,
    pub cardreschedint: Opt,
    pub carduse: Opt,
    pub cardwait: Opt,
    pub classify: Opt,
    pub cce2wait: Opt,
    pub cce: Opt,
    pub cce3wait: Opt,
    pub cceateint: Opt,
    pub cceboost: Opt,
    pub cceboostdel: Opt,
    pub cceboostint: Opt,
    pub cceboostvlim: Opt,
    pub ccemaxeff: Opt,
    pub ccemaxround: Opt,
    pub ccemineff: Opt,
    pub ccereleff: Opt,
    pub ccertc: Opt,
    pub ccertcint: Opt,
    pub ccertcintvlim: Opt,
    pub ccesuccessrat: Opt,
    pub ccewait: Opt,
    pub check: Opt,
    pub clim: Opt,
    pub compact: Opt,
    pub deco: Opt,
    pub deco1opt: Opt,
    pub decolim: Opt,
    pub decompose: Opt,
    pub defragfree: Opt,
    pub defragint: Opt,
    pub delmax: Opt,
    pub dlim: Opt,
    pub druplig: Opt,
    pub drupligcheck: Opt,
    pub drupligtrace: Opt,
    pub drupligtraceorig: Opt,
    pub elim: Opt,
    pub elmaxeff: Opt,
    pub elmblk: Opt,
    pub elmblkwait: Opt,
    pub elmboost: Opt,
    pub elmboostdel: Opt,
    pub elmboostint: Opt,
    pub elmboostvlim: Opt,
    pub elmclslim: Opt,
    pub elmfull: Opt,
    pub elmineff: Opt,
    pub elmlitslim: Opt,
    pub elmocclim1: Opt,
    pub elmocclim: Opt,
    pub elmocclim2: Opt,
    pub elmoccsumforced: Opt,
    pub elmreleff: Opt,
    pub elmresched: Opt,
    pub elmroundlim: Opt,
    pub elmrtc: Opt,
    pub elmrtcint: Opt,
    pub elmrtcintvlim: Opt,
    pub elmotfstr: Opt,
    pub elmotfsub: Opt,
    pub elmsuccessmaxwortc: Opt,
    pub elmsuccessrat: Opt,
    pub exitonabort: Opt,
    pub factmax: Opt,
    pub factor: Opt,
    pub features: Opt,
    pub gauss: Opt,
    pub gausscardweak: Opt,
    pub gaussexptrn: Opt,
    pub gaussextrall: Opt,
    pub gaussmaxeff: Opt,
    pub gaussmaxor: Opt,
    pub gaussmineff: Opt,
    pub gaussreleff: Opt,
    pub gausswait: Opt,
    pub gluekeep: Opt,
    pub gluekeepsize: Opt,
    pub gluemacdfast: Opt,
    pub gluemacdslow: Opt,
    pub gluemacdsmooth: Opt,
    pub gluescale: Opt,
    pub hbrdom: Opt,
    pub import: Opt,
    pub incredcint: Opt,
    pub incredconfslim: Opt,
    pub incsavevisits: Opt,
    pub inprocessing: Opt,
    pub irrlim: Opt,
    pub itsmacdfast: Opt,
    pub itsmacdslow: Opt,
    pub itsmacdsmooth: Opt,
    pub jlevelmacdfast: Opt,
    pub jlevelmacdslow: Opt,
    pub jlevelmacdsmooth: Opt,
    pub jwhred: Opt,
    pub keepmaxglue: Opt,
    pub keepmaxglueint: Opt,
    pub lhbr: Opt,
    pub lkhd: Opt,
    pub locs: Opt,
    pub locsbanner: Opt,
    pub locsboost: Opt,
    pub locscint: Opt,
    pub locsclim: Opt,
    pub locset: Opt,
    pub locsexport: Opt,
    pub locsmaxeff: Opt,
    pub locsmineff: Opt,
    pub locsred: Opt,
    pub locsreleff: Opt,
    pub locsrtc: Opt,
    pub locsvared: Opt,
    pub locswait: Opt,
    pub log: Opt,
    pub maxscaledglue: Opt,
    pub memlim: Opt,
    pub minimize: Opt,
    pub minlocalgluelim: Opt,
    pub minlocalsizelim: Opt,
    pub minrecgluelim: Opt,
    pub minrecsizelim: Opt,
    pub move_0: Opt,
    pub otfs: Opt,
    pub penmax: Opt,
    pub phase: Opt,
    pub phaseluckfactor: Opt,
    pub phaselucklim: Opt,
    pub phaseluckmaxround: Opt,
    pub phasesave: Opt,
    pub plain: Opt,
    pub plim: Opt,
    pub poison: Opt,
    pub prbasic: Opt,
    pub prbasicmaxeff: Opt,
    pub prbasicmineff: Opt,
    pub prbasicreleff: Opt,
    pub prbasicroundlim: Opt,
    pub prbasicrtc: Opt,
    pub prbrtc: Opt,
    pub prbsimple: Opt,
    pub prbsimpleboost: Opt,
    pub prbsimpleliftdepth: Opt,
    pub prbsimplemaxeff: Opt,
    pub prbsimplemineff: Opt,
    pub prbsimplereleff: Opt,
    pub prbsimplertc: Opt,
    pub probe: Opt,
    pub profile: Opt,
    pub profilelong: Opt,
    pub promote: Opt,
    pub promotegluelim: Opt,
    pub prune: Opt,
    pub pruneclim: Opt,
    pub pruneinit: Opt,
    pub prunelevel: Opt,
    pub prunesize: Opt,
    pub prunemin: Opt,
    pub prunemax: Opt,
    pub prunepure: Opt,
    pub prunered: Opt,
    pub prunevsids: Opt,
    pub pure_0: Opt,
    pub quatres: Opt,
    pub quatreswait: Opt,
    pub queuesort: Opt,
    pub randec: Opt,
    pub randecint: Opt,
    pub randphase: Opt,
    pub randphaseint: Opt,
    pub redcls: Opt,
    pub redclsglue: Opt,
    pub redclsize: Opt,
    pub redclsmaxdec: Opt,
    pub redclsmaxdepth: Opt,
    pub redclsmaxlrg: Opt,
    pub redclsmaxprops: Opt,
    pub redclstype: Opt,
    pub reduce: Opt,
    pub reducefixed: Opt,
    pub reduceinc: Opt,
    pub reduceinit: Opt,
    pub reducereset: Opt,
    pub restart: Opt,
    pub restartfixed: Opt,
    pub restartblock: Opt,
    pub restartblocklim: Opt,
    pub restartblockbound: Opt,
    pub restartcheckforced: Opt,
    pub restartdelay: Opt,
    pub restartdelaylim: Opt,
    pub restartint: Opt,
    pub restartforcelim: Opt,
    pub restartforcemode: Opt,
    pub restartpen1: Opt,
    pub restartpen2: Opt,
    pub restartpen3: Opt,
    pub restartpenstab: Opt,
    pub retireint: Opt,
    pub retiremin: Opt,
    pub retirenb: Opt,
    pub reusetrail: Opt,
    pub rmincpen: Opt,
    pub scincinc: Opt,
    pub scincincdelta: Opt,
    pub scincincincint: Opt,
    pub scincincmin: Opt,
    pub scincincmode: Opt,
    pub scoreshift: Opt,
    pub seed: Opt,
    pub simpbintinc: Opt,
    pub simpbintinclim: Opt,
    pub simpcintdelay: Opt,
    pub simpcintinc: Opt,
    pub simpcintincdiv: Opt,
    pub simpcintmaxhard: Opt,
    pub simpcintmaxsoft: Opt,
    pub simpidiv: Opt,
    pub simpincdelmaxfact: Opt,
    pub simpincdelmaxmin: Opt,
    pub simpinitdelay: Opt,
    pub simpintsizepen: Opt,
    pub simpiscale: Opt,
    pub simpitdelay: Opt,
    pub simpjleveldecdelay: Opt,
    pub simpitintdecdelay: Opt,
    pub simpitintinc: Opt,
    pub simpitintinclim: Opt,
    pub simplify: Opt,
    pub simprtc: Opt,
    pub simptintinc: Opt,
    pub simptintinclim: Opt,
    pub simpvarchg: Opt,
    pub simpvarlim: Opt,
    pub sizemaxpen: Opt,
    pub sizepen: Opt,
    pub sleeponabort: Opt,
    pub smallirr: Opt,
    pub smallve: Opt,
    pub smallvevars: Opt,
    pub smallvewait: Opt,
    pub sortlits: Opt,
    pub stabema: Opt,
    pub subl: Opt,
    pub sweep: Opt,
    pub sweepboost: Opt,
    pub sweepboostdel: Opt,
    pub sweepboostint: Opt,
    pub sweepboostvlim: Opt,
    pub sweepfacdec: Opt,
    pub sweepforgive: Opt,
    pub sweepirr: Opt,
    pub sweepmaxdec: Opt,
    pub sweepmaxeff: Opt,
    pub sweepmaxround: Opt,
    pub sweepmindec: Opt,
    pub sweepmineff: Opt,
    pub sweepred: Opt,
    pub sweepreleff: Opt,
    pub sweeprtc: Opt,
    pub sweeprtcint: Opt,
    pub sweeprtcintvlim: Opt,
    pub sweepsuccessmaxwortc: Opt,
    pub sweepsuccessrat: Opt,
    pub sweepwait: Opt,
    pub synclsall: Opt,
    pub synclsglue: Opt,
    pub synclsint: Opt,
    pub synclslen: Opt,
    pub syncunint: Opt,
    pub termint: Opt,
    pub ternres: Opt,
    pub ternresboost: Opt,
    pub ternresrtc: Opt,
    pub ternreswait: Opt,
    pub tlevelema: Opt,
    pub transred: Opt,
    pub transredwait: Opt,
    pub trapiflush: Opt,
    pub trdmaxeff: Opt,
    pub trdmineff: Opt,
    pub trdreleff: Opt,
    pub treelook: Opt,
    pub treelookboost: Opt,
    pub treelookfull: Opt,
    pub treelookmaxeff: Opt,
    pub treelookmineff: Opt,
    pub treelookreleff: Opt,
    pub treelookrtc: Opt,
    pub trep: Opt,
    pub trepint: Opt,
    pub trnreleff: Opt,
    pub trnrmaxeff: Opt,
    pub trnrmineff: Opt,
    pub unhdatrn: Opt,
    pub unhdextstamp: Opt,
    pub unhdhbr: Opt,
    pub unhdlnpr: Opt,
    pub unhdmaxeff: Opt,
    pub unhdmineff: Opt,
    pub unhdreleff: Opt,
    pub unhdroundlim: Opt,
    pub unhide: Opt,
    pub unhidewait: Opt,
    pub usedtwice: Opt,
    pub verbose: Opt,
    pub wait: Opt,
    pub waitmax: Opt,
    pub witness: Opt,
    pub afterlast: Opt,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Opt {
    pub lng: *const libc::c_char,
    pub descrp: *const libc::c_char,
    pub val: libc::c_int,
    pub min: libc::c_int,
    pub max: libc::c_int,
    pub dflt: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Mem {
    pub state: *mut libc::c_void,
    pub alloc: lglalloc,
    pub realloc: lglrealloc,
    pub dealloc: lgldealloc,
}
pub type lgldealloc = Option::<
    unsafe extern "C" fn(*mut libc::c_void, *mut libc::c_void, size_t) -> (),
>;
pub type lglrealloc = Option::<
    unsafe extern "C" fn(
        *mut libc::c_void,
        *mut libc::c_void,
        size_t,
        size_t,
    ) -> *mut libc::c_void,
>;
pub type lglalloc = Option::<
    unsafe extern "C" fn(*mut libc::c_void, size_t) -> *mut libc::c_void,
>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct RNG {
    pub z: libc::c_uint,
    pub w: libc::c_uint,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Conf {
    pub lit: libc::c_int,
    pub rsn: [libc::c_int; 2],
}
pub type State = libc::c_uint;
pub const RESET: State = 1024;
pub const LOOKED: State = 512;
pub const FAILED: State = 256;
pub const UNSATISFIED: State = 128;
pub const EXTENDED: State = 64;
pub const SATISFIED: State = 32;
pub const UNKNOWN: State = 16;
pub const READY: State = 8;
pub const USED: State = 4;
pub const OPTSET: State = 2;
pub const UNUSED: State = 1;
pub type Mnt = uint64_t;
pub type uint64_t = __uint64_t;
pub type Exp = libc::c_int;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct rusage {
    pub ru_utime: timeval,
    pub ru_stime: timeval,
    pub c2rust_unnamed: C2RustUnnamed_139,
    pub c2rust_unnamed_0: C2RustUnnamed_138,
    pub c2rust_unnamed_1: C2RustUnnamed_137,
    pub c2rust_unnamed_2: C2RustUnnamed_136,
    pub c2rust_unnamed_3: C2RustUnnamed_135,
    pub c2rust_unnamed_4: C2RustUnnamed_134,
    pub c2rust_unnamed_5: C2RustUnnamed_133,
    pub c2rust_unnamed_6: C2RustUnnamed_132,
    pub c2rust_unnamed_7: C2RustUnnamed_131,
    pub c2rust_unnamed_8: C2RustUnnamed_130,
    pub c2rust_unnamed_9: C2RustUnnamed_129,
    pub c2rust_unnamed_10: C2RustUnnamed_128,
    pub c2rust_unnamed_11: C2RustUnnamed_127,
    pub c2rust_unnamed_12: C2RustUnnamed_126,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_126 {
    pub ru_nivcsw: libc::c_long,
    pub __ru_nivcsw_word: __syscall_slong_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_127 {
    pub ru_nvcsw: libc::c_long,
    pub __ru_nvcsw_word: __syscall_slong_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_128 {
    pub ru_nsignals: libc::c_long,
    pub __ru_nsignals_word: __syscall_slong_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_129 {
    pub ru_msgrcv: libc::c_long,
    pub __ru_msgrcv_word: __syscall_slong_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_130 {
    pub ru_msgsnd: libc::c_long,
    pub __ru_msgsnd_word: __syscall_slong_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_131 {
    pub ru_oublock: libc::c_long,
    pub __ru_oublock_word: __syscall_slong_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_132 {
    pub ru_inblock: libc::c_long,
    pub __ru_inblock_word: __syscall_slong_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_133 {
    pub ru_nswap: libc::c_long,
    pub __ru_nswap_word: __syscall_slong_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_134 {
    pub ru_majflt: libc::c_long,
    pub __ru_majflt_word: __syscall_slong_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_135 {
    pub ru_minflt: libc::c_long,
    pub __ru_minflt_word: __syscall_slong_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_136 {
    pub ru_isrss: libc::c_long,
    pub __ru_isrss_word: __syscall_slong_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_137 {
    pub ru_idrss: libc::c_long,
    pub __ru_idrss_word: __syscall_slong_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_138 {
    pub ru_ixrss: libc::c_long,
    pub __ru_ixrss_word: __syscall_slong_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_139 {
    pub ru_maxrss: libc::c_long,
    pub __ru_maxrss_word: __syscall_slong_t,
}
pub const RUSAGE_SELF: __rusage_who = 0;
pub type __rusage_who_t = libc::c_int;
pub const LRGCS: Tag = 4;
pub const MASKCS: Tag = 7;
pub const REDCS: Tag = 8;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Lim {
    pub confs: int64_t,
    pub decs: int64_t,
    pub props: int64_t,
}
pub const FREEVAR: Tag = 0;
pub const TRNCS: Tag = 3;
pub const OCCS: Tag = 1;
pub const RMSHFT: Tag = 4;
pub const BINCS: Tag = 2;
pub type ptrdiff_t = libc::c_long;
pub const DECISION: Tag = 0;
pub const UNITCS: Tag = 1;
pub const FIXEDVAR: Tag = 1;
pub const EQUIVAR: Tag = 2;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PruneState {
    pub parent: *mut LGL,
    pub child: *mut LGL,
    pub clause: Stk,
    pub map: *mut libc::c_int,
    pub nvars: libc::c_int,
    pub red: libc::c_int,
    pub irr: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PAGSL {
    pub psm: libc::c_int,
    pub act: libc::c_int,
    pub glue: libc::c_int,
    pub size: libc::c_int,
    pub lidx: libc::c_int,
}
pub const ELIMVAR: Tag = 3;
pub type Tag = libc::c_uint;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Features {
    pub n: libc::c_int,
    pub s: libc::c_int,
    pub vo: libc::c_int,
    pub vc: libc::c_int,
    pub co: libc::c_int,
    pub cc: libc::c_int,
    pub b: libc::c_int,
    pub t: libc::c_int,
    pub q: libc::c_int,
    pub c1: libc::c_int,
    pub c2: libc::c_int,
    pub c3: libc::c_int,
    pub c4: libc::c_int,
    pub x: libc::c_int,
    pub a1: libc::c_int,
    pub a2: libc::c_int,
    pub g: libc::c_int,
    pub j: libc::c_int,
    pub c: libc::c_int,
    pub o: libc::c_int,
}
pub type Cnf = int64_t;
pub type Fun = [uint64_t; 64];
#[derive(Copy, Clone)]
#[repr(C)]
pub struct DFPR {
    pub discovered: libc::c_int,
    pub finished: libc::c_int,
    pub parent: libc::c_int,
    pub root: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct DFL {
    pub discovered: libc::c_int,
    pub finished: libc::c_int,
    pub c2rust_unnamed: C2RustUnnamed_140,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_140 {
    pub lit: libc::c_int,
    pub sign: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct DFOPF {
    pub observed: libc::c_int,
    pub pushed: libc::c_int,
    pub flag: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Wtk {
    pub start: *mut Work,
    pub top: *mut Work,
    pub end: *mut Work,
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct Work {
    #[bitfield(name = "wrag", ty = "libc::c_uint", bits = "0..=1")]
    #[bitfield(name = "lit", ty = "libc::c_int", bits = "2..=31")]
    #[bitfield(name = "other", ty = "libc::c_int", bits = "32..=61")]
    #[bitfield(name = "red", ty = "libc::c_uint", bits = "62..=62")]
    #[bitfield(name = "removed", ty = "libc::c_uint", bits = "63..=63")]
    pub wrag_lit_other_red_removed: [u8; 8],
}
pub const AFTER: Wrag = 2;
pub type Wrag = libc::c_uint;
pub const POSTFIX: Wrag = 3;
pub const BEFORE: Wrag = 1;
pub const PREFIX: Wrag = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Ftk {
    pub start: *mut Flt,
    pub top: *mut Flt,
    pub end: *mut Flt,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PSz {
    pub pos: libc::c_int,
    pub size: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_141 {
    pub cnt: libc::c_int,
    pub sum: int64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_142 {
    pub cnt: libc::c_int,
    pub sum: int64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct POSLIDX {
    pub pos: libc::c_int,
    pub lidx: libc::c_int,
}
pub const _ISdigit: C2RustUnnamed_143 = 2048;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Buf {
    pub start: *mut libc::c_char,
    pub size: size_t,
    pub count: size_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct IrrTrav {
    pub state: *mut libc::c_void,
    pub trav: Option::<unsafe extern "C" fn(*mut libc::c_void, libc::c_int) -> ()>,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Trv {
    pub state: *mut libc::c_void,
    pub trav: Option::<unsafe extern "C" fn(*mut libc::c_void, libc::c_int) -> ()>,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct TN {
    pub t: libc::c_double,
    pub n: *const libc::c_char,
}
pub type C2RustUnnamed_143 = libc::c_uint;
pub const _ISalnum: C2RustUnnamed_143 = 8;
pub const _ISpunct: C2RustUnnamed_143 = 4;
pub const _IScntrl: C2RustUnnamed_143 = 2;
pub const _ISblank: C2RustUnnamed_143 = 1;
pub const _ISgraph: C2RustUnnamed_143 = 32768;
pub const _ISprint: C2RustUnnamed_143 = 16384;
pub const _ISspace: C2RustUnnamed_143 = 8192;
pub const _ISxdigit: C2RustUnnamed_143 = 4096;
pub const _ISalpha: C2RustUnnamed_143 = 1024;
pub const _ISlower: C2RustUnnamed_143 = 512;
pub const _ISupper: C2RustUnnamed_143 = 256;
pub type __rusage_who = libc::c_int;
pub const RUSAGE_CHILDREN: __rusage_who = -1;
#[inline]
unsafe extern "C" fn atoi(mut __nptr: *const libc::c_char) -> libc::c_int {
    return strtol(
        __nptr,
        0 as *mut libc::c_void as *mut *mut libc::c_char,
        10 as libc::c_int,
    ) as libc::c_int;
}
#[inline]
unsafe extern "C" fn tolower(mut __c: libc::c_int) -> libc::c_int {
    return if __c >= -(128 as libc::c_int) && __c < 256 as libc::c_int {
        *(*__ctype_tolower_loc()).offset(__c as isize)
    } else {
        __c
    };
}
#[inline]
unsafe extern "C" fn toupper(mut __c: libc::c_int) -> libc::c_int {
    return if __c >= -(128 as libc::c_int) && __c < 256 as libc::c_int {
        *(*__ctype_toupper_loc()).offset(__c as isize)
    } else {
        __c
    };
}
static mut featurenames: [*const libc::c_char; 20] = [
    b"n\0" as *const u8 as *const libc::c_char,
    b"s\0" as *const u8 as *const libc::c_char,
    b"vo\0" as *const u8 as *const libc::c_char,
    b"vc\0" as *const u8 as *const libc::c_char,
    b"co\0" as *const u8 as *const libc::c_char,
    b"cc\0" as *const u8 as *const libc::c_char,
    b"b\0" as *const u8 as *const libc::c_char,
    b"t\0" as *const u8 as *const libc::c_char,
    b"q\0" as *const u8 as *const libc::c_char,
    b"c1\0" as *const u8 as *const libc::c_char,
    b"c2\0" as *const u8 as *const libc::c_char,
    b"c3\0" as *const u8 as *const libc::c_char,
    b"c4\0" as *const u8 as *const libc::c_char,
    b"x\0" as *const u8 as *const libc::c_char,
    b"a1\0" as *const u8 as *const libc::c_char,
    b"a2\0" as *const u8 as *const libc::c_char,
    b"g\0" as *const u8 as *const libc::c_char,
    b"j\0" as *const u8 as *const libc::c_char,
    b"c\0" as *const u8 as *const libc::c_char,
    b"o\0" as *const u8 as *const libc::c_char,
];
static mut lglfloorldtab: [libc::c_uint; 256] = [
    -(1 as libc::c_int) as libc::c_uint,
    0 as libc::c_int as libc::c_uint,
    1 as libc::c_int as libc::c_uint,
    1 as libc::c_int as libc::c_uint,
    2 as libc::c_int as libc::c_uint,
    2 as libc::c_int as libc::c_uint,
    2 as libc::c_int as libc::c_uint,
    2 as libc::c_int as libc::c_uint,
    3 as libc::c_int as libc::c_uint,
    3 as libc::c_int as libc::c_uint,
    3 as libc::c_int as libc::c_uint,
    3 as libc::c_int as libc::c_uint,
    3 as libc::c_int as libc::c_uint,
    3 as libc::c_int as libc::c_uint,
    3 as libc::c_int as libc::c_uint,
    3 as libc::c_int as libc::c_uint,
    4 as libc::c_int as libc::c_uint,
    4 as libc::c_int as libc::c_uint,
    4 as libc::c_int as libc::c_uint,
    4 as libc::c_int as libc::c_uint,
    4 as libc::c_int as libc::c_uint,
    4 as libc::c_int as libc::c_uint,
    4 as libc::c_int as libc::c_uint,
    4 as libc::c_int as libc::c_uint,
    4 as libc::c_int as libc::c_uint,
    4 as libc::c_int as libc::c_uint,
    4 as libc::c_int as libc::c_uint,
    4 as libc::c_int as libc::c_uint,
    4 as libc::c_int as libc::c_uint,
    4 as libc::c_int as libc::c_uint,
    4 as libc::c_int as libc::c_uint,
    4 as libc::c_int as libc::c_uint,
    5 as libc::c_int as libc::c_uint,
    5 as libc::c_int as libc::c_uint,
    5 as libc::c_int as libc::c_uint,
    5 as libc::c_int as libc::c_uint,
    5 as libc::c_int as libc::c_uint,
    5 as libc::c_int as libc::c_uint,
    5 as libc::c_int as libc::c_uint,
    5 as libc::c_int as libc::c_uint,
    5 as libc::c_int as libc::c_uint,
    5 as libc::c_int as libc::c_uint,
    5 as libc::c_int as libc::c_uint,
    5 as libc::c_int as libc::c_uint,
    5 as libc::c_int as libc::c_uint,
    5 as libc::c_int as libc::c_uint,
    5 as libc::c_int as libc::c_uint,
    5 as libc::c_int as libc::c_uint,
    5 as libc::c_int as libc::c_uint,
    5 as libc::c_int as libc::c_uint,
    5 as libc::c_int as libc::c_uint,
    5 as libc::c_int as libc::c_uint,
    5 as libc::c_int as libc::c_uint,
    5 as libc::c_int as libc::c_uint,
    5 as libc::c_int as libc::c_uint,
    5 as libc::c_int as libc::c_uint,
    5 as libc::c_int as libc::c_uint,
    5 as libc::c_int as libc::c_uint,
    5 as libc::c_int as libc::c_uint,
    5 as libc::c_int as libc::c_uint,
    5 as libc::c_int as libc::c_uint,
    5 as libc::c_int as libc::c_uint,
    5 as libc::c_int as libc::c_uint,
    5 as libc::c_int as libc::c_uint,
    6 as libc::c_int as libc::c_uint,
    6 as libc::c_int as libc::c_uint,
    6 as libc::c_int as libc::c_uint,
    6 as libc::c_int as libc::c_uint,
    6 as libc::c_int as libc::c_uint,
    6 as libc::c_int as libc::c_uint,
    6 as libc::c_int as libc::c_uint,
    6 as libc::c_int as libc::c_uint,
    6 as libc::c_int as libc::c_uint,
    6 as libc::c_int as libc::c_uint,
    6 as libc::c_int as libc::c_uint,
    6 as libc::c_int as libc::c_uint,
    6 as libc::c_int as libc::c_uint,
    6 as libc::c_int as libc::c_uint,
    6 as libc::c_int as libc::c_uint,
    6 as libc::c_int as libc::c_uint,
    6 as libc::c_int as libc::c_uint,
    6 as libc::c_int as libc::c_uint,
    6 as libc::c_int as libc::c_uint,
    6 as libc::c_int as libc::c_uint,
    6 as libc::c_int as libc::c_uint,
    6 as libc::c_int as libc::c_uint,
    6 as libc::c_int as libc::c_uint,
    6 as libc::c_int as libc::c_uint,
    6 as libc::c_int as libc::c_uint,
    6 as libc::c_int as libc::c_uint,
    6 as libc::c_int as libc::c_uint,
    6 as libc::c_int as libc::c_uint,
    6 as libc::c_int as libc::c_uint,
    6 as libc::c_int as libc::c_uint,
    6 as libc::c_int as libc::c_uint,
    6 as libc::c_int as libc::c_uint,
    6 as libc::c_int as libc::c_uint,
    6 as libc::c_int as libc::c_uint,
    6 as libc::c_int as libc::c_uint,
    6 as libc::c_int as libc::c_uint,
    6 as libc::c_int as libc::c_uint,
    6 as libc::c_int as libc::c_uint,
    6 as libc::c_int as libc::c_uint,
    6 as libc::c_int as libc::c_uint,
    6 as libc::c_int as libc::c_uint,
    6 as libc::c_int as libc::c_uint,
    6 as libc::c_int as libc::c_uint,
    6 as libc::c_int as libc::c_uint,
    6 as libc::c_int as libc::c_uint,
    6 as libc::c_int as libc::c_uint,
    6 as libc::c_int as libc::c_uint,
    6 as libc::c_int as libc::c_uint,
    6 as libc::c_int as libc::c_uint,
    6 as libc::c_int as libc::c_uint,
    6 as libc::c_int as libc::c_uint,
    6 as libc::c_int as libc::c_uint,
    6 as libc::c_int as libc::c_uint,
    6 as libc::c_int as libc::c_uint,
    6 as libc::c_int as libc::c_uint,
    6 as libc::c_int as libc::c_uint,
    6 as libc::c_int as libc::c_uint,
    6 as libc::c_int as libc::c_uint,
    6 as libc::c_int as libc::c_uint,
    6 as libc::c_int as libc::c_uint,
    6 as libc::c_int as libc::c_uint,
    6 as libc::c_int as libc::c_uint,
    6 as libc::c_int as libc::c_uint,
    6 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
    7 as libc::c_int as libc::c_uint,
];
static mut lglbasevar2funtab: [uint64_t; 6] = [
    0xaaaaaaaaaaaaaaaa as libc::c_ulonglong as uint64_t,
    0xcccccccccccccccc as libc::c_ulonglong as uint64_t,
    0xf0f0f0f0f0f0f0f0 as libc::c_ulonglong as uint64_t,
    0xff00ff00ff00ff00 as libc::c_ulonglong as uint64_t,
    0xffff0000ffff0000 as libc::c_ulonglong as uint64_t,
    0xffffffff00000000 as libc::c_ulonglong as uint64_t,
];
unsafe extern "C" fn lglfloorld(mut n: libc::c_uint) -> libc::c_uint {
    if n < ((1 as libc::c_int) << 8 as libc::c_int) as libc::c_uint {
        return lglfloorldtab[n as usize];
    }
    if n < ((1 as libc::c_int) << 16 as libc::c_int) as libc::c_uint {
        return (8 as libc::c_int as libc::c_uint)
            .wrapping_add(lglfloorldtab[(n >> 8 as libc::c_int) as usize]);
    }
    if n < ((1 as libc::c_int) << 24 as libc::c_int) as libc::c_uint {
        return (16 as libc::c_int as libc::c_uint)
            .wrapping_add(lglfloorldtab[(n >> 16 as libc::c_int) as usize]);
    }
    return (24 as libc::c_int as libc::c_uint)
        .wrapping_add(lglfloorldtab[(n >> 24 as libc::c_int) as usize]);
}
unsafe extern "C" fn lglispow2(mut n: libc::c_int) -> libc::c_int {
    return (n & n - 1 as libc::c_int == 0) as libc::c_int;
}
unsafe extern "C" fn lglceild(mut n: libc::c_int) -> libc::c_int {
    let mut res: libc::c_int = lglfloorld(n as libc::c_uint) as libc::c_int;
    if lglispow2(n) == 0 {
        res += 1;
        res;
    }
    return res;
}
unsafe extern "C" fn lglchkflt(mut a: Flt) {}
unsafe extern "C" fn lglexp(mut a: Flt) -> Exp {
    let mut tmp: Flt = a >> 32 as libc::c_int;
    let mut res: Exp = tmp as Exp;
    res -= 0x10000000 as libc::c_int;
    return res;
}
unsafe extern "C" fn lglmnt(mut a: Flt) -> Mnt {
    let mut res: Mnt = (a as libc::c_ulonglong & 0x1ffffffff as libc::c_ulonglong)
        as Mnt;
    res = (res as libc::c_ulonglong | 0x100000000 as libc::c_ulonglong) as Mnt;
    return res;
}
unsafe extern "C" fn lglflt(mut e: Exp, mut m: Mnt) -> Flt {
    let mut res: Flt = 0;
    if m == 0 {
        return 0 as libc::c_longlong as Flt;
    }
    if (m as libc::c_ulonglong) < 0x100000000 as libc::c_ulonglong {
        while m as libc::c_ulonglong & 0x100000000 as libc::c_ulonglong == 0 {
            m <<= 1 as libc::c_int;
            if !(e > -(2147483647 as libc::c_int) - 1 as libc::c_int) {
                break;
            }
            e -= 1;
            e;
        }
    } else {
        while m as libc::c_ulonglong > 0x1ffffffff as libc::c_ulonglong {
            m >>= 1 as libc::c_int;
            if !(e > -(2147483647 as libc::c_int) - 1 as libc::c_int) {
                break;
            }
            e += 1;
            e;
        }
    }
    if e < -(0x10000000 as libc::c_int) {
        return 0 as libc::c_longlong as Flt;
    }
    if e > 0x7fffffff as libc::c_int - 0x10000000 as libc::c_int {
        return 0x7fffffffffffffff as libc::c_longlong as Flt;
    }
    e += 0x10000000 as libc::c_int;
    res = (m as libc::c_ulonglong & !(0x100000000 as libc::c_ulonglong)) as Flt;
    res |= (e as Flt) << 32 as libc::c_int;
    return res;
}
unsafe extern "C" fn lglrat(mut n: libc::c_uint, mut d: libc::c_uint) -> Flt {
    let mut m: Mnt = 0;
    let mut e: Exp = 0;
    if n == 0 {
        return 0 as libc::c_longlong as Flt;
    }
    if d == 0 {
        return 0x7fffffffffffffff as libc::c_longlong as Flt;
    }
    m = n as Mnt;
    e = 0 as libc::c_int;
    while m as libc::c_ulonglong & (1 as libc::c_ulonglong) << 63 as libc::c_int == 0 {
        m <<= 1 as libc::c_int;
        e -= 1;
        e;
    }
    m = m / d as Mnt;
    return lglflt(e, m);
}
unsafe extern "C" fn lglflt2str(mut lgl: *mut LGL, mut a: Flt) -> *const libc::c_char {
    let mut d: libc::c_double = 0.;
    let mut e: libc::c_double = 0.;
    if a as libc::c_longlong == 0 as libc::c_longlong {
        return b"0\0" as *const u8 as *const libc::c_char;
    }
    if a as libc::c_longlong == 0x7fffffffffffffff as libc::c_longlong {
        return b"inf\0" as *const u8 as *const libc::c_char;
    }
    d = lglmnt(a) as libc::c_double;
    d /= 4294967296 as libc::c_longlong as libc::c_double;
    e = lglexp(a) as libc::c_double;
    e += 32 as libc::c_int as libc::c_double;
    (*(*lgl).fltstr).current += 1;
    (*(*lgl).fltstr).current;
    if (*(*lgl).fltstr).current == 6 as libc::c_int {
        (*(*lgl).fltstr).current = 0 as libc::c_int;
    }
    sprintf(
        ((*(*lgl).fltstr).str_0[(*(*lgl).fltstr).current as usize]).as_mut_ptr(),
        b"%.6fd%+03.0f\0" as *const u8 as *const libc::c_char,
        d,
        e,
    );
    return ((*(*lgl).fltstr).str_0[(*(*lgl).fltstr).current as usize]).as_mut_ptr();
}
unsafe extern "C" fn lgladdflt(mut a: Flt, mut b: Flt) -> Flt {
    let mut e: Exp = 0;
    let mut f: Exp = 0;
    let mut g: Exp = 0;
    let mut m: Mnt = 0;
    let mut n: Mnt = 0;
    let mut o: Mnt = 0;
    lglchkflt(a);
    lglchkflt(b);
    if a as libc::c_longlong == 0x7fffffffffffffff as libc::c_longlong {
        return 0x7fffffffffffffff as libc::c_longlong as Flt;
    }
    if b as libc::c_longlong == 0x7fffffffffffffff as libc::c_longlong {
        return 0x7fffffffffffffff as libc::c_longlong as Flt;
    }
    if a as libc::c_longlong == 0 as libc::c_longlong {
        return b;
    }
    if b as libc::c_longlong == 0 as libc::c_longlong {
        return a;
    }
    e = lglexp(a);
    f = lglexp(b);
    if e < f {
        g = e;
        e = f;
        f = g;
        o = a as Mnt;
        a = b;
        b = o as Flt;
    }
    m = lglmnt(a);
    n = lglmnt(b);
    if ((e - f) as ptrdiff_t)
        < ::core::mem::size_of::<Mnt>() as libc::c_ulong as ptrdiff_t
            * 8 as libc::c_int as ptrdiff_t
    {
        m = m.wrapping_add(n >> e - f);
    }
    return lglflt(e, m);
}
unsafe extern "C" fn lglmulflt(mut a: Flt, mut b: Flt) -> Flt {
    let mut e: Exp = 0;
    let mut ea: Exp = 0;
    let mut eb: Exp = 0;
    let mut m: Mnt = 0;
    let mut ma: Mnt = 0;
    let mut mb: Mnt = 0;
    lglchkflt(a);
    lglchkflt(b);
    if a as libc::c_longlong == 0x7fffffffffffffff as libc::c_longlong {
        return 0x7fffffffffffffff as libc::c_longlong as Flt;
    }
    if b as libc::c_longlong == 0x7fffffffffffffff as libc::c_longlong {
        return 0x7fffffffffffffff as libc::c_longlong as Flt;
    }
    if a as libc::c_longlong == 0 as libc::c_longlong {
        return 0 as libc::c_longlong as Flt;
    }
    if b as libc::c_longlong == 0 as libc::c_longlong {
        return 0 as libc::c_longlong as Flt;
    }
    ea = lglexp(a);
    eb = lglexp(b);
    if ea > 0 as libc::c_int && eb > 0 as libc::c_int
        && 2147483647 as libc::c_int - ea < eb
    {
        return 0x7fffffffffffffff as libc::c_longlong as Flt;
    }
    e = ea + eb;
    if e > 0x7fffffff as libc::c_int - 0x10000000 as libc::c_int - 32 as libc::c_int {
        return 0x7fffffffffffffff as libc::c_longlong as Flt;
    }
    e += 32 as libc::c_int;
    ma = lglmnt(a);
    mb = lglmnt(b);
    ma >>= 1 as libc::c_int;
    mb >>= 1 as libc::c_int;
    m = ma * mb;
    m >>= 30 as libc::c_int;
    return lglflt(e, m);
}
unsafe extern "C" fn lglshflt(mut a: Flt, mut s: libc::c_int) -> Flt {
    let mut e: Exp = 0;
    let mut m: Mnt = 0;
    if a as libc::c_longlong == 0x7fffffffffffffff as libc::c_longlong {
        return 0x7fffffffffffffff as libc::c_longlong as Flt;
    }
    if a as libc::c_longlong == 0 as libc::c_longlong {
        return 0 as libc::c_longlong as Flt;
    }
    e = lglexp(a);
    if e < -(2147483647 as libc::c_int) - 1 as libc::c_int + s {
        return 0 as libc::c_longlong as Flt;
    }
    e -= s;
    m = lglmnt(a);
    return lglflt(e, m);
}
unsafe extern "C" fn lglscr2str(mut lgl: *mut LGL, mut scr: Flt) -> *const libc::c_char {
    return lglflt2str(lgl, scr);
}
unsafe extern "C" fn lglwrn(
    mut lgl: *mut LGL,
    mut msg: *const libc::c_char,
    mut args: ...
) {
    let mut ap: ::core::ffi::VaListImpl;
    fprintf(
        (*lgl).out,
        b"*** warning in '%s': \0" as *const u8 as *const libc::c_char,
        b"lglib.c\0" as *const u8 as *const libc::c_char,
    );
    ap = args.clone();
    vfprintf((*lgl).out, msg, ap.as_va_list());
    fputc('\n' as i32, (*lgl).out);
    fflush((*lgl).out);
}
unsafe extern "C" fn lgldie(
    mut lgl: *mut LGL,
    mut msg: *const libc::c_char,
    mut args: ...
) {
    let mut ap: ::core::ffi::VaListImpl;
    fprintf(
        (*lgl).out,
        b"*** internal error in '%s': \0" as *const u8 as *const libc::c_char,
        b"lglib.c\0" as *const u8 as *const libc::c_char,
    );
    ap = args.clone();
    vfprintf((*lgl).out, msg, ap.as_va_list());
    fputc('\n' as i32, (*lgl).out);
    fflush((*lgl).out);
    exit(0 as libc::c_int);
}
unsafe extern "C" fn lglabort(mut lgl: *mut LGL) {
    if lgl.is_null() {
        exit(1 as libc::c_int);
    }
    if !((*lgl).opts).is_null() && (*(*lgl).opts).sleeponabort.val != 0 {
        fprintf(
            stderr,
            b"liblgl.a: Process %d will sleep for %d seconds  before continuing with 'lglabort' procedure.\n\0"
                as *const u8 as *const libc::c_char,
            getpid(),
            (*(*lgl).opts).sleeponabort.val,
        );
        fflush(stderr);
        sleep((*(*lgl).opts).sleeponabort.val as libc::c_uint);
    }
    if !((*lgl).cbs).is_null() && ((*(*lgl).cbs).onabort).is_some() {
        ((*(*lgl).cbs).onabort)
            .expect("non-null function pointer")((*(*lgl).cbs).abortstate);
    }
    if !((*lgl).opts).is_null() && (*(*lgl).opts).exitonabort.val != 0 {
        exit(1 as libc::c_int);
    }
    abort();
}
unsafe extern "C" fn lglprefix(mut lgl: *mut LGL) -> *const libc::c_char {
    return if !lgl.is_null() && !((*lgl).prefix).is_null() {
        (*lgl).prefix as *const libc::c_char
    } else {
        b"c (LGL HAS NO PREFIX YET) \0" as *const u8 as *const libc::c_char
    };
}
unsafe extern "C" fn lglmsgstart(
    mut lgl: *mut LGL,
    mut level: libc::c_int,
) -> libc::c_int {
    if (*(*lgl).opts).verbose.val < level {
        return 0 as libc::c_int;
    }
    if !((*lgl).cbs).is_null() && ((*(*lgl).cbs).msglock.lock).is_some() {
        ((*(*lgl).cbs).msglock.lock)
            .expect("non-null function pointer")((*(*lgl).cbs).msglock.state);
    }
    fputs(lglprefix(lgl), (*lgl).out);
    if (*lgl).tid >= 0 as libc::c_int {
        fprintf((*lgl).out, b"%d \0" as *const u8 as *const libc::c_char, (*lgl).tid);
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn lglmsgend(mut lgl: *mut LGL) {
    fputc('\n' as i32, (*lgl).out);
    fflush((*lgl).out);
    if !((*lgl).cbs).is_null() && ((*(*lgl).cbs).msglock.unlock).is_some() {
        ((*(*lgl).cbs).msglock.unlock)
            .expect("non-null function pointer")((*(*lgl).cbs).msglock.state);
    }
}
unsafe extern "C" fn lglprt(
    mut lgl: *mut LGL,
    mut level: libc::c_int,
    mut msg: *const libc::c_char,
    mut args: ...
) {
    let mut ap: ::core::ffi::VaListImpl;
    if (*(*lgl).opts).verbose.val < level {
        return;
    }
    lglmsgstart(lgl, level);
    ap = args.clone();
    vfprintf((*lgl).out, msg, ap.as_va_list());
    lglmsgend(lgl);
}
#[no_mangle]
pub unsafe extern "C" fn lglprocesstime() -> libc::c_double {
    let mut u: rusage = rusage {
        ru_utime: timeval { tv_sec: 0, tv_usec: 0 },
        ru_stime: timeval { tv_sec: 0, tv_usec: 0 },
        c2rust_unnamed: C2RustUnnamed_139 { ru_maxrss: 0 },
        c2rust_unnamed_0: C2RustUnnamed_138 { ru_ixrss: 0 },
        c2rust_unnamed_1: C2RustUnnamed_137 { ru_idrss: 0 },
        c2rust_unnamed_2: C2RustUnnamed_136 { ru_isrss: 0 },
        c2rust_unnamed_3: C2RustUnnamed_135 { ru_minflt: 0 },
        c2rust_unnamed_4: C2RustUnnamed_134 { ru_majflt: 0 },
        c2rust_unnamed_5: C2RustUnnamed_133 { ru_nswap: 0 },
        c2rust_unnamed_6: C2RustUnnamed_132 { ru_inblock: 0 },
        c2rust_unnamed_7: C2RustUnnamed_131 { ru_oublock: 0 },
        c2rust_unnamed_8: C2RustUnnamed_130 { ru_msgsnd: 0 },
        c2rust_unnamed_9: C2RustUnnamed_129 { ru_msgrcv: 0 },
        c2rust_unnamed_10: C2RustUnnamed_128 {
            ru_nsignals: 0,
        },
        c2rust_unnamed_11: C2RustUnnamed_127 { ru_nvcsw: 0 },
        c2rust_unnamed_12: C2RustUnnamed_126 { ru_nivcsw: 0 },
    };
    let mut res: libc::c_double = 0.;
    if getrusage(RUSAGE_SELF as libc::c_int, &mut u) != 0 {
        return 0 as libc::c_int as libc::c_double;
    }
    res = u.ru_utime.tv_sec as libc::c_double
        + 1e-6f64 * u.ru_utime.tv_usec as libc::c_double;
    res
        += u.ru_stime.tv_sec as libc::c_double
            + 1e-6f64 * u.ru_stime.tv_usec as libc::c_double;
    return res;
}
unsafe extern "C" fn lglgetime(mut lgl: *mut LGL) -> libc::c_double {
    (*(*lgl).stats).times += 1;
    (*(*lgl).stats).times;
    if !((*lgl).cbs).is_null() && ((*(*lgl).cbs).getime).is_some() {
        return ((*(*lgl).cbs).getime).expect("non-null function pointer")()
    } else {
        return lglprocesstime()
    };
}
unsafe extern "C" fn lglprofidx(
    mut lgl: *mut LGL,
    mut timestatsptr: *mut libc::c_double,
) -> libc::c_int {
    let mut res: libc::c_int = 0;
    res = timestatsptr.offset_from((*lgl).times as *mut libc::c_double) as libc::c_long
        as libc::c_int;
    return res;
}
unsafe extern "C" fn lglignprofidx(
    mut lgl: *mut LGL,
    mut idx: libc::c_int,
) -> libc::c_int {
    let mut res: libc::c_int = 0;
    match (*(*lgl).opts).profile.val {
        0 => {
            res = (((&mut (*(0 as *mut Times)).lookahead as *mut libc::c_double)
                .offset_from(&mut (*(0 as *mut Times)).all) as libc::c_long)
                < idx as libc::c_long) as libc::c_int;
        }
        1 => {
            res = (((&mut (*(0 as *mut Times)).probe as *mut libc::c_double)
                .offset_from(&mut (*(0 as *mut Times)).all) as libc::c_long)
                < idx as libc::c_long) as libc::c_int;
        }
        2 => {
            res = (((&mut (*(0 as *mut Times)).backward as *mut libc::c_double)
                .offset_from(&mut (*(0 as *mut Times)).all) as libc::c_long)
                < idx as libc::c_long) as libc::c_int;
        }
        3 => {
            res = (((&mut (*(0 as *mut Times)).reduce as *mut libc::c_double)
                .offset_from(&mut (*(0 as *mut Times)).all) as libc::c_long)
                < idx as libc::c_long) as libc::c_int;
        }
        _ => {
            res = 0 as libc::c_int;
        }
    }
    return res;
}
unsafe extern "C" fn lglignprofptr(
    mut lgl: *mut LGL,
    mut timestatsptr: *mut libc::c_double,
) -> libc::c_int {
    return lglignprofidx(lgl, lglprofidx(lgl, timestatsptr));
}
unsafe extern "C" fn lglstart(mut lgl: *mut LGL, mut timestatsptr: *mut libc::c_double) {
    let mut timer: *mut Timer = 0 as *mut Timer;
    let mut ign: libc::c_int = 0;
    let mut idx: libc::c_int = 0;
    idx = lglprofidx(lgl, timestatsptr);
    ign = lglignprofidx(lgl, idx);
    let fresh0 = (*(*lgl).timers).nest;
    (*(*lgl).timers).nest = (*(*lgl).timers).nest + 1;
    timer = ((*(*lgl).timers).stk).as_mut_ptr().offset(fresh0 as isize);
    (*timer).idx = idx;
    (*timer).ign = ign;
    if (*timer).ign != 0 {
        (*timer).start = 0 as libc::c_int as libc::c_double;
    } else {
        (*timer).start = lglgetime(lgl);
    };
}
#[no_mangle]
pub unsafe extern "C" fn lglflushtimers(mut lgl: *mut LGL) {
    let mut time: libc::c_double = lglgetime(lgl);
    let mut delta: libc::c_double = 0.;
    let mut entered: libc::c_double = 0.;
    let mut ptr: *mut libc::c_double = 0 as *mut libc::c_double;
    let mut timer: *mut Timer = 0 as *mut Timer;
    let mut nest: libc::c_int = 0;
    nest = 0 as libc::c_int;
    while nest < (*(*lgl).timers).nest {
        timer = ((*(*lgl).timers).stk).as_mut_ptr().offset(nest as isize);
        if !((*timer).ign != 0) {
            entered = (*timer).start;
            (*timer).start = time;
            delta = time - entered;
            if delta < 0 as libc::c_int as libc::c_double {
                delta = 0 as libc::c_int as libc::c_double;
            }
            ptr = ((*lgl).times as *mut libc::c_double).offset((*timer).idx as isize);
            *ptr += delta;
        }
        nest += 1;
        nest;
    }
}
#[no_mangle]
pub unsafe extern "C" fn lglsec(mut lgl: *mut LGL) -> libc::c_double {
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 7], &[libc::c_char; 7]>(b"lglsec\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    lglflushtimers(lgl);
    return (*(*lgl).times).all;
}
unsafe extern "C" fn lglstop(mut lgl: *mut LGL) {
    let mut timer: *mut Timer = 0 as *mut Timer;
    timer = ((*(*lgl).timers).stk)
        .as_mut_ptr()
        .offset((*(*lgl).timers).nest as isize)
        .offset(-(1 as libc::c_int as isize));
    if (*timer).ign == 0 {
        lglflushtimers(lgl);
    }
    (*(*lgl).timers).nest -= 1;
    (*(*lgl).timers).nest;
}
#[no_mangle]
pub unsafe extern "C" fn lglsetid(
    mut lgl: *mut LGL,
    mut tid: libc::c_int,
    mut tids: libc::c_int,
) {
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 9], &[libc::c_char; 9]>(b"lglsetid\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).forked == 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 9], &[libc::c_char; 9]>(b"lglsetid\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"forked manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if !(tid < 0 as libc::c_int) {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 9], &[libc::c_char; 9]>(b"lglsetid\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"negative id\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if !(tid >= tids) {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 9], &[libc::c_char; 9]>(b"lglsetid\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(
            stderr,
            b"id exceed number of ids\0" as *const u8 as *const libc::c_char,
        );
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    (*lgl).tid = tid;
    (*lgl).tids = tids;
}
unsafe extern "C" fn lglinc(mut lgl: *mut LGL, mut bytes: size_t) {
    (*(*lgl).stats).bytes.current = ((*(*lgl).stats).bytes.current).wrapping_add(bytes);
    if (*(*lgl).stats).bytes.max < (*(*lgl).stats).bytes.current {
        (*(*lgl).stats).bytes.max = (*(*lgl).stats).bytes.current;
    }
}
unsafe extern "C" fn lgldec(mut lgl: *mut LGL, mut bytes: size_t) {
    (*(*lgl).stats).bytes.current = ((*(*lgl).stats).bytes.current).wrapping_sub(bytes);
}
unsafe extern "C" fn lglnew(mut lgl: *mut LGL, mut bytes: size_t) -> *mut libc::c_void {
    let mut res: *mut libc::c_void = 0 as *mut libc::c_void;
    if bytes == 0 {
        return 0 as *mut libc::c_void;
    }
    if ((*(*lgl).mem).alloc).is_some() {
        res = ((*(*lgl).mem).alloc)
            .expect("non-null function pointer")((*(*lgl).mem).state, bytes);
    } else {
        res = malloc(bytes);
    }
    if res.is_null() {
        lgldie(
            lgl,
            b"out of memory allocating %ld bytes\0" as *const u8 as *const libc::c_char,
            bytes,
        );
    }
    lglinc(lgl, bytes);
    if !res.is_null() {
        memset(res, 0 as libc::c_int, bytes);
    }
    return res;
}
unsafe extern "C" fn lgldel(
    mut lgl: *mut LGL,
    mut ptr: *mut libc::c_void,
    mut bytes: size_t,
) {
    if ptr.is_null() {
        return;
    }
    lgldec(lgl, bytes);
    if ((*(*lgl).mem).dealloc).is_some() {
        ((*(*lgl).mem).dealloc)
            .expect("non-null function pointer")((*(*lgl).mem).state, ptr, bytes);
    } else {
        free(ptr);
    };
}
unsafe extern "C" fn lglrsz(
    mut lgl: *mut LGL,
    mut ptr: *mut libc::c_void,
    mut old: size_t,
    mut new: size_t,
) -> *mut libc::c_void {
    let mut res: *mut libc::c_void = 0 as *mut libc::c_void;
    if ptr.is_null() {
        return lglnew(lgl, new);
    }
    if new == 0 {
        lgldel(lgl, ptr, old);
        return 0 as *mut libc::c_void;
    }
    if old == new {
        return ptr;
    }
    lgldec(lgl, old);
    if ((*(*lgl).mem).realloc).is_some() {
        res = ((*(*lgl).mem).realloc)
            .expect("non-null function pointer")((*(*lgl).mem).state, ptr, old, new);
    } else {
        res = realloc(ptr, new);
    }
    if res.is_null() {
        lgldie(
            lgl,
            b"out of memory reallocating %ld to %ld bytes\0" as *const u8
                as *const libc::c_char,
            old,
            new,
        );
    }
    lglinc(lgl, new);
    if new > old {
        memset(res.offset(old as isize), 0 as libc::c_int, new.wrapping_sub(old));
    }
    return res;
}
unsafe extern "C" fn lglstrdup(
    mut lgl: *mut LGL,
    mut str: *const libc::c_char,
) -> *mut libc::c_char {
    let mut res: *mut libc::c_char = 0 as *mut libc::c_char;
    res = lglnew(
        lgl,
        (strlen(str))
            .wrapping_add(1 as libc::c_int as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_char>() as libc::c_ulong),
    ) as *mut libc::c_char;
    return strcpy(res, str);
}
unsafe extern "C" fn lgldelstr(mut lgl: *mut LGL, mut str: *mut libc::c_char) {
    lgldel(
        lgl,
        str as *mut libc::c_void,
        (strlen(str))
            .wrapping_add(1 as libc::c_int as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_char>() as libc::c_ulong),
    );
    str = 0 as *mut libc::c_char;
}
unsafe extern "C" fn lglinitcbs(mut lgl: *mut LGL) {
    if ((*lgl).cbs).is_null() {
        (*lgl)
            .cbs = lglnew(
            lgl,
            (1 as libc::c_int as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<Cbs>() as libc::c_ulong),
        ) as *mut Cbs;
    }
}
#[no_mangle]
pub unsafe extern "C" fn lglonabort(
    mut lgl: *mut LGL,
    mut abortstate: *mut libc::c_void,
    mut onabort: Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
) {
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 11], &[libc::c_char; 11]>(b"lglonabort\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).forked == 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 11], &[libc::c_char; 11]>(b"lglonabort\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"forked manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    lglinitcbs(lgl);
    (*(*lgl).cbs).abortstate = abortstate;
    (*(*lgl).cbs).onabort = onabort;
}
#[no_mangle]
pub unsafe extern "C" fn lglseterm(
    mut lgl: *mut LGL,
    mut fun: Option::<unsafe extern "C" fn(*mut libc::c_void) -> libc::c_int>,
    mut state: *mut libc::c_void,
) {
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 10], &[libc::c_char; 10]>(b"lglseterm\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).forked == 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 10], &[libc::c_char; 10]>(b"lglseterm\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"forked manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    lglinitcbs(lgl);
    (*(*lgl).cbs).term.fun = fun;
    (*(*lgl).cbs).term.state = state;
}
#[no_mangle]
pub unsafe extern "C" fn lglsetproduceunit(
    mut lgl: *mut LGL,
    mut fun: Option::<unsafe extern "C" fn(*mut libc::c_void, libc::c_int) -> ()>,
    mut state: *mut libc::c_void,
) {
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<
                &[u8; 18],
                &[libc::c_char; 18],
            >(b"lglsetproduceunit\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).forked == 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<
                &[u8; 18],
                &[libc::c_char; 18],
            >(b"lglsetproduceunit\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"forked manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    lglinitcbs(lgl);
    (*(*lgl).cbs).units.produce.fun = fun;
    (*(*lgl).cbs).units.produce.state = state;
}
#[no_mangle]
pub unsafe extern "C" fn lglsetconsumeunits(
    mut lgl: *mut LGL,
    mut fun: Option::<
        unsafe extern "C" fn(
            *mut libc::c_void,
            *mut *mut libc::c_int,
            *mut *mut libc::c_int,
        ) -> (),
    >,
    mut state: *mut libc::c_void,
) {
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<
                &[u8; 19],
                &[libc::c_char; 19],
            >(b"lglsetconsumeunits\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).forked == 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<
                &[u8; 19],
                &[libc::c_char; 19],
            >(b"lglsetconsumeunits\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"forked manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    lglinitcbs(lgl);
    (*(*lgl).cbs).units.consume.fun = fun;
    (*(*lgl).cbs).units.consume.state = state;
}
#[no_mangle]
pub unsafe extern "C" fn lglsetconsumedunits(
    mut lgl: *mut LGL,
    mut fun: Option::<unsafe extern "C" fn(*mut libc::c_void, libc::c_int) -> ()>,
    mut state: *mut libc::c_void,
) {
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<
                &[u8; 20],
                &[libc::c_char; 20],
            >(b"lglsetconsumedunits\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).forked == 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<
                &[u8; 20],
                &[libc::c_char; 20],
            >(b"lglsetconsumedunits\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"forked manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    lglinitcbs(lgl);
    (*(*lgl).cbs).units.consumed.fun = fun;
    (*(*lgl).cbs).units.consumed.state = state;
}
#[no_mangle]
pub unsafe extern "C" fn lglsetproducecls(
    mut lgl: *mut LGL,
    mut fun: Option::<
        unsafe extern "C" fn(*mut libc::c_void, *mut libc::c_int, libc::c_int) -> (),
    >,
    mut state: *mut libc::c_void,
) {
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<
                &[u8; 17],
                &[libc::c_char; 17],
            >(b"lglsetproducecls\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).forked == 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<
                &[u8; 17],
                &[libc::c_char; 17],
            >(b"lglsetproducecls\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"forked manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    lglinitcbs(lgl);
    (*(*lgl).cbs).cls.produce.fun = fun;
    (*(*lgl).cbs).cls.produce.state = state;
}
#[no_mangle]
pub unsafe extern "C" fn lglsetconsumecls(
    mut lgl: *mut LGL,
    mut fun: Option::<
        unsafe extern "C" fn(
            *mut libc::c_void,
            *mut *mut libc::c_int,
            *mut libc::c_int,
        ) -> (),
    >,
    mut state: *mut libc::c_void,
) {
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<
                &[u8; 17],
                &[libc::c_char; 17],
            >(b"lglsetconsumecls\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).forked == 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<
                &[u8; 17],
                &[libc::c_char; 17],
            >(b"lglsetconsumecls\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"forked manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    lglinitcbs(lgl);
    (*(*lgl).cbs).cls.consume.fun = fun;
    (*(*lgl).cbs).cls.consume.state = state;
}
#[no_mangle]
pub unsafe extern "C" fn lglsetconsumedcls(
    mut lgl: *mut LGL,
    mut fun: Option::<unsafe extern "C" fn(*mut libc::c_void, libc::c_int) -> ()>,
    mut state: *mut libc::c_void,
) {
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<
                &[u8; 18],
                &[libc::c_char; 18],
            >(b"lglsetconsumedcls\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).forked == 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<
                &[u8; 18],
                &[libc::c_char; 18],
            >(b"lglsetconsumedcls\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"forked manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    lglinitcbs(lgl);
    (*(*lgl).cbs).cls.consumed.fun = fun;
    (*(*lgl).cbs).cls.consumed.state = state;
}
#[no_mangle]
pub unsafe extern "C" fn lglsetlockeq(
    mut lgl: *mut LGL,
    mut fun: Option::<unsafe extern "C" fn(*mut libc::c_void) -> *mut libc::c_int>,
    mut state: *mut libc::c_void,
) {
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<
                &[u8; 13],
                &[libc::c_char; 13],
            >(b"lglsetlockeq\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).forked == 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<
                &[u8; 13],
                &[libc::c_char; 13],
            >(b"lglsetlockeq\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"forked manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    lglinitcbs(lgl);
    (*(*lgl).cbs).eqs.lock.fun = fun;
    (*(*lgl).cbs).eqs.lock.state = state;
}
#[no_mangle]
pub unsafe extern "C" fn lglsetunlockeq(
    mut lgl: *mut LGL,
    mut fun: Option::<
        unsafe extern "C" fn(*mut libc::c_void, libc::c_int, libc::c_int) -> (),
    >,
    mut state: *mut libc::c_void,
) {
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<
                &[u8; 15],
                &[libc::c_char; 15],
            >(b"lglsetunlockeq\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).forked == 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<
                &[u8; 15],
                &[libc::c_char; 15],
            >(b"lglsetunlockeq\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"forked manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    lglinitcbs(lgl);
    (*(*lgl).cbs).eqs.unlock.fun = fun;
    (*(*lgl).cbs).eqs.unlock.state = state;
}
#[no_mangle]
pub unsafe extern "C" fn lglsetmsglock(
    mut lgl: *mut LGL,
    mut lock: Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
    mut unlock: Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
    mut state: *mut libc::c_void,
) {
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<
                &[u8; 14],
                &[libc::c_char; 14],
            >(b"lglsetmsglock\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).forked == 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<
                &[u8; 14],
                &[libc::c_char; 14],
            >(b"lglsetmsglock\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"forked manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    lglinitcbs(lgl);
    (*(*lgl).cbs).msglock.lock = lock;
    (*(*lgl).cbs).msglock.unlock = unlock;
    (*(*lgl).cbs).msglock.state = state;
}
#[no_mangle]
pub unsafe extern "C" fn lglsetime(
    mut lgl: *mut LGL,
    mut time: Option::<unsafe extern "C" fn() -> libc::c_double>,
) {
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 10], &[libc::c_char; 10]>(b"lglsetime\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).forked == 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 10], &[libc::c_char; 10]>(b"lglsetime\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"forked manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    lglinitcbs(lgl);
    (*(*lgl).cbs).getime = time;
}
unsafe extern "C" fn lglfullstk(mut s: *mut Stk) -> libc::c_int {
    return ((*s).top == (*s).end) as libc::c_int;
}
unsafe extern "C" fn lglmtstk(mut s: *mut Stk) -> libc::c_int {
    return ((*s).top == (*s).start) as libc::c_int;
}
unsafe extern "C" fn lglcntstk(mut s: *mut Stk) -> size_t {
    return ((*s).top).offset_from((*s).start) as libc::c_long as size_t;
}
unsafe extern "C" fn lglszstk(mut s: *mut Stk) -> size_t {
    return ((*s).end).offset_from((*s).start) as libc::c_long as size_t;
}
unsafe extern "C" fn lglpeek(mut s: *mut Stk, mut pos: libc::c_int) -> libc::c_int {
    return *((*s).start).offset(pos as isize);
}
unsafe extern "C" fn lglpoke(
    mut s: *mut Stk,
    mut pos: libc::c_int,
    mut val: libc::c_int,
) {
    *((*s).start).offset(pos as isize) = val;
}
unsafe extern "C" fn lglenlstk(mut lgl: *mut LGL, mut s: *mut Stk) {
    let mut old_size: size_t = lglszstk(s);
    let mut new_size: size_t = if old_size != 0 {
        2 as libc::c_int as size_t * old_size
    } else {
        1 as libc::c_int as size_t
    };
    let mut count: size_t = lglcntstk(s);
    (*s)
        .start = lglrsz(
        lgl,
        (*s).start as *mut libc::c_void,
        old_size.wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
        new_size.wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
    ) as *mut libc::c_int;
    (*s).top = ((*s).start).offset(count as isize);
    (*s).end = ((*s).start).offset(new_size as isize);
}
unsafe extern "C" fn lglrelstk(mut lgl: *mut LGL, mut s: *mut Stk) {
    lgldel(
        lgl,
        (*s).start as *mut libc::c_void,
        (lglszstk(s))
            .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
    );
    (*s).start = 0 as *mut libc::c_int;
    memset(
        s as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<Stk>() as libc::c_ulong,
    );
}
unsafe extern "C" fn lglshrstk(
    mut lgl: *mut LGL,
    mut s: *mut Stk,
    mut new_size: libc::c_int,
) {
    let mut old_size: size_t = 0;
    let mut count: size_t = lglcntstk(s);
    if new_size > 0 as libc::c_int {
        old_size = lglszstk(s);
        (*s)
            .start = lglrsz(
            lgl,
            (*s).start as *mut libc::c_void,
            old_size
                .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
            (new_size as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
        ) as *mut libc::c_int;
        (*s).top = ((*s).start).offset(count as isize);
        (*s).end = ((*s).start).offset(new_size as isize);
    } else {
        lglrelstk(lgl, s);
    };
}
unsafe extern "C" fn lglfitstk(mut lgl: *mut LGL, mut s: *mut Stk) {
    lglshrstk(lgl, s, lglcntstk(s) as libc::c_int);
}
unsafe extern "C" fn lglpushstk(
    mut lgl: *mut LGL,
    mut s: *mut Stk,
    mut elem: libc::c_int,
) {
    if lglfullstk(s) != 0 {
        lglenlstk(lgl, s);
    }
    let fresh1 = (*s).top;
    (*s).top = ((*s).top).offset(1);
    *fresh1 = elem;
}
unsafe extern "C" fn lglrmstk(mut s: *mut Stk, mut elem: libc::c_int) {
    let mut p: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut q: *mut libc::c_int = 0 as *mut libc::c_int;
    p = (*s).start;
    while p < (*s).top {
        if *p == elem {
            break;
        }
        p = p.offset(1);
        p;
    }
    let fresh2 = p;
    p = p.offset(1);
    q = fresh2;
    while p < (*s).top {
        let fresh3 = p;
        p = p.offset(1);
        let fresh4 = q;
        q = q.offset(1);
        *fresh4 = *fresh3;
    }
    (*s).top = q;
}
unsafe extern "C" fn lglpopstk(mut s: *mut Stk) -> libc::c_int {
    (*s).top = ((*s).top).offset(-1);
    return *(*s).top;
}
unsafe extern "C" fn lgltopstk(mut s: *mut Stk) -> libc::c_int {
    return *((*s).top).offset(-(1 as libc::c_int) as isize);
}
unsafe extern "C" fn lglrststk(mut s: *mut Stk, mut newsz: libc::c_int) {
    (*s).top = ((*s).start).offset(newsz as isize);
}
unsafe extern "C" fn lglclnstk(mut s: *mut Stk) {
    lglrststk(s, 0 as libc::c_int);
}
unsafe extern "C" fn lgltrapi(
    mut lgl: *mut LGL,
    mut msg: *const libc::c_char,
    mut args: ...
) {
    let mut ap: ::core::ffi::VaListImpl;
    ap = args.clone();
    vfprintf((*lgl).apitrace, msg, ap.as_va_list());
    fputc('\n' as i32, (*lgl).apitrace);
    if (*(*lgl).opts).trapiflush.val != 0 {
        fflush((*lgl).apitrace);
    }
}
unsafe extern "C" fn lglopenapitrace(mut lgl: *mut LGL, mut name: *const libc::c_char) {
    let mut file: *mut FILE = 0 as *mut FILE;
    let mut cmd: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut len: libc::c_int = 0;
    len = strlen(name) as libc::c_int;
    if len >= 3 as libc::c_int
        && strcmp(
            name.offset(len as isize).offset(-(3 as libc::c_int as isize)),
            b".gz\0" as *const u8 as *const libc::c_char,
        ) == 0
    {
        len += 20 as libc::c_int;
        cmd = lglnew(
            lgl,
            (len as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<libc::c_char>() as libc::c_ulong),
        ) as *mut libc::c_char;
        sprintf(cmd, b"gzip -c > %s\0" as *const u8 as *const libc::c_char, name);
        file = popen(cmd, b"w\0" as *const u8 as *const libc::c_char);
        lgldel(
            lgl,
            cmd as *mut libc::c_void,
            (len as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<libc::c_char>() as libc::c_ulong),
        );
        cmd = 0 as *mut libc::c_char;
        if !file.is_null() {
            (*lgl).closeapitrace = 2 as libc::c_int as libc::c_char;
        }
    } else {
        file = fopen(name, b"w\0" as *const u8 as *const libc::c_char);
        if !file.is_null() {
            (*lgl).closeapitrace = 1 as libc::c_int as libc::c_char;
        }
    }
    if !file.is_null() {
        (*lgl).apitrace = file;
    } else {
        lglwrn(
            lgl,
            b"can not write API trace to '%s'\0" as *const u8 as *const libc::c_char,
            name,
        );
    }
    if !((*lgl).apitrace).is_null() {
        lgltrapi(lgl, b"init\0" as *const u8 as *const libc::c_char);
    }
}
#[no_mangle]
pub unsafe extern "C" fn lglwtrapi(mut lgl: *mut LGL, mut apitrace: *mut FILE) {
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 10], &[libc::c_char; 10]>(b"lglwtrapi\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).state as libc::c_uint & UNUSED as libc::c_int as libc::c_uint != 0
    {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 10], &[libc::c_char; 10]>(b"lglwtrapi\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(
            stderr,
            b"!(%s)\0" as *const u8 as *const libc::c_char,
            b"UNUSED\0" as *const u8 as *const libc::c_char,
        );
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if ((*lgl).apitrace).is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 10], &[libc::c_char; 10]>(b"lglwtrapi\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(
            stderr,
            b"can only write one API trace\0" as *const u8 as *const libc::c_char,
        );
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    (*lgl).apitrace = apitrace;
    if !((*lgl).apitrace).is_null() {
        lgltrapi(lgl, b"init\0" as *const u8 as *const libc::c_char);
    }
}
unsafe extern "C" fn lglrand(mut lgl: *mut LGL) -> libc::c_uint {
    let mut res: libc::c_uint = 0;
    (*lgl)
        .rng
        .z = (36969 as libc::c_int as libc::c_uint)
        .wrapping_mul((*lgl).rng.z & 65535 as libc::c_int as libc::c_uint)
        .wrapping_add((*lgl).rng.z >> 16 as libc::c_int);
    (*lgl)
        .rng
        .w = (18000 as libc::c_int as libc::c_uint)
        .wrapping_mul((*lgl).rng.w & 65535 as libc::c_int as libc::c_uint)
        .wrapping_add((*lgl).rng.w >> 16 as libc::c_int);
    res = ((*lgl).rng.z << 16 as libc::c_int).wrapping_add((*lgl).rng.w);
    return res;
}
unsafe extern "C" fn lglmtftk(mut ftk: *mut Ftk) -> libc::c_int {
    return ((*ftk).top == (*ftk).start) as libc::c_int;
}
unsafe extern "C" fn lglfullftk(mut ftk: *mut Ftk) -> libc::c_int {
    return ((*ftk).top == (*ftk).end) as libc::c_int;
}
unsafe extern "C" fn lglsizeftk(mut ftk: *mut Ftk) -> libc::c_int {
    return ((*ftk).end).offset_from((*ftk).start) as libc::c_long as libc::c_int;
}
unsafe extern "C" fn lglcntftk(mut ftk: *mut Ftk) -> libc::c_int {
    return ((*ftk).top).offset_from((*ftk).start) as libc::c_long as libc::c_int;
}
unsafe extern "C" fn lglrelftk(mut lgl: *mut LGL, mut ftk: *mut Ftk) {
    lgldel(
        lgl,
        (*ftk).start as *mut libc::c_void,
        (lglsizeftk(ftk) as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Flt>() as libc::c_ulong),
    );
    (*ftk).start = 0 as *mut Flt;
    memset(
        ftk as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<Ftk>() as libc::c_ulong,
    );
}
unsafe extern "C" fn lglenlftk(mut lgl: *mut LGL, mut ftk: *mut Ftk) {
    let mut oldsize: libc::c_int = lglsizeftk(ftk);
    let mut newsize: libc::c_int = if oldsize != 0 {
        2 as libc::c_int * oldsize
    } else {
        1 as libc::c_int
    };
    let mut count: libc::c_int = lglcntftk(ftk);
    (*ftk)
        .start = lglrsz(
        lgl,
        (*ftk).start as *mut libc::c_void,
        (oldsize as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Flt>() as libc::c_ulong),
        (newsize as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Flt>() as libc::c_ulong),
    ) as *mut Flt;
    (*ftk).top = ((*ftk).start).offset(count as isize);
    (*ftk).end = ((*ftk).start).offset(newsize as isize);
}
unsafe extern "C" fn lglpushftk(mut lgl: *mut LGL, mut ftk: *mut Ftk, mut f: Flt) {
    if lglfullftk(ftk) != 0 {
        lglenlftk(lgl, ftk);
    }
    let fresh5 = (*ftk).top;
    (*ftk).top = ((*ftk).top).offset(1);
    *fresh5 = f;
}
unsafe extern "C" fn lgltopftk(mut ftk: *mut Ftk) -> Flt {
    return *((*ftk).top).offset(-(1 as libc::c_int) as isize);
}
unsafe extern "C" fn lglpopftk(mut ftk: *mut Ftk) -> Flt {
    (*ftk).top = ((*ftk).top).offset(-1);
    return *(*ftk).top;
}
unsafe extern "C" fn lglfullctk(mut ctk: *mut Ctk) -> libc::c_int {
    return ((*ctk).top == (*ctk).end) as libc::c_int;
}
unsafe extern "C" fn lglsizectk(mut ctk: *mut Ctk) -> libc::c_int {
    return ((*ctk).end).offset_from((*ctk).start) as libc::c_long as libc::c_int;
}
unsafe extern "C" fn lglcntctk(mut ctk: *mut Ctk) -> libc::c_int {
    return ((*ctk).top).offset_from((*ctk).start) as libc::c_long as libc::c_int;
}
unsafe extern "C" fn lglrelctk(mut lgl: *mut LGL, mut ctk: *mut Ctk) {
    lgldel(
        lgl,
        (*ctk).start as *mut libc::c_void,
        (lglsizectk(ctk) as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Ctr>() as libc::c_ulong),
    );
    (*ctk).start = 0 as *mut Ctr;
    memset(
        ctk as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<Ctk>() as libc::c_ulong,
    );
}
unsafe extern "C" fn lglenlctk(mut lgl: *mut LGL, mut ctk: *mut Ctk) {
    let mut oldsize: libc::c_int = lglsizectk(ctk);
    let mut newsize: libc::c_int = if oldsize != 0 {
        2 as libc::c_int * oldsize
    } else {
        1 as libc::c_int
    };
    let mut count: libc::c_int = lglcntctk(ctk);
    (*ctk)
        .start = lglrsz(
        lgl,
        (*ctk).start as *mut libc::c_void,
        (oldsize as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Ctr>() as libc::c_ulong),
        (newsize as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Ctr>() as libc::c_ulong),
    ) as *mut Ctr;
    (*ctk).top = ((*ctk).start).offset(count as isize);
    (*ctk).end = ((*ctk).start).offset(newsize as isize);
}
unsafe extern "C" fn lglpushcontrol(mut lgl: *mut LGL, mut decision: libc::c_int) {
    let mut ctk: *mut Ctk = &mut (*lgl).control;
    let mut ctr: *mut Ctr = 0 as *mut Ctr;
    if lglfullctk(ctk) != 0 {
        lglenlctk(lgl, ctk);
    }
    let fresh6 = (*ctk).top;
    (*ctk).top = ((*ctk).top).offset(1);
    ctr = fresh6;
    (*ctr).set_decision(decision);
    (*ctr).set_used(0 as libc::c_int as libc::c_uint);
    (*ctr).set_used2(0 as libc::c_int as libc::c_uint);
}
unsafe extern "C" fn lglpopcontrol(mut lgl: *mut LGL) {
    (*lgl).control.top = ((*lgl).control.top).offset(-1);
    (*lgl).control.top;
}
unsafe extern "C" fn lglrstcontrol(mut lgl: *mut LGL, mut count: libc::c_int) {
    while lglcntctk(&mut (*lgl).control) > count {
        lglpopcontrol(lgl);
    }
}
unsafe extern "C" fn lglctr(mut lgl: *mut LGL, mut level: libc::c_int) -> *mut Ctr {
    let mut ctk: *mut Ctk = &mut (*lgl).control;
    let mut res: *mut Ctr = 0 as *mut Ctr;
    res = ((*ctk).start).offset(level as isize);
    return res;
}
unsafe extern "C" fn lglevelused(
    mut lgl: *mut LGL,
    mut level: libc::c_int,
) -> libc::c_uint {
    return (*lglctr(lgl, level)).used();
}
unsafe extern "C" fn lgluselevel(mut lgl: *mut LGL, mut level: libc::c_int) {
    let mut ctk: *mut Ctk = &mut (*lgl).control;
    let mut ctr: *mut Ctr = 0 as *mut Ctr;
    ctr = ((*ctk).start).offset(level as isize);
    if (*ctr).used() == 0 {
        lglpushstk(lgl, &mut (*lgl).frames, level);
        (*ctr).set_used(1 as libc::c_int as libc::c_uint);
    } else if (*ctr).used() as libc::c_int == 1 as libc::c_int {
        (*ctr).set_used(2 as libc::c_int as libc::c_uint);
    }
}
unsafe extern "C" fn lglunuselevel(mut lgl: *mut LGL, mut level: libc::c_int) {
    let mut ctk: *mut Ctk = &mut (*lgl).control;
    let mut ctr: *mut Ctr = 0 as *mut Ctr;
    if level >= lglcntctk(ctk) {
        return;
    }
    ctr = ((*ctk).start).offset(level as isize);
    (*ctr).set_used(0 as libc::c_int as libc::c_uint);
}
#[no_mangle]
pub unsafe extern "C" fn lglgetenv(
    mut lgl: *mut LGL,
    mut opt: *mut Opt,
    mut lname: *const libc::c_char,
) {
    let mut q: *const libc::c_char = 0 as *const libc::c_char;
    let mut valstr: *const libc::c_char = 0 as *const libc::c_char;
    let mut uname: [libc::c_char; 40] = [0; 40];
    let mut p: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut newval: libc::c_int = 0;
    let mut oldval: libc::c_int = 0;
    uname[0 as libc::c_int as usize] = 'L' as i32 as libc::c_char;
    uname[1 as libc::c_int as usize] = 'G' as i32 as libc::c_char;
    uname[2 as libc::c_int as usize] = 'L' as i32 as libc::c_char;
    p = uname.as_mut_ptr().offset(3 as libc::c_int as isize);
    q = lname;
    while *q != 0 {
        let fresh7 = p;
        p = p.offset(1);
        *fresh7 = ({
            let mut __res: libc::c_int = 0;
            if ::core::mem::size_of::<libc::c_int>() as libc::c_ulong
                > 1 as libc::c_int as libc::c_ulong
            {
                if 0 != 0 {
                    let mut __c: libc::c_int = *q as libc::c_int;
                    __res = if __c < -(128 as libc::c_int) || __c > 255 as libc::c_int {
                        __c
                    } else {
                        *(*__ctype_toupper_loc()).offset(__c as isize)
                    };
                } else {
                    __res = toupper(*q as libc::c_int);
                }
            } else {
                __res = *(*__ctype_toupper_loc()).offset(*q as libc::c_int as isize);
            }
            __res
        }) as libc::c_char;
        q = q.offset(1);
        q;
    }
    *p = 0 as libc::c_int as libc::c_char;
    valstr = getenv(uname.as_mut_ptr());
    if valstr.is_null() {
        return;
    }
    oldval = (*opt).val;
    newval = atoi(valstr);
    if newval < (*opt).min {
        newval = (*opt).min;
    }
    if newval > (*opt).max {
        newval = (*opt).max;
    }
    if newval == oldval {
        return;
    }
    (*opt).val = newval;
    if !((*lgl).apitrace).is_null() {
        lgltrapi(
            lgl,
            b"option %s %d\0" as *const u8 as *const libc::c_char,
            lname,
            newval,
        );
    }
    if ((*lgl).clone).is_null() {} else {
        fprintf(
            stderr,
            b"liblgl.a: %s:%d: %s: Coverage target `%s' reached.\0" as *const u8
                as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 10], &[libc::c_char; 10]>(b"lglgetenv\0"))
                .as_ptr(),
            1818 as libc::c_int,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            b"lgl->clone\0" as *const u8 as *const libc::c_char,
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputc('\n' as i32, stderr);
        fflush(stderr);
        abort();
    }
    if !((*lgl).clone).is_null() {
        lglsetopt((*lgl).clone, lname, newval);
    }
}
unsafe extern "C" fn lglchkenv(mut lgl: *mut LGL) {
    extern "C" {
        static mut environ: *mut *mut libc::c_char;
    }
    let mut src: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut eos: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut dst: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut p: *mut *mut libc::c_char = 0 as *mut *mut libc::c_char;
    let mut s: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut d: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut len: libc::c_int = 0;
    p = environ;
    loop {
        src = *p;
        if src.is_null() {
            break;
        }
        if !(*src.offset(0 as libc::c_int as isize) as libc::c_int != 'L' as i32
            || *src.offset(1 as libc::c_int as isize) as libc::c_int != 'G' as i32
            || *src.offset(2 as libc::c_int as isize) as libc::c_int != 'L' as i32)
        {
            eos = src;
            while *eos as libc::c_int != 0 && *eos as libc::c_int != '=' as i32 {
                eos = eos.offset(1);
                eos;
            }
            len = eos.offset_from(src.offset(3 as libc::c_int as isize)) as libc::c_long
                as libc::c_int;
            dst = lglnew(
                lgl,
                ((len + 1 as libc::c_int) as libc::c_ulong)
                    .wrapping_mul(
                        ::core::mem::size_of::<libc::c_char>() as libc::c_ulong,
                    ),
            ) as *mut libc::c_char;
            d = dst;
            s = src.offset(3 as libc::c_int as isize);
            while s < eos {
                let fresh8 = d;
                d = d.offset(1);
                *fresh8 = ({
                    let mut __res: libc::c_int = 0;
                    if ::core::mem::size_of::<libc::c_int>() as libc::c_ulong
                        > 1 as libc::c_int as libc::c_ulong
                    {
                        if 0 != 0 {
                            let mut __c: libc::c_int = *s as libc::c_int;
                            __res = if __c < -(128 as libc::c_int)
                                || __c > 255 as libc::c_int
                            {
                                __c
                            } else {
                                *(*__ctype_tolower_loc()).offset(__c as isize)
                            };
                        } else {
                            __res = tolower(*s as libc::c_int);
                        }
                    } else {
                        __res = *(*__ctype_tolower_loc())
                            .offset(*s as libc::c_int as isize);
                    }
                    __res
                }) as libc::c_char;
                s = s.offset(1);
                s;
            }
            *d = 0 as libc::c_int as libc::c_char;
            if lglhasopt(lgl, dst) == 0
                && strcmp(dst, b"apitrace\0" as *const u8 as *const libc::c_char) != 0
                && strcmp(dst, b"eak\0" as *const u8 as *const libc::c_char) != 0
            {
                lglwrn(
                    lgl,
                    b"invalid 'LGL...' environment '%s'\0" as *const u8
                        as *const libc::c_char,
                    src,
                );
            }
            lgldel(
                lgl,
                dst as *mut libc::c_void,
                ((len + 1 as libc::c_int) as libc::c_ulong)
                    .wrapping_mul(
                        ::core::mem::size_of::<libc::c_char>() as libc::c_ulong,
                    ),
            );
            dst = 0 as *mut libc::c_char;
        }
        p = p.offset(1);
        p;
    };
}
unsafe extern "C" fn lglforcedruplig(mut lgl: *mut LGL, mut val: libc::c_int) {
    if val != 0 {
        (*(*lgl).opts).bca.val = 0 as libc::c_int;
    } else {
        (*(*lgl).opts).bca.val = (*(*lgl).opts).bca.dflt;
    }
    if val != 0 {
        (*(*lgl).opts).card.val = 0 as libc::c_int;
    } else {
        (*(*lgl).opts).card.val = (*(*lgl).opts).card.dflt;
    }
    if val != 0 {
        (*(*lgl).opts).gauss.val = 0 as libc::c_int;
    } else {
        (*(*lgl).opts).gauss.val = (*(*lgl).opts).gauss.dflt;
    }
    if val != 0 {
        (*(*lgl).opts).smallve.val = 0 as libc::c_int;
    } else {
        (*(*lgl).opts).smallve.val = (*(*lgl).opts).smallve.dflt;
    }
    if val != 0 {
        (*(*lgl).opts).unhide.val = 0 as libc::c_int;
    } else {
        (*(*lgl).opts).unhide.val = (*(*lgl).opts).unhide.dflt;
    };
}
unsafe extern "C" fn lglsetdruplig(mut lgl: *mut LGL, mut val: libc::c_int) {
    lglforcedruplig(lgl, val);
    lglprt(
        lgl,
        1 as libc::c_int,
        b"[druplig] druplig checking switched %s\0" as *const u8 as *const libc::c_char,
        if val != 0 {
            b"on\0" as *const u8 as *const libc::c_char
        } else {
            b"off\0" as *const u8 as *const libc::c_char
        },
    );
}
unsafe extern "C" fn lglsetplain(mut lgl: *mut LGL, mut val: libc::c_int) {
    if val != 0 {
        (*(*lgl).opts).bca.val = 0 as libc::c_int;
    } else {
        (*(*lgl).opts).bca.val = (*(*lgl).opts).bca.dflt;
    }
    if val != 0 {
        (*(*lgl).opts).block.val = 0 as libc::c_int;
    } else {
        (*(*lgl).opts).block.val = (*(*lgl).opts).block.dflt;
    }
    if val != 0 {
        (*(*lgl).opts).card.val = 0 as libc::c_int;
    } else {
        (*(*lgl).opts).card.val = (*(*lgl).opts).card.dflt;
    }
    if val != 0 {
        (*(*lgl).opts).cce.val = 0 as libc::c_int;
    } else {
        (*(*lgl).opts).cce.val = (*(*lgl).opts).cce.dflt;
    }
    if val != 0 {
        (*(*lgl).opts).decompose.val = 0 as libc::c_int;
    } else {
        (*(*lgl).opts).decompose.val = (*(*lgl).opts).decompose.dflt;
    }
    if val != 0 {
        (*(*lgl).opts).elim.val = 0 as libc::c_int;
    } else {
        (*(*lgl).opts).elim.val = (*(*lgl).opts).elim.dflt;
    }
    if val != 0 {
        (*(*lgl).opts).gauss.val = 0 as libc::c_int;
    } else {
        (*(*lgl).opts).gauss.val = (*(*lgl).opts).gauss.dflt;
    }
    if val != 0 {
        (*(*lgl).opts).locs.val = 0 as libc::c_int;
    } else {
        (*(*lgl).opts).locs.val = (*(*lgl).opts).locs.dflt;
    }
    if val != 0 {
        (*(*lgl).opts).probe.val = 0 as libc::c_int;
    } else {
        (*(*lgl).opts).probe.val = (*(*lgl).opts).probe.dflt;
    }
    if val != 0 {
        (*(*lgl).opts).quatres.val = 0 as libc::c_int;
    } else {
        (*(*lgl).opts).quatres.val = (*(*lgl).opts).quatres.dflt;
    }
    if val != 0 {
        (*(*lgl).opts).sweep.val = 0 as libc::c_int;
    } else {
        (*(*lgl).opts).sweep.val = (*(*lgl).opts).sweep.dflt;
    }
    if val != 0 {
        (*(*lgl).opts).ternres.val = 0 as libc::c_int;
    } else {
        (*(*lgl).opts).ternres.val = (*(*lgl).opts).ternres.dflt;
    }
    if val != 0 {
        (*(*lgl).opts).transred.val = 0 as libc::c_int;
    } else {
        (*(*lgl).opts).transred.val = (*(*lgl).opts).transred.dflt;
    }
    if val != 0 {
        (*(*lgl).opts).unhide.val = 0 as libc::c_int;
    } else {
        (*(*lgl).opts).unhide.val = (*(*lgl).opts).unhide.dflt;
    }
    lglprt(
        lgl,
        1 as libc::c_int,
        b"[plain] plain solving switched %s\0" as *const u8 as *const libc::c_char,
        if val != 0 {
            b"on\0" as *const u8 as *const libc::c_char
        } else {
            b"off\0" as *const u8 as *const libc::c_char
        },
    );
}
unsafe extern "C" fn lglsetwait(mut lgl: *mut LGL, mut val: libc::c_int) {
    if val != 0 {
        (*(*lgl).opts).batewait.val = (*(*lgl).opts).batewait.dflt;
    } else {
        (*(*lgl).opts).batewait.val = 0 as libc::c_int;
    }
    if val != 0 {
        (*(*lgl).opts).bcawait.val = (*(*lgl).opts).bcawait.dflt;
    } else {
        (*(*lgl).opts).bcawait.val = 0 as libc::c_int;
    }
    if val != 0 {
        (*(*lgl).opts).blockwait.val = (*(*lgl).opts).blockwait.dflt;
    } else {
        (*(*lgl).opts).blockwait.val = 0 as libc::c_int;
    }
    if val != 0 {
        (*(*lgl).opts).ccewait.val = (*(*lgl).opts).ccewait.dflt;
    } else {
        (*(*lgl).opts).ccewait.val = 0 as libc::c_int;
    }
    if val != 0 {
        (*(*lgl).opts).elmblkwait.val = (*(*lgl).opts).elmblkwait.dflt;
    } else {
        (*(*lgl).opts).elmblkwait.val = 0 as libc::c_int;
    }
    if val != 0 {
        (*(*lgl).opts).gausswait.val = (*(*lgl).opts).gausswait.dflt;
    } else {
        (*(*lgl).opts).gausswait.val = 0 as libc::c_int;
    }
    if val != 0 {
        (*(*lgl).opts).smallvewait.val = (*(*lgl).opts).smallvewait.dflt;
    } else {
        (*(*lgl).opts).smallvewait.val = 0 as libc::c_int;
    }
    if val != 0 {
        (*(*lgl).opts).sweepwait.val = (*(*lgl).opts).sweepwait.dflt;
    } else {
        (*(*lgl).opts).sweepwait.val = 0 as libc::c_int;
    }
    if val != 0 {
        (*(*lgl).opts).ternreswait.val = (*(*lgl).opts).ternreswait.dflt;
    } else {
        (*(*lgl).opts).ternreswait.val = 0 as libc::c_int;
    }
    if val != 0 {
        (*(*lgl).opts).transredwait.val = (*(*lgl).opts).transredwait.dflt;
    } else {
        (*(*lgl).opts).transredwait.val = 0 as libc::c_int;
    }
    if val != 0 {
        (*(*lgl).opts).unhidewait.val = (*(*lgl).opts).unhidewait.dflt;
    } else {
        (*(*lgl).opts).unhidewait.val = 0 as libc::c_int;
    }
    lglprt(
        lgl,
        1 as libc::c_int,
        b"[wait] waiting %s\0" as *const u8 as *const libc::c_char,
        if val != 0 {
            b"enabled\0" as *const u8 as *const libc::c_char
        } else {
            b"disabled\0" as *const u8 as *const libc::c_char
        },
    );
}
unsafe extern "C" fn lglnewlgl(
    mut mem: *mut libc::c_void,
    mut alloc: lglalloc,
    mut realloc_0: lglrealloc,
    mut dealloc: lgldealloc,
) -> *mut LGL {
    let mut lgl: *mut LGL = (if alloc.is_some() {
        alloc
            .expect(
                "non-null function pointer",
            )(mem, ::core::mem::size_of::<LGL>() as libc::c_ulong)
    } else {
        malloc(::core::mem::size_of::<LGL>() as libc::c_ulong)
    }) as *mut LGL;
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 10], &[libc::c_char; 10]>(b"lglnewlgl\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(
            stderr,
            b"out of memory allocating main solver object\0" as *const u8
                as *const libc::c_char,
        );
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    memset(
        lgl as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<LGL>() as libc::c_ulong,
    );
    (*lgl)
        .mem = (if alloc.is_some() {
        alloc
            .expect(
                "non-null function pointer",
            )(mem, ::core::mem::size_of::<Mem>() as libc::c_ulong)
    } else {
        malloc(::core::mem::size_of::<Mem>() as libc::c_ulong)
    }) as *mut Mem;
    if !((*lgl).mem).is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 10], &[libc::c_char; 10]>(b"lglnewlgl\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(
            stderr,
            b"out of memory allocating memory manager object\0" as *const u8
                as *const libc::c_char,
        );
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    (*(*lgl).mem).state = mem;
    (*(*lgl).mem).alloc = alloc;
    (*(*lgl).mem).realloc = realloc_0;
    (*(*lgl).mem).dealloc = dealloc;
    (*lgl)
        .opts = (if alloc.is_some() {
        alloc
            .expect(
                "non-null function pointer",
            )(mem, ::core::mem::size_of::<Opts>() as libc::c_ulong)
    } else {
        malloc(::core::mem::size_of::<Opts>() as libc::c_ulong)
    }) as *mut Opts;
    if !((*lgl).opts).is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 10], &[libc::c_char; 10]>(b"lglnewlgl\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(
            stderr,
            b"out of memory allocating option manager object\0" as *const u8
                as *const libc::c_char,
        );
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    memset(
        (*lgl).opts as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<Opts>() as libc::c_ulong,
    );
    (*lgl)
        .stats = (if alloc.is_some() {
        alloc
            .expect(
                "non-null function pointer",
            )(mem, ::core::mem::size_of::<Stats>() as libc::c_ulong)
    } else {
        malloc(::core::mem::size_of::<Stats>() as libc::c_ulong)
    }) as *mut Stats;
    if !((*lgl).stats).is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 10], &[libc::c_char; 10]>(b"lglnewlgl\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(
            stderr,
            b"out of memory allocating statistic counters\0" as *const u8
                as *const libc::c_char,
        );
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    memset(
        (*lgl).stats as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<Stats>() as libc::c_ulong,
    );
    lglinc(lgl, ::core::mem::size_of::<LGL>() as libc::c_ulong);
    lglinc(lgl, ::core::mem::size_of::<Mem>() as libc::c_ulong);
    lglinc(lgl, ::core::mem::size_of::<Opts>() as libc::c_ulong);
    lglinc(lgl, ::core::mem::size_of::<Stats>() as libc::c_ulong);
    return lgl;
}
unsafe extern "C" fn lglsetmaxminscore(mut lgl: *mut LGL) {
    let mut oldmaxscore: Flt = (*lgl).maxscore;
    let mut oldminscore: Flt = (*lgl).minscore;
    (*lgl).maxscore = lglflt(500 as libc::c_int, 1 as libc::c_int as Mnt);
    (*lgl).minscore = lglflt(-(500 as libc::c_int), 1 as libc::c_int as Mnt);
    if oldmaxscore != (*lgl).maxscore {
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[set-maximum-score] maximum score limit %s\0" as *const u8
                as *const libc::c_char,
            lglscr2str(lgl, (*lgl).maxscore),
        );
    }
    if oldminscore != (*lgl).minscore {
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[set-minimum-score] minimum score limit %s\0" as *const u8
                as *const libc::c_char,
            lglscr2str(lgl, (*lgl).minscore),
        );
    }
}
unsafe extern "C" fn lglsetscincf(mut lgl: *mut LGL, mut scincinc: libc::c_int) {
    if scincinc == (*lgl).scincinc {
        return;
    }
    (*lgl)
        .scincf = lglrat(
        (1000 as libc::c_int + scincinc) as libc::c_uint,
        1000 as libc::c_int as libc::c_uint,
    );
    let fresh9 = (*(*lgl).stats).setscincf.count;
    (*(*lgl).stats).setscincf.count = (*(*lgl).stats).setscincf.count + 1;
    if fresh9 == 0 {
        (*(*lgl).stats).setscincf.max = scincinc;
        (*(*lgl).stats).setscincf.min = (*(*lgl).stats).setscincf.max;
    } else {
        if scincinc < (*(*lgl).stats).setscincf.min {
            (*(*lgl).stats).setscincf.min = scincinc;
        }
        if scincinc > (*(*lgl).stats).setscincf.max {
            (*(*lgl).stats).setscincf.max = scincinc;
        }
    }
    lglprt(
        lgl,
        2 as libc::c_int,
        b"[set-score-increment-%d] factor %s (%d/1000) after %lld conflicts\0"
            as *const u8 as *const libc::c_char,
        (*(*lgl).stats).setscincf.count,
        lglscr2str(lgl, (*lgl).scincf),
        scincinc,
        (*(*lgl).stats).confs as libc::c_longlong,
    );
    (*lgl).scincinc = scincinc;
}
unsafe extern "C" fn lglinitscores(mut lgl: *mut LGL) {
    lglsetmaxminscore(lgl);
    lglsetscincf(lgl, (*(*lgl).opts).scincinc.val);
}
#[no_mangle]
pub unsafe extern "C" fn lglminit(
    mut mem: *mut libc::c_void,
    mut alloc: lglalloc,
    mut realloc_0: lglrealloc,
    mut dealloc: lgldealloc,
) -> *mut LGL {
    let mut apitracename: *const libc::c_char = 0 as *const libc::c_char;
    let mut lgl: *mut LGL = 0 as *mut LGL;
    let mut i: libc::c_int = 0;
    lgl = 0 as *mut LGL;
    if !(alloc.is_none() as libc::c_int + realloc_0.is_none() as libc::c_int
        + dealloc.is_none() as libc::c_int != 0 as libc::c_int
        && alloc.is_none() as libc::c_int + realloc_0.is_none() as libc::c_int
            + dealloc.is_none() as libc::c_int != 3 as libc::c_int)
    {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 9], &[libc::c_char; 9]>(b"lglminit\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(
            stderr,
            b"inconsistent set of external memory handlers\0" as *const u8
                as *const libc::c_char,
        );
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    lgl = lglnewlgl(mem, alloc, realloc_0, dealloc);
    (*lgl).tid = -(1 as libc::c_int);
    lglpushcontrol(lgl, 0 as libc::c_int);
    (*lgl).out = stdout;
    (*lgl).prefix = lglstrdup(lgl, b"c \0" as *const u8 as *const libc::c_char);
    apitracename = getenv(b"LGLAPITRACE\0" as *const u8 as *const libc::c_char);
    if !apitracename.is_null() {
        lglopenapitrace(lgl, apitracename);
    }
    lglinitopts(lgl, (*lgl).opts);
    if (*(*lgl).opts).plain.val != 0 {
        lglsetplain(lgl, 1 as libc::c_int);
    }
    if (*(*lgl).opts).druplig.val != 0 {
        lglsetdruplig(lgl, 1 as libc::c_int);
    }
    if (*(*lgl).opts).wait.val == 0 {
        lglsetwait(lgl, 0 as libc::c_int);
    }
    (*lgl)
        .times = lglnew(
        lgl,
        (1 as libc::c_int as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Times>() as libc::c_ulong),
    ) as *mut Times;
    (*lgl)
        .timers = lglnew(
        lgl,
        (1 as libc::c_int as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Timers>() as libc::c_ulong),
    ) as *mut Timers;
    (*lgl)
        .limits = lglnew(
        lgl,
        (1 as libc::c_int as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Limits>() as libc::c_ulong),
    ) as *mut Limits;
    (*lgl)
        .fltstr = lglnew(
        lgl,
        (1 as libc::c_int as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<FltStr>() as libc::c_ulong),
    ) as *mut FltStr;
    (*lgl)
        .red = lglnew(
        lgl,
        ((((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int + 1 as libc::c_int)
            as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Stk>() as libc::c_ulong),
    ) as *mut Stk;
    (*lgl)
        .wchs = lglnew(
        lgl,
        (1 as libc::c_int as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Wchs>() as libc::c_ulong),
    ) as *mut Wchs;
    i = 0 as libc::c_int;
    while i < 31 as libc::c_int {
        (*(*lgl).wchs)
            .start[i
            as usize] = (2147483647 as libc::c_int as libc::c_uint)
            .wrapping_mul(2 as libc::c_uint)
            .wrapping_add(1 as libc::c_uint);
        i += 1;
        i;
    }
    lglpushstk(
        lgl,
        &mut (*(*lgl).wchs).stk,
        (2147483647 as libc::c_int as libc::c_uint)
            .wrapping_mul(2 as libc::c_uint)
            .wrapping_add(1 as libc::c_uint) as libc::c_int,
    );
    lglpushstk(
        lgl,
        &mut (*(*lgl).wchs).stk,
        (2147483647 as libc::c_int as libc::c_uint)
            .wrapping_mul(2 as libc::c_uint)
            .wrapping_add(1 as libc::c_uint) as libc::c_int,
    );
    (*lgl).scinc = lglflt(0 as libc::c_int, 1 as libc::c_int as Mnt);
    (*lgl).state = UNUSED;
    return lgl;
}
unsafe extern "C" fn lglcopyclonenfork(mut dst: *mut LGL, mut src: *mut LGL) {
    memcpy(
        (*dst).opts as *mut libc::c_void,
        (*src).opts as *const libc::c_void,
        ::core::mem::size_of::<Opts>() as libc::c_ulong,
    );
    (*dst).out = (*src).out;
    if !((*dst).prefix).is_null() {
        lgldelstr(dst, (*dst).prefix);
    }
    (*dst).prefix = lglstrdup(dst, (*src).prefix);
    if !((*src).cbs).is_null() {
        lglinitcbs(dst);
        if ((*(*src).cbs).onabort).is_some() {
            (*(*dst).cbs).abortstate = (*(*src).cbs).abortstate;
            (*(*dst).cbs).onabort = (*(*src).cbs).onabort;
        }
        if ((*(*src).cbs).getime).is_some() {
            (*(*dst).cbs).getime = (*(*src).cbs).getime;
        }
    }
}
#[no_mangle]
pub unsafe extern "C" fn lglmclone(
    mut orig: *mut LGL,
    mut mem: *mut libc::c_void,
    mut alloc: lglalloc,
    mut realloc_0: lglrealloc,
    mut dealloc: lgldealloc,
) -> *mut LGL {
    let mut max_bytes: size_t = 0;
    let mut current_bytes: size_t = 0;
    let mut lgl: *mut LGL = orig;
    let mut glue: libc::c_int = 0;
    if orig.is_null() {
        return 0 as *mut LGL;
    }
    lglcompact(orig);
    lgl = lglnewlgl(mem, alloc, realloc_0, dealloc);
    memcpy(
        lgl as *mut libc::c_void,
        orig as *const libc::c_void,
        (&mut (*orig).mem as *mut *mut Mem as *mut libc::c_char)
            .offset_from(orig as *mut libc::c_char) as libc::c_long as libc::c_ulong,
    );
    max_bytes = (*(*lgl).stats).bytes.max;
    current_bytes = (*(*lgl).stats).bytes.current;
    memcpy(
        (*lgl).stats as *mut libc::c_void,
        (*orig).stats as *const libc::c_void,
        ::core::mem::size_of::<Stats>() as libc::c_ulong,
    );
    (*(*lgl).stats).bytes.current = current_bytes;
    (*(*lgl).stats).bytes.max = max_bytes;
    lglcopyclonenfork(lgl, orig);
    (*lgl)
        .limits = lglnew(
        lgl,
        (1 as libc::c_int as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Limits>() as libc::c_ulong),
    ) as *mut Limits;
    memcpy(
        (*lgl).limits as *mut libc::c_void,
        (*orig).limits as *const libc::c_void,
        (1 as libc::c_int as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Limits>() as libc::c_ulong),
    );
    (*lgl)
        .times = lglnew(
        lgl,
        (1 as libc::c_int as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Times>() as libc::c_ulong),
    ) as *mut Times;
    memcpy(
        (*lgl).times as *mut libc::c_void,
        (*orig).times as *const libc::c_void,
        (1 as libc::c_int as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Times>() as libc::c_ulong),
    );
    (*lgl)
        .timers = lglnew(
        lgl,
        (1 as libc::c_int as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Timers>() as libc::c_ulong),
    ) as *mut Timers;
    memcpy(
        (*lgl).timers as *mut libc::c_void,
        (*orig).timers as *const libc::c_void,
        (1 as libc::c_int as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Timers>() as libc::c_ulong),
    );
    (*lgl)
        .fltstr = lglnew(
        lgl,
        (1 as libc::c_int as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<FltStr>() as libc::c_ulong),
    ) as *mut FltStr;
    memcpy(
        (*lgl).fltstr as *mut libc::c_void,
        (*orig).fltstr as *const libc::c_void,
        (1 as libc::c_int as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<FltStr>() as libc::c_ulong),
    );
    (*lgl)
        .ext = lglnew(
        lgl,
        ((*orig).szext as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Ext>() as libc::c_ulong),
    ) as *mut Ext;
    memcpy(
        (*lgl).ext as *mut libc::c_void,
        (*orig).ext as *const libc::c_void,
        ((*orig).szext as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Ext>() as libc::c_ulong),
    );
    (*lgl)
        .i2e = lglnew(
        lgl,
        ((*orig).szvars as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
    ) as *mut libc::c_int;
    memcpy(
        (*lgl).i2e as *mut libc::c_void,
        (*orig).i2e as *const libc::c_void,
        ((*orig).szvars as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
    );
    (*lgl)
        .doms = lglnew(
        lgl,
        ((2 as libc::c_int * (*orig).szvars) as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
    ) as *mut libc::c_int;
    memcpy(
        (*lgl).doms as *mut libc::c_void,
        (*orig).doms as *const libc::c_void,
        ((2 as libc::c_int * (*orig).szvars) as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
    );
    (*lgl)
        .dvars = lglnew(
        lgl,
        ((*orig).szvars as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<DVar>() as libc::c_ulong),
    ) as *mut DVar;
    memcpy(
        (*lgl).dvars as *mut libc::c_void,
        (*orig).dvars as *const libc::c_void,
        ((*orig).szvars as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<DVar>() as libc::c_ulong),
    );
    (*lgl)
        .qvars = lglnew(
        lgl,
        ((*orig).szvars as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<QVar>() as libc::c_ulong),
    ) as *mut QVar;
    memcpy(
        (*lgl).qvars as *mut libc::c_void,
        (*orig).qvars as *const libc::c_void,
        ((*orig).szvars as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<QVar>() as libc::c_ulong),
    );
    (*lgl)
        .avars = lglnew(
        lgl,
        ((*orig).szvars as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<AVar>() as libc::c_ulong),
    ) as *mut AVar;
    memcpy(
        (*lgl).avars as *mut libc::c_void,
        (*orig).avars as *const libc::c_void,
        ((*orig).szvars as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<AVar>() as libc::c_ulong),
    );
    (*lgl)
        .vals = lglnew(
        lgl,
        ((*orig).szvars as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Val>() as libc::c_ulong),
    ) as *mut Val;
    memcpy(
        (*lgl).vals as *mut libc::c_void,
        (*orig).vals as *const libc::c_void,
        ((*orig).szvars as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Val>() as libc::c_ulong),
    );
    (*lgl)
        .jwh = lglnew(
        lgl,
        ((2 as libc::c_int * (*orig).szvars) as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Flt>() as libc::c_ulong),
    ) as *mut Flt;
    memcpy(
        (*lgl).jwh as *mut libc::c_void,
        (*orig).jwh as *const libc::c_void,
        ((2 as libc::c_int * (*orig).szvars) as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Flt>() as libc::c_ulong),
    );
    (*lgl)
        .drail = lglnew(
        lgl,
        ((*orig).szdrail as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<TD>() as libc::c_ulong),
    ) as *mut TD;
    memcpy(
        (*lgl).drail as *mut libc::c_void,
        (*orig).drail as *const libc::c_void,
        ((*orig).szdrail as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<TD>() as libc::c_ulong),
    );
    (*lgl)
        .red = lglnew(
        lgl,
        ((((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int + 1 as libc::c_int)
            as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Stk>() as libc::c_ulong),
    ) as *mut Stk;
    glue = 0 as libc::c_int;
    while glue <= ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int {
        let mut COUNT: size_t = ((*((*orig).red).offset(glue as isize)).top)
            .offset_from((*((*orig).red).offset(glue as isize)).start) as libc::c_long
            as size_t;
        let mut SIZE: size_t = ((*((*orig).red).offset(glue as isize)).end)
            .offset_from((*((*orig).red).offset(glue as isize)).start) as libc::c_long
            as size_t;
        let mut BYTES: size_t = SIZE
            .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong);
        let ref mut fresh10 = (*((*lgl).red).offset(glue as isize)).start;
        *fresh10 = lglnew(
            lgl,
            SIZE.wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
        ) as *mut libc::c_int;
        memcpy(
            (*((*lgl).red).offset(glue as isize)).start as *mut libc::c_void,
            (*((*orig).red).offset(glue as isize)).start as *const libc::c_void,
            BYTES,
        );
        let ref mut fresh11 = (*((*lgl).red).offset(glue as isize)).top;
        *fresh11 = ((*((*lgl).red).offset(glue as isize)).start).offset(COUNT as isize);
        let ref mut fresh12 = (*((*lgl).red).offset(glue as isize)).end;
        *fresh12 = ((*((*lgl).red).offset(glue as isize)).start).offset(SIZE as isize);
        glue += 1;
        glue;
    }
    (*lgl)
        .wchs = lglnew(
        lgl,
        (1 as libc::c_int as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Wchs>() as libc::c_ulong),
    ) as *mut Wchs;
    memcpy(
        (*lgl).wchs as *mut libc::c_void,
        (*orig).wchs as *const libc::c_void,
        ::core::mem::size_of::<Wchs>() as libc::c_ulong,
    );
    let mut COUNT_0: size_t = ((*(*orig).wchs).stk.top)
        .offset_from((*(*orig).wchs).stk.start) as libc::c_long as size_t;
    let mut SIZE_0: size_t = ((*(*orig).wchs).stk.end)
        .offset_from((*(*orig).wchs).stk.start) as libc::c_long as size_t;
    let mut BYTES_0: size_t = SIZE_0
        .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong);
    (*(*lgl).wchs)
        .stk
        .start = lglnew(
        lgl,
        SIZE_0.wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
    ) as *mut libc::c_int;
    memcpy(
        (*(*lgl).wchs).stk.start as *mut libc::c_void,
        (*(*orig).wchs).stk.start as *const libc::c_void,
        BYTES_0,
    );
    (*(*lgl).wchs).stk.top = ((*(*lgl).wchs).stk.start).offset(COUNT_0 as isize);
    (*(*lgl).wchs).stk.end = ((*(*lgl).wchs).stk.start).offset(SIZE_0 as isize);
    let mut COUNT_1: size_t = ((*orig).control.top).offset_from((*orig).control.start)
        as libc::c_long as size_t;
    let mut SIZE_1: size_t = ((*orig).control.end).offset_from((*orig).control.start)
        as libc::c_long as size_t;
    let mut BYTES_1: size_t = SIZE_1
        .wrapping_mul(::core::mem::size_of::<Ctr>() as libc::c_ulong);
    (*lgl)
        .control
        .start = lglnew(
        lgl,
        SIZE_1.wrapping_mul(::core::mem::size_of::<Ctr>() as libc::c_ulong),
    ) as *mut Ctr;
    memcpy(
        (*lgl).control.start as *mut libc::c_void,
        (*orig).control.start as *const libc::c_void,
        BYTES_1,
    );
    (*lgl).control.top = ((*lgl).control.start).offset(COUNT_1 as isize);
    (*lgl).control.end = ((*lgl).control.start).offset(SIZE_1 as isize);
    let mut COUNT_2: size_t = ((*orig).clause.top).offset_from((*orig).clause.start)
        as libc::c_long as size_t;
    let mut SIZE_2: size_t = ((*orig).clause.end).offset_from((*orig).clause.start)
        as libc::c_long as size_t;
    let mut BYTES_2: size_t = SIZE_2
        .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong);
    (*lgl)
        .clause
        .start = lglnew(
        lgl,
        SIZE_2.wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
    ) as *mut libc::c_int;
    memcpy(
        (*lgl).clause.start as *mut libc::c_void,
        (*orig).clause.start as *const libc::c_void,
        BYTES_2,
    );
    (*lgl).clause.top = ((*lgl).clause.start).offset(COUNT_2 as isize);
    (*lgl).clause.end = ((*lgl).clause.start).offset(SIZE_2 as isize);
    let mut COUNT_3: size_t = ((*orig).eclause.top).offset_from((*orig).eclause.start)
        as libc::c_long as size_t;
    let mut SIZE_3: size_t = ((*orig).eclause.end).offset_from((*orig).eclause.start)
        as libc::c_long as size_t;
    let mut BYTES_3: size_t = SIZE_3
        .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong);
    (*lgl)
        .eclause
        .start = lglnew(
        lgl,
        SIZE_3.wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
    ) as *mut libc::c_int;
    memcpy(
        (*lgl).eclause.start as *mut libc::c_void,
        (*orig).eclause.start as *const libc::c_void,
        BYTES_3,
    );
    (*lgl).eclause.top = ((*lgl).eclause.start).offset(COUNT_3 as isize);
    (*lgl).eclause.end = ((*lgl).eclause.start).offset(SIZE_3 as isize);
    let mut COUNT_4: size_t = ((*orig).extend.top).offset_from((*orig).extend.start)
        as libc::c_long as size_t;
    let mut SIZE_4: size_t = ((*orig).extend.end).offset_from((*orig).extend.start)
        as libc::c_long as size_t;
    let mut BYTES_4: size_t = SIZE_4
        .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong);
    (*lgl)
        .extend
        .start = lglnew(
        lgl,
        SIZE_4.wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
    ) as *mut libc::c_int;
    memcpy(
        (*lgl).extend.start as *mut libc::c_void,
        (*orig).extend.start as *const libc::c_void,
        BYTES_4,
    );
    (*lgl).extend.top = ((*lgl).extend.start).offset(COUNT_4 as isize);
    (*lgl).extend.end = ((*lgl).extend.start).offset(SIZE_4 as isize);
    let mut COUNT_5: size_t = ((*orig).irr.top).offset_from((*orig).irr.start)
        as libc::c_long as size_t;
    let mut SIZE_5: size_t = ((*orig).irr.end).offset_from((*orig).irr.start)
        as libc::c_long as size_t;
    let mut BYTES_5: size_t = SIZE_5
        .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong);
    (*lgl)
        .irr
        .start = lglnew(
        lgl,
        SIZE_5.wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
    ) as *mut libc::c_int;
    memcpy(
        (*lgl).irr.start as *mut libc::c_void,
        (*orig).irr.start as *const libc::c_void,
        BYTES_5,
    );
    (*lgl).irr.top = ((*lgl).irr.start).offset(COUNT_5 as isize);
    (*lgl).irr.end = ((*lgl).irr.start).offset(SIZE_5 as isize);
    let mut COUNT_6: size_t = ((*orig).trail.top).offset_from((*orig).trail.start)
        as libc::c_long as size_t;
    let mut SIZE_6: size_t = ((*orig).trail.end).offset_from((*orig).trail.start)
        as libc::c_long as size_t;
    let mut BYTES_6: size_t = SIZE_6
        .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong);
    (*lgl)
        .trail
        .start = lglnew(
        lgl,
        SIZE_6.wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
    ) as *mut libc::c_int;
    memcpy(
        (*lgl).trail.start as *mut libc::c_void,
        (*orig).trail.start as *const libc::c_void,
        BYTES_6,
    );
    (*lgl).trail.top = ((*lgl).trail.start).offset(COUNT_6 as isize);
    (*lgl).trail.end = ((*lgl).trail.start).offset(SIZE_6 as isize);
    let mut COUNT_7: size_t = ((*orig).frames.top).offset_from((*orig).frames.start)
        as libc::c_long as size_t;
    let mut SIZE_7: size_t = ((*orig).frames.end).offset_from((*orig).frames.start)
        as libc::c_long as size_t;
    let mut BYTES_7: size_t = SIZE_7
        .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong);
    (*lgl)
        .frames
        .start = lglnew(
        lgl,
        SIZE_7.wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
    ) as *mut libc::c_int;
    memcpy(
        (*lgl).frames.start as *mut libc::c_void,
        (*orig).frames.start as *const libc::c_void,
        BYTES_7,
    );
    (*lgl).frames.top = ((*lgl).frames.start).offset(COUNT_7 as isize);
    (*lgl).frames.end = ((*lgl).frames.start).offset(SIZE_7 as isize);
    let mut COUNT_8: size_t = ((*orig).promote.top).offset_from((*orig).promote.start)
        as libc::c_long as size_t;
    let mut SIZE_8: size_t = ((*orig).promote.end).offset_from((*orig).promote.start)
        as libc::c_long as size_t;
    let mut BYTES_8: size_t = SIZE_8
        .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong);
    (*lgl)
        .promote
        .start = lglnew(
        lgl,
        SIZE_8.wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
    ) as *mut libc::c_int;
    memcpy(
        (*lgl).promote.start as *mut libc::c_void,
        (*orig).promote.start as *const libc::c_void,
        BYTES_8,
    );
    (*lgl).promote.top = ((*lgl).promote.start).offset(COUNT_8 as isize);
    (*lgl).promote.end = ((*lgl).promote.start).offset(SIZE_8 as isize);
    let mut COUNT_9: size_t = ((*orig).eassume.top).offset_from((*orig).eassume.start)
        as libc::c_long as size_t;
    let mut SIZE_9: size_t = ((*orig).eassume.end).offset_from((*orig).eassume.start)
        as libc::c_long as size_t;
    let mut BYTES_9: size_t = SIZE_9
        .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong);
    (*lgl)
        .eassume
        .start = lglnew(
        lgl,
        SIZE_9.wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
    ) as *mut libc::c_int;
    memcpy(
        (*lgl).eassume.start as *mut libc::c_void,
        (*orig).eassume.start as *const libc::c_void,
        BYTES_9,
    );
    (*lgl).eassume.top = ((*lgl).eassume.start).offset(COUNT_9 as isize);
    (*lgl).eassume.end = ((*lgl).eassume.start).offset(SIZE_9 as isize);
    let mut COUNT_10: size_t = ((*orig).assume.top).offset_from((*orig).assume.start)
        as libc::c_long as size_t;
    let mut SIZE_10: size_t = ((*orig).assume.end).offset_from((*orig).assume.start)
        as libc::c_long as size_t;
    let mut BYTES_10: size_t = SIZE_10
        .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong);
    (*lgl)
        .assume
        .start = lglnew(
        lgl,
        SIZE_10.wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
    ) as *mut libc::c_int;
    memcpy(
        (*lgl).assume.start as *mut libc::c_void,
        (*orig).assume.start as *const libc::c_void,
        BYTES_10,
    );
    (*lgl).assume.top = ((*lgl).assume.start).offset(COUNT_10 as isize);
    (*lgl).assume.end = ((*lgl).assume.start).offset(SIZE_10 as isize);
    let mut COUNT_11: size_t = ((*orig).learned.top).offset_from((*orig).learned.start)
        as libc::c_long as size_t;
    let mut SIZE_11: size_t = ((*orig).learned.end).offset_from((*orig).learned.start)
        as libc::c_long as size_t;
    let mut BYTES_11: size_t = SIZE_11
        .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong);
    (*lgl)
        .learned
        .start = lglnew(
        lgl,
        SIZE_11.wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
    ) as *mut libc::c_int;
    memcpy(
        (*lgl).learned.start as *mut libc::c_void,
        (*orig).learned.start as *const libc::c_void,
        BYTES_11,
    );
    (*lgl).learned.top = ((*lgl).learned.start).offset(COUNT_11 as isize);
    (*lgl).learned.end = ((*lgl).learned.start).offset(SIZE_11 as isize);
    let mut COUNT_12: size_t = ((*orig).dsched.top).offset_from((*orig).dsched.start)
        as libc::c_long as size_t;
    let mut SIZE_12: size_t = ((*orig).dsched.end).offset_from((*orig).dsched.start)
        as libc::c_long as size_t;
    let mut BYTES_12: size_t = SIZE_12
        .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong);
    (*lgl)
        .dsched
        .start = lglnew(
        lgl,
        SIZE_12.wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
    ) as *mut libc::c_int;
    memcpy(
        (*lgl).dsched.start as *mut libc::c_void,
        (*orig).dsched.start as *const libc::c_void,
        BYTES_12,
    );
    (*lgl).dsched.top = ((*lgl).dsched.start).offset(COUNT_12 as isize);
    (*lgl).dsched.end = ((*lgl).dsched.start).offset(SIZE_12 as isize);
    let mut COUNT_13: size_t = ((*orig).queue.stk.top)
        .offset_from((*orig).queue.stk.start) as libc::c_long as size_t;
    let mut SIZE_13: size_t = ((*orig).queue.stk.end)
        .offset_from((*orig).queue.stk.start) as libc::c_long as size_t;
    let mut BYTES_13: size_t = SIZE_13
        .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong);
    (*lgl)
        .queue
        .stk
        .start = lglnew(
        lgl,
        SIZE_13.wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
    ) as *mut libc::c_int;
    memcpy(
        (*lgl).queue.stk.start as *mut libc::c_void,
        (*orig).queue.stk.start as *const libc::c_void,
        BYTES_13,
    );
    (*lgl).queue.stk.top = ((*lgl).queue.stk.start).offset(COUNT_13 as isize);
    (*lgl).queue.stk.end = ((*lgl).queue.stk.start).offset(SIZE_13 as isize);
    (*lgl).queue.mt = (*orig).queue.mt;
    (*lgl).queue.next = (*orig).queue.next;
    (*(*lgl).stats).bytes.max = (*(*orig).stats).bytes.max;
    return lgl;
}
#[no_mangle]
pub unsafe extern "C" fn lglclone(mut lgl: *mut LGL) -> *mut LGL {
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 9], &[libc::c_char; 9]>(b"lglclone\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*(*lgl).opts).druplig.val == 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 9], &[libc::c_char; 9]>(b"lglclone\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(
            stderr,
            b"can not clone if Druplig checking is enabled\0" as *const u8
                as *const libc::c_char,
        );
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    return lglmclone(
        lgl,
        (*(*lgl).mem).state,
        (*(*lgl).mem).alloc,
        (*(*lgl).mem).realloc,
        (*(*lgl).mem).dealloc,
    );
}
#[no_mangle]
pub unsafe extern "C" fn lglchkclone(mut lgl: *mut LGL) {
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 12], &[libc::c_char; 12]>(b"lglchkclone\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).forked == 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 12], &[libc::c_char; 12]>(b"lglchkclone\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"forked manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if !((*lgl).clone).is_null() {
        lglrelease((*lgl).clone);
    }
    (*lgl).clone = lglclone(lgl);
    if !((*lgl).apitrace).is_null() {
        lgltrapi(lgl, b"chkclone\0" as *const u8 as *const libc::c_char);
    }
}
#[no_mangle]
pub unsafe extern "C" fn lglinit() -> *mut LGL {
    return lglminit(0 as *mut libc::c_void, None, None, None);
}
unsafe extern "C" fn lglmaxoptnamelen(mut lgl: *mut LGL) -> libc::c_int {
    let mut res: libc::c_int = 0 as libc::c_int;
    let mut len: libc::c_int = 0;
    let mut o: *mut Opt = 0 as *mut Opt;
    o = (&mut (*(*lgl).opts).beforefirst as *mut Opt).offset(1 as libc::c_int as isize);
    while o
        <= (&mut (*(*lgl).opts).afterlast as *mut Opt)
            .offset(-(1 as libc::c_int as isize))
    {
        len = strlen((*o).lng) as libc::c_int;
        if len > res {
            res = len;
        }
        o = o.offset(1);
        o;
    }
    return res;
}
#[no_mangle]
pub unsafe extern "C" fn lglusage(mut lgl: *mut LGL) {
    let mut fmt: [libc::c_char; 20] = [0; 20];
    let mut len: libc::c_int = 0;
    let mut o: *mut Opt = 0 as *mut Opt;
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 9], &[libc::c_char; 9]>(b"lglusage\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).forked == 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 9], &[libc::c_char; 9]>(b"lglusage\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"forked manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    len = lglmaxoptnamelen(lgl);
    sprintf(fmt.as_mut_ptr(), b"--%%-%ds\0" as *const u8 as *const libc::c_char, len);
    o = (&mut (*(*lgl).opts).beforefirst as *mut Opt).offset(1 as libc::c_int as isize);
    while o
        <= (&mut (*(*lgl).opts).afterlast as *mut Opt)
            .offset(-(1 as libc::c_int as isize))
    {
        fprintf((*lgl).out, b"   \0" as *const u8 as *const libc::c_char);
        fprintf((*lgl).out, fmt.as_mut_ptr(), (*o).lng);
        fprintf(
            (*lgl).out,
            b" %s [%d]\n\0" as *const u8 as *const libc::c_char,
            (*o).descrp,
            (*o).val,
        );
        o = o.offset(1);
        o;
    }
}
unsafe extern "C" fn lglstrhasprefix(
    mut str: *const libc::c_char,
    mut prefix: *const libc::c_char,
) -> libc::c_int {
    let mut p: *const libc::c_char = 0 as *const libc::c_char;
    let mut q: *const libc::c_char = 0 as *const libc::c_char;
    p = str;
    q = prefix;
    while *q as libc::c_int != 0 && *p as libc::c_int == *q as libc::c_int {
        p = p.offset(1);
        p;
        q = q.offset(1);
        q;
    }
    return (*q == 0) as libc::c_int;
}
unsafe extern "C" fn lglignopt(mut name: *const libc::c_char) -> libc::c_int {
    if strcmp(name, b"abstime\0" as *const u8 as *const libc::c_char) == 0 {
        return 1 as libc::c_int;
    }
    if strcmp(name, b"check\0" as *const u8 as *const libc::c_char) == 0 {
        return 1 as libc::c_int;
    }
    if lglstrhasprefix(name, b"drup\0" as *const u8 as *const libc::c_char) != 0 {
        return 1 as libc::c_int;
    }
    if strcmp(name, b"exitonabort\0" as *const u8 as *const libc::c_char) == 0 {
        return 1 as libc::c_int;
    }
    if strcmp(name, b"log\0" as *const u8 as *const libc::c_char) == 0 {
        return 1 as libc::c_int;
    }
    if strcmp(name, b"sleeponabort\0" as *const u8 as *const libc::c_char) == 0 {
        return 1 as libc::c_int;
    }
    if strcmp(name, b"verbose\0" as *const u8 as *const libc::c_char) == 0 {
        return 1 as libc::c_int;
    }
    if strcmp(name, b"witness\0" as *const u8 as *const libc::c_char) == 0 {
        return 1 as libc::c_int;
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn lglopts(
    mut lgl: *mut LGL,
    mut prefix: *const libc::c_char,
    mut ignsome: libc::c_int,
) {
    let mut o: *mut Opt = 0 as *mut Opt;
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 8], &[libc::c_char; 8]>(b"lglopts\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).forked == 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 8], &[libc::c_char; 8]>(b"lglopts\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"forked manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    o = (&mut (*(*lgl).opts).beforefirst as *mut Opt).offset(1 as libc::c_int as isize);
    while o
        <= (&mut (*(*lgl).opts).afterlast as *mut Opt)
            .offset(-(1 as libc::c_int as isize))
    {
        if !(ignsome != 0 && lglignopt((*o).lng) != 0) {
            fprintf(
                (*lgl).out,
                b"%s--%s=%d\n\0" as *const u8 as *const libc::c_char,
                prefix,
                (*o).lng,
                (*o).val,
            );
        }
        o = o.offset(1);
        o;
    }
}
#[no_mangle]
pub unsafe extern "C" fn lglrgopts(mut lgl: *mut LGL) {
    let mut o: *mut Opt = 0 as *mut Opt;
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 10], &[libc::c_char; 10]>(b"lglrgopts\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).forked == 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 10], &[libc::c_char; 10]>(b"lglrgopts\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"forked manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    o = (&mut (*(*lgl).opts).beforefirst as *mut Opt).offset(1 as libc::c_int as isize);
    while o
        <= (&mut (*(*lgl).opts).afterlast as *mut Opt)
            .offset(-(1 as libc::c_int as isize))
    {
        fprintf(
            (*lgl).out,
            b"%s %d %d %d\n\0" as *const u8 as *const libc::c_char,
            (*o).lng,
            (*o).val,
            (*o).min,
            (*o).max,
        );
        o = o.offset(1);
        o;
    }
}
#[no_mangle]
pub unsafe extern "C" fn lglpcs(mut lgl: *mut LGL, mut mixed: libc::c_int) {
    let mut i: libc::c_int = 0;
    let mut printi: libc::c_int = 0;
    let mut printl: libc::c_int = 0;
    let mut range: int64_t = 0;
    let mut o: *mut Opt = 0 as *mut Opt;
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 7], &[libc::c_char; 7]>(b"lglpcs\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).forked == 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 7], &[libc::c_char; 7]>(b"lglpcs\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"forked manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    o = (&mut (*(*lgl).opts).beforefirst as *mut Opt).offset(1 as libc::c_int as isize);
    while o
        <= (&mut (*(*lgl).opts).afterlast as *mut Opt)
            .offset(-(1 as libc::c_int as isize))
    {
        if !(lglignopt((*o).lng) != 0) {
            range = (*o).max as int64_t;
            range -= (*o).min as int64_t;
            if !(range >= 7 as libc::c_int as int64_t && mixed < 0 as libc::c_int) {
                printl = 0 as libc::c_int;
                printi = printl;
                printf(b"%s \0" as *const u8 as *const libc::c_char, (*o).lng);
                if range < 7 as libc::c_int as int64_t {
                    printf(b"{%d\0" as *const u8 as *const libc::c_char, (*o).min);
                    i = (*o).min + 1 as libc::c_int;
                    while i <= (*o).max {
                        printf(b",%d\0" as *const u8 as *const libc::c_char, i);
                        i += 1;
                        i;
                    }
                    printf(b"}\0" as *const u8 as *const libc::c_char);
                } else if mixed == 0 {
                    printf(
                        b"[%d,%d]\0" as *const u8 as *const libc::c_char,
                        (*o).min,
                        (*o).max,
                    );
                    printi = 1 as libc::c_int;
                    printl = ((*o).min > 0 as libc::c_int
                        && range >= 100 as libc::c_int as int64_t) as libc::c_int;
                } else if (*o).dflt == (*o).min || (*o).dflt == (*o).max {
                    printf(
                        b"{%d,%d,%d,%d,%d}\0" as *const u8 as *const libc::c_char,
                        (*o).min,
                        ((*o).min as int64_t
                            + (1 as libc::c_int as int64_t * range
                                + 3 as libc::c_int as int64_t)
                                / 4 as libc::c_int as int64_t) as libc::c_int,
                        ((*o).min as int64_t
                            + (2 as libc::c_int as int64_t * range
                                + 3 as libc::c_int as int64_t)
                                / 4 as libc::c_int as int64_t) as libc::c_int,
                        ((*o).min as int64_t
                            + (3 as libc::c_int as int64_t * range
                                + 3 as libc::c_int as int64_t)
                                / 4 as libc::c_int as int64_t) as libc::c_int,
                        (*o).max,
                    );
                } else if (*o).dflt == (*o).min + 1 as libc::c_int {
                    printf(
                        b"{%d,%d,%d,%d}\0" as *const u8 as *const libc::c_char,
                        (*o).min,
                        (*o).dflt,
                        ((*o).dflt as int64_t
                            + ((*o).max as int64_t - (*o).dflt as int64_t)
                                / 2 as libc::c_int as int64_t) as libc::c_int,
                        (*o).max,
                    );
                } else if (*o).dflt + 1 as libc::c_int == (*o).max {
                    printf(
                        b"{%d,%d,%d,%d}\0" as *const u8 as *const libc::c_char,
                        (*o).min,
                        ((*o).min as int64_t
                            + ((*o).dflt as int64_t - (*o).min as int64_t)
                                / 2 as libc::c_int as int64_t) as libc::c_int,
                        (*o).dflt,
                        (*o).max,
                    );
                } else {
                    printf(
                        b"{%d,%d,%d,%d,%d}\0" as *const u8 as *const libc::c_char,
                        (*o).min,
                        ((*o).min as int64_t
                            + ((*o).dflt as int64_t - (*o).min as int64_t)
                                / 2 as libc::c_int as int64_t) as libc::c_int,
                        (*o).dflt,
                        ((*o).dflt as int64_t
                            + ((*o).max as int64_t - (*o).min as int64_t)
                                / 2 as libc::c_int as int64_t) as libc::c_int,
                        (*o).max,
                    );
                }
                printf(b"[%d]\0" as *const u8 as *const libc::c_char, (*o).dflt);
                if printi != 0 {
                    printf(b"i\0" as *const u8 as *const libc::c_char);
                }
                if printl != 0 {
                    printf(b"l\0" as *const u8 as *const libc::c_char);
                }
                printf(b" # %s\n\0" as *const u8 as *const libc::c_char, (*o).descrp);
            }
        }
        o = o.offset(1);
        o;
    }
}
#[no_mangle]
pub unsafe extern "C" fn lglhasopt(
    mut lgl: *mut LGL,
    mut opt: *const libc::c_char,
) -> libc::c_int {
    let mut o: *mut Opt = 0 as *mut Opt;
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 10], &[libc::c_char; 10]>(b"lglhasopt\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).forked == 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 10], &[libc::c_char; 10]>(b"lglhasopt\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"forked manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    o = (&mut (*(*lgl).opts).beforefirst as *mut Opt).offset(1 as libc::c_int as isize);
    while o
        <= (&mut (*(*lgl).opts).afterlast as *mut Opt)
            .offset(-(1 as libc::c_int as isize))
    {
        if strcmp((*o).lng, opt) == 0 {
            return 1 as libc::c_int;
        }
        o = o.offset(1);
        o;
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn lglfirstopt(mut lgl: *mut LGL) -> *mut libc::c_void {
    return (&mut (*(*lgl).opts).beforefirst as *mut Opt)
        .offset(1 as libc::c_int as isize) as *mut libc::c_void;
}
#[no_mangle]
pub unsafe extern "C" fn lglnextopt(
    mut lgl: *mut LGL,
    mut current: *mut libc::c_void,
    mut nameptr: *mut *const libc::c_char,
    mut valptr: *mut libc::c_int,
    mut minptr: *mut libc::c_int,
    mut maxptr: *mut libc::c_int,
) -> *mut libc::c_void {
    let mut opt: *mut Opt = current as *mut Opt;
    let mut res: *mut Opt = opt.offset(1 as libc::c_int as isize);
    if res
        > (&mut (*(*lgl).opts).afterlast as *mut Opt)
            .offset(-(1 as libc::c_int as isize))
    {
        return 0 as *mut libc::c_void;
    }
    if !nameptr.is_null() {
        *nameptr = (*opt).lng;
    }
    if !valptr.is_null() {
        *valptr = (*opt).val;
    }
    if !minptr.is_null() {
        *minptr = (*opt).min;
    }
    if !maxptr.is_null() {
        *maxptr = (*opt).max;
    }
    return res as *mut libc::c_void;
}
#[no_mangle]
pub unsafe extern "C" fn lglsetopt(
    mut lgl: *mut LGL,
    mut opt: *const libc::c_char,
    mut val: libc::c_int,
) {
    let mut oldval: libc::c_int = 0;
    let mut o: *mut Opt = 0 as *mut Opt;
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 10], &[libc::c_char; 10]>(b"lglsetopt\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).forked == 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 10], &[libc::c_char; 10]>(b"lglsetopt\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"forked manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    o = (&mut (*(*lgl).opts).beforefirst as *mut Opt).offset(1 as libc::c_int as isize);
    while o
        <= (&mut (*(*lgl).opts).afterlast as *mut Opt)
            .offset(-(1 as libc::c_int as isize))
    {
        if strcmp((*o).lng, opt) == 0 {
            break;
        }
        o = o.offset(1);
        o;
    }
    if o
        > (&mut (*(*lgl).opts).afterlast as *mut Opt)
            .offset(-(1 as libc::c_int as isize))
    {
        return;
    }
    if val < (*o).min {
        val = (*o).min;
    }
    if (*o).max < val {
        val = (*o).max;
    }
    oldval = (*o).val;
    (*o).val = val;
    if o == &mut (*(*lgl).opts).plain as *mut Opt {
        if val > 0 as libc::c_int && oldval == 0 {
            lglsetplain(lgl, 1 as libc::c_int);
        }
        if val == 0 && oldval != 0 {
            lglsetplain(lgl, 0 as libc::c_int);
        }
    }
    if o == &mut (*(*lgl).opts).druplig as *mut Opt {
        if val > 0 as libc::c_int && oldval == 0 {
            lglsetdruplig(lgl, 1 as libc::c_int);
        }
        if val == 0 && oldval != 0 {
            lglsetdruplig(lgl, 0 as libc::c_int);
        }
    }
    if o == &mut (*(*lgl).opts).wait as *mut Opt {
        if val > 0 as libc::c_int && oldval == 0 {
            lglsetwait(lgl, 1 as libc::c_int);
        }
        if val == 0 && oldval != 0 {
            lglsetwait(lgl, 0 as libc::c_int);
        }
    }
    if o == &mut (*(*lgl).opts).phase as *mut Opt && val != oldval {
        (*lgl).flushphases = 1 as libc::c_int as libc::c_char;
    }
    if (*lgl).state as libc::c_uint == UNUSED as libc::c_int as libc::c_uint {
        (*lgl).state = OPTSET;
    }
    if !((*lgl).apitrace).is_null() {
        lgltrapi(lgl, b"option %s %d\0" as *const u8 as *const libc::c_char, opt, val);
    }
    if (*(*lgl).opts).druplig.val != 0 {
        lglforcedruplig(lgl, 1 as libc::c_int);
    }
}
unsafe extern "C" fn lglws(mut ch: libc::c_int) -> libc::c_int {
    return (ch == ' ' as i32 || ch == '\t' as i32 || ch == '\n' as i32
        || ch == '\r' as i32) as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn lglreadopts(
    mut lgl: *mut LGL,
    mut file: *mut FILE,
) -> libc::c_int {
    let mut res: libc::c_int = 0;
    let mut ch: libc::c_int = 0;
    let mut val: libc::c_int = 0;
    let mut nvalbuf: libc::c_int = 0;
    let mut noptbuf: libc::c_int = 0;
    let mut optbuf: [libc::c_char; 40] = [0; 40];
    let mut valbuf: [libc::c_char; 40] = [0; 40];
    let mut opt: *const libc::c_char = 0 as *const libc::c_char;
    res = 0 as libc::c_int;
    loop {
        loop {
            ch = getc(file);
            if !(lglws(ch) != 0) {
                break;
            }
        }
        if ch == -(1 as libc::c_int) {
            break;
        }
        noptbuf = 0 as libc::c_int;
        let fresh13 = noptbuf;
        noptbuf = noptbuf + 1;
        optbuf[fresh13 as usize] = ch as libc::c_char;
        loop {
            ch = getc(file);
            if !(ch != -(1 as libc::c_int) && lglws(ch) == 0) {
                break;
            }
            if noptbuf + 1 as libc::c_int
                >= ::core::mem::size_of::<[libc::c_char; 40]>() as libc::c_ulong
                    as libc::c_int
            {
                ch = -(1 as libc::c_int);
                break;
            } else {
                let fresh14 = noptbuf;
                noptbuf = noptbuf + 1;
                optbuf[fresh14 as usize] = ch as libc::c_char;
            }
        }
        if ch == -(1 as libc::c_int) {
            break;
        }
        let fresh15 = noptbuf;
        noptbuf = noptbuf + 1;
        optbuf[fresh15 as usize] = 0 as libc::c_int as libc::c_char;
        loop {
            ch = getc(file);
            if !(lglws(ch) != 0) {
                break;
            }
        }
        if ch == -(1 as libc::c_int) {
            break;
        }
        nvalbuf = 0 as libc::c_int;
        let fresh16 = nvalbuf;
        nvalbuf = nvalbuf + 1;
        valbuf[fresh16 as usize] = ch as libc::c_char;
        loop {
            ch = getc(file);
            if !(ch != -(1 as libc::c_int) && lglws(ch) == 0) {
                break;
            }
            if nvalbuf + 1 as libc::c_int
                >= ::core::mem::size_of::<[libc::c_char; 40]>() as libc::c_ulong
                    as libc::c_int
            {
                break;
            }
            let fresh17 = nvalbuf;
            nvalbuf = nvalbuf + 1;
            valbuf[fresh17 as usize] = ch as libc::c_char;
        }
        let fresh18 = nvalbuf;
        nvalbuf = nvalbuf + 1;
        valbuf[fresh18 as usize] = 0 as libc::c_int as libc::c_char;
        opt = optbuf.as_mut_ptr();
        val = atoi(valbuf.as_mut_ptr());
        lglprt(
            lgl,
            1 as libc::c_int,
            b"read option --%s=%d\0" as *const u8 as *const libc::c_char,
            opt,
            val,
        );
        lglsetopt(lgl, opt, val);
        res += 1;
        res;
    }
    return res;
}
#[no_mangle]
pub unsafe extern "C" fn lglsetout(mut lgl: *mut LGL, mut out: *mut FILE) {
    (*lgl).out = out;
}
#[no_mangle]
pub unsafe extern "C" fn lglsetrace(mut lgl: *mut LGL, mut trace: *mut FILE) {
    (*lgl).trace = trace;
}
#[no_mangle]
pub unsafe extern "C" fn lglgetout(mut lgl: *mut LGL) -> *mut FILE {
    return (*lgl).out;
}
#[no_mangle]
pub unsafe extern "C" fn lglsetprefix(
    mut lgl: *mut LGL,
    mut prefix: *const libc::c_char,
) {
    lgldelstr(lgl, (*lgl).prefix);
    (*lgl).prefix = lglstrdup(lgl, prefix);
}
#[no_mangle]
pub unsafe extern "C" fn lglgetprefix(mut lgl: *mut LGL) -> *const libc::c_char {
    return (*lgl).prefix;
}
unsafe extern "C" fn lgligetopt(
    mut lgl: *mut LGL,
    mut opt: *const libc::c_char,
) -> *mut Opt {
    let mut o: *mut Opt = 0 as *mut Opt;
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 11], &[libc::c_char; 11]>(b"lgligetopt\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).forked == 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 11], &[libc::c_char; 11]>(b"lgligetopt\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"forked manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    o = (&mut (*(*lgl).opts).beforefirst as *mut Opt).offset(1 as libc::c_int as isize);
    while o
        <= (&mut (*(*lgl).opts).afterlast as *mut Opt)
            .offset(-(1 as libc::c_int as isize))
    {
        if strcmp((*o).lng, opt) == 0 {
            return o;
        }
        o = o.offset(1);
        o;
    }
    return 0 as *mut Opt;
}
#[no_mangle]
pub unsafe extern "C" fn lglgetopt(
    mut lgl: *mut LGL,
    mut opt: *const libc::c_char,
) -> libc::c_int {
    let mut o: *mut Opt = lgligetopt(lgl, opt);
    return if !o.is_null() { (*o).val } else { 0 as libc::c_int };
}
#[no_mangle]
pub unsafe extern "C" fn lgldefopt(
    mut lgl: *mut LGL,
    mut opt: *const libc::c_char,
) -> libc::c_int {
    let mut o: *mut Opt = lgligetopt(lgl, opt);
    return if !o.is_null() { (*o).dflt } else { 0 as libc::c_int };
}
#[no_mangle]
pub unsafe extern "C" fn lglgetoptminmax(
    mut lgl: *mut LGL,
    mut opt: *const libc::c_char,
    mut min_ptr: *mut libc::c_int,
    mut max_ptr: *mut libc::c_int,
) -> libc::c_int {
    let mut o: *mut Opt = lgligetopt(lgl, opt);
    if o.is_null() {
        return 0 as libc::c_int;
    }
    if !min_ptr.is_null() {
        *min_ptr = (*o).min;
    }
    if !max_ptr.is_null() {
        *max_ptr = (*o).max;
    }
    return (*o).val;
}
unsafe extern "C" fn lglrszvars(mut lgl: *mut LGL, mut new_size: libc::c_int) {
    let mut old_size: libc::c_int = (*lgl).szvars;
    (*lgl)
        .vals = lglrsz(
        lgl,
        (*lgl).vals as *mut libc::c_void,
        (old_size as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Val>() as libc::c_ulong),
        (new_size as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Val>() as libc::c_ulong),
    ) as *mut Val;
    (*lgl)
        .i2e = lglrsz(
        lgl,
        (*lgl).i2e as *mut libc::c_void,
        (old_size as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
        (new_size as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
    ) as *mut libc::c_int;
    (*lgl)
        .doms = lglrsz(
        lgl,
        (*lgl).doms as *mut libc::c_void,
        ((2 as libc::c_int * old_size) as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
        ((2 as libc::c_int * new_size) as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
    ) as *mut libc::c_int;
    (*lgl)
        .dvars = lglrsz(
        lgl,
        (*lgl).dvars as *mut libc::c_void,
        (old_size as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<DVar>() as libc::c_ulong),
        (new_size as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<DVar>() as libc::c_ulong),
    ) as *mut DVar;
    (*lgl)
        .avars = lglrsz(
        lgl,
        (*lgl).avars as *mut libc::c_void,
        (old_size as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<AVar>() as libc::c_ulong),
        (new_size as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<AVar>() as libc::c_ulong),
    ) as *mut AVar;
    (*lgl)
        .qvars = lglrsz(
        lgl,
        (*lgl).qvars as *mut libc::c_void,
        (old_size as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<QVar>() as libc::c_ulong),
        (new_size as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<QVar>() as libc::c_ulong),
    ) as *mut QVar;
    (*lgl)
        .jwh = lglrsz(
        lgl,
        (*lgl).jwh as *mut libc::c_void,
        ((2 as libc::c_int * old_size) as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Flt>() as libc::c_ulong),
        ((2 as libc::c_int * new_size) as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Flt>() as libc::c_ulong),
    ) as *mut Flt;
    (*lgl).szvars = new_size;
}
unsafe extern "C" fn lglenlvars(mut lgl: *mut LGL) {
    let mut old_size: size_t = 0;
    let mut new_size: size_t = 0;
    old_size = (*lgl).szvars as size_t;
    new_size = if old_size != 0 {
        2 as libc::c_int as size_t * old_size
    } else {
        4 as libc::c_int as size_t
    };
    lglrszvars(lgl, new_size as libc::c_int);
}
unsafe extern "C" fn lglredvars(mut lgl: *mut LGL) {
    let mut old_size: size_t = 0;
    let mut new_size: size_t = 0;
    old_size = (*lgl).szvars as size_t;
    new_size = (*lgl).nvars as size_t;
    if new_size == old_size {
        return;
    }
    lglrszvars(lgl, new_size as libc::c_int);
}
unsafe extern "C" fn lglmax(mut a: libc::c_int, mut b: libc::c_int) -> libc::c_int {
    return if a > b { a } else { b };
}
unsafe extern "C" fn lgldvar(mut lgl: *mut LGL, mut lit: libc::c_int) -> *mut DVar {
    return ((*lgl).dvars).offset(abs(lit) as isize);
}
unsafe extern "C" fn lglavar(mut lgl: *mut LGL, mut lit: libc::c_int) -> *mut AVar {
    return ((*lgl).avars).offset(abs(lit) as isize);
}
unsafe extern "C" fn lglval(mut lgl: *mut LGL, mut lit: libc::c_int) -> Val {
    let mut idx: libc::c_int = abs(lit);
    let mut res: Val = 0;
    res = *((*lgl).vals).offset(idx as isize);
    if lit < 0 as libc::c_int {
        res = -(res as libc::c_int) as Val;
    }
    return res;
}
unsafe extern "C" fn lgltrail(mut lgl: *mut LGL, mut lit: libc::c_int) -> libc::c_int {
    return (*lglavar(lgl, lit)).trail;
}
unsafe extern "C" fn lglevel2trail(
    mut lgl: *mut LGL,
    mut level: libc::c_int,
) -> libc::c_int {
    return lgltrail(lgl, (*lglctr(lgl, level)).decision());
}
unsafe extern "C" fn lgltd(mut lgl: *mut LGL, mut lit: libc::c_int) -> *mut TD {
    let mut pos: libc::c_int = lgltrail(lgl, lit);
    return ((*lgl).drail).offset(pos as isize);
}
unsafe extern "C" fn lglevel(mut lgl: *mut LGL, mut lit: libc::c_int) -> libc::c_int {
    return (*lgltd(lgl, lit)).level();
}
unsafe extern "C" fn lglisfree(mut lgl: *mut LGL, mut lit: libc::c_int) -> libc::c_int {
    return ((*lglavar(lgl, lit)).type_0() as libc::c_int == FREEVAR as libc::c_int)
        as libc::c_int;
}
unsafe extern "C" fn lglqvar(mut lgl: *mut LGL, mut lit: libc::c_int) -> *mut QVar {
    return ((*lgl).qvars).offset(abs(lit) as isize);
}
unsafe extern "C" fn lgldpos(
    mut lgl: *mut LGL,
    mut lit: libc::c_int,
) -> *mut libc::c_int {
    let mut qv: *mut QVar = 0 as *mut QVar;
    let mut res: *mut libc::c_int = 0 as *mut libc::c_int;
    qv = lglqvar(lgl, lit);
    res = &mut (*qv).pos;
    return res;
}
unsafe extern "C" fn lglscrcmp(
    mut lgl: *mut LGL,
    mut a: Flt,
    mut b: Flt,
) -> libc::c_int {
    let shift: libc::c_int = (*(*lgl).opts).scoreshift.val;
    a >>= shift;
    b >>= shift;
    if a < b {
        return -(1 as libc::c_int);
    }
    if a > b {
        return 1 as libc::c_int;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn lgldcmp(
    mut lgl: *mut LGL,
    mut l: libc::c_int,
    mut k: libc::c_int,
) -> libc::c_int {
    let mut pv: *mut QVar = lglqvar(lgl, l);
    let mut qv: *mut QVar = lglqvar(lgl, k);
    let mut res: libc::c_int = 0;
    if (*pv).important() == 0 && (*qv).important() as libc::c_int != 0 {
        return -(1 as libc::c_int);
    }
    if (*pv).important() as libc::c_int != 0 && (*qv).important() == 0 {
        return 1 as libc::c_int;
    }
    res = lglscrcmp(lgl, (*pv).score, (*qv).score);
    if res != 0 {
        return res;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn lgldup(mut lgl: *mut LGL, mut lit: libc::c_int) {
    let mut child: libc::c_int = lit;
    let mut parent: libc::c_int = 0;
    let mut cpos: libc::c_int = 0;
    let mut ppos: libc::c_int = 0;
    let mut p: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut cposptr: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut pposptr: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut s: *mut Stk = &mut (*lgl).dsched;
    p = (*s).start;
    cposptr = lgldpos(lgl, child);
    cpos = *cposptr;
    while cpos > 0 as libc::c_int {
        ppos = (cpos - 1 as libc::c_int) / 2 as libc::c_int;
        parent = *p.offset(ppos as isize);
        if lgldcmp(lgl, parent, lit) >= 0 as libc::c_int {
            break;
        }
        pposptr = lgldpos(lgl, parent);
        *p.offset(cpos as isize) = parent;
        *pposptr = cpos;
        cpos = ppos;
    }
    if *cposptr == cpos {
        return;
    }
    *cposptr = cpos;
    *p.offset(cpos as isize) = lit;
}
unsafe extern "C" fn lglddown(mut lgl: *mut LGL, mut lit: libc::c_int) {
    let mut parent: libc::c_int = lit;
    let mut child: libc::c_int = 0;
    let mut right: libc::c_int = 0;
    let mut ppos: libc::c_int = 0;
    let mut cpos: libc::c_int = 0;
    let mut p: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut pposptr: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut cposptr: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut size: libc::c_int = 0;
    let mut s: *mut Stk = &mut (*lgl).dsched;
    size = lglcntstk(s) as libc::c_int;
    p = (*s).start;
    pposptr = lgldpos(lgl, parent);
    ppos = *pposptr;
    loop {
        cpos = 2 as libc::c_int * ppos + 1 as libc::c_int;
        if cpos >= size {
            break;
        }
        child = *p.offset(cpos as isize);
        if (cpos + 1 as libc::c_int) < size {
            right = *p.offset((cpos + 1 as libc::c_int) as isize);
            if lgldcmp(lgl, child, right) < 0 as libc::c_int {
                cpos += 1;
                cpos;
                child = right;
            }
        }
        if lgldcmp(lgl, child, lit) <= 0 as libc::c_int {
            break;
        }
        cposptr = lgldpos(lgl, child);
        *p.offset(ppos as isize) = child;
        *cposptr = ppos;
        ppos = cpos;
    }
    if *pposptr == ppos {
        return;
    }
    *pposptr = ppos;
    *p.offset(ppos as isize) = lit;
}
unsafe extern "C" fn lgldsched(mut lgl: *mut LGL, mut lit: libc::c_int) {
    let mut p: *mut libc::c_int = lgldpos(lgl, lit);
    let mut s: *mut Stk = &mut (*lgl).dsched;
    *p = lglcntstk(s) as libc::c_int;
    lglpushstk(lgl, s, lit);
    lgldup(lgl, lit);
    lglddown(lgl, lit);
}
unsafe extern "C" fn lgltopdsched(mut lgl: *mut LGL) -> libc::c_int {
    return *((*lgl).dsched.start).offset(0 as libc::c_int as isize);
}
unsafe extern "C" fn lglpopdsched(mut lgl: *mut LGL) -> libc::c_int {
    let mut s: *mut Stk = &mut (*lgl).dsched;
    let mut res: libc::c_int = 0;
    let mut last: libc::c_int = 0;
    let mut cnt: libc::c_int = 0;
    let mut p: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut qv: *mut QVar = 0 as *mut QVar;
    res = *(*s).start;
    qv = lglqvar(lgl, res);
    (*qv).pos = -(1 as libc::c_int);
    last = lglpopstk(s);
    cnt = lglcntstk(s) as libc::c_int;
    if cnt == 0 {
        return res;
    }
    p = lgldpos(lgl, last);
    *p = 0 as libc::c_int;
    *(*s).start = last;
    lglddown(lgl, last);
    return res;
}
unsafe extern "C" fn lgldreschedule(mut lgl: *mut LGL) {
    let mut s: *mut Stk = &mut (*lgl).dsched;
    let mut idx: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut pos: libc::c_int = 0;
    let mut cnt: libc::c_int = lglcntstk(s) as libc::c_int;
    let mut qv: *mut QVar = 0 as *mut QVar;
    idx = 2 as libc::c_int;
    while idx < (*lgl).nvars {
        qv = lglqvar(lgl, idx);
        if !((*qv).enqueued() != 0) {
            (*qv).pos = -(1 as libc::c_int);
        }
        idx += 1;
        idx;
    }
    pos = 0 as libc::c_int;
    (*s).top = (*s).start;
    i = 0 as libc::c_int;
    while i < cnt {
        idx = *((*s).start).offset(i as isize);
        if !(abs(idx) <= 1 as libc::c_int) {
            qv = lglqvar(lgl, idx);
            if lglisfree(lgl, idx) == 0 {
                (*qv).pos = -(1 as libc::c_int);
            } else {
                *((*s).start).offset(pos as isize) = idx;
                let fresh19 = pos;
                pos = pos + 1;
                (*qv).pos = fresh19;
                (*s).top = ((*s).top).offset(1);
                (*s).top;
                lgldup(lgl, idx);
                lglddown(lgl, idx);
            }
        }
        i += 1;
        i;
    }
    lglfitstk(lgl, s);
}
unsafe extern "C" fn lglenq(
    mut lgl: *mut LGL,
    mut idx: libc::c_int,
    mut updatequeuenext: libc::c_int,
) {
    let mut qv: *mut QVar = lglqvar(lgl, idx);
    (*qv).set_enqueued(1 as libc::c_int as libc::c_uint);
    (*qv).pos = lglcntstk(&mut (*lgl).queue.stk) as libc::c_int;
    lglpushstk(lgl, &mut (*lgl).queue.stk, idx);
    if updatequeuenext != 0 || (*lgl).queue.next < 0 as libc::c_int {
        (*lgl).queue.next = (*qv).pos;
    }
}
unsafe extern "C" fn lglrescorevars(mut lgl: *mut LGL) {
    let mut oldscinc: Flt = 0;
    let mut oldscore: Flt = 0;
    let mut newscore: Flt = 0;
    let mut oldmaxscore: Flt = 0 as libc::c_int as Flt;
    let mut newmaxscore: Flt = 0 as libc::c_int as Flt;
    let mut newotfs: int64_t = 0;
    let mut qv: *mut QVar = 0 as *mut QVar;
    let mut idx: libc::c_int = 0;
    (*(*lgl).stats).rescored.vars += 1;
    (*(*lgl).stats).rescored.vars;
    idx = 2 as libc::c_int;
    while idx < (*lgl).nvars {
        qv = lglqvar(lgl, idx);
        if !((*qv).enqueued() != 0) {
            oldscore = (*qv).score;
            if oldscore > oldmaxscore {
                oldmaxscore = oldscore;
            }
            if oldscore as libc::c_longlong == 0 as libc::c_longlong {
                newscore = oldscore;
            } else if oldscore <= (*lgl).minscore {
                newscore = (*lgl).minscore;
            } else {
                newscore = lglshflt(oldscore, 500 as libc::c_int);
                if newscore < (*lgl).minscore {
                    newscore = (*lgl).minscore;
                }
            }
            if !(newscore <= (*lgl).minscore) {
                newscore = oldscore >> 32 as libc::c_int;
            }
            (*qv).score = newscore;
            if (*qv).score > newmaxscore {
                newmaxscore = (*qv).score;
            }
        }
        idx += 1;
        idx;
    }
    lgldreschedule(lgl);
    newotfs = (*(*lgl).stats).otfs.driving + (*(*lgl).stats).otfs.restarting;
    lglprt(
        lgl,
        3 as libc::c_int,
        b"[rescored-vars-%d] after %lld conflicts and %lld OTFS\0" as *const u8
            as *const libc::c_char,
        (*(*lgl).stats).rescored.vars,
        (*(*lgl).stats).confs - (*(*lgl).limits).rescore.vars.confs,
        newotfs - (*(*lgl).limits).rescore.vars.otfs,
    );
    (*(*lgl).limits).rescore.vars.confs = (*(*lgl).stats).confs;
    (*(*lgl).limits).rescore.vars.otfs = newotfs;
    lglprt(
        lgl,
        3 as libc::c_int,
        b"[rescored-vars-%d] old maximum score %s\0" as *const u8 as *const libc::c_char,
        (*(*lgl).stats).rescored.vars,
        lglscr2str(lgl, oldmaxscore),
    );
    lglprt(
        lgl,
        3 as libc::c_int,
        b"[rescored-vars-%d] new maximum score %s\0" as *const u8 as *const libc::c_char,
        (*(*lgl).stats).rescored.vars,
        lglscr2str(lgl, newmaxscore),
    );
    oldscinc = (*lgl).scinc;
    (*lgl).scinc = lglshflt(oldscinc, 500 as libc::c_int);
    lglprt(
        lgl,
        3 as libc::c_int,
        b"[rescored-vars-%d] old score increment %s\0" as *const u8
            as *const libc::c_char,
        (*(*lgl).stats).rescored.vars,
        lglscr2str(lgl, oldscinc),
    );
    lglprt(
        lgl,
        3 as libc::c_int,
        b"[rescored-vars-%d] new score increment %s\0" as *const u8
            as *const libc::c_char,
        (*(*lgl).stats).rescored.vars,
        lglscr2str(lgl, (*lgl).scinc),
    );
}
unsafe extern "C" fn lglbumpscinc(mut lgl: *mut LGL) {
    let mut oldscinc: Flt = 0;
    if (*lgl).simp as libc::c_int != 0 && (*(*lgl).opts).bumpsimp.val == 0 {
        return;
    }
    oldscinc = (*lgl).scinc;
    (*lgl).scinc = lglmulflt(oldscinc, (*lgl).scincf);
    if (*lgl).scinc >= (*lgl).maxscore {
        lglrescorevars(lgl);
    }
    if (*lgl).simp == 0
        && (*(*lgl).stats).confs % (*(*lgl).opts).scincincincint.val as int64_t == 0
    {
        let mut newscincinc: libc::c_int = (*lgl).scincinc;
        if (*(*lgl).opts).scincincmode.val == 1 as libc::c_int {
            newscincinc -= (*(*lgl).opts).scincincdelta.val;
        } else if (*(*lgl).opts).scincincmode.val == 2 as libc::c_int {
            newscincinc = ((*(*lgl).opts).scincincmin.val + newscincinc)
                / 2 as libc::c_int;
        }
        if newscincinc < (*(*lgl).opts).scincincmin.val {
            newscincinc = (*(*lgl).opts).scincincmin.val;
        }
        if newscincinc != (*lgl).scincinc {
            lglsetscincf(lgl, newscincinc);
        }
    }
}
unsafe extern "C" fn lglnewvar(mut lgl: *mut LGL) -> libc::c_int {
    let mut av: *mut AVar = 0 as *mut AVar;
    let mut dv: *mut DVar = 0 as *mut DVar;
    let mut qv: *mut QVar = 0 as *mut QVar;
    let mut res: libc::c_int = 0;
    if (*lgl).nvars == (*lgl).szvars {
        lglenlvars(lgl);
    }
    if (*lgl).nvars != 0 {
        let fresh20 = (*lgl).nvars;
        (*lgl).nvars = (*lgl).nvars + 1;
        res = fresh20;
    } else {
        res = 2 as libc::c_int;
        (*lgl).nvars = 3 as libc::c_int;
    }
    if res > (2147483647 as libc::c_int >> RMSHFT as libc::c_int) - 2 as libc::c_int {
        lgldie(
            lgl,
            b"more than %d variables\0" as *const u8 as *const libc::c_char,
            (2147483647 as libc::c_int >> RMSHFT as libc::c_int) - 2 as libc::c_int
                - 1 as libc::c_int,
        );
    }
    dv = ((*lgl).dvars).offset(res as isize);
    memset(
        dv as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<DVar>() as libc::c_ulong,
    );
    av = ((*lgl).avars).offset(res as isize);
    memset(
        av as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<AVar>() as libc::c_ulong,
    );
    qv = ((*lgl).qvars).offset(res as isize);
    memset(
        qv as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<QVar>() as libc::c_ulong,
    );
    (*qv).set_glag(-(1 as libc::c_int));
    (*qv).pos = -(1 as libc::c_int);
    lglenq(lgl, res, 1 as libc::c_int);
    (*lgl).unassigned += 1;
    (*lgl).unassigned;
    (*lgl).allphaseset = 0 as libc::c_int as libc::c_char;
    return res;
}
unsafe extern "C" fn lglsgn(mut lit: libc::c_int) -> libc::c_int {
    return if lit < 0 as libc::c_int { -(1 as libc::c_int) } else { 1 as libc::c_int };
}
unsafe extern "C" fn lglelit2ext(mut lgl: *mut LGL, mut elit: libc::c_int) -> *mut Ext {
    let mut idx: libc::c_int = abs(elit);
    return ((*lgl).ext).offset(idx as isize);
}
unsafe extern "C" fn lglerepr(mut lgl: *mut LGL, mut elit: libc::c_int) -> libc::c_int {
    let mut res: libc::c_int = 0;
    let mut next: libc::c_int = 0;
    let mut tmp: libc::c_int = 0;
    let mut ext: *mut Ext = 0 as *mut Ext;
    res = elit;
    loop {
        ext = lglelit2ext(lgl, res);
        if (*ext).equiv() == 0 {
            break;
        }
        next = (*ext).repr;
        if res < 0 as libc::c_int {
            next = -next;
        }
        res = next;
    }
    tmp = elit;
    loop {
        ext = lglelit2ext(lgl, tmp);
        if (*ext).equiv() == 0 {
            break;
        }
        next = (*ext).repr;
        (*ext).repr = if tmp < 0 as libc::c_int { -res } else { res };
        if tmp < 0 as libc::c_int {
            next = -next;
        }
        tmp = next;
    }
    return res;
}
unsafe extern "C" fn lgladjext(mut lgl: *mut LGL, mut eidx: libc::c_int) {
    let mut old: size_t = 0;
    let mut new: size_t = 0;
    old = (*lgl).szext as size_t;
    new = if old != 0 {
        2 as libc::c_int as size_t * old
    } else {
        2 as libc::c_int as size_t
    };
    while eidx as libc::c_uint as size_t >= new {
        new = new * 2 as libc::c_int as size_t;
    }
    (*lgl)
        .ext = lglrsz(
        lgl,
        (*lgl).ext as *mut libc::c_void,
        old.wrapping_mul(::core::mem::size_of::<Ext>() as libc::c_ulong),
        new.wrapping_mul(::core::mem::size_of::<Ext>() as libc::c_ulong),
    ) as *mut Ext;
    (*lgl).szext = new as libc::c_int;
}
unsafe extern "C" fn lglmelter(mut lgl: *mut LGL) {
    if (*lgl).allfrozen != 0 {
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[melter] not all literals assumed to be frozen anymore\0" as *const u8
                as *const libc::c_char,
        );
        (*lgl).allfrozen = 0 as libc::c_int as libc::c_char;
    }
    if (*(*lgl).limits).elm.pen != 0 || (*(*lgl).limits).blk.pen != 0
        || (*(*lgl).limits).cce.pen != 0
    {
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[melter] reset penalties: %d elm, %d blk, %d cce\0" as *const u8
                as *const libc::c_char,
            (*(*lgl).limits).elm.pen,
            (*(*lgl).limits).blk.pen,
            (*(*lgl).limits).cce.pen,
        );
        (*(*lgl).limits).cce.pen = 0 as libc::c_int;
        (*(*lgl).limits).blk.pen = (*(*lgl).limits).cce.pen;
        (*(*lgl).limits).elm.pen = (*(*lgl).limits).blk.pen;
    }
    (*lgl).allfrozen = 0 as libc::c_int as libc::c_char;
    (*lgl).frozen = (*lgl).allfrozen;
}
unsafe extern "C" fn lglimportaux(
    mut lgl: *mut LGL,
    mut elit: libc::c_int,
) -> libc::c_int {
    let mut res: libc::c_int = 0;
    let mut repr: libc::c_int = 0;
    let mut eidx: libc::c_int = abs(elit);
    let mut ext: *mut Ext = 0 as *mut Ext;
    if eidx >= (*lgl).szext {
        lgladjext(lgl, eidx);
    }
    if eidx > (*lgl).maxext {
        (*lgl).maxext = eidx;
        lglmelter(lgl);
    }
    repr = lglerepr(lgl, elit);
    ext = lglelit2ext(lgl, repr);
    res = (*ext).repr;
    if (*ext).imported() == 0 {
        res = lglnewvar(lgl);
        (*ext).repr = res;
        (*ext).set_imported(1 as libc::c_int as libc::c_uint);
        *((*lgl).i2e).offset(res as isize) = 2 as libc::c_int * eidx;
        lglmelter(lgl);
    }
    if repr < 0 as libc::c_int {
        res = -res;
    }
    return res;
}
unsafe extern "C" fn lglimport(mut lgl: *mut LGL, mut elit: libc::c_int) -> libc::c_int {
    if (*(*lgl).opts).import.val == 0 {
        if (*lgl).maxext == 0 {
            lglimportaux(lgl, 1 as libc::c_int);
        }
        while (*lgl).maxext < abs(elit) {
            lglimportaux(lgl, (*lgl).maxext + 1 as libc::c_int);
        }
    }
    return lglimportaux(lgl, elit);
}
unsafe extern "C" fn lglidx2stk(
    mut lgl: *mut LGL,
    mut red: libc::c_int,
    mut lidx: libc::c_int,
) -> *mut Stk {
    let mut glue: libc::c_int = 0 as libc::c_int;
    let mut s: *mut Stk = 0 as *mut Stk;
    if red == 0 {
        s = &mut (*lgl).irr;
    } else {
        glue = lidx & ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int;
        lidx >>= 4 as libc::c_int;
        s = &mut *((*lgl).red).offset(glue as isize) as *mut Stk;
    }
    return s;
}
unsafe extern "C" fn lglidx2lits(
    mut lgl: *mut LGL,
    mut red: libc::c_int,
    mut lidx: libc::c_int,
) -> *mut libc::c_int {
    let mut s: *mut Stk = lglidx2stk(lgl, red, lidx);
    let mut res: *mut libc::c_int = 0 as *mut libc::c_int;
    res = ((*s).start)
        .offset((if red != 0 { lidx >> 4 as libc::c_int } else { lidx }) as isize);
    return res;
}
unsafe extern "C" fn lgliselim(mut lgl: *mut LGL, mut lit: libc::c_int) -> libc::c_int {
    let mut tag: Tag = (*lglavar(lgl, lit)).type_0() as Tag;
    return (tag as libc::c_uint == ELIMVAR as libc::c_int as libc::c_uint)
        as libc::c_int;
}
unsafe extern "C" fn lglexport(mut lgl: *mut LGL, mut ilit: libc::c_int) -> libc::c_int {
    let mut iidx: libc::c_int = 0;
    let mut tidx: libc::c_int = 0;
    let mut eidx: libc::c_int = 0;
    let mut def: libc::c_int = 0;
    let mut res: libc::c_int = 0;
    iidx = abs(ilit);
    tidx = *((*lgl).i2e).offset(iidx as isize);
    def = tidx & 1 as libc::c_int;
    tidx >>= 1 as libc::c_int;
    eidx = tidx;
    if def != 0 {
        eidx += (*lgl).maxext;
    }
    res = eidx;
    if ilit < 0 as libc::c_int {
        res = -res;
    }
    return res;
}
unsafe extern "C" fn lglrsn(
    mut lgl: *mut LGL,
    mut lit: libc::c_int,
) -> *mut libc::c_int {
    return ((*lgltd(lgl, lit)).rsn).as_mut_ptr();
}
unsafe extern "C" fn lglulit(mut lit: libc::c_int) -> libc::c_int {
    return 2 as libc::c_int * abs(lit) + (lit < 0 as libc::c_int) as libc::c_int;
}
unsafe extern "C" fn lglsetdom(
    mut lgl: *mut LGL,
    mut lit: libc::c_int,
    mut dom: libc::c_int,
) {
    *((*lgl).doms).offset(lglulit(lit) as isize) = dom;
}
unsafe extern "C" fn lglgetdom(mut lgl: *mut LGL, mut lit: libc::c_int) -> libc::c_int {
    let mut res: libc::c_int = 0;
    res = *((*lgl).doms).offset(lglulit(lit) as isize);
    return res;
}
unsafe extern "C" fn lglhts(mut lgl: *mut LGL, mut lit: libc::c_int) -> *mut HTS {
    return ((*lgldvar(lgl, lit)).hts)
        .as_mut_ptr()
        .offset((lit < 0 as libc::c_int) as libc::c_int as isize);
}
unsafe extern "C" fn lglhts2wchs(
    mut lgl: *mut LGL,
    mut hts: *mut HTS,
) -> *mut libc::c_int {
    let mut res: *mut libc::c_int = ((*(*lgl).wchs).stk.start)
        .offset((*hts).offset as isize);
    return res;
}
unsafe extern "C" fn lgldrupligaddclsaux(
    mut lgl: *mut LGL,
    mut red: libc::c_int,
    mut c: *const libc::c_int,
) {}
unsafe extern "C" fn lgldrupligaddclsarg(
    mut lgl: *mut LGL,
    mut red: libc::c_int,
    mut args: ...
) {}
unsafe extern "C" fn lgldrupligaddcls(mut lgl: *mut LGL, mut red: libc::c_int) {}
unsafe extern "C" fn lgldrupligdelclsarg(mut lgl: *mut LGL, mut args: ...) {}
unsafe extern "C" fn lgldrupligdelclsaux(mut lgl: *mut LGL, mut c: *const libc::c_int) {}
unsafe extern "C" fn lgldrupligunit(mut lgl: *mut LGL, mut lit: libc::c_int) {}
unsafe extern "C" fn lglassign(
    mut lgl: *mut LGL,
    mut lit: libc::c_int,
    mut r0: libc::c_int,
    mut r1: libc::c_int,
) {
    let mut p: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut other: libc::c_int = 0;
    let mut other2: libc::c_int = 0;
    let mut c: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut lidx: libc::c_int = 0;
    let mut found: libc::c_int = 0;
    let mut idx: libc::c_int = 0;
    let mut phase: libc::c_int = 0;
    let mut glue: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut dom: libc::c_int = 0;
    let mut red: libc::c_int = 0;
    let mut irr: libc::c_int = 0;
    let mut av: *mut AVar = lglavar(lgl, lit);
    let mut td: *mut TD = 0 as *mut TD;
    (*av).trail = lglcntstk(&mut (*lgl).trail) as libc::c_int;
    if (*av).trail >= (*lgl).szdrail {
        let mut newszdrail: libc::c_int = if (*lgl).szdrail != 0 {
            2 as libc::c_int * (*lgl).szdrail
        } else {
            1 as libc::c_int
        };
        (*lgl)
            .drail = lglrsz(
            lgl,
            (*lgl).drail as *mut libc::c_void,
            ((*lgl).szdrail as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<TD>() as libc::c_ulong),
            (newszdrail as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<TD>() as libc::c_ulong),
        ) as *mut TD;
        (*lgl).szdrail = newszdrail;
    }
    td = lgltd(lgl, lit);
    tag = r0 & MASKCS as libc::c_int;
    dom = if tag == BINCS as libc::c_int {
        lglgetdom(lgl, -(r0 >> RMSHFT as libc::c_int))
    } else {
        lit
    };
    lglsetdom(lgl, lit, dom);
    idx = abs(lit);
    phase = lglsgn(lit);
    *((*lgl).vals).offset(idx as isize) = phase as Val;
    if (*lgl).simp == 0 {
        (*(*lgl).stats).agility -= (*(*lgl).stats).agility >> 13 as libc::c_int;
        if (*av).phase() != phase {
            (*av).set_phase(phase);
            (*(*lgl).stats).agility
                += (1 as libc::c_int as int64_t) << 19 as libc::c_int;
            (*(*lgl).stats).stability.changed += 1;
            (*(*lgl).stats).stability.changed;
        }
    }
    (*td).set_level((*lgl).level);
    if (*lgl).level == 0 {
        lgldrupligunit(lgl, lit);
        (*td).set_irr(1 as libc::c_int as libc::c_uint);
        if (*av).type_0() as libc::c_int == EQUIVAR as libc::c_int {
            (*(*lgl).stats).equiv.current -= 1;
            (*(*lgl).stats).equiv.current;
            (*(*lgl).stats).equiv.sum -= 1;
            (*(*lgl).stats).equiv.sum;
        } else {
            (*av).set_type_0(FIXEDVAR as libc::c_int as libc::c_uint);
        }
        (*(*lgl).stats).fixed.sum += 1;
        (*(*lgl).stats).fixed.sum;
        (*(*lgl).stats).fixed.current += 1;
        (*(*lgl).stats).fixed.current;
        (*(*lgl).stats).prgss += 1;
        (*(*lgl).stats).prgss;
        (*(*lgl).stats).irrprgss += 1;
        (*(*lgl).stats).irrprgss;
        (*td)
            .rsn[0 as libc::c_int
            as usize] = UNITCS as libc::c_int
            | ((lit as libc::c_uint) << RMSHFT as libc::c_int) as libc::c_int;
        (*td).rsn[1 as libc::c_int as usize] = 0 as libc::c_int;
        if !((*lgl).cbs).is_null() && ((*(*lgl).cbs).units.produce.fun).is_some() {
            (*(*lgl).stats).sync.units.produced += 1;
            (*(*lgl).stats).sync.units.produced;
            ((*(*lgl).cbs).units.produce.fun)
                .expect(
                    "non-null function pointer",
                )((*(*lgl).cbs).units.produce.state, lglexport(lgl, lit));
        }
    } else {
        (*td).rsn[0 as libc::c_int as usize] = r0;
        (*td).rsn[1 as libc::c_int as usize] = r1;
        if (*lgl).level == 1 as libc::c_int {
            if tag == DECISION as libc::c_int {
                irr = 1 as libc::c_int;
            } else {
                red = r0 & REDCS as libc::c_int;
                irr = (red == 0) as libc::c_int;
                if irr != 0 {
                    if tag == BINCS as libc::c_int {
                        other = r0 >> RMSHFT as libc::c_int;
                        irr = (*lgltd(lgl, other)).irr() as libc::c_int;
                    } else if tag == TRNCS as libc::c_int {
                        other = r0 >> RMSHFT as libc::c_int;
                        irr = (*lgltd(lgl, other)).irr() as libc::c_int;
                        if irr != 0 {
                            other2 = r1;
                            irr = (*lgltd(lgl, other2)).irr() as libc::c_int;
                        }
                    } else {
                        lidx = r1;
                        c = lglidx2lits(lgl, red, lidx);
                        found = 0 as libc::c_int;
                        p = c;
                        while irr != 0
                            && {
                                other = *p;
                                other != 0
                            }
                        {
                            if other == lit {
                                found += 1;
                                found;
                            } else {
                                irr = (*lgltd(lgl, other)).irr() as libc::c_int;
                            }
                            p = p.offset(1);
                            p;
                        }
                    }
                }
            }
        } else {
            irr = 0 as libc::c_int;
        }
        (*td).set_irr(irr as libc::c_uint);
    }
    lglpushstk(lgl, &mut (*lgl).trail, lit);
    if (*lgl).simp == 0 && (*lgl).failed == 0
        && (*av).assumed()
            & (1 as libc::c_uint) << (lit > 0 as libc::c_int) as libc::c_int != 0
    {
        (*lgl).failed = -lit;
    }
    (*lgl).unassigned -= 1;
    (*lgl).unassigned;
    (*td).set_lrglue(0 as libc::c_int as libc::c_uint);
    if r0 & REDCS as libc::c_int != 0
        && r0 & MASKCS as libc::c_int == LRGCS as libc::c_int
    {
        glue = r1 & ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int;
        (*(*lgl).stats).lir[glue as usize].forcing += 1;
        (*(*lgl).stats).lir[glue as usize].forcing;
        if (*lgl).level != 0 && (0 as libc::c_int) < glue
            && glue < ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int
        {
            (*lgl).lrgluereasons += 1;
            (*lgl).lrgluereasons;
            (*td).set_lrglue(1 as libc::c_int as libc::c_uint);
        }
    }
}
unsafe extern "C" fn lglf2rce(
    mut lgl: *mut LGL,
    mut lit: libc::c_int,
    mut other: libc::c_int,
    mut red: libc::c_int,
) {
    lglassign(
        lgl,
        lit,
        ((other as libc::c_uint) << RMSHFT as libc::c_int) as libc::c_int
            | BINCS as libc::c_int | red,
        0 as libc::c_int,
    );
}
unsafe extern "C" fn lglf3rce(
    mut lgl: *mut LGL,
    mut lit: libc::c_int,
    mut other: libc::c_int,
    mut other2: libc::c_int,
    mut red: libc::c_int,
) {
    lglassign(
        lgl,
        lit,
        ((other as libc::c_uint) << RMSHFT as libc::c_int) as libc::c_int
            | TRNCS as libc::c_int | red,
        other2,
    );
}
unsafe extern "C" fn lglflrce(
    mut lgl: *mut LGL,
    mut lit: libc::c_int,
    mut red: libc::c_int,
    mut lidx: libc::c_int,
) {
    lglassign(lgl, lit, red | LRGCS as libc::c_int, lidx);
}
unsafe extern "C" fn lgldscheduled(
    mut lgl: *mut LGL,
    mut lit: libc::c_int,
) -> libc::c_int {
    let mut qv: *mut QVar = lglqvar(lgl, lit);
    if (*qv).enqueued() != 0 {
        return 1 as libc::c_int;
    }
    return ((*qv).pos >= 0 as libc::c_int) as libc::c_int;
}
unsafe extern "C" fn lglunassign(mut lgl: *mut LGL, mut lit: libc::c_int) {
    let mut idx: libc::c_int = abs(lit);
    let mut r0: libc::c_int = 0;
    let mut r1: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut lidx: libc::c_int = 0;
    let mut glue: libc::c_int = 0;
    let mut qv: *mut QVar = 0 as *mut QVar;
    let mut td: *mut TD = 0 as *mut TD;
    *((*lgl).vals).offset(idx as isize) = 0 as libc::c_int as Val;
    (*lgl).unassigned += 1;
    (*lgl).unassigned;
    qv = lglqvar(lgl, idx);
    if !((*qv).enqueued() != 0) {
        if (*qv).pos < 0 as libc::c_int {
            lgldsched(lgl, idx);
        }
    }
    td = lgltd(lgl, idx);
    r0 = (*td).rsn[0 as libc::c_int as usize];
    if r0 & REDCS as libc::c_int == 0 {
        return;
    }
    tag = r0 & MASKCS as libc::c_int;
    if tag != LRGCS as libc::c_int {
        return;
    }
    r1 = (*td).rsn[1 as libc::c_int as usize];
    glue = r1 & ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int;
    if (*td).lrglue() != 0 {
        (*lgl).lrgluereasons -= 1;
        (*lgl).lrgluereasons;
    }
    if glue < ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int {
        return;
    }
    lidx = r1 >> 4 as libc::c_int;
    lglrststk(&mut *((*lgl).red).offset(glue as isize), lidx);
}
unsafe extern "C" fn lglifixed(mut lgl: *mut LGL, mut lit: libc::c_int) -> Val {
    let mut res: libc::c_int = 0;
    res = lglval(lgl, lit) as libc::c_int;
    if res == 0 {
        return 0 as libc::c_int as Val;
    }
    if lglevel(lgl, lit) > 0 as libc::c_int {
        return 0 as libc::c_int as Val;
    }
    return res as Val;
}
unsafe extern "C" fn lglbacktrack(mut lgl: *mut LGL, mut level: libc::c_int) {
    let mut lit: libc::c_int = 0;
    if (*(*lgl).stats).stability.level > 0 as libc::c_int {
        (*(*lgl).stats).stability.level = 0 as libc::c_int;
    }
    if (*lgl).failed != 0 && (*lgl).failed != -(1 as libc::c_int)
        && lglevel(lgl, (*lgl).failed) > level
    {
        (*lgl).failed = 0 as libc::c_int;
    }
    while lglmtstk(&mut (*lgl).trail) == 0 {
        lit = lgltopstk(&mut (*lgl).trail);
        if lglevel(lgl, lit) <= level {
            break;
        }
        lglunassign(lgl, lit);
        (*lgl).trail.top = ((*lgl).trail.top).offset(-1);
        (*lgl).trail.top;
    }
    if level == 0 {
        while lglmtstk(
            &mut *((*lgl).red)
                .offset(
                    (((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int)
                        as isize,
                ),
        ) == 0
        {
            let mut tmp: libc::c_int = lglpopstk(
                &mut *((*lgl).red)
                    .offset(
                        (((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int)
                            as isize,
                    ),
            );
        }
    }
    if (*lgl).alevel > level {
        (*lgl).alevel = level;
        if (*lgl).assumed != 0 {
            (*lgl).assumed = 0 as libc::c_int;
        }
    }
    (*lgl).level = level;
    lglrstcontrol(lgl, level + 1 as libc::c_int);
    (*lgl).conf.lit = 0 as libc::c_int;
    (*lgl).conf.rsn[1 as libc::c_int as usize] = 0 as libc::c_int;
    (*lgl)
        .conf
        .rsn[0 as libc::c_int as usize] = (*lgl).conf.rsn[1 as libc::c_int as usize];
    (*lgl).next = lglcntstk(&mut (*lgl).trail) as libc::c_int;
    (*lgl).next2 = (*lgl).next;
}
unsafe extern "C" fn lglmarked(mut lgl: *mut LGL, mut lit: libc::c_int) -> libc::c_int {
    let mut res: libc::c_int = (*lglavar(lgl, lit)).mark;
    if lit < 0 as libc::c_int {
        res = -res;
    }
    return res;
}
unsafe extern "C" fn lglunit(mut lgl: *mut LGL, mut lit: libc::c_int) {
    lglassign(
        lgl,
        lit,
        ((lit as libc::c_uint) << RMSHFT as libc::c_int) as libc::c_int
            | UNITCS as libc::c_int,
        0 as libc::c_int,
    );
}
unsafe extern "C" fn lglmark(mut lgl: *mut LGL, mut lit: libc::c_int) {
    (*lglavar(lgl, lit)).mark = lglsgn(lit);
}
unsafe extern "C" fn lglmarkunmarked(mut lgl: *mut LGL, mut lit: libc::c_int) {
    let mut av: *mut AVar = lglavar(lgl, lit);
    (*av).mark = lglsgn(lit);
}
unsafe extern "C" fn lglunmark(mut lgl: *mut LGL, mut lit: libc::c_int) {
    (*lglavar(lgl, lit)).mark = 0 as libc::c_int;
}
unsafe extern "C" fn lglchksimpcls(mut lgl: *mut LGL) {}
unsafe extern "C" fn lglcval(
    mut lgl: *mut LGL,
    mut litorval: libc::c_int,
) -> libc::c_int {
    if litorval == 1 as libc::c_int || litorval == -(1 as libc::c_int) {
        return litorval;
    }
    return lglval(lgl, litorval) as libc::c_int;
}
unsafe extern "C" fn lglisimpcls(mut lgl: *mut LGL) -> libc::c_int {
    let mut p: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut q: *mut libc::c_int = (*lgl).clause.start;
    let mut lit: libc::c_int = 0;
    let mut satisfied: libc::c_int = 0;
    let mut val: libc::c_int = 0;
    let mut mark: libc::c_int = 0;
    satisfied = 0 as libc::c_int;
    p = q;
    loop {
        lit = *p;
        if !(lit != 0) {
            break;
        }
        if !(satisfied != 0) {
            val = lglval(lgl, lit) as libc::c_int;
            if val > 0 as libc::c_int {
                satisfied = 1 as libc::c_int;
            } else if !(val < 0 as libc::c_int) {
                mark = lglmarked(lgl, lit);
                if !(mark > 0 as libc::c_int) {
                    if mark < 0 as libc::c_int {
                        satisfied = 1 as libc::c_int;
                    } else {
                        let fresh21 = q;
                        q = q.offset(1);
                        *fresh21 = lit;
                        lglmark(lgl, lit);
                    }
                }
            }
        }
        p = p.offset(1);
        p;
    }
    *q = 0 as libc::c_int;
    (*lgl).clause.top = q.offset(1 as libc::c_int as isize);
    satisfied != 0;
    while q > (*lgl).clause.start {
        q = q.offset(-1);
        lglunmark(lgl, *q);
    }
    return satisfied;
}
unsafe extern "C" fn lglesimpcls(mut lgl: *mut LGL) -> libc::c_int {
    let mut p: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut q: *mut libc::c_int = (*lgl).clause.start;
    let mut lit: libc::c_int = 0;
    let mut satisfied: libc::c_int = 0;
    let mut val: libc::c_int = 0;
    let mut mark: libc::c_int = 0;
    satisfied = 0 as libc::c_int;
    p = q;
    while satisfied == 0
        && {
            lit = *p;
            lit != 0
        }
    {
        val = lglcval(lgl, lit);
        if val > 0 as libc::c_int {
            satisfied = 1 as libc::c_int;
        } else if !(val < 0 as libc::c_int) {
            mark = lglmarked(lgl, lit);
            if !(mark > 0 as libc::c_int) {
                if mark < 0 as libc::c_int {
                    satisfied = 1 as libc::c_int;
                } else {
                    let fresh22 = q;
                    q = q.offset(1);
                    *fresh22 = lit;
                    lglmark(lgl, lit);
                }
            }
        }
        p = p.offset(1);
        p;
    }
    *q = 0 as libc::c_int;
    (*lgl).clause.top = q.offset(1 as libc::c_int as isize);
    satisfied != 0;
    while q > (*lgl).clause.start {
        q = q.offset(-1);
        lglunmark(lgl, *q);
    }
    return satisfied;
}
unsafe extern "C" fn lglorderclsaux(mut lgl: *mut LGL, mut start: *mut libc::c_int) {
    let mut p: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut max: libc::c_int = 0 as libc::c_int;
    let mut level: libc::c_int = 0;
    let mut lit: libc::c_int = 0;
    let mut val: libc::c_int = 0;
    p = start;
    loop {
        lit = *p;
        if !(lit != 0) {
            break;
        }
        val = lglval(lgl, lit) as libc::c_int;
        if val < 0 as libc::c_int {
            level = lglevel(lgl, lit);
        } else if val > 0 as libc::c_int {
            level = 2147483647 as libc::c_int - 1 as libc::c_int;
        } else {
            level = 2147483647 as libc::c_int;
        }
        if !(level <= max) {
            max = level;
            *p = *start.offset(0 as libc::c_int as isize);
            *start.offset(0 as libc::c_int as isize) = lit;
        }
        p = p.offset(1);
        p;
    };
}
unsafe extern "C" fn lglordercls(mut lgl: *mut LGL) {
    lglorderclsaux(lgl, (*lgl).clause.start);
    lglorderclsaux(lgl, ((*lgl).clause.start).offset(1 as libc::c_int as isize));
}
unsafe extern "C" fn lglfreewch(
    mut lgl: *mut LGL,
    mut oldoffset: libc::c_uint,
    mut oldhcount: libc::c_uint,
) {
    let mut ldoldhcount: libc::c_uint = lglceild(oldhcount as libc::c_int)
        as libc::c_uint;
    *((*(*lgl).wchs).stk.start)
        .offset(
            oldoffset as isize,
        ) = (*(*lgl).wchs).start[ldoldhcount as usize] as libc::c_int;
    (*(*lgl).wchs).start[ldoldhcount as usize] = oldoffset;
    (*(*lgl).wchs).free += 1;
    (*(*lgl).wchs).free;
}
unsafe extern "C" fn lglshrinkhts(
    mut lgl: *mut LGL,
    mut hts: *mut HTS,
    mut newcount: libc::c_int,
) {
    let mut i: libc::c_uint = 0;
    let mut oldcount: libc::c_uint = (*hts).count;
    let mut p: *mut libc::c_int = 0 as *mut libc::c_int;
    if newcount as libc::c_uint == oldcount {
        return;
    }
    p = lglhts2wchs(lgl, hts);
    i = newcount as libc::c_uint;
    while i < oldcount {
        *p.offset(i as isize) = 0 as libc::c_int;
        i = i.wrapping_add(1);
        i;
    }
    (*hts).count = newcount as libc::c_uint;
    if newcount != 0 {
        return;
    }
    lglfreewch(lgl, (*hts).offset, oldcount);
    (*hts).offset = 0 as libc::c_int as libc::c_uint;
}
unsafe extern "C" fn lglenlwchs(mut lgl: *mut LGL, mut hts: *mut HTS) -> ptrdiff_t {
    let mut oldhcount: libc::c_uint = 0;
    let mut ldoldhcount: libc::c_uint = 0;
    let mut ldnewhcount: libc::c_uint = 0;
    let mut newhcount: libc::c_uint = 0;
    let mut oldwcount: libc::c_ulong = 0;
    let mut newwcount: libc::c_ulong = 0;
    let mut oldwsize: libc::c_ulong = 0;
    let mut newwsize: libc::c_ulong = 0;
    let mut oldwstart: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut newwstart: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut start: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut oldoffset: libc::c_uint = 0;
    let mut newoffset: libc::c_uint = 0;
    let mut i: libc::c_uint = 0;
    let mut j: libc::c_uint = 0;
    let mut res: ptrdiff_t = 0;
    res = 0 as libc::c_int as ptrdiff_t;
    oldhcount = (*hts).count;
    oldoffset = (*hts).offset;
    newhcount = 1 as libc::c_int as libc::c_uint;
    ldnewhcount = 0 as libc::c_int as libc::c_uint;
    ldoldhcount = lglfloorld(oldhcount);
    ldnewhcount = ldoldhcount.wrapping_add(1 as libc::c_int as libc::c_uint);
    if ldnewhcount > 31 as libc::c_int as libc::c_uint {
        lgldie(lgl, b"watcher stack overflow\0" as *const u8 as *const libc::c_char);
    }
    newhcount = (1 as libc::c_uint) << ldnewhcount;
    (*(*lgl).stats).enlwchs += 1;
    (*(*lgl).stats).enlwchs;
    newoffset = (*(*lgl).wchs).start[ldnewhcount as usize];
    start = (*(*lgl).wchs).stk.start;
    if newoffset
        != (2147483647 as libc::c_int as libc::c_uint)
            .wrapping_mul(2 as libc::c_uint)
            .wrapping_add(1 as libc::c_uint)
    {
        (*(*lgl).wchs)
            .start[ldnewhcount
            as usize] = *start.offset(newoffset as isize) as libc::c_uint;
        *start.offset(newoffset as isize) = 0 as libc::c_int;
        (*(*lgl).wchs).free -= 1;
        (*(*lgl).wchs).free;
    } else {
        oldwcount = lglcntstk(&mut (*(*lgl).wchs).stk);
        newwcount = oldwcount.wrapping_add(newhcount as libc::c_ulong);
        if newwcount
            > (2147483647 as libc::c_int as libc::c_uint)
                .wrapping_mul(2 as libc::c_uint)
                .wrapping_add(1 as libc::c_uint) as libc::c_ulong
        {
            lgldie(
                lgl,
                b"watcher stack memory arena overflow\0" as *const u8
                    as *const libc::c_char,
            );
        }
        oldwsize = lglszstk(&mut (*(*lgl).wchs).stk);
        newwsize = oldwsize;
        while newwsize < newwcount {
            newwsize = newwsize.wrapping_mul(2 as libc::c_int as libc::c_ulong);
        }
        if newwsize
            > (2147483647 as libc::c_int as libc::c_uint)
                .wrapping_mul(2 as libc::c_uint)
                .wrapping_add(1 as libc::c_uint) as libc::c_ulong
        {
            newwsize = (2147483647 as libc::c_int as libc::c_uint)
                .wrapping_mul(2 as libc::c_uint)
                .wrapping_add(1 as libc::c_uint) as libc::c_ulong;
        }
        if newwsize > oldwsize {
            oldwstart = (*(*lgl).wchs).stk.start;
            newwstart = oldwstart;
            newwstart = lglrsz(
                lgl,
                newwstart as *mut libc::c_void,
                oldwsize
                    .wrapping_mul(
                        ::core::mem::size_of::<libc::c_int>() as libc::c_ulong,
                    ),
                newwsize
                    .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
            ) as *mut libc::c_int;
            res = newwstart.offset_from(oldwstart) as libc::c_long;
            if res != 0 {
                (*(*lgl).wchs).stk.start = newwstart;
                start = (*(*lgl).wchs).stk.start;
            }
            (*(*lgl).wchs).stk.end = start.offset(newwsize as isize);
        }
        (*(*lgl).wchs).stk.top = start.offset(newwcount as isize);
        *((*(*lgl).wchs).stk.top)
            .offset(
                -(1 as libc::c_int) as isize,
            ) = (2147483647 as libc::c_int as libc::c_uint)
            .wrapping_mul(2 as libc::c_uint)
            .wrapping_add(1 as libc::c_uint) as libc::c_int;
        newoffset = oldwcount.wrapping_sub(1 as libc::c_int as libc::c_ulong)
            as libc::c_uint;
    }
    j = newoffset;
    i = oldoffset;
    while i < oldoffset.wrapping_add(oldhcount) {
        let fresh23 = j;
        j = j.wrapping_add(1);
        *start.offset(fresh23 as isize) = *start.offset(i as isize);
        *start.offset(i as isize) = 0 as libc::c_int;
        i = i.wrapping_add(1);
        i;
    }
    while j < newoffset.wrapping_add(newhcount) {
        let fresh24 = j;
        j = j.wrapping_add(1);
        *start.offset(fresh24 as isize) = 0 as libc::c_int;
    }
    (*hts).offset = newoffset;
    if oldhcount > 0 as libc::c_int as libc::c_uint {
        lglfreewch(lgl, oldoffset, oldhcount);
    }
    return res;
}
unsafe extern "C" fn lglpushwch(
    mut lgl: *mut LGL,
    mut hts: *mut HTS,
    mut wch: libc::c_int,
) -> ptrdiff_t {
    let mut res: ptrdiff_t = 0 as libc::c_int as ptrdiff_t;
    let mut wchs: *mut libc::c_int = lglhts2wchs(lgl, hts);
    if *wchs.offset((*hts).count as isize) != 0 {
        res = lglenlwchs(lgl, hts);
        wchs = lglhts2wchs(lgl, hts);
    }
    let fresh25 = (*hts).count;
    (*hts).count = ((*hts).count).wrapping_add(1);
    *wchs.offset(fresh25 as isize) = wch;
    (*(*lgl).stats).pshwchs += 1;
    (*(*lgl).stats).pshwchs;
    return res;
}
unsafe extern "C" fn lglwchbin(
    mut lgl: *mut LGL,
    mut lit: libc::c_int,
    mut other: libc::c_int,
    mut red: libc::c_int,
) -> ptrdiff_t {
    let mut hts: *mut HTS = lglhts(lgl, lit);
    let mut cs: libc::c_int = ((other as libc::c_uint) << RMSHFT as libc::c_int)
        as libc::c_int | BINCS as libc::c_int | red;
    let mut res: ptrdiff_t = 0;
    res = lglpushwch(lgl, hts, cs);
    return res;
}
unsafe extern "C" fn lglwchtrn(
    mut lgl: *mut LGL,
    mut a: libc::c_int,
    mut b: libc::c_int,
    mut c: libc::c_int,
    mut red: libc::c_int,
) -> ptrdiff_t {
    let mut hts: *mut HTS = lglhts(lgl, a);
    let mut cs: libc::c_int = ((b as libc::c_uint) << RMSHFT as libc::c_int)
        as libc::c_int | TRNCS as libc::c_int | red;
    let mut res: ptrdiff_t = 0;
    res = lglpushwch(lgl, hts, cs);
    res += lglpushwch(lgl, hts, c);
    return res;
}
unsafe extern "C" fn lglwchlrg(
    mut lgl: *mut LGL,
    mut lit: libc::c_int,
    mut other: libc::c_int,
    mut red: libc::c_int,
    mut lidx: libc::c_int,
) -> ptrdiff_t {
    let mut hts: *mut HTS = lglhts(lgl, lit);
    let mut blit: libc::c_int = ((other as libc::c_uint) << RMSHFT as libc::c_int)
        as libc::c_int | LRGCS as libc::c_int | red;
    let mut res: ptrdiff_t = 0 as libc::c_int as ptrdiff_t;
    res += lglpushwch(lgl, hts, blit);
    res += lglpushwch(lgl, hts, lidx);
    return res;
}
unsafe extern "C" fn lglevar(mut lgl: *mut LGL, mut lit: libc::c_int) -> *mut EVar {
    let mut idx: libc::c_int = abs(lit);
    return ((*lgl).evars).offset(idx as isize);
}
unsafe extern "C" fn lglepos(
    mut lgl: *mut LGL,
    mut lit: libc::c_int,
) -> *mut libc::c_int {
    let mut ev: *mut EVar = 0 as *mut EVar;
    let mut res: *mut libc::c_int = 0 as *mut libc::c_int;
    ev = lglevar(lgl, lit);
    res = &mut (*ev).pos;
    return res;
}
unsafe extern "C" fn lglecmp(
    mut lgl: *mut LGL,
    mut l: libc::c_int,
    mut k: libc::c_int,
) -> libc::c_int {
    return (*lglevar(lgl, k)).score - (*lglevar(lgl, l)).score;
}
unsafe extern "C" fn lgleup(mut lgl: *mut LGL, mut lit: libc::c_int) {
    let mut child: libc::c_int = lit;
    let mut parent: libc::c_int = 0;
    let mut cpos: libc::c_int = 0;
    let mut ppos: libc::c_int = 0;
    let mut p: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut cposptr: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut pposptr: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut s: *mut Stk = &mut (*lgl).esched;
    p = (*s).start;
    cposptr = lglepos(lgl, child);
    cpos = *cposptr;
    while cpos > 0 as libc::c_int {
        ppos = (cpos - 1 as libc::c_int) / 2 as libc::c_int;
        parent = *p.offset(ppos as isize);
        if lglecmp(lgl, parent, lit) >= 0 as libc::c_int {
            break;
        }
        pposptr = lglepos(lgl, parent);
        *p.offset(cpos as isize) = parent;
        *pposptr = cpos;
        cpos = ppos;
    }
    if *cposptr == cpos {
        return;
    }
    *cposptr = cpos;
    *p.offset(cpos as isize) = lit;
}
unsafe extern "C" fn lgledown(mut lgl: *mut LGL, mut lit: libc::c_int) {
    let mut parent: libc::c_int = lit;
    let mut child: libc::c_int = 0;
    let mut right: libc::c_int = 0;
    let mut ppos: libc::c_int = 0;
    let mut cpos: libc::c_int = 0;
    let mut p: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut pposptr: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut cposptr: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut size: libc::c_int = 0;
    let mut s: *mut Stk = &mut (*lgl).esched;
    size = lglcntstk(s) as libc::c_int;
    p = (*s).start;
    pposptr = lglepos(lgl, parent);
    ppos = *pposptr;
    loop {
        cpos = 2 as libc::c_int * ppos + 1 as libc::c_int;
        if cpos >= size {
            break;
        }
        child = *p.offset(cpos as isize);
        if (cpos + 1 as libc::c_int) < size {
            right = *p.offset((cpos + 1 as libc::c_int) as isize);
            if lglecmp(lgl, child, right) < 0 as libc::c_int {
                cpos += 1;
                cpos;
                child = right;
            }
        }
        if lglecmp(lgl, child, lit) <= 0 as libc::c_int {
            break;
        }
        cposptr = lglepos(lgl, child);
        *p.offset(ppos as isize) = child;
        *cposptr = ppos;
        ppos = cpos;
    }
    if *pposptr == ppos {
        return;
    }
    *pposptr = ppos;
    *p.offset(ppos as isize) = lit;
}
unsafe extern "C" fn lglifrozen(
    mut lgl: *mut LGL,
    mut ilit: libc::c_int,
) -> libc::c_int {
    let mut elit: libc::c_int = lglexport(lgl, ilit);
    let mut ext: *mut Ext = lglelit2ext(lgl, elit);
    return ((*ext).frozen != 0 || (*ext).tmpfrozen() as libc::c_int != 0) as libc::c_int;
}
unsafe extern "C" fn lglesched(mut lgl: *mut LGL, mut lit: libc::c_int) {
    let mut av: *mut AVar = 0 as *mut AVar;
    let mut p: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut s: *mut Stk = 0 as *mut Stk;
    if (*lgl).cceing != 0 {
        return;
    }
    if lglifrozen(lgl, lit) != 0 {
        return;
    }
    if lglisfree(lgl, lit) == 0 {
        return;
    }
    if (*lgl).donotsched != 0 {
        av = lglavar(lgl, lit);
        if (*lgl).eliminating as libc::c_int != 0 && (*av).donotelm() as libc::c_int != 0
        {
            return;
        }
        if (*lgl).blocking as libc::c_int != 0 && (*av).donotblk() as libc::c_int != 0 {
            return;
        }
    }
    p = lglepos(lgl, lit);
    s = &mut (*lgl).esched;
    if *p >= 0 as libc::c_int {
        return;
    }
    *p = lglcntstk(s) as libc::c_int;
    lglpushstk(lgl, s, lit);
    lgleup(lgl, lit);
    lgledown(lgl, lit);
}
unsafe extern "C" fn lglgcd(mut a: libc::c_uint, mut b: libc::c_uint) -> libc::c_uint {
    let mut tmp: libc::c_uint = 0;
    if a < b {
        let mut TMP: libc::c_uint = a;
        a = b;
        b = TMP;
    }
    while b != 0 {
        tmp = b;
        b = a.wrapping_rem(b);
        a = tmp;
    }
    return a;
}
unsafe extern "C" fn lglrandidxtrav(
    mut lgl: *mut LGL,
    mut fun: Option::<unsafe extern "C" fn(*mut LGL, libc::c_int) -> libc::c_int>,
) -> libc::c_int {
    let mut idx: libc::c_int = 0;
    let mut delta: libc::c_int = 0;
    let mut mod_0: libc::c_int = 0;
    let mut prev: libc::c_int = 0;
    let mut first: libc::c_int = 0;
    let mut res: libc::c_int = 0;
    mod_0 = lglmax((*lgl).nvars, 2 as libc::c_int);
    first = mod_0;
    idx = (lglrand(lgl)).wrapping_rem(mod_0 as libc::c_uint) as libc::c_int;
    delta = (lglrand(lgl)).wrapping_rem(mod_0 as libc::c_uint) as libc::c_int;
    if delta == 0 {
        delta += 1;
        delta;
    }
    while lglgcd(delta as libc::c_uint, mod_0 as libc::c_uint)
        > 1 as libc::c_int as libc::c_uint
    {
        delta += 1;
        if delta == mod_0 {
            delta = 1 as libc::c_int;
        }
    }
    res = 1 as libc::c_int;
    while res != 0 {
        if idx >= 2 as libc::c_int
            && fun.expect("non-null function pointer")(lgl, idx) == 0
        {
            res = 0 as libc::c_int;
        } else {
            prev = idx;
            idx += delta;
            if idx >= mod_0 {
                idx -= mod_0;
            }
            if idx == first {
                break;
            }
            if first == mod_0 {
                first = prev;
            }
        }
    }
    return res;
}
unsafe extern "C" fn lglrem(mut lgl: *mut LGL) -> libc::c_int {
    let mut res: libc::c_int = (*lgl).nvars;
    if res == 0 {
        return 0 as libc::c_int;
    }
    res -= (*(*lgl).stats).fixed.current + 2 as libc::c_int;
    return res;
}
unsafe extern "C" fn lglpcnt(
    mut n: libc::c_double,
    mut d: libc::c_double,
) -> libc::c_double {
    if d <= 0 as libc::c_int as libc::c_double || n == 0. {
        return 0.0f64;
    }
    return 100.0f64 * n / d;
}
unsafe extern "C" fn lglecalc(mut lgl: *mut LGL, mut ev: *mut EVar) -> libc::c_int {
    let mut oldscore: libc::c_int = (*ev).score;
    let mut o0: libc::c_int = (*ev).occ[0 as libc::c_int as usize];
    let mut o1: libc::c_int = (*ev).occ[1 as libc::c_int as usize];
    let mut newscore: libc::c_int = 0;
    if o0 == 0 || o1 == 0 {
        newscore = 0 as libc::c_int;
    } else {
        newscore = o0 + o1;
    }
    (*ev).score = newscore;
    return newscore - oldscore;
}
unsafe extern "C" fn lglocc(mut lgl: *mut LGL, mut lit: libc::c_int) -> libc::c_int {
    if (*lgl).occs == 0 {
        return (*lglhts(lgl, lit)).count as libc::c_int;
    }
    return (*lglevar(lgl, lit)).occ[(lit < 0 as libc::c_int) as libc::c_int as usize];
}
unsafe extern "C" fn lglflushtouched(mut lgl: *mut LGL) {
    let mut q: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut idx: libc::c_int = 0;
    let mut mt: libc::c_int = 0 as libc::c_int;
    let mut pos: *mut libc::c_int = (*(*lgl).c2rust_unnamed.elm).touched.pos;
    let mut newpos: libc::c_int = 0 as libc::c_int;
    let mut touched: *mut Stk = &mut (*(*lgl).c2rust_unnamed.elm).touched.stk;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    q = (*touched).start;
    p = q;
    while p < (*touched).top as *const libc::c_int {
        idx = *p;
        if idx != 0 {
            let fresh26 = newpos;
            newpos = newpos + 1;
            *pos.offset(idx as isize) = fresh26;
            let fresh27 = q;
            q = q.offset(1);
            *fresh27 = idx;
        } else {
            mt += 1;
            mt;
        }
        p = p.offset(1);
        p;
    }
    (*(*lgl).c2rust_unnamed.elm).touched.mt = 0 as libc::c_int;
    (*touched).top = q;
}
unsafe extern "C" fn lgltouch(mut lgl: *mut LGL, mut lit: libc::c_int) {
    let mut idx: libc::c_int = abs(lit);
    let mut posptr: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut oldpos: libc::c_int = 0;
    let mut newpos: libc::c_int = 0;
    posptr = ((*(*lgl).c2rust_unnamed.elm).touched.pos).offset(idx as isize);
    newpos = lglcntstk(&mut (*(*lgl).c2rust_unnamed.elm).touched.stk) as libc::c_int;
    oldpos = *posptr;
    lglpushstk(lgl, &mut (*(*lgl).c2rust_unnamed.elm).touched.stk, idx);
    *posptr = newpos;
    if oldpos >= 0 as libc::c_int {
        lglpoke(&mut (*(*lgl).c2rust_unnamed.elm).touched.stk, oldpos, 0 as libc::c_int);
        (*(*lgl).c2rust_unnamed.elm).touched.mt += 1;
        (*(*lgl).c2rust_unnamed.elm).touched.mt;
        if (*(*lgl).c2rust_unnamed.elm).touched.mt
            > (*(*lgl).c2rust_unnamed.elm).touched.nvars
        {
            lglflushtouched(lgl);
        }
    }
}
unsafe extern "C" fn lglpoptouched(mut lgl: *mut LGL) -> libc::c_int {
    let mut res: libc::c_int = 0;
    let mut posptr: *mut libc::c_int = 0 as *mut libc::c_int;
    loop {
        if lglmtstk(&mut (*(*lgl).c2rust_unnamed.elm).touched.stk) != 0 {
            return 0 as libc::c_int;
        }
        res = lglpopstk(&mut (*(*lgl).c2rust_unnamed.elm).touched.stk);
        if res != 0 {
            break;
        }
        (*(*lgl).c2rust_unnamed.elm).touched.mt -= 1;
        (*(*lgl).c2rust_unnamed.elm).touched.mt;
    }
    posptr = ((*(*lgl).c2rust_unnamed.elm).touched.pos).offset(res as isize);
    *posptr = -(1 as libc::c_int);
    return res;
}
unsafe extern "C" fn lgltouched(mut lgl: *mut LGL, mut lit: libc::c_int) -> libc::c_int {
    let mut idx: libc::c_int = abs(lit);
    return (*((*(*lgl).c2rust_unnamed.elm).touched.pos).offset(idx as isize)
        >= 0 as libc::c_int) as libc::c_int;
}
unsafe extern "C" fn lglincocc(mut lgl: *mut LGL, mut lit: libc::c_int) {
    let mut idx: libc::c_int = 0;
    let mut sign: libc::c_int = 0;
    let mut change: libc::c_int = 0;
    let mut ev: *mut EVar = 0 as *mut EVar;
    if (*lgl).occs == 0 {
        return;
    }
    idx = abs(lit);
    sign = (lit < 0 as libc::c_int) as libc::c_int;
    ev = lglevar(lgl, lit);
    (*ev).occ[sign as usize] += 1 as libc::c_int;
    change = lglecalc(lgl, ev);
    if (*ev).pos < 0 as libc::c_int {
        lglesched(lgl, idx);
    } else if change > 0 as libc::c_int {
        lgledown(lgl, idx);
    } else if change < 0 as libc::c_int {
        lgleup(lgl, idx);
    }
    if (*lgl).touching != 0 {
        lgltouch(lgl, lit);
    }
}
unsafe extern "C" fn lglisact(mut act: libc::c_int) -> libc::c_int {
    return (2147483647 as libc::c_int >> RMSHFT as libc::c_int <= act
        && act < 2147483647 as libc::c_int - 1 as libc::c_int) as libc::c_int;
}
unsafe extern "C" fn lglrescoreglue(
    mut lgl: *mut LGL,
    mut glue: libc::c_int,
) -> libc::c_int {
    let mut c: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut p: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut oldact: libc::c_int = 0;
    let mut newact: libc::c_int = 0;
    let mut count: libc::c_int = 0 as libc::c_int;
    let retireint: libc::c_int = (*(*lgl).opts).retireint.val;
    let mut lir: *mut Stk = ((*lgl).red).offset(glue as isize);
    c = (*lir).start;
    while c < (*lir).top {
        oldact = *c;
        if oldact == 2147483647 as libc::c_int {
            p = c.offset(1 as libc::c_int as isize);
            while p < (*lir).top && *p == 2147483647 as libc::c_int {
                p = p.offset(1);
                p;
            }
            p = p.offset(-1);
            p;
        } else if (2147483647 as libc::c_int >> RMSHFT as libc::c_int) + retireint
            < oldact
        {
            newact = (oldact - (2147483647 as libc::c_int >> RMSHFT as libc::c_int)
                - retireint + 1 as libc::c_int) / 2 as libc::c_int;
            newact += (2147483647 as libc::c_int >> RMSHFT as libc::c_int) + retireint;
            let fresh28 = c;
            c = c.offset(1);
            *fresh28 = newact;
            p = c;
            while *p != 0 {
                p = p.offset(1);
                p;
            }
            count += 1;
            count;
        } else {
            p = c.offset(1 as libc::c_int as isize);
            while *p != 0 {
                p = p.offset(1);
                p;
            }
        }
        c = p.offset(1 as libc::c_int as isize);
    }
    return count;
}
unsafe extern "C" fn lglrescoreclauses(mut lgl: *mut LGL) {
    let mut glue: libc::c_int = 0;
    let mut count: libc::c_int = 0 as libc::c_int;
    (*(*lgl).stats).rescored.clauses += 1;
    (*(*lgl).stats).rescored.clauses;
    glue = 0 as libc::c_int;
    while glue < ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int {
        count += lglrescoreglue(lgl, glue);
        glue += 1;
        glue;
    }
    lglprt(
        lgl,
        3 as libc::c_int,
        b"[rescored-clauses-%d] rescored activity of %d clauses\0" as *const u8
            as *const libc::c_char,
        (*(*lgl).stats).rescored.clauses,
        count,
    );
}
unsafe extern "C" fn lglchkirrstats(mut lgl: *mut LGL) {}
unsafe extern "C" fn lglincirr(mut lgl: *mut LGL, mut size: libc::c_int) {
    if size < 2 as libc::c_int {
        return;
    }
    (*(*lgl).stats).irr.clauses.cur += 1;
    (*(*lgl).stats).irr.clauses.cur;
    if (*(*lgl).stats).irr.clauses.cur > (*(*lgl).stats).irr.clauses.max {
        (*(*lgl).stats).irr.clauses.max = (*(*lgl).stats).irr.clauses.cur;
    }
    (*(*lgl).stats).irr.lits.cur += size;
    if (*(*lgl).stats).irr.lits.cur > (*(*lgl).stats).irr.lits.max {
        (*(*lgl).stats).irr.lits.max = (*(*lgl).stats).irr.lits.cur;
    }
    (*(*lgl).stats).irrprgss += 1;
    (*(*lgl).stats).irrprgss;
}
unsafe extern "C" fn lgldecirr(mut lgl: *mut LGL, mut size: libc::c_int) {
    (*(*lgl).stats).irr.clauses.cur -= 1;
    (*(*lgl).stats).irr.clauses.cur;
    (*(*lgl).stats).irr.lits.cur -= size;
    (*(*lgl).stats).irrprgss += 1;
    (*(*lgl).stats).irrprgss;
}
unsafe extern "C" fn lglincglag(mut lgl: *mut LGL) {
    if (*lgl).glag
        == ((1 as libc::c_int) << 30 as libc::c_int - 1 as libc::c_int)
            - 1 as libc::c_int
    {
        let mut idx: libc::c_int = 0;
        idx = 2 as libc::c_int;
        while idx < (*lgl).nvars {
            let ref mut fresh29 = *lglqvar(lgl, idx);
            (*fresh29).set_glag(-(1 as libc::c_int));
            idx += 1;
            idx;
        }
        (*lgl).glag = 0 as libc::c_int;
    } else {
        (*lgl).glag += 1;
        (*lgl).glag;
    };
}
unsafe extern "C" fn lglaged(mut lgl: *mut LGL, mut lit: libc::c_int) -> libc::c_int {
    let mut level: libc::c_int = lglevel(lgl, lit);
    let mut qv: *mut QVar = 0 as *mut QVar;
    let fresh30 = level;
    level = level + 1;
    if fresh30 == 0 {
        return 1 as libc::c_int;
    }
    qv = lglqvar(lgl, level);
    if (*qv).glag() >= (*lgl).glag {
        return 1 as libc::c_int;
    }
    (*qv).set_glag((*lgl).glag);
    return 0 as libc::c_int;
}
static mut lglar1scalegluetab: [libc::c_int; 16] = [
    0 as libc::c_int,
    1 as libc::c_int,
    2 as libc::c_int,
    3 as libc::c_int,
    4 as libc::c_int,
    5 as libc::c_int,
    6 as libc::c_int,
    7 as libc::c_int,
    8 as libc::c_int,
    9 as libc::c_int,
    10 as libc::c_int,
    11 as libc::c_int,
    12 as libc::c_int,
    13 as libc::c_int,
    14 as libc::c_int,
    15 as libc::c_int,
];
static mut lglar2scalegluetab: [libc::c_int; 16] = [
    0 as libc::c_int,
    1 as libc::c_int,
    3 as libc::c_int,
    6 as libc::c_int,
    10 as libc::c_int,
    15 as libc::c_int,
    21 as libc::c_int,
    28 as libc::c_int,
    36 as libc::c_int,
    45 as libc::c_int,
    55 as libc::c_int,
    66 as libc::c_int,
    78 as libc::c_int,
    91 as libc::c_int,
    105 as libc::c_int,
    120 as libc::c_int,
];
static mut lglsqrtscalegluetab: [libc::c_int; 16] = [
    0 as libc::c_int,
    1 as libc::c_int,
    2 as libc::c_int,
    5 as libc::c_int,
    10 as libc::c_int,
    17 as libc::c_int,
    26 as libc::c_int,
    37 as libc::c_int,
    50 as libc::c_int,
    65 as libc::c_int,
    82 as libc::c_int,
    101 as libc::c_int,
    122 as libc::c_int,
    145 as libc::c_int,
    170 as libc::c_int,
    197 as libc::c_int,
];
static mut lglsqrtldscalegluetab: [libc::c_int; 16] = [
    0 as libc::c_int,
    1 as libc::c_int,
    2 as libc::c_int,
    5 as libc::c_int,
    10 as libc::c_int,
    17 as libc::c_int,
    26 as libc::c_int,
    37 as libc::c_int,
    50 as libc::c_int,
    65 as libc::c_int,
    82 as libc::c_int,
    122 as libc::c_int,
    226 as libc::c_int,
    530 as libc::c_int,
    1522 as libc::c_int,
    5042 as libc::c_int,
];
static mut lglldscalegluetab: [libc::c_int; 16] = [
    0 as libc::c_int,
    1 as libc::c_int,
    4 as libc::c_int,
    8 as libc::c_int,
    16 as libc::c_int,
    32 as libc::c_int,
    64 as libc::c_int,
    128 as libc::c_int,
    256 as libc::c_int,
    512 as libc::c_int,
    1024 as libc::c_int,
    2048 as libc::c_int,
    4096 as libc::c_int,
    8192 as libc::c_int,
    16384 as libc::c_int,
    32768 as libc::c_int,
];
unsafe extern "C" fn lglsearchscaleglue(
    mut unscaled: libc::c_int,
    mut tab: *const libc::c_int,
) -> libc::c_int {
    let mut res: libc::c_int = 0;
    res = 0 as libc::c_int;
    while res < (1 as libc::c_int) << 4 as libc::c_int
        && *tab.offset((res + 1 as libc::c_int) as isize) <= unscaled
    {
        res += 1;
        res;
    }
    return res;
}
unsafe extern "C" fn lglunboundedscaleglue(
    mut lgl: *mut LGL,
    mut origlue: libc::c_int,
) -> libc::c_int {
    let mut res: libc::c_int = 0;
    let mut red: libc::c_int = 0;
    if origlue <= (*(*lgl).opts).gluekeep.val {
        res = 0 as libc::c_int;
    } else {
        red = origlue - (*(*lgl).opts).gluekeep.val;
        match (*(*lgl).opts).gluescale.val {
            2 => {
                res = lglsearchscaleglue(red, lglar2scalegluetab.as_ptr());
            }
            3 => {
                res = lglsearchscaleglue(red, lglsqrtscalegluetab.as_ptr());
            }
            4 => {
                res = lglsearchscaleglue(red, lglsqrtldscalegluetab.as_ptr());
            }
            5 => {
                res = lglsearchscaleglue(red, lglldscalegluetab.as_ptr());
            }
            1 | _ => {
                res = lglsearchscaleglue(red, lglar1scalegluetab.as_ptr());
            }
        }
        if res > ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int {
            res = ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int;
        }
    }
    return res;
}
unsafe extern "C" fn lglscaleglue(
    mut lgl: *mut LGL,
    mut origlue: libc::c_int,
) -> libc::c_int {
    let mut res: libc::c_int = lglunboundedscaleglue(lgl, origlue);
    if (*(*lgl).opts).maxscaledglue.val <= res {
        res = ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int;
    }
    return res;
}
unsafe extern "C" fn lglunscaleglue(
    mut lgl: *mut LGL,
    mut scaledglue: libc::c_int,
) -> libc::c_int {
    let mut res: libc::c_int = 0 as libc::c_int;
    if scaledglue == 0 {
        res = 0 as libc::c_int;
    } else {
        match (*(*lgl).opts).gluescale.val {
            2 => {
                res = lglar2scalegluetab[scaledglue as usize];
            }
            3 => {
                res = lglsqrtldscalegluetab[scaledglue as usize];
            }
            4 => {
                res = lglsqrtldscalegluetab[scaledglue as usize];
            }
            5 => {
                res = lglldscalegluetab[scaledglue as usize];
            }
            1 | _ => {
                res = lglar1scalegluetab[scaledglue as usize];
            }
        }
        res += (*(*lgl).opts).gluekeep.val;
    }
    return res;
}
unsafe extern "C" fn lglcheckgluereduced(
    mut lgl: *mut LGL,
    mut lidx: libc::c_int,
    mut gluelim: libc::c_int,
    mut sizelim: libc::c_int,
    mut newunscaledglueptr: *mut libc::c_int,
) -> libc::c_int {
    let mut oldscaledglue: libc::c_int = 0;
    let mut newunscaledglue: libc::c_int = 0;
    let mut newscaledglue: libc::c_int = 0;
    let mut lit: libc::c_int = 0;
    let mut pos: libc::c_int = 0;
    let mut size: libc::c_int = 0;
    let mut c: *const libc::c_int = 0 as *const libc::c_int;
    let mut lir: *mut Stk = 0 as *mut Stk;
    oldscaledglue = lidx & ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int;
    if oldscaledglue == 0 {
        return 0 as libc::c_int;
    }
    if oldscaledglue >= ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int {
        return 0 as libc::c_int;
    }
    lglincglag(lgl);
    lir = ((*lgl).red).offset(oldscaledglue as isize);
    pos = lidx >> 4 as libc::c_int;
    c = ((*lir).start).offset(pos as isize);
    if c > (*lir).top as *const libc::c_int {
        return 0 as libc::c_int;
    }
    if *c.offset(0 as libc::c_int as isize) >= 2147483647 as libc::c_int {
        return 0 as libc::c_int;
    }
    newunscaledglue = 0 as libc::c_int;
    size = newunscaledglue;
    loop {
        lit = *c.offset(size as isize);
        if !(lit != 0) {
            break;
        }
        size += 1;
        if size > sizelim {
            return 0 as libc::c_int;
        }
        if lglaged(lgl, lit) != 0 {
            continue;
        }
        newunscaledglue += 1;
        if newunscaledglue > gluelim {
            return 0 as libc::c_int;
        }
    }
    newscaledglue = lglscaleglue(lgl, newunscaledglue);
    if oldscaledglue <= newscaledglue {
        return 0 as libc::c_int;
    }
    if !newunscaledglueptr.is_null() {
        *newunscaledglueptr = newunscaledglue;
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn lglcheckpromotion(mut lgl: *mut LGL, mut lidx: libc::c_int) {
    let gluelim: libc::c_int = (*(*lgl).opts).promotegluelim.val;
    let mut glue: libc::c_int = 0;
    if (*(*lgl).opts).promote.val == 0 {
        return;
    }
    glue = lidx & ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int;
    if glue == 0 {
        return;
    }
    if glue >= ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int {
        return;
    }
    if lglcheckgluereduced(
        lgl,
        lidx,
        gluelim,
        2147483647 as libc::c_int,
        0 as *mut libc::c_int,
    ) == 0
    {
        return;
    }
    lglpushstk(lgl, &mut (*lgl).promote, lidx);
    (*(*lgl).stats).promote.tried += 1;
    (*(*lgl).stats).promote.tried;
}
unsafe extern "C" fn lglbumplidx(mut lgl: *mut LGL, mut lidx: libc::c_int) {
    let mut glue: libc::c_int = lidx
        & ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int;
    let mut c: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut ap: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut act: libc::c_int = 0;
    let mut pos: libc::c_int = 0;
    let retirenb: libc::c_int = (*(*lgl).opts).retirenb.val;
    let retireint: libc::c_int = (*(*lgl).opts).retireint.val;
    let mut lir: *mut Stk = ((*lgl).red).offset(glue as isize);
    if (*lgl).simp as libc::c_int != 0 && (*(*lgl).opts).bumpsimp.val == 0 {
        return;
    }
    if glue >= ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int {
        return;
    }
    pos = lidx >> 4 as libc::c_int;
    c = ((*lir).start).offset(pos as isize);
    ap = c.offset(-(1 as libc::c_int as isize));
    act = *ap;
    if act < 2147483647 as libc::c_int - 1 as libc::c_int {
        act += 1 as libc::c_int;
        if retirenb != 0
            && act < (2147483647 as libc::c_int >> RMSHFT as libc::c_int) + retireint
        {
            act = (2147483647 as libc::c_int >> RMSHFT as libc::c_int) + retireint;
        }
        *ap = act;
    }
    (*(*lgl).stats).lir[glue as usize].resolved += 1;
    (*(*lgl).stats).lir[glue as usize].resolved;
    if act >= 2147483647 as libc::c_int - 1 as libc::c_int {
        lglrescoreclauses(lgl);
    }
}
unsafe extern "C" fn lglbumpnupdatelidx(mut lgl: *mut LGL, mut lidx: libc::c_int) {
    lglbumplidx(lgl, lidx);
    lglcheckpromotion(lgl, lidx);
}
unsafe extern "C" fn lglincjwh(mut lgl: *mut LGL, mut lit: libc::c_int, mut inc: Flt) {
    let mut ulit: libc::c_int = lglulit(lit);
    let mut old: Flt = *((*lgl).jwh).offset(ulit as isize);
    let mut new: Flt = lgladdflt(old, inc);
    *((*lgl).jwh).offset(ulit as isize) = new;
}
unsafe extern "C" fn lglmtaux(mut lgl: *mut LGL, mut red: libc::c_int) {
    if (*lgl).mt != 0 {
        return;
    }
    (*lgl).mt = 1 as libc::c_int;
    lgldrupligaddclsarg(lgl, red, 0 as libc::c_int);
}
unsafe extern "C" fn lglmt(mut lgl: *mut LGL) {
    lglmtaux(lgl, REDCS as libc::c_int);
}
unsafe extern "C" fn lgladdcls(
    mut lgl: *mut LGL,
    mut red: libc::c_int,
    mut origlue: libc::c_int,
    mut force: libc::c_int,
) -> libc::c_int {
    let mut size: libc::c_int = 0;
    let mut lit: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut other2: libc::c_int = 0;
    let mut p: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut lidx: libc::c_int = 0;
    let mut unit: libc::c_int = 0;
    let mut blit: libc::c_int = 0;
    let mut maxbytesptr: *mut int64_t = 0 as *mut int64_t;
    let mut bytes: int64_t = 0;
    let mut scaledglue: libc::c_int = 0;
    let mut prevglue: libc::c_int = 0;
    let mut inc: Flt = 0;
    let mut val: Val = 0;
    let mut w: *mut Stk = 0 as *mut Stk;
    (*(*lgl).stats).prgss += 1;
    (*(*lgl).stats).prgss;
    if (*lgl).eliminating != 0 {
        size = lglcntstk(&mut (*lgl).clause) as libc::c_int;
        (*(*lgl).stats).steps += size as int64_t;
        (*(*lgl).stats).elm.steps += size as int64_t;
    }
    if red == 0 {
        (*(*lgl).stats).irrprgss += 1;
        (*(*lgl).stats).irrprgss;
    }
    if force != 0 {
        lglchksimpcls(lgl);
    }
    size = (lglcntstk(&mut (*lgl).clause)).wrapping_sub(1 as libc::c_int as size_t)
        as libc::c_int;
    if red == 0 {
        lglincirr(lgl, size);
    } else if size == 2 as libc::c_int {
        (*(*lgl).stats).red.bin += 1;
        (*(*lgl).stats).red.bin;
    } else if size == 3 as libc::c_int {
        (*(*lgl).stats).red.trn += 1;
        (*(*lgl).stats).red.trn;
    }
    if size == 0 {
        lglmtaux(lgl, red);
        return 0 as libc::c_int;
    }
    lit = *((*lgl).clause.start).offset(0 as libc::c_int as isize);
    if size == 1 as libc::c_int {
        if lglval(lgl, lit) == 0 {
            lglunit(lgl, lit);
        }
        return 0 as libc::c_int;
    }
    inc = lglflt(-size, 1 as libc::c_int as Mnt);
    other = *((*lgl).clause.start).offset(1 as libc::c_int as isize);
    if size == 2 as libc::c_int {
        lglwchbin(lgl, lit, other, red);
        lglwchbin(lgl, other, lit, red);
        if force != 0 && (lglval(lgl, lit) as libc::c_int) < 0 as libc::c_int {
            lglf2rce(lgl, other, lit, red);
        }
        if force != 0 && (lglval(lgl, other) as libc::c_int) < 0 as libc::c_int {
            lglf2rce(lgl, lit, other, red);
        }
        if red == 0 && (*lgl).dense as libc::c_int != 0 {
            lglincocc(lgl, lit);
            lglincocc(lgl, other);
        }
        if red == 0 {
            lglincjwh(lgl, lit, inc);
            lglincjwh(lgl, other, inc);
        }
        return 0 as libc::c_int;
    }
    lglordercls(lgl);
    lit = *((*lgl).clause.start).offset(0 as libc::c_int as isize);
    other = *((*lgl).clause.start).offset(1 as libc::c_int as isize);
    if size == 3 as libc::c_int {
        other2 = *((*lgl).clause.start).offset(2 as libc::c_int as isize);
        lglwchtrn(lgl, lit, other, other2, red);
        lglwchtrn(lgl, other, lit, other2, red);
        lglwchtrn(lgl, other2, lit, other, red);
        if force != 0 && (lglval(lgl, lit) as libc::c_int) < 0 as libc::c_int
            && (lglval(lgl, other) as libc::c_int) < 0 as libc::c_int
        {
            lglf3rce(lgl, other2, lit, other, red);
        }
        if force != 0 && (lglval(lgl, lit) as libc::c_int) < 0 as libc::c_int
            && (lglval(lgl, other2) as libc::c_int) < 0 as libc::c_int
        {
            lglf3rce(lgl, other, lit, other2, red);
        }
        if force != 0 && (lglval(lgl, other) as libc::c_int) < 0 as libc::c_int
            && (lglval(lgl, other2) as libc::c_int) < 0 as libc::c_int
        {
            lglf3rce(lgl, lit, other, other2, red);
        }
        if red == 0 && (*lgl).dense as libc::c_int != 0 {
            lglincocc(lgl, lit);
            lglincocc(lgl, other);
            lglincocc(lgl, other2);
        }
        if red == 0 {
            lglincjwh(lgl, lit, inc);
            lglincjwh(lgl, other, inc);
            lglincjwh(lgl, other2, inc);
        }
        return 0 as libc::c_int;
    }
    if red != 0 {
        scaledglue = lglscaleglue(lgl, origlue);
        if scaledglue == ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int
            && (*(*lgl).opts).keepmaxglue.val != 0
            && (*(*lgl).stats).clauses.maxglue.count
                % (*(*lgl).opts).keepmaxglueint.val as int64_t == 0
        {
            (*(*lgl).stats).clauses.maxglue.count += 1;
            (*(*lgl).stats).clauses.maxglue.count;
            (*(*lgl).stats).clauses.maxglue.kept += 1;
            (*(*lgl).stats).clauses.maxglue.kept;
            scaledglue = ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int
                - 1 as libc::c_int;
        }
        (*(*lgl).stats).clauses.scglue += scaledglue as int64_t;
        if scaledglue == ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int {
            (*(*lgl).stats).clauses.maxglue.count += 1;
            (*(*lgl).stats).clauses.maxglue.count;
        } else {
            (*(*lgl).stats).clauses.nonmaxglue += 1;
            (*(*lgl).stats).clauses.nonmaxglue;
        }
        w = ((*lgl).red).offset(scaledglue as isize);
        lidx = (lglcntstk(w)).wrapping_add(1 as libc::c_int as size_t) as libc::c_int;
        if lidx
            > ((1 as libc::c_int) << 31 as libc::c_int - 4 as libc::c_int)
                - 2 as libc::c_int
        {
            prevglue = scaledglue;
            if lidx
                > ((1 as libc::c_int) << 31 as libc::c_int - 4 as libc::c_int)
                    - 2 as libc::c_int
            {
                scaledglue = prevglue;
                while (scaledglue + 1 as libc::c_int)
                    < ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int
                    && lidx
                        > ((1 as libc::c_int) << 31 as libc::c_int - 4 as libc::c_int)
                            - 2 as libc::c_int
                {
                    scaledglue += 1;
                    w = ((*lgl).red).offset(scaledglue as isize);
                    lidx = (lglcntstk(w)).wrapping_add(1 as libc::c_int as size_t)
                        as libc::c_int;
                }
            }
            if lidx
                > ((1 as libc::c_int) << 31 as libc::c_int - 4 as libc::c_int)
                    - 2 as libc::c_int
            {
                scaledglue = prevglue;
                while scaledglue > 0 as libc::c_int
                    && lidx
                        > ((1 as libc::c_int) << 31 as libc::c_int - 4 as libc::c_int)
                            - 2 as libc::c_int
                {
                    scaledglue -= 1;
                    w = ((*lgl).red).offset(scaledglue as isize);
                    lidx = (lglcntstk(w)).wrapping_add(1 as libc::c_int as size_t)
                        as libc::c_int;
                }
            }
            if lidx
                > ((1 as libc::c_int) << 31 as libc::c_int - 4 as libc::c_int)
                    - 2 as libc::c_int
                && scaledglue
                    < ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int
            {
                scaledglue = ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int;
                w = ((*lgl).red).offset(scaledglue as isize);
                lidx = (lglcntstk(w)).wrapping_add(1 as libc::c_int as size_t)
                    as libc::c_int;
            }
            if lidx
                > ((1 as libc::c_int) << 31 as libc::c_int - 4 as libc::c_int)
                    - 2 as libc::c_int
                && scaledglue
                    == ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int
            {
                lglbacktrack(lgl, 0 as libc::c_int);
                lidx = lglcntstk(w) as libc::c_int;
            }
            if lidx
                > ((1 as libc::c_int) << 31 as libc::c_int - 4 as libc::c_int)
                    - 2 as libc::c_int
            {
                lgldie(
                    lgl,
                    b"number of redundant large clause literals exhausted\0" as *const u8
                        as *const libc::c_char,
                );
            }
        }
        maxbytesptr = &mut (*((*(*lgl).stats).lir)
            .as_mut_ptr()
            .offset(scaledglue as isize))
            .maxbytes;
        lglpushstk(lgl, w, 2147483647 as libc::c_int >> RMSHFT as libc::c_int);
        lidx <<= 4 as libc::c_int;
        lidx |= scaledglue;
        if scaledglue < ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int {
            (*(*lgl).stats).lir[scaledglue as usize].clauses += 1;
            (*(*lgl).stats).lir[scaledglue as usize].clauses;
        }
        (*(*lgl).stats).lir[scaledglue as usize].added += 1;
        (*(*lgl).stats).lir[scaledglue as usize].added;
    } else {
        w = &mut (*lgl).irr;
        maxbytesptr = &mut (*(*lgl).stats).irr.maxbytes;
        lidx = lglcntstk(w) as libc::c_int;
        scaledglue = 0 as libc::c_int;
        if lidx <= 0 as libc::c_int && lglmtstk(w) == 0 {
            lgldie(
                lgl,
                b"number of irredundant large clause literals exhausted\0" as *const u8
                    as *const libc::c_char,
            );
        }
    }
    p = (*lgl).clause.start;
    loop {
        other2 = *p;
        if !(other2 != 0) {
            break;
        }
        lglpushstk(lgl, w, other2);
        lglincjwh(lgl, other2, inc);
        p = p.offset(1);
        p;
    }
    lglpushstk(lgl, w, 0 as libc::c_int);
    bytes = (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)
        .wrapping_mul(lglcntstk(w) as int64_t as libc::c_ulong) as int64_t;
    if bytes > *maxbytesptr {
        *maxbytesptr = bytes;
    }
    unit = 0 as libc::c_int;
    p = (*lgl).clause.start;
    loop {
        other2 = *p;
        if !(other2 != 0) {
            break;
        }
        val = lglval(lgl, other2);
        if !((val as libc::c_int) < 0 as libc::c_int) {
            if unit != 0 {
                unit = 2147483647 as libc::c_int;
            } else {
                unit = other2;
            }
        }
        p = p.offset(1);
        p;
    }
    if force != 0 && unit != 0 && unit != 2147483647 as libc::c_int {
        lglflrce(lgl, unit, red, lidx);
    }
    if red == 0
        || red != 0
            && scaledglue < ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int
    {
        lglwchlrg(lgl, lit, other, red, lidx);
        lglwchlrg(lgl, other, lit, red, lidx);
    }
    if red != 0
        && scaledglue != ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int
    {
        (*(*lgl).stats).red.lrg += 1;
        (*(*lgl).stats).red.lrg;
    }
    if red == 0 && (*lgl).dense as libc::c_int != 0 {
        if lidx
            > ((1 as libc::c_int) << 31 as libc::c_int - RMSHFT as libc::c_int)
                - 2 as libc::c_int
        {
            lgldie(
                lgl,
                b"number of irredundant large clause literals exhausted\0" as *const u8
                    as *const libc::c_char,
            );
        }
        blit = lidx << RMSHFT as libc::c_int | OCCS as libc::c_int;
        p = (*lgl).clause.start;
        loop {
            other2 = *p;
            if !(other2 != 0) {
                break;
            }
            lglincocc(lgl, other2);
            lglpushwch(lgl, lglhts(lgl, other2), blit);
            p = p.offset(1);
            p;
        }
    }
    lglchkirrstats(lgl);
    return lidx;
}
unsafe extern "C" fn lgliadd(mut lgl: *mut LGL, mut ilit: libc::c_int) {
    let mut size: libc::c_int = 0;
    lglpushstk(lgl, &mut (*lgl).clause, ilit);
    if !(ilit != 0) {
        if lglesimpcls(lgl) == 0 {
            lgladdcls(lgl, 0 as libc::c_int, 0 as libc::c_int, 1 as libc::c_int);
            (*(*lgl).stats).irr.clauses.add += 1;
            (*(*lgl).stats).irr.clauses.add;
            size = (lglcntstk(&mut (*lgl).clause))
                .wrapping_sub(1 as libc::c_int as size_t) as libc::c_int;
            (*(*lgl).stats).irr.lits.add += size as int64_t;
        }
        lglclnstk(&mut (*lgl).clause);
        lglclnstk(&mut (*lgl).eclause);
    }
}
unsafe extern "C" fn lgleunassignall(mut lgl: *mut LGL) {
    let mut eidx: libc::c_int = 0;
    eidx = 1 as libc::c_int;
    while eidx <= (*lgl).maxext {
        let ref mut fresh31 = *lglelit2ext(lgl, eidx);
        (*fresh31).set_val(0 as libc::c_int);
        eidx += 1;
        eidx;
    }
}
unsafe extern "C" fn lglchkeassumeclean(mut lgl: *mut LGL) {}
unsafe extern "C" fn lglchkassumeclean(mut lgl: *mut LGL) {}
unsafe extern "C" fn lglreset(mut lgl: *mut LGL) {
    let mut elit: libc::c_int = 0;
    let mut ilit: libc::c_int = 0;
    let mut erepr: libc::c_int = 0;
    let mut ext: *mut Ext = 0 as *mut Ext;
    let mut rext: *mut Ext = 0 as *mut Ext;
    let mut bit: libc::c_uint = 0;
    let mut av: *mut AVar = 0 as *mut AVar;
    if (*lgl).state as libc::c_uint == RESET as libc::c_int as libc::c_uint {
        return;
    }
    if (*lgl).state as libc::c_uint <= USED as libc::c_int as libc::c_uint {
        return;
    }
    if (*lgl).level > 0 as libc::c_int {
        lglbacktrack(lgl, 0 as libc::c_int);
    }
    if lglmtstk(&mut (*lgl).eassume) == 0 {
        while lglmtstk(&mut (*lgl).eassume) == 0 {
            elit = lglpopstk(&mut (*lgl).eassume);
            ext = lglelit2ext(lgl, elit);
            (*ext).set_assumed(0 as libc::c_int as libc::c_uint);
            if (*ext).failed() != 0 {
                (*ext).set_failed(0 as libc::c_int as libc::c_uint);
                erepr = lglerepr(lgl, elit);
                if erepr != elit {
                    rext = lglelit2ext(lgl, erepr);
                    (*rext).set_failed(0 as libc::c_int as libc::c_uint);
                }
            }
        }
    }
    lglchkeassumeclean(lgl);
    if lglmtstk(&mut (*lgl).assume) == 0 {
        while lglmtstk(&mut (*lgl).assume) == 0 {
            ilit = lglpopstk(&mut (*lgl).assume);
            av = lglavar(lgl, ilit);
            bit = (1 as libc::c_uint) << (ilit < 0 as libc::c_int) as libc::c_int;
            (*av).set_assumed((*av).assumed() & !bit);
            (*av).set_failed((*av).failed() & !bit);
        }
    }
    if (*lgl).failed != 0 {
        (*lgl).failed = 0 as libc::c_int;
    }
    if (*lgl).assumed != 0 {
        (*lgl).assumed = 0 as libc::c_int;
    }
    lglchkassumeclean(lgl);
    lgleunassignall(lgl);
    if !((*lgl).cbs).is_null() && (*(*lgl).cbs).term.done != 0 {
        (*(*lgl).cbs).term.done = 0 as libc::c_int;
    }
    (*lgl).state = RESET;
}
unsafe extern "C" fn lgluse(mut lgl: *mut LGL) {
    if (*lgl).state as libc::c_uint >= USED as libc::c_int as libc::c_uint {
        return;
    }
    (*lgl).state = USED;
}
unsafe extern "C" fn lglupdatealiased(mut lgl: *mut LGL, mut elit: libc::c_int) {
    let mut ext: *mut Ext = 0 as *mut Ext;
    let mut erepr: libc::c_int = 0;
    if abs(elit) > (*lgl).maxext {
        return;
    }
    erepr = lglerepr(lgl, elit);
    if erepr == elit {
        return;
    }
    ext = lglelit2ext(lgl, erepr);
    if (*ext).aliased() != 0 {
        return;
    }
    (*ext).set_aliased(1 as libc::c_int as libc::c_uint);
}
unsafe extern "C" fn lgleadd(mut lgl: *mut LGL, mut elit: libc::c_int) {
    let mut ilit: libc::c_int = 0;
    lglreset(lgl);
    if elit != 0 {
        lglupdatealiased(lgl, elit);
        ilit = lglimport(lgl, elit);
    } else {
        ilit = 0 as libc::c_int;
    }
    lglpushstk(lgl, &mut (*lgl).eclause, elit);
    lgliadd(lgl, ilit);
}
#[no_mangle]
pub unsafe extern "C" fn lgladd(mut lgl: *mut LGL, mut elit: libc::c_int) {
    let mut eidx: libc::c_int = abs(elit);
    let mut ext: *mut Ext = 0 as *mut Ext;
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 7], &[libc::c_char; 7]>(b"lgladd\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).forked == 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 7], &[libc::c_char; 7]>(b"lgladd\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"forked manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if !((*lgl).apitrace).is_null() {
        lgltrapi(lgl, b"add %d\0" as *const u8 as *const libc::c_char, elit);
    }
    if (0 as libc::c_int) < eidx && eidx <= (*lgl).maxext {
        ext = lglelit2ext(lgl, elit);
        if (*ext).melted() == 0 {} else {
            fprintf(
                stderr,
                b"*** API usage error of '%s' in '%s'\0" as *const u8
                    as *const libc::c_char,
                b"lglib.c\0" as *const u8 as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 7], &[libc::c_char; 7]>(b"lgladd\0"))
                    .as_ptr(),
            );
            if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
                fprintf(
                    stderr,
                    b" (tid %d)\0" as *const u8 as *const libc::c_char,
                    (*lgl).tid,
                );
            }
            fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
            fprintf(
                stderr,
                b"adding melted literal %d\0" as *const u8 as *const libc::c_char,
                elit,
            );
            fputc('\n' as i32, stderr);
            fflush(stderr);
            lglabort(lgl);
            exit(1 as libc::c_int);
        }
    }
    (*(*lgl).stats).calls.add += 1;
    (*(*lgl).stats).calls.add;
    lgleadd(lgl, elit);
    lgluse(lgl);
    if !((*lgl).clone).is_null() {
        lgladd((*lgl).clone, elit);
    }
}
unsafe extern "C" fn lglisetphase(
    mut lgl: *mut LGL,
    mut lit: libc::c_int,
    mut phase: libc::c_int,
) {
    let mut av: *mut AVar = 0 as *mut AVar;
    if lit < 0 as libc::c_int {
        lit = -lit;
        phase = -phase;
    }
    av = lglavar(lgl, lit);
    (*av).set_fase(phase);
}
unsafe extern "C" fn lglesetphase(
    mut lgl: *mut LGL,
    mut elit: libc::c_int,
    mut phase: libc::c_int,
) {
    let mut ilit: libc::c_int = lglimport(lgl, elit);
    if abs(ilit) >= 2 as libc::c_int {
        lglisetphase(lgl, ilit, phase);
    }
}
#[no_mangle]
pub unsafe extern "C" fn lglsetphase(mut lgl: *mut LGL, mut elit: libc::c_int) {
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 12], &[libc::c_char; 12]>(b"lglsetphase\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).forked == 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 12], &[libc::c_char; 12]>(b"lglsetphase\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"forked manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if !((*lgl).apitrace).is_null() {
        lgltrapi(lgl, b"setphase %d\0" as *const u8 as *const libc::c_char, elit);
    }
    if elit != 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 12], &[libc::c_char; 12]>(b"lglsetphase\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(
            stderr,
            b"invalid literal argument\0" as *const u8 as *const libc::c_char,
        );
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if elit < 0 as libc::c_int {
        lglesetphase(lgl, -elit, -(1 as libc::c_int));
    } else {
        lglesetphase(lgl, elit, 1 as libc::c_int);
    }
    if !((*lgl).clone).is_null() {
        lglsetphase((*lgl).clone, elit);
    }
}
#[no_mangle]
pub unsafe extern "C" fn lglresetphase(mut lgl: *mut LGL, mut elit: libc::c_int) {
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<
                &[u8; 14],
                &[libc::c_char; 14],
            >(b"lglresetphase\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).forked == 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<
                &[u8; 14],
                &[libc::c_char; 14],
            >(b"lglresetphase\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"forked manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if !((*lgl).apitrace).is_null() {
        lgltrapi(lgl, b"resetphase %d\0" as *const u8 as *const libc::c_char, elit);
    }
    if elit != 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<
                &[u8; 14],
                &[libc::c_char; 14],
            >(b"lglresetphase\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(
            stderr,
            b"invalid literal argument\0" as *const u8 as *const libc::c_char,
        );
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    lglesetphase(lgl, elit, 0 as libc::c_int);
    if !((*lgl).clone).is_null() {
        lglresetphase((*lgl).clone, elit);
    }
}
unsafe extern "C" fn lglisetimportant(mut lgl: *mut LGL, mut lit: libc::c_int) {
    let mut qv: *mut QVar = 0 as *mut QVar;
    qv = lglqvar(lgl, lit);
    (*qv).set_important(1 as libc::c_int as libc::c_uint);
}
unsafe extern "C" fn lglesetimportant(mut lgl: *mut LGL, mut elit: libc::c_int) {
    let mut ilit: libc::c_int = lglimport(lgl, elit);
    if abs(ilit) >= 2 as libc::c_int {
        lglisetimportant(lgl, ilit);
    }
}
#[no_mangle]
pub unsafe extern "C" fn lglsetimportant(mut lgl: *mut LGL, mut elit: libc::c_int) {
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<
                &[u8; 16],
                &[libc::c_char; 16],
            >(b"lglsetimportant\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).forked == 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<
                &[u8; 16],
                &[libc::c_char; 16],
            >(b"lglsetimportant\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"forked manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if !((*lgl).apitrace).is_null() {
        lgltrapi(lgl, b"setimportant %d\0" as *const u8 as *const libc::c_char, elit);
    }
    if elit != 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<
                &[u8; 16],
                &[libc::c_char; 16],
            >(b"lglsetimportant\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(
            stderr,
            b"invalid literal argument\0" as *const u8 as *const libc::c_char,
        );
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if elit < 0 as libc::c_int {
        lglesetphase(lgl, -elit, -(1 as libc::c_int));
    } else {
        lglesetimportant(lgl, elit);
    }
    if !((*lgl).clone).is_null() {
        lglsetimportant((*lgl).clone, elit);
    }
}
unsafe extern "C" fn lgleassume(mut lgl: *mut LGL, mut elit: libc::c_int) {
    let mut ilit: libc::c_int = 0;
    let mut val: libc::c_int = 0;
    let mut bit: libc::c_uint = 0;
    let mut av: *mut AVar = 0 as *mut AVar;
    let mut ext: *mut Ext = 0 as *mut Ext;
    lglreset(lgl);
    ilit = lglimport(lgl, elit);
    bit = (1 as libc::c_uint) << (elit < 0 as libc::c_int) as libc::c_int;
    ext = lglelit2ext(lgl, elit);
    if (*ext).assumed() & bit == 0 {
        (*ext).set_assumed((*ext).assumed() | bit);
        lglpushstk(lgl, &mut (*lgl).eassume, elit);
    }
    val = lglcval(lgl, ilit);
    if val == 0 {
        av = lglavar(lgl, ilit);
        bit = (1 as libc::c_uint) << (ilit < 0 as libc::c_int) as libc::c_int;
        if !((*av).assumed() & bit != 0) {
            (*av).set_assumed((*av).assumed() | bit);
            (*av).assumed() & (bit ^ 3 as libc::c_int as libc::c_uint) != 0;
            lglpushstk(lgl, &mut (*lgl).assume, ilit);
        }
    } else if !(val > 0 as libc::c_int) {
        if ilit != -(1 as libc::c_int) {
            av = lglavar(lgl, ilit);
            bit = (1 as libc::c_uint) << (ilit < 0 as libc::c_int) as libc::c_int;
            if (*av).assumed() & bit == 0 {
                (*av).set_assumed((*av).assumed() | bit);
                lglpushstk(lgl, &mut (*lgl).assume, ilit);
            }
        }
        if (*lgl).failed == 0 {
            (*lgl).failed = ilit;
        }
    }
}
unsafe extern "C" fn lglecassume(mut lgl: *mut LGL, mut elit: libc::c_int) {}
#[no_mangle]
pub unsafe extern "C" fn lglassume(mut lgl: *mut LGL, mut elit: libc::c_int) {
    let mut eidx: libc::c_int = abs(elit);
    let mut ext: *mut Ext = 0 as *mut Ext;
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 10], &[libc::c_char; 10]>(b"lglassume\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).forked == 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 10], &[libc::c_char; 10]>(b"lglassume\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"forked manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if !((*lgl).apitrace).is_null() {
        lgltrapi(lgl, b"assume %d\0" as *const u8 as *const libc::c_char, elit);
    }
    (*(*lgl).stats).calls.assume += 1;
    (*(*lgl).stats).calls.assume;
    if elit != 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 10], &[libc::c_char; 10]>(b"lglassume\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(
            stderr,
            b"can not assume invalid literal 0\0" as *const u8 as *const libc::c_char,
        );
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (0 as libc::c_int) < eidx && eidx <= (*lgl).maxext {
        ext = lglelit2ext(lgl, elit);
        if (*ext).melted() == 0 {} else {
            fprintf(
                stderr,
                b"*** API usage error of '%s' in '%s'\0" as *const u8
                    as *const libc::c_char,
                b"lglib.c\0" as *const u8 as *const libc::c_char,
                (*::core::mem::transmute::<
                    &[u8; 10],
                    &[libc::c_char; 10],
                >(b"lglassume\0"))
                    .as_ptr(),
            );
            if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
                fprintf(
                    stderr,
                    b" (tid %d)\0" as *const u8 as *const libc::c_char,
                    (*lgl).tid,
                );
            }
            fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
            fprintf(
                stderr,
                b"assuming melted literal %d\0" as *const u8 as *const libc::c_char,
                elit,
            );
            fputc('\n' as i32, stderr);
            fflush(stderr);
            lglabort(lgl);
            exit(1 as libc::c_int);
        }
    }
    lgleassume(lgl, elit);
    lgluse(lgl);
    lglmelter(lgl);
    if !((*lgl).clone).is_null() {
        lglassume((*lgl).clone, elit);
    }
}
#[no_mangle]
pub unsafe extern "C" fn lglcassume(mut lgl: *mut LGL, mut elit: libc::c_int) {
    let mut eidx: libc::c_int = abs(elit);
    let mut ext: *mut Ext = 0 as *mut Ext;
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 11], &[libc::c_char; 11]>(b"lglcassume\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).forked == 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 11], &[libc::c_char; 11]>(b"lglcassume\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"forked manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if !((*lgl).apitrace).is_null() {
        lgltrapi(lgl, b"cassume %d\0" as *const u8 as *const libc::c_char, elit);
    }
    (*(*lgl).stats).calls.cassume += 1;
    (*(*lgl).stats).calls.cassume;
    if (0 as libc::c_int) < eidx && eidx <= (*lgl).maxext {
        ext = lglelit2ext(lgl, elit);
        if (*ext).melted() == 0 {} else {
            fprintf(
                stderr,
                b"*** API usage error of '%s' in '%s'\0" as *const u8
                    as *const libc::c_char,
                b"lglib.c\0" as *const u8 as *const libc::c_char,
                (*::core::mem::transmute::<
                    &[u8; 11],
                    &[libc::c_char; 11],
                >(b"lglcassume\0"))
                    .as_ptr(),
            );
            if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
                fprintf(
                    stderr,
                    b" (tid %d)\0" as *const u8 as *const libc::c_char,
                    (*lgl).tid,
                );
            }
            fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
            fprintf(
                stderr,
                b"assuming melted literal %d\0" as *const u8 as *const libc::c_char,
                elit,
            );
            fputc('\n' as i32, stderr);
            fflush(stderr);
            lglabort(lgl);
            exit(1 as libc::c_int);
        }
    }
    lglecassume(lgl, elit);
    lgluse(lgl);
    if !((*lgl).clone).is_null() {
        lglcassume((*lgl).clone, elit);
    }
}
#[no_mangle]
pub unsafe extern "C" fn lglfixate(mut lgl: *mut LGL) {
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut eassume: Stk = Stk {
        start: 0 as *mut libc::c_int,
        top: 0 as *mut libc::c_int,
        end: 0 as *mut libc::c_int,
    };
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 10], &[libc::c_char; 10]>(b"lglfixate\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).forked == 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 10], &[libc::c_char; 10]>(b"lglfixate\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"forked manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if !((*lgl).apitrace).is_null() {
        lgltrapi(lgl, b"fixate\0" as *const u8 as *const libc::c_char);
    }
    if (*lgl).mt != 0 {
        return;
    }
    memset(
        &mut eassume as *mut Stk as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<Stk>() as libc::c_ulong,
    );
    p = (*lgl).eassume.start;
    while p < (*lgl).eassume.top as *const libc::c_int {
        lglpushstk(lgl, &mut eassume, *p);
        p = p.offset(1);
        p;
    }
    p = eassume.start;
    while p < eassume.top as *const libc::c_int {
        lgleadd(lgl, *p);
        lgleadd(lgl, 0 as libc::c_int);
        p = p.offset(1);
        p;
    }
    lglrelstk(lgl, &mut eassume);
    lgluse(lgl);
    if !((*lgl).clone).is_null() {
        lglfixate((*lgl).clone);
    }
}
unsafe extern "C" fn lglbonflict(
    mut lgl: *mut LGL,
    mut lit: libc::c_int,
    mut blit: libc::c_int,
) {
    (*lgl).conf.lit = lit;
    (*lgl).conf.rsn[0 as libc::c_int as usize] = blit;
}
unsafe extern "C" fn lgltonflict(
    mut lgl: *mut LGL,
    mut lit: libc::c_int,
    mut blit: libc::c_int,
    mut other2: libc::c_int,
) {
    (*lgl).conf.lit = lit;
    (*lgl).conf.rsn[0 as libc::c_int as usize] = blit;
    (*lgl).conf.rsn[1 as libc::c_int as usize] = other2;
}
unsafe extern "C" fn lglonflict(
    mut lgl: *mut LGL,
    mut check: libc::c_int,
    mut lit: libc::c_int,
    mut red: libc::c_int,
    mut lidx: libc::c_int,
) {
    let mut glue: libc::c_int = 0;
    (*lgl).conf.lit = lit;
    (*lgl).conf.rsn[0 as libc::c_int as usize] = red | LRGCS as libc::c_int;
    (*lgl).conf.rsn[1 as libc::c_int as usize] = lidx;
    if red != 0 {
        glue = lidx & ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int;
        (*(*lgl).stats).lir[glue as usize].conflicts += 1;
        (*(*lgl).stats).lir[glue as usize].conflicts;
    }
}
unsafe extern "C" fn lgldeclscnt(
    mut lgl: *mut LGL,
    mut size: libc::c_int,
    mut red: libc::c_int,
    mut glue: libc::c_int,
) {
    if red == 0 {
        lgldecirr(lgl, size);
    } else if size == 2 as libc::c_int {
        (*(*lgl).stats).red.bin -= 1;
        (*(*lgl).stats).red.bin;
    } else if size == 3 as libc::c_int {
        (*(*lgl).stats).red.trn -= 1;
        (*(*lgl).stats).red.trn;
    } else {
        (*(*lgl).stats).red.lrg -= 1;
        (*(*lgl).stats).red.lrg;
        (*(*lgl).stats).lir[glue as usize].clauses -= 1;
        (*(*lgl).stats).lir[glue as usize].clauses;
    };
}
unsafe extern "C" fn lglrminc(
    mut lgl: *mut LGL,
    mut w: *const libc::c_int,
    mut eow: *const libc::c_int,
) {
    let mut inc: libc::c_int = 0;
    inc = eow.offset_from(w) as libc::c_long as libc::c_int;
    inc >>= (*(*lgl).opts).rmincpen.val;
    inc += 1;
    inc;
    if (*lgl).blocking != 0 {
        (*(*lgl).stats).steps += inc as int64_t;
        (*(*lgl).stats).blk.steps += inc as int64_t;
    } else if (*lgl).eliminating != 0 {
        (*(*lgl).stats).steps += inc as int64_t;
        (*(*lgl).stats).elm.steps += inc as int64_t;
    } else if (*lgl).simpleprobing != 0 {
        (*(*lgl).stats).steps += inc as int64_t;
        (*(*lgl).stats).prb.simple.steps += inc as int64_t;
    }
}
unsafe extern "C" fn lglrmtwch(
    mut lgl: *mut LGL,
    mut lit: libc::c_int,
    mut other1: libc::c_int,
    mut other2: libc::c_int,
    mut red: libc::c_int,
) {
    let mut p: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut blit: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut blit1: libc::c_int = 0;
    let mut blit2: libc::c_int = 0;
    let mut w: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut eow: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tag: libc::c_int = 0;
    let mut hts: *mut HTS = 0 as *mut HTS;
    hts = lglhts(lgl, lit);
    w = lglhts2wchs(lgl, hts);
    p = w;
    eow = w.offset((*hts).count as isize);
    lglrminc(lgl, w, eow);
    blit1 = ((other1 as libc::c_uint) << RMSHFT as libc::c_int) as libc::c_int | red
        | TRNCS as libc::c_int;
    blit2 = ((other2 as libc::c_uint) << RMSHFT as libc::c_int) as libc::c_int | red
        | TRNCS as libc::c_int;
    loop {
        let fresh32 = p;
        p = p.offset(1);
        blit = *fresh32;
        tag = blit & MASKCS as libc::c_int;
        if tag == BINCS as libc::c_int || tag == OCCS as libc::c_int {
            continue;
        }
        let fresh33 = p;
        p = p.offset(1);
        other = *fresh33;
        if tag == LRGCS as libc::c_int {
            continue;
        }
        if blit == blit1 && other == other2 {
            break;
        }
        if blit == blit2 && other == other1 {
            break;
        }
    }
    while p < eow {
        *p.offset(-(2 as libc::c_int) as isize) = *p.offset(0 as libc::c_int as isize);
        p = p.offset(1);
        p;
    }
    lglshrinkhts(
        lgl,
        hts,
        (p.offset_from(w) as libc::c_long - 2 as libc::c_int as libc::c_long)
            as libc::c_int,
    );
}
unsafe extern "C" fn lglpopnunmarkstk(mut lgl: *mut LGL, mut stk: *mut Stk) {
    while lglmtstk(stk) == 0 {
        let mut lit: libc::c_int = lglpopstk(stk);
        if lit == 0 {
            continue;
        }
        (*lglavar(lgl, lit)).mark = 0 as libc::c_int;
    }
}
unsafe extern "C" fn lglpopnunlcamarkstk(mut lgl: *mut LGL, mut stk: *mut Stk) {
    while lglmtstk(stk) == 0 {
        let ref mut fresh34 = *lglavar(lgl, lglpopstk(stk));
        (*fresh34).set_lcamark(0 as libc::c_int as libc::c_uint);
    }
}
unsafe extern "C" fn lglcamarked(
    mut lgl: *mut LGL,
    mut lit: libc::c_int,
) -> libc::c_int {
    match (*lglavar(lgl, lit)).lcamark() as libc::c_int {
        1 => {
            return if lit < 0 as libc::c_int {
                -(1 as libc::c_int)
            } else {
                1 as libc::c_int
            };
        }
        2 => {
            return if lit < 0 as libc::c_int {
                -(2 as libc::c_int)
            } else {
                2 as libc::c_int
            };
        }
        4 => {
            return if lit < 0 as libc::c_int {
                1 as libc::c_int
            } else {
                -(1 as libc::c_int)
            };
        }
        8 => {
            return if lit < 0 as libc::c_int {
                2 as libc::c_int
            } else {
                -(2 as libc::c_int)
            };
        }
        _ => return 0 as libc::c_int,
    };
}
unsafe extern "C" fn lglcamark(
    mut lgl: *mut LGL,
    mut lit: libc::c_int,
    mut mark: libc::c_int,
) {
    let mut newmark: libc::c_int = 0;
    let mut av: *mut AVar = 0 as *mut AVar;
    av = lglavar(lgl, lit);
    newmark = mark;
    if lit < 0 as libc::c_int {
        newmark <<= 2 as libc::c_int;
    }
    (*av).set_lcamark(newmark as libc::c_uint);
    lglpushstk(lgl, &mut (*lgl).c2rust_unnamed_0.lcaseen, lit);
}
unsafe extern "C" fn lgbiglca(
    mut lgl: *mut LGL,
    mut a: libc::c_int,
    mut b: libc::c_int,
    mut stepsptr: *mut int64_t,
) -> libc::c_int {
    let mut blit: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut mark: libc::c_int = 0;
    let mut negmark: libc::c_int = 0;
    let mut prevmark: libc::c_int = 0;
    let mut c: libc::c_int = 0;
    let mut res: libc::c_int = 0;
    let mut prev: libc::c_int = 0;
    let mut next: libc::c_int = 0;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut w: *const libc::c_int = 0 as *const libc::c_int;
    let mut eow: *const libc::c_int = 0 as *const libc::c_int;
    let mut steps: int64_t = 0;
    let mut hts: *mut HTS = 0 as *mut HTS;
    lglcamark(lgl, a, 1 as libc::c_int);
    lglcamark(lgl, b, 2 as libc::c_int);
    next = 0 as libc::c_int;
    res = next;
    steps = 0 as libc::c_int as int64_t;
    's_45: while next < lglcntstk(&mut (*lgl).c2rust_unnamed_0.lcaseen) as libc::c_int {
        let fresh35 = next;
        next = next + 1;
        c = lglpeek(&mut (*lgl).c2rust_unnamed_0.lcaseen, fresh35);
        mark = lglcamarked(lgl, c);
        negmark = mark ^ 3 as libc::c_int;
        hts = lglhts(lgl, c);
        if (*hts).count == 0 {
            continue;
        }
        w = lglhts2wchs(lgl, hts);
        eow = w.offset((*hts).count as isize);
        steps += 1;
        steps;
        p = w;
        while p < eow {
            blit = *p;
            tag = blit & MASKCS as libc::c_int;
            if tag == TRNCS as libc::c_int || tag == LRGCS as libc::c_int {
                p = p.offset(1);
                p;
            }
            if !(tag != BINCS as libc::c_int) {
                prev = -(blit >> RMSHFT as libc::c_int);
                if !(lglevel(lgl, prev) == 0) {
                    if !(lglval(lgl, prev) as libc::c_int <= 0 as libc::c_int) {
                        prevmark = lglcamarked(lgl, prev);
                        if !(prevmark < 0 as libc::c_int) {
                            if !(mark == prevmark) {
                                if prevmark == negmark {
                                    res = prev;
                                    break 's_45;
                                } else {
                                    lglcamark(lgl, prev, mark);
                                }
                            }
                        }
                    }
                }
            }
            p = p.offset(1);
            p;
        }
    }
    lglpopnunlcamarkstk(lgl, &mut (*lgl).c2rust_unnamed_0.lcaseen);
    *stepsptr += steps;
    return res;
}
unsafe extern "C" fn lglimplca(
    mut lgl: *mut LGL,
    mut a: libc::c_int,
    mut b: libc::c_int,
    mut stepsptr: *mut int64_t,
) -> libc::c_int {
    let mut r0: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut mark: libc::c_int = 0;
    let mut negmark: libc::c_int = 0;
    let mut prevmark: libc::c_int = 0;
    let mut c: libc::c_int = 0;
    let mut res: libc::c_int = 0;
    let mut prev: libc::c_int = 0;
    let mut next: libc::c_int = 0;
    let mut steps: int64_t = 0;
    lglcamark(lgl, a, 1 as libc::c_int);
    lglcamark(lgl, b, 2 as libc::c_int);
    next = 0 as libc::c_int;
    res = next;
    steps = 0 as libc::c_int as int64_t;
    while next < lglcntstk(&mut (*lgl).c2rust_unnamed_0.lcaseen) as libc::c_int {
        let fresh36 = next;
        next = next + 1;
        c = lglpeek(&mut (*lgl).c2rust_unnamed_0.lcaseen, fresh36);
        mark = lglcamarked(lgl, c);
        negmark = mark ^ 3 as libc::c_int;
        steps += 1;
        steps;
        r0 = *lglrsn(lgl, c);
        tag = r0 & MASKCS as libc::c_int;
        if tag != BINCS as libc::c_int {
            continue;
        }
        prev = -(r0 >> RMSHFT as libc::c_int);
        if lglevel(lgl, prev) == 0 {
            continue;
        }
        if lglval(lgl, prev) as libc::c_int <= 0 as libc::c_int {
            continue;
        }
        prevmark = lglcamarked(lgl, prev);
        if prevmark < 0 as libc::c_int {
            continue;
        }
        if mark == prevmark {
            continue;
        }
        if prevmark == negmark {
            res = prev;
            break;
        } else {
            lglcamark(lgl, prev, mark);
        }
    }
    lglpopnunlcamarkstk(lgl, &mut (*lgl).c2rust_unnamed_0.lcaseen);
    *stepsptr += steps;
    return res;
}
unsafe extern "C" fn lglhbrdom(
    mut lgl: *mut LGL,
    mut a: libc::c_int,
    mut b: libc::c_int,
    mut stepsptr: *mut int64_t,
) -> libc::c_int {
    match (*(*lgl).opts).hbrdom.val {
        2 => return lgbiglca(lgl, a, b, stepsptr),
        1 => return lglimplca(lgl, a, b, stepsptr),
        _ => return lglgetdom(lgl, a),
    };
}
unsafe extern "C" fn lglrmlwch(
    mut lgl: *mut LGL,
    mut lit: libc::c_int,
    mut red: libc::c_int,
    mut lidx: libc::c_int,
) {
    let mut blit: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut p: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut q: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut w: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut eow: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut ored: libc::c_int = 0;
    let mut olidx: libc::c_int = 0;
    let mut hts: *mut HTS = 0 as *mut HTS;
    hts = lglhts(lgl, lit);
    w = lglhts2wchs(lgl, hts);
    p = w;
    eow = w.offset((*hts).count as isize);
    lglrminc(lgl, w, eow);
    loop {
        let fresh37 = p;
        p = p.offset(1);
        blit = *fresh37;
        tag = blit & MASKCS as libc::c_int;
        if tag == BINCS as libc::c_int {
            continue;
        }
        if tag == OCCS as libc::c_int {
            continue;
        }
        let fresh38 = p;
        p = p.offset(1);
        olidx = *fresh38;
        if tag == TRNCS as libc::c_int {
            continue;
        }
        ored = blit & REDCS as libc::c_int;
        if ored != red {
            continue;
        }
        if olidx == lidx {
            break;
        }
    }
    q = p;
    while q < eow {
        *q.offset(-(2 as libc::c_int) as isize) = *q.offset(0 as libc::c_int as isize);
        q = q.offset(1);
        q;
    }
    lglshrinkhts(
        lgl,
        hts,
        (q.offset_from(w) as libc::c_long - 2 as libc::c_int as libc::c_long)
            as libc::c_int,
    );
}
unsafe extern "C" fn lglpropsearch(mut lgl: *mut LGL, mut lit: libc::c_int) {
    let mut q: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut eos: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut blit: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut other2: libc::c_int = 0;
    let mut other3: libc::c_int = 0;
    let mut red: libc::c_int = 0;
    let mut prev: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut val: libc::c_int = 0;
    let mut val2: libc::c_int = 0;
    let mut lidx: libc::c_int = 0;
    let mut c: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut l: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut delta: ptrdiff_t = 0;
    let mut visits: libc::c_int = 0;
    let mut hts: *mut HTS = 0 as *mut HTS;
    hts = lglhts(lgl, -lit);
    if (*hts).offset == 0 {
        return;
    }
    q = lglhts2wchs(lgl, hts);
    eos = q.offset((*hts).count as isize);
    visits = 0 as libc::c_int;
    let mut current_block_75: u64;
    p = q;
    while p < eos as *const libc::c_int {
        visits += 1;
        visits;
        blit = *p;
        let fresh39 = q;
        q = q.offset(1);
        *fresh39 = blit;
        tag = blit & MASKCS as libc::c_int;
        if tag != BINCS as libc::c_int {
            p = p.offset(1);
            let fresh40 = q;
            q = q.offset(1);
            *fresh40 = *p;
        }
        other = blit >> RMSHFT as libc::c_int;
        val = lglval(lgl, other) as libc::c_int;
        if !(val > 0 as libc::c_int) {
            red = blit & REDCS as libc::c_int;
            if tag == BINCS as libc::c_int {
                if val < 0 as libc::c_int {
                    lglbonflict(lgl, -lit, blit);
                    p = p.offset(1);
                    p;
                    break;
                } else {
                    lglf2rce(lgl, other, -lit, red);
                }
            } else if tag == TRNCS as libc::c_int {
                other2 = *p;
                val2 = lglval(lgl, other2) as libc::c_int;
                if !(val2 > 0 as libc::c_int) {
                    if !(val == 0 && val2 == 0) {
                        if val < 0 as libc::c_int && val2 < 0 as libc::c_int {
                            lgltonflict(lgl, -lit, blit, other2);
                            p = p.offset(1);
                            p;
                            break;
                        } else {
                            if val == 0 {
                                let mut TMP: libc::c_int = other;
                                other = other2;
                                other2 = TMP;
                            }
                            lglf3rce(lgl, other2, -lit, other, red);
                        }
                    }
                }
            } else {
                lidx = *p;
                c = lglidx2lits(lgl, red, lidx);
                other2 = *c.offset(0 as libc::c_int as isize);
                if other2 == -lit {
                    let ref mut fresh41 = *c.offset(0 as libc::c_int as isize);
                    *fresh41 = *c.offset(1 as libc::c_int as isize);
                    other2 = *fresh41;
                    *c.offset(1 as libc::c_int as isize) = -lit;
                }
                if other2 != other {
                    other = other2;
                    val = lglval(lgl, other) as libc::c_int;
                    if val > 0 as libc::c_int {
                        *q
                            .offset(
                                -(2 as libc::c_int) as isize,
                            ) = LRGCS as libc::c_int
                            | ((other2 as libc::c_uint) << RMSHFT as libc::c_int)
                                as libc::c_int | red;
                        current_block_75 = 1841672684692190573;
                    } else {
                        current_block_75 = 3689906465960840878;
                    }
                } else {
                    current_block_75 = 3689906465960840878;
                }
                match current_block_75 {
                    1841672684692190573 => {}
                    _ => {
                        val2 = 0 as libc::c_int;
                        prev = -lit;
                        l = c.offset(2 as libc::c_int as isize);
                        loop {
                            other2 = *l;
                            if !(other2 != 0) {
                                break;
                            }
                            *l = prev;
                            val2 = lglval(lgl, other2) as libc::c_int;
                            if val2 >= 0 as libc::c_int {
                                break;
                            }
                            prev = other2;
                            l = l.offset(1);
                            l;
                        }
                        if other2 != 0 {
                            *c.offset(1 as libc::c_int as isize) = other2;
                            delta = lglwchlrg(lgl, other2, other, red, lidx);
                            if delta != 0 {
                                p = p.offset(delta as isize);
                                q = q.offset(delta as isize);
                                eos = eos.offset(delta as isize);
                            }
                            q = q.offset(-(2 as libc::c_int as isize));
                        } else {
                            while l > c.offset(2 as libc::c_int as isize) {
                                l = l.offset(-1);
                                other3 = *l;
                                *l = prev;
                                prev = other3;
                            }
                            if val < 0 as libc::c_int {
                                lglonflict(lgl, 1 as libc::c_int, -lit, red, lidx);
                                p = p.offset(1);
                                p;
                                break;
                            } else {
                                lglflrce(lgl, other, red, lidx);
                            }
                        }
                    }
                }
            }
        }
        p = p.offset(1);
        p;
    }
    while p < eos as *const libc::c_int {
        let fresh42 = p;
        p = p.offset(1);
        let fresh43 = q;
        q = q.offset(1);
        *fresh43 = *fresh42;
    }
    lglshrinkhts(
        lgl,
        hts,
        ((*hts).count as libc::c_long - p.offset_from(q) as libc::c_long) as libc::c_int,
    );
    (*(*lgl).stats).visits.search += visits as int64_t;
}
unsafe extern "C" fn lglhbred(
    mut lgl: *mut LGL,
    mut subsumed: libc::c_int,
    mut red: libc::c_int,
) -> libc::c_int {
    let mut res: libc::c_int = if subsumed != 0 { red } else { REDCS as libc::c_int };
    return res;
}
unsafe extern "C" fn lglrmlocc(
    mut lgl: *mut LGL,
    mut lit: libc::c_int,
    mut red: libc::c_int,
    mut lidx: libc::c_int,
) {
    let mut search: libc::c_int = 0;
    let mut blit: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut p: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut q: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut w: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut eow: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut hts: *mut HTS = 0 as *mut HTS;
    hts = lglhts(lgl, lit);
    search = lidx << RMSHFT as libc::c_int | OCCS as libc::c_int | red;
    w = lglhts2wchs(lgl, hts);
    p = w;
    eow = w.offset((*hts).count as isize);
    lglrminc(lgl, w, eow);
    loop {
        let fresh44 = p;
        p = p.offset(1);
        blit = *fresh44;
        tag = blit & MASKCS as libc::c_int;
        if tag == TRNCS as libc::c_int || tag == LRGCS as libc::c_int {
            p = p.offset(1);
            p;
        }
        if !(blit != search) {
            break;
        }
    }
    q = p;
    while q < eow {
        *q.offset(-(1 as libc::c_int) as isize) = *q.offset(0 as libc::c_int as isize);
        q = q.offset(1);
        q;
    }
    lglshrinkhts(
        lgl,
        hts,
        (q.offset_from(w) as libc::c_long - 1 as libc::c_int as libc::c_long)
            as libc::c_int,
    );
}
unsafe extern "C" fn lglflushremovedoccs(mut lgl: *mut LGL, mut lit: libc::c_int) {
    let mut hts: *mut HTS = lglhts(lgl, lit);
    let mut w: *mut libc::c_int = lglhts2wchs(lgl, hts);
    let mut eow: *mut libc::c_int = w.offset((*hts).count as isize);
    let mut blit: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut red: libc::c_int = 0;
    let mut lidx: libc::c_int = 0;
    let mut p: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut q: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut c: *mut libc::c_int = 0 as *mut libc::c_int;
    lglrminc(lgl, w, eow);
    let mut current_block_14: u64;
    q = w;
    p = q;
    while p < eow {
        blit = *p;
        tag = blit & MASKCS as libc::c_int;
        red = blit & REDCS as libc::c_int;
        if tag == TRNCS as libc::c_int || tag == LRGCS as libc::c_int {
            p = p.offset(1);
            p;
        }
        if tag == BINCS as libc::c_int {
            let fresh45 = q;
            q = q.offset(1);
            *fresh45 = blit;
        } else if tag == TRNCS as libc::c_int {
            let fresh46 = q;
            q = q.offset(1);
            *fresh46 = blit;
            let fresh47 = q;
            q = q.offset(1);
            *fresh47 = *p;
        } else {
            if red == 0 {
                lidx = if tag == LRGCS as libc::c_int {
                    *p
                } else {
                    blit >> RMSHFT as libc::c_int
                };
                c = lglidx2lits(lgl, red, lidx);
                if *c.offset(0 as libc::c_int as isize) == 2147483647 as libc::c_int {
                    current_block_14 = 12675440807659640239;
                } else {
                    current_block_14 = 12349973810996921269;
                }
            } else {
                current_block_14 = 12349973810996921269;
            }
            match current_block_14 {
                12675440807659640239 => {}
                _ => {
                    let fresh48 = q;
                    q = q.offset(1);
                    *fresh48 = blit;
                    if tag == LRGCS as libc::c_int {
                        let fresh49 = q;
                        q = q.offset(1);
                        *fresh49 = *p;
                    }
                }
            }
        }
        p = p.offset(1);
        p;
    }
    lglshrinkhts(lgl, hts, q.offset_from(w) as libc::c_long as libc::c_int);
}
unsafe extern "C" fn lglpropupdvisits(
    mut lgl: *mut LGL,
    mut visits: libc::c_int,
    mut steps: int64_t,
) {
    if (*lgl).lkhd != 0 {
        (*(*lgl).stats).visits.lkhd += visits as int64_t;
    } else if (*lgl).simp != 0 {
        (*(*lgl).stats).visits.simp += visits as int64_t;
    } else {
        (*(*lgl).stats).visits.search += visits as int64_t;
    }
    if (*lgl).simp != 0 {
        if (*lgl).basicprobing != 0 {
            (*(*lgl).stats).steps += visits as int64_t + steps;
            (*(*lgl).stats).prb.basic.steps += visits as int64_t + steps;
        } else if (*lgl).simpleprobing != 0 {
            (*(*lgl).stats).steps += visits as int64_t + steps;
            (*(*lgl).stats).prb.simple.steps += visits as int64_t + steps;
        } else if (*lgl).treelooking != 0 {
            (*(*lgl).stats).steps += visits as int64_t + steps;
            (*(*lgl).stats).prb.treelook.steps += visits as int64_t + steps;
        } else if (*lgl).sweeping != 0 {
            (*(*lgl).stats).steps += visits as int64_t + steps;
            (*(*lgl).stats).sweep.steps += visits as int64_t + steps;
        }
    }
}
unsafe extern "C" fn lglprop(mut lgl: *mut LGL, mut lit: libc::c_int) {
    let mut current_block: u64;
    let mut p: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut q: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut eos: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut blit: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut other2: libc::c_int = 0;
    let mut other3: libc::c_int = 0;
    let mut red: libc::c_int = 0;
    let mut prev: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut val: libc::c_int = 0;
    let mut val2: libc::c_int = 0;
    let mut lidx: libc::c_int = 0;
    let mut c: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut l: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut dom: libc::c_int = 0;
    let mut hbred: libc::c_int = 0;
    let mut subsumed: libc::c_int = 0;
    let mut glue: libc::c_int = 0;
    let mut flushoccs: libc::c_int = 0;
    let mut visits: libc::c_int = 0;
    let mut steps: int64_t = 0;
    let mut delta: ptrdiff_t = 0;
    let mut hts: *mut HTS = 0 as *mut HTS;
    hts = lglhts(lgl, -lit);
    if (*hts).offset == 0 {
        return;
    }
    flushoccs = 0 as libc::c_int;
    q = lglhts2wchs(lgl, hts);
    eos = q.offset((*hts).count as isize);
    visits = 0 as libc::c_int;
    steps = 0 as libc::c_int as int64_t;
    p = q;
    while p < eos {
        blit = *p;
        tag = blit & MASKCS as libc::c_int;
        red = blit & REDCS as libc::c_int;
        if tag == OCCS as libc::c_int {
            let fresh50 = q;
            q = q.offset(1);
            *fresh50 = blit;
        } else {
            visits += 1;
            visits;
            other = blit >> RMSHFT as libc::c_int;
            val = lglval(lgl, other) as libc::c_int;
            if tag == BINCS as libc::c_int {
                let fresh51 = q;
                q = q.offset(1);
                *fresh51 = blit;
                if !(val > 0 as libc::c_int) {
                    if !(red != 0 && lgliselim(lgl, other) != 0) {
                        if val < 0 as libc::c_int {
                            lglbonflict(lgl, -lit, blit);
                            p = p.offset(1);
                            p;
                            break;
                        } else {
                            lglf2rce(lgl, other, -lit, red);
                        }
                    }
                }
            } else if tag == TRNCS as libc::c_int {
                let fresh52 = q;
                q = q.offset(1);
                *fresh52 = blit;
                p = p.offset(1);
                other2 = *p;
                let fresh53 = q;
                q = q.offset(1);
                *fresh53 = other2;
                if !(val > 0 as libc::c_int) {
                    if !(red != 0 && lgliselim(lgl, other) != 0) {
                        val2 = lglval(lgl, other2) as libc::c_int;
                        if !(val2 > 0 as libc::c_int) {
                            if !(val == 0 && val2 == 0) {
                                if !(red != 0 && lgliselim(lgl, other2) != 0) {
                                    if val < 0 as libc::c_int && val2 < 0 as libc::c_int {
                                        lgltonflict(lgl, -lit, blit, other2);
                                        p = p.offset(1);
                                        p;
                                        break;
                                    } else {
                                        if val == 0 {
                                            let mut TMP: libc::c_int = other;
                                            other = other2;
                                            other2 = TMP;
                                        }
                                        if (*lgl).level != 0 && (*lgl).simp as libc::c_int != 0
                                            && (*(*lgl).opts).lhbr.val != 0
                                        {
                                            dom = lglgetdom(lgl, lit);
                                            if lglgetdom(lgl, -other) != dom {
                                                current_block = 6995485257845010542;
                                            } else {
                                                dom = lglhbrdom(lgl, lit, -other, &mut steps);
                                                if dom == 0 {
                                                    current_block = 6995485257845010542;
                                                } else {
                                                    subsumed = (dom == lit || dom == -other) as libc::c_int;
                                                    hbred = lglhbred(lgl, subsumed, red);
                                                    lgldrupligaddclsarg(
                                                        lgl,
                                                        REDCS as libc::c_int,
                                                        -dom,
                                                        other2,
                                                        0 as libc::c_int,
                                                    );
                                                    if subsumed != 0 {
                                                        lglrmtwch(lgl, other2, other, -lit, red);
                                                        lglrmtwch(lgl, other, other2, -lit, red);
                                                        (*(*lgl).stats).hbr.sub += 1;
                                                        (*(*lgl).stats).hbr.sub;
                                                        if red != 0 {
                                                            (*(*lgl).stats).red.trn -= 1;
                                                            (*(*lgl).stats).red.trn;
                                                        } else {
                                                            lgldecirr(lgl, 3 as libc::c_int);
                                                            if (*lgl).dense != 0 {
                                                                if -dom == -lit {
                                                                    lgldecocc(lgl, other);
                                                                } else {
                                                                    lgldecocc(lgl, -lit);
                                                                }
                                                            }
                                                        }
                                                        lgldrupligdelclsarg(
                                                            lgl,
                                                            -lit,
                                                            other,
                                                            other2,
                                                            0 as libc::c_int,
                                                        );
                                                    }
                                                    delta = 0 as libc::c_int as ptrdiff_t;
                                                    if dom == lit {
                                                        blit = ((other2 as libc::c_uint) << RMSHFT as libc::c_int)
                                                            as libc::c_int | BINCS as libc::c_int | hbred;
                                                        *q.offset(-(2 as libc::c_int) as isize) = blit;
                                                        q = q.offset(-1);
                                                        q;
                                                    } else {
                                                        if dom == -other {
                                                            q = q.offset(-(2 as libc::c_int as isize));
                                                        }
                                                        delta += lglwchbin(lgl, -dom, other2, hbred);
                                                    }
                                                    delta += lglwchbin(lgl, other2, -dom, hbred);
                                                    if delta != 0 {
                                                        p = p.offset(delta as isize);
                                                        q = q.offset(delta as isize);
                                                        eos = eos.offset(delta as isize);
                                                    }
                                                    if hbred != 0 {
                                                        (*(*lgl).stats).red.bin += 1;
                                                        (*(*lgl).stats).red.bin;
                                                    } else {
                                                        lglincirr(lgl, 2 as libc::c_int);
                                                    }
                                                    lglf2rce(lgl, other2, -dom, hbred);
                                                    (*(*lgl).stats).hbr.trn += 1;
                                                    (*(*lgl).stats).hbr.trn;
                                                    (*(*lgl).stats).hbr.cnt += 1;
                                                    (*(*lgl).stats).hbr.cnt;
                                                    (*(*lgl).stats).prgss += 1;
                                                    (*(*lgl).stats).prgss;
                                                    current_block = 17965632435239708295;
                                                }
                                            }
                                        } else {
                                            current_block = 6995485257845010542;
                                        }
                                        match current_block {
                                            17965632435239708295 => {}
                                            _ => {
                                                lglf3rce(lgl, other2, -lit, other, red);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            } else {
                if val > 0 as libc::c_int {
                    current_block = 18068423332002198354;
                } else {
                    lidx = *p.offset(1 as libc::c_int as isize);
                    c = lglidx2lits(lgl, red, lidx);
                    other2 = *c.offset(0 as libc::c_int as isize);
                    if other2 >= 2147483647 as libc::c_int >> RMSHFT as libc::c_int {
                        p = p.offset(1);
                        p;
                        current_block = 17965632435239708295;
                    } else {
                        if other2 == -lit {
                            let ref mut fresh54 = *c.offset(0 as libc::c_int as isize);
                            *fresh54 = *c.offset(1 as libc::c_int as isize);
                            other2 = *fresh54;
                            *c.offset(1 as libc::c_int as isize) = -lit;
                        }
                        if other2 != other {
                            other = other2;
                            val = lglval(lgl, other) as libc::c_int;
                            blit = red;
                            blit |= LRGCS as libc::c_int;
                            blit
                                |= ((other2 as libc::c_uint) << RMSHFT as libc::c_int)
                                    as libc::c_int;
                            if val > 0 as libc::c_int {
                                current_block = 18068423332002198354;
                            } else {
                                current_block = 3024367268842933116;
                            }
                        } else {
                            current_block = 3024367268842933116;
                        }
                        match current_block {
                            18068423332002198354 => {}
                            _ => {
                                if red != 0 && lgliselim(lgl, other) != 0 {
                                    current_block = 18068423332002198354;
                                } else {
                                    val2 = 2147483647 as libc::c_int;
                                    prev = -lit;
                                    l = c.offset(2 as libc::c_int as isize);
                                    loop {
                                        other2 = *l;
                                        if !(other2 != 0) {
                                            break;
                                        }
                                        *l = prev;
                                        val2 = lglval(lgl, other2) as libc::c_int;
                                        if val2 >= 0 as libc::c_int {
                                            break;
                                        }
                                        if red != 0 && lgliselim(lgl, other2) != 0 {
                                            break;
                                        }
                                        prev = other2;
                                        l = l.offset(1);
                                        l;
                                    }
                                    if other2 != 0 && val2 >= 0 as libc::c_int {
                                        *c.offset(1 as libc::c_int as isize) = other2;
                                        delta = lglwchlrg(lgl, other2, other, red, lidx);
                                        if delta != 0 {
                                            p = p.offset(delta as isize);
                                            q = q.offset(delta as isize);
                                            eos = eos.offset(delta as isize);
                                        }
                                        p = p.offset(1);
                                        p;
                                        current_block = 17965632435239708295;
                                    } else {
                                        while l > c.offset(2 as libc::c_int as isize) {
                                            l = l.offset(-1);
                                            other3 = *l;
                                            *l = prev;
                                            prev = other3;
                                        }
                                        if other2 != 0 && val2 < 0 as libc::c_int {
                                            current_block = 18068423332002198354;
                                        } else if val < 0 as libc::c_int {
                                            lglonflict(lgl, 1 as libc::c_int, -lit, red, lidx);
                                            break;
                                        } else {
                                            if (*lgl).level != 0 && (*lgl).simp as libc::c_int != 0
                                                && (*(*lgl).opts).lhbr.val != 0
                                            {
                                                dom = 0 as libc::c_int;
                                                l = c;
                                                loop {
                                                    other2 = *l;
                                                    if !(other2 != 0) {
                                                        current_block = 1180384664817104288;
                                                        break;
                                                    }
                                                    if !(other2 == other) {
                                                        if !(lglevel(lgl, other2) == 0) {
                                                            if dom == 0 {
                                                                dom = lglgetdom(lgl, -other);
                                                            }
                                                            if dom != lglgetdom(lgl, -other2) {
                                                                current_block = 1886366973491328931;
                                                                break;
                                                            }
                                                        }
                                                    }
                                                    l = l.offset(1);
                                                    l;
                                                }
                                                match current_block {
                                                    1886366973491328931 => {}
                                                    _ => {
                                                        dom = 0 as libc::c_int;
                                                        l = c;
                                                        loop {
                                                            other2 = *l;
                                                            if !(other2 != 0) {
                                                                break;
                                                            }
                                                            if !(other2 == other) {
                                                                if !(lglevel(lgl, other2) == 0) {
                                                                    dom = lglhbrdom(lgl, dom, -other2, &mut steps);
                                                                }
                                                            }
                                                            l = l.offset(1);
                                                            l;
                                                        }
                                                        if dom == 0 {
                                                            current_block = 1886366973491328931;
                                                        } else {
                                                            subsumed = 0 as libc::c_int;
                                                            l = c;
                                                            while subsumed == 0
                                                                && {
                                                                    other2 = *l;
                                                                    other2 != 0
                                                                }
                                                            {
                                                                subsumed = (dom == -other2) as libc::c_int;
                                                                l = l.offset(1);
                                                                l;
                                                            }
                                                            hbred = lglhbred(lgl, subsumed, red);
                                                            lgldrupligaddclsarg(
                                                                lgl,
                                                                REDCS as libc::c_int,
                                                                -dom,
                                                                other,
                                                                0 as libc::c_int,
                                                            );
                                                            if subsumed != 0 {
                                                                lglrmlwch(lgl, other, red, lidx);
                                                                (*(*lgl).stats).hbr.sub += 1;
                                                                (*(*lgl).stats).hbr.sub;
                                                                if red != 0 {
                                                                    glue = lidx
                                                                        & ((1 as libc::c_int) << 4 as libc::c_int)
                                                                            - 1 as libc::c_int;
                                                                    if glue
                                                                        != ((1 as libc::c_int) << 4 as libc::c_int)
                                                                            - 1 as libc::c_int
                                                                    {
                                                                        (*(*lgl).stats).red.lrg -= 1;
                                                                        (*(*lgl).stats).red.lrg;
                                                                        (*(*lgl).stats).lir[glue as usize].clauses -= 1;
                                                                        (*(*lgl).stats).lir[glue as usize].clauses;
                                                                    }
                                                                }
                                                                if red == 0 && (*lgl).dense as libc::c_int != 0 {
                                                                    l = c;
                                                                    loop {
                                                                        other2 = *l;
                                                                        if !(other2 != 0) {
                                                                            break;
                                                                        }
                                                                        if other2 != -lit {
                                                                            lglrmlocc(lgl, other2, 0 as libc::c_int, lidx);
                                                                        }
                                                                        if !(other2 == -dom) {
                                                                            if !(other2 == other) {
                                                                                lgldecocc(lgl, other2);
                                                                            }
                                                                        }
                                                                        l = l.offset(1);
                                                                        l;
                                                                    }
                                                                    flushoccs += 1;
                                                                    flushoccs;
                                                                }
                                                                if red != 0
                                                                    && glue
                                                                        < ((1 as libc::c_int) << 4 as libc::c_int)
                                                                            - 1 as libc::c_int
                                                                {
                                                                    *c
                                                                        .offset(
                                                                            -(1 as libc::c_int) as isize,
                                                                        ) = 2147483647 as libc::c_int;
                                                                }
                                                                lgldrupligdelclsaux(lgl, c);
                                                                l = c;
                                                                while *l != 0 {
                                                                    *l = 2147483647 as libc::c_int;
                                                                    l = l.offset(1);
                                                                    l;
                                                                }
                                                                if red == 0 {
                                                                    lgldecirr(
                                                                        lgl,
                                                                        l.offset_from(c) as libc::c_long as libc::c_int,
                                                                    );
                                                                }
                                                                *l = 2147483647 as libc::c_int;
                                                            }
                                                            delta = 0 as libc::c_int as ptrdiff_t;
                                                            if dom == lit {
                                                                blit = ((other as libc::c_uint) << RMSHFT as libc::c_int)
                                                                    as libc::c_int | BINCS as libc::c_int | hbred;
                                                                let fresh55 = q;
                                                                q = q.offset(1);
                                                                *fresh55 = blit;
                                                                p = p.offset(1);
                                                                p;
                                                            } else {
                                                                if subsumed != 0 {
                                                                    p = p.offset(1);
                                                                    p;
                                                                }
                                                                delta += lglwchbin(lgl, -dom, other, hbred);
                                                            }
                                                            delta += lglwchbin(lgl, other, -dom, hbred);
                                                            if delta != 0 {
                                                                p = p.offset(delta as isize);
                                                                q = q.offset(delta as isize);
                                                                eos = eos.offset(delta as isize);
                                                            }
                                                            if hbred != 0 {
                                                                (*(*lgl).stats).red.bin += 1;
                                                                (*(*lgl).stats).red.bin;
                                                            } else {
                                                                lglincirr(lgl, 2 as libc::c_int);
                                                            }
                                                            lglf2rce(lgl, other, -dom, hbred);
                                                            (*(*lgl).stats).hbr.lrg += 1;
                                                            (*(*lgl).stats).hbr.lrg;
                                                            (*(*lgl).stats).hbr.cnt += 1;
                                                            (*(*lgl).stats).hbr.cnt;
                                                            (*(*lgl).stats).prgss += 1;
                                                            (*(*lgl).stats).prgss;
                                                            if subsumed != 0 {
                                                                current_block = 17965632435239708295;
                                                            } else {
                                                                current_block = 18068423332002198354;
                                                            }
                                                        }
                                                    }
                                                }
                                            } else {
                                                current_block = 1886366973491328931;
                                            }
                                            match current_block {
                                                17965632435239708295 => {}
                                                18068423332002198354 => {}
                                                _ => {
                                                    lglflrce(lgl, other, red, lidx);
                                                    current_block = 18068423332002198354;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                match current_block {
                    17965632435239708295 => {}
                    _ => {
                        let fresh56 = q;
                        q = q.offset(1);
                        *fresh56 = blit;
                        p = p.offset(1);
                        let fresh57 = q;
                        q = q.offset(1);
                        *fresh57 = *p;
                    }
                }
            }
        }
        p = p.offset(1);
        p;
    }
    while p < eos {
        let fresh58 = p;
        p = p.offset(1);
        let fresh59 = q;
        q = q.offset(1);
        *fresh59 = *fresh58;
    }
    lglshrinkhts(
        lgl,
        hts,
        ((*hts).count as libc::c_long - p.offset_from(q) as libc::c_long) as libc::c_int,
    );
    if flushoccs != 0 {
        lglflushremovedoccs(lgl, -lit);
    }
    lglpropupdvisits(lgl, visits, steps);
}
unsafe extern "C" fn lglprop2(mut lgl: *mut LGL, mut lit: libc::c_int) {
    let mut other: libc::c_int = 0;
    let mut blit: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut val: libc::c_int = 0;
    let mut red: libc::c_int = 0;
    let mut visits: libc::c_int = 0;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut w: *const libc::c_int = 0 as *const libc::c_int;
    let mut eow: *const libc::c_int = 0 as *const libc::c_int;
    let mut travs: int64_t = 0;
    let mut hts: *mut HTS = 0 as *mut HTS;
    visits = 0 as libc::c_int;
    travs = 0 as libc::c_int as int64_t;
    hts = lglhts(lgl, -lit);
    w = lglhts2wchs(lgl, hts);
    eow = w.offset((*hts).count as isize);
    p = w;
    while p < eow {
        blit = *p;
        tag = blit & MASKCS as libc::c_int;
        if tag == TRNCS as libc::c_int || tag == LRGCS as libc::c_int {
            p = p.offset(1);
            p;
        }
        if !(tag != BINCS as libc::c_int) {
            visits += 1;
            visits;
            red = blit & REDCS as libc::c_int;
            other = blit >> RMSHFT as libc::c_int;
            travs += 1;
            travs;
            if !(lgliselim(lgl, other) != 0) {
                val = lglval(lgl, other) as libc::c_int;
                if !(val > 0 as libc::c_int) {
                    if val < 0 as libc::c_int {
                        lglbonflict(lgl, -lit, blit);
                        break;
                    } else {
                        lglf2rce(lgl, other, -lit, red);
                    }
                }
            }
        }
        p = p.offset(1);
        p;
    }
    lglpropupdvisits(lgl, visits, travs);
}
unsafe extern "C" fn lglhasconflict(mut lgl: *mut LGL) -> libc::c_int {
    return ((*lgl).conf.lit != 0 as libc::c_int) as libc::c_int;
}
unsafe extern "C" fn lglbcpcomplete(mut lgl: *mut LGL) -> libc::c_int {
    if (*lgl).next2 < (*lgl).next {
        return 0 as libc::c_int;
    }
    if (*lgl).next < lglcntstk(&mut (*lgl).trail) as libc::c_int {
        return 0 as libc::c_int;
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn lglchkbcpclean(
    mut lgl: *mut LGL,
    mut where_0: *const libc::c_char,
) {}
unsafe extern "C" fn lglbcp(mut lgl: *mut LGL) -> libc::c_int {
    let mut lit: libc::c_int = 0;
    let mut trail: libc::c_int = 0;
    let mut count: libc::c_int = 0;
    count = 0 as libc::c_int;
    while (*lgl).conf.lit == 0 {
        trail = lglcntstk(&mut (*lgl).trail) as libc::c_int;
        if (*lgl).next2 < trail {
            let fresh60 = (*lgl).next2;
            (*lgl).next2 = (*lgl).next2 + 1;
            lit = lglpeek(&mut (*lgl).trail, fresh60);
            lglprop2(lgl, lit);
        } else {
            if (*lgl).next >= trail {
                break;
            }
            count += 1;
            count;
            let fresh61 = (*lgl).next;
            (*lgl).next = (*lgl).next + 1;
            lit = lglpeek(&mut (*lgl).trail, fresh61);
            lglprop(lgl, lit);
        }
    }
    if (*lgl).lkhd != 0 {
        (*(*lgl).stats).steps += count as int64_t;
        (*(*lgl).stats).props.lkhd += count as int64_t;
    } else if (*lgl).simp != 0 {
        (*(*lgl).stats).steps += count as int64_t;
        (*(*lgl).stats).props.simp += count as int64_t;
    } else {
        (*(*lgl).stats).steps += count as int64_t;
        (*(*lgl).stats).props.search += count as int64_t;
    }
    return (lglhasconflict(lgl) == 0) as libc::c_int;
}
unsafe extern "C" fn lglbcpsearch(mut lgl: *mut LGL) -> libc::c_int {
    let mut lit: libc::c_int = 0;
    let mut count: libc::c_int = 0 as libc::c_int;
    while ((*lgl).failed == 0 || (*lgl).level == 0) && (*lgl).conf.lit == 0
        && (*lgl).next < lglcntstk(&mut (*lgl).trail) as libc::c_int
    {
        let fresh62 = (*lgl).next;
        (*lgl).next = (*lgl).next + 1;
        lit = lglpeek(&mut (*lgl).trail, fresh62);
        lglpropsearch(lgl, lit);
        count += 1;
        count;
    }
    (*(*lgl).stats).steps += count as int64_t;
    (*(*lgl).stats).props.search += count as int64_t;
    (*lgl).next2 = (*lgl).next;
    if (*lgl).conf.lit != 0 && (*lgl).failed != 0 {
        (*lgl).failed = 0 as libc::c_int;
    }
    return ((*lgl).conf.lit == 0 && (*lgl).failed == 0) as libc::c_int;
}
unsafe extern "C" fn lgldecision(
    mut lgl: *mut LGL,
    mut lit: libc::c_int,
) -> libc::c_int {
    let mut rsn: *mut libc::c_int = lglrsn(lgl, lit);
    let mut tag: libc::c_int = *rsn.offset(0 as libc::c_int as isize)
        & MASKCS as libc::c_int;
    return (tag == DECISION as libc::c_int) as libc::c_int;
}
unsafe extern "C" fn lglassumption(
    mut lgl: *mut LGL,
    mut lit: libc::c_int,
) -> libc::c_int {
    return (*lglavar(lgl, lit)).assumed() as libc::c_int;
}
unsafe extern "C" fn lglpull(mut lgl: *mut LGL, mut lit: libc::c_int) -> libc::c_int {
    let mut av: *mut AVar = lglavar(lgl, lit);
    let mut level: libc::c_int = 0;
    let mut res: libc::c_int = 0;
    level = lglevel(lgl, lit);
    if level == 0 {
        return 0 as libc::c_int;
    }
    if (*av).mark != 0 {
        return 0 as libc::c_int;
    }
    (*av).mark = 1 as libc::c_int;
    lglpushstk(lgl, &mut (*lgl).seen, lit);
    if level == (*lgl).level {
        res = 1 as libc::c_int;
    } else {
        lglpushstk(lgl, &mut (*lgl).clause, lit);
        lgluselevel(lgl, level);
        res = 0 as libc::c_int;
    }
    return res;
}
unsafe extern "C" fn lglusedtwice(
    mut lgl: *mut LGL,
    mut lit: libc::c_int,
) -> libc::c_int {
    let mut level: libc::c_int = 0;
    if (*(*lgl).opts).usedtwice.val == 0 {
        return 1 as libc::c_int;
    }
    level = lglevel(lgl, lit);
    (*(*lgl).stats).mincls.usedtwice.search += 1;
    (*(*lgl).stats).mincls.usedtwice.search;
    if lglevelused(lgl, level) >= 2 as libc::c_int as libc::c_uint {
        return 1 as libc::c_int;
    }
    (*(*lgl).stats).mincls.usedtwice.hits += 1;
    (*(*lgl).stats).mincls.usedtwice.hits;
    return 0 as libc::c_int;
}
unsafe extern "C" fn lglpoison(
    mut lgl: *mut LGL,
    mut lit: libc::c_int,
    mut stk: *mut Stk,
    mut local: libc::c_int,
) -> libc::c_int {
    let mut av: *mut AVar = lglavar(lgl, lit);
    let mut level: libc::c_int = 0;
    let mut res: libc::c_int = 0;
    if (*av).mark != 0 {
        res = 0 as libc::c_int;
    } else {
        level = lglevel(lgl, lit);
        if level == 0 {
            res = 0 as libc::c_int;
        } else if lgldecision(lgl, lit) != 0 {
            res = 1 as libc::c_int;
        } else if lglevelused(lgl, level) < 2 as libc::c_int as libc::c_uint {
            res = 1 as libc::c_int;
        } else {
            if (*(*lgl).opts).poison.val != 0 {
                (*(*lgl).stats).mincls.poison.search += 1;
                (*(*lgl).stats).mincls.poison.search;
            }
            if (*av).poisoned() != 0 {
                (*(*lgl).stats).mincls.poison.hits += 1;
                (*(*lgl).stats).mincls.poison.hits;
                res = 1 as libc::c_int;
            } else if local != 0 {
                res = 1 as libc::c_int;
            } else if lglusedtwice(lgl, lit) != 0 {
                (*av).mark = 1 as libc::c_int;
                lglpushstk(lgl, &mut (*lgl).seen, lit);
                lglpushstk(lgl, stk, lit);
                res = 0 as libc::c_int;
            } else {
                res = 1 as libc::c_int;
            }
        }
    }
    if res != 0 && (*(*lgl).opts).poison.val != 0 && (*av).poisoned() == 0 {
        (*av).set_poisoned(1 as libc::c_int as libc::c_uint);
        lglpushstk(lgl, &mut (*lgl).poisoned, lit);
    }
    return res;
}
unsafe extern "C" fn lglminclslit(
    mut lgl: *mut LGL,
    mut start: libc::c_int,
    mut local: libc::c_int,
) -> libc::c_int {
    let mut lit: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut r0: libc::c_int = 0;
    let mut r1: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut p: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut q: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut top: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut old: libc::c_int = 0;
    let mut level: libc::c_int = 0;
    let mut poisoned: libc::c_int = 0;
    let mut rsn: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut found: libc::c_int = 0;
    let mut av: *mut AVar = 0 as *mut AVar;
    let mut bv: *mut AVar = 0 as *mut AVar;
    lit = start;
    level = lglevel(lgl, lit);
    if level == (*lgl).level {
        return 0 as libc::c_int;
    }
    if lglusedtwice(lgl, lit) == 0 {
        return 0 as libc::c_int;
    }
    rsn = lglrsn(lgl, lit);
    r0 = *rsn.offset(0 as libc::c_int as isize);
    tag = r0 & MASKCS as libc::c_int;
    if tag == DECISION as libc::c_int {
        return 0 as libc::c_int;
    }
    old = lglcntstk(&mut (*lgl).seen) as libc::c_int;
    's_60: loop {
        r1 = *rsn.offset(1 as libc::c_int as isize);
        if tag == BINCS as libc::c_int || tag == TRNCS as libc::c_int {
            other = r0 >> RMSHFT as libc::c_int;
            if lglpoison(lgl, other, &mut (*lgl).minstk, local) != 0 {
                break;
            }
            if tag == TRNCS as libc::c_int
                && lglpoison(lgl, r1, &mut (*lgl).minstk, local) != 0
            {
                break;
            }
        } else {
            p = lglidx2lits(lgl, r0 & REDCS as libc::c_int, r1);
            found = 0 as libc::c_int;
            loop {
                let fresh63 = p;
                p = p.offset(1);
                other = *fresh63;
                if !(other != 0) {
                    break;
                }
                if other == -lit {
                    found += 1;
                    found;
                } else if lglpoison(lgl, other, &mut (*lgl).minstk, local) != 0 {
                    break 's_60;
                }
            }
        }
        if lglmtstk(&mut (*lgl).minstk) != 0 {
            lglrelstk(lgl, &mut (*lgl).minstk);
            return 1 as libc::c_int;
        }
        lit = lglpopstk(&mut (*lgl).minstk);
        rsn = lglrsn(lgl, lit);
        r0 = *rsn.offset(0 as libc::c_int as isize);
        tag = r0 & MASKCS as libc::c_int;
    }
    lglclnstk(&mut (*lgl).minstk);
    p = (*lgl).seen.top;
    (*lgl).seen.top = ((*lgl).seen.start).offset(old as isize);
    top = (*lgl).seen.top;
    while p > top {
        p = p.offset(-1);
        lit = *p;
        av = lglavar(lgl, lit);
        (*av).mark = 0 as libc::c_int;
        if (*(*lgl).opts).poison.val == 0 {
            continue;
        }
        poisoned = (*av).poisoned() as libc::c_int;
        if poisoned != 0 {
            continue;
        }
        rsn = lglrsn(lgl, lit);
        r0 = *rsn.offset(0 as libc::c_int as isize);
        tag = r0 & MASKCS as libc::c_int;
        r1 = *rsn.offset(1 as libc::c_int as isize);
        if tag == BINCS as libc::c_int || tag == TRNCS as libc::c_int {
            other = r0 >> RMSHFT as libc::c_int;
            bv = lglavar(lgl, other);
            if (*bv).poisoned() != 0 {
                poisoned = 1 as libc::c_int;
            } else if tag == TRNCS as libc::c_int {
                bv = lglavar(lgl, r1);
                if (*bv).poisoned() != 0 {
                    poisoned = 1 as libc::c_int;
                }
            }
        } else {
            q = lglidx2lits(lgl, r0 & REDCS as libc::c_int, r1);
            while poisoned == 0
                && {
                    let fresh64 = q;
                    q = q.offset(1);
                    other = *fresh64;
                    other != 0
                }
            {
                poisoned = (*lglavar(lgl, other)).poisoned() as libc::c_int;
            }
        }
        if poisoned == 0 {
            continue;
        }
        (*av).set_poisoned(1 as libc::c_int as libc::c_uint);
        lglpushstk(lgl, &mut (*lgl).poisoned, lit);
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn lglmaxmb(mut lgl: *mut LGL) -> libc::c_double {
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 9], &[libc::c_char; 9]>(b"lglmaxmb\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    return ((*(*lgl).stats).bytes.max)
        .wrapping_add(::core::mem::size_of::<LGL>() as libc::c_ulong) as libc::c_double
        / ((1 as libc::c_int) << 20 as libc::c_int) as libc::c_double;
}
#[no_mangle]
pub unsafe extern "C" fn lglbytes(mut lgl: *mut LGL) -> size_t {
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 9], &[libc::c_char; 9]>(b"lglbytes\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    return (*(*lgl).stats).bytes.current;
}
#[no_mangle]
pub unsafe extern "C" fn lglmb(mut lgl: *mut LGL) -> libc::c_double {
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 6], &[libc::c_char; 6]>(b"lglmb\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    return ((*(*lgl).stats).bytes.current)
        .wrapping_add(::core::mem::size_of::<LGL>() as libc::c_ulong) as libc::c_double
        / ((1 as libc::c_int) << 20 as libc::c_int) as libc::c_double;
}
unsafe extern "C" fn lglavg(
    mut n: libc::c_double,
    mut d: libc::c_double,
) -> libc::c_double {
    return if d != 0 as libc::c_int as libc::c_double { n / d } else { 0.0f64 };
}
unsafe extern "C" fn lglheight(mut lgl: *mut LGL) -> libc::c_double {
    return (*(*lgl).stats).jlevel.slow.val as libc::c_double
        / ((1 as libc::c_ulonglong) << 32 as libc::c_int) as libc::c_double;
}
unsafe extern "C" fn lgltlevel(mut lgl: *mut LGL) -> libc::c_double {
    return (*(*lgl).stats).tlevel.val as libc::c_double
        / ((1 as libc::c_ulonglong) << 32 as libc::c_int) as libc::c_double;
}
unsafe extern "C" fn lglglue(mut lgl: *mut LGL) -> libc::c_double {
    return (*(*lgl).stats).glue.slow.val as libc::c_double
        / ((1 as libc::c_ulonglong) << 32 as libc::c_int) as libc::c_double;
}
unsafe extern "C" fn lglrephead(mut lgl: *mut LGL) {
    if (*lgl).tid > 0 as libc::c_int {
        return;
    }
    (*lgl).repforcehead = 0 as libc::c_int as libc::c_char;
    (*lgl).repcntdown = 22 as libc::c_int;
    if (*lgl).tid > 0 as libc::c_int {
        return;
    }
    if !((*lgl).cbs).is_null() && ((*(*lgl).cbs).msglock.lock).is_some() {
        ((*(*lgl).cbs).msglock.lock)
            .expect("non-null function pointer")((*(*lgl).cbs).msglock.state);
    }
    fprintf((*lgl).out, b"%s\n\0" as *const u8 as *const libc::c_char, (*lgl).prefix);
    fprintf(
        (*lgl).out,
        b"%s%s seconds         irredundant            redundant clauses   glue   iterations\"      MB    stability\n\0"
            as *const u8 as *const libc::c_char,
        (*lgl).prefix,
        if (*lgl).tid == 0 {
            b"  \0" as *const u8 as *const libc::c_char
        } else {
            b"\0" as *const u8 as *const libc::c_char
        },
    );
    fprintf(
        (*lgl).out,
        b"%s%s         variables clauses conflicts  large ternary binary     jlevel       jlevel'  agility     tlevel\n\0"
            as *const u8 as *const libc::c_char,
        (*lgl).prefix,
        if (*lgl).tid == 0 {
            b"  \0" as *const u8 as *const libc::c_char
        } else {
            b"\0" as *const u8 as *const libc::c_char
        },
    );
    fprintf((*lgl).out, b"%s\n\0" as *const u8 as *const libc::c_char, (*lgl).prefix);
    fflush((*lgl).out);
    if !((*lgl).cbs).is_null() && ((*(*lgl).cbs).msglock.unlock).is_some() {
        ((*(*lgl).cbs).msglock.unlock)
            .expect("non-null function pointer")((*(*lgl).cbs).msglock.state);
    }
}
unsafe extern "C" fn lglitder(mut lgl: *mut LGL) -> libc::c_double {
    return 10000.0f64
        * lglavg(
            (*(*lgl).stats).its.avg.diff.smoothed.val as libc::c_double
                / ((1 as libc::c_ulonglong) << 32 as libc::c_int) as libc::c_double,
            (*(*lgl).stats).confs as libc::c_double,
        );
}
unsafe extern "C" fn lgljlevelder(mut lgl: *mut LGL) -> libc::c_double {
    return (*(*lgl).stats).jlevel.diff.smoothed.val as libc::c_double
        / ((1 as libc::c_longlong) << 32 as libc::c_int) as libc::c_double;
}
unsafe extern "C" fn lglrep(
    mut lgl: *mut LGL,
    mut level: libc::c_int,
    mut type_0: libc::c_char,
) {
    if (*(*lgl).opts).verbose.val < level {
        return;
    }
    if level > 0 as libc::c_int && (*lgl).repforcehead as libc::c_int != 0
        || {
            let fresh65 = (*lgl).repcntdown;
            (*lgl).repcntdown = (*lgl).repcntdown - 1;
            fresh65 == 0
        }
    {
        lglrephead(lgl);
    }
    lglprt(
        lgl,
        level,
        b" %c %6.1f %7d %8d %9lld %7d %6d %5d %4.0f %5.0f %6.0f %5.0f %4.0f %3.0f %5.0f %6.0f\0"
            as *const u8 as *const libc::c_char,
        type_0 as libc::c_int,
        if (*(*lgl).opts).abstime.val != 0 { lglgetime(lgl) } else { lglsec(lgl) },
        lglrem(lgl),
        (*(*lgl).stats).irr.clauses.cur,
        (*(*lgl).stats).confs as libc::c_longlong,
        (*(*lgl).stats).red.lrg,
        (*(*lgl).stats).red.trn,
        (*(*lgl).stats).red.bin,
        lglglue(lgl),
        lglheight(lgl),
        lglitder(lgl),
        lgljlevelder(lgl),
        lglmb(lgl),
        100.0f64
            * ((*(*lgl).stats).agility as libc::c_double
                / ((1 as libc::c_longlong) << 32 as libc::c_int) as libc::c_double),
        1000.0f64
            * ((*(*lgl).stats).stability.avg.val as libc::c_double
                / ((1 as libc::c_longlong) << 32 as libc::c_int) as libc::c_double),
        lgltlevel(lgl),
    );
    (*(*lgl).stats).reported += 1;
    (*(*lgl).stats).reported;
}
unsafe extern "C" fn lglflshrep(mut lgl: *mut LGL) {
    if (*(*lgl).stats).reported == 0 {
        return;
    }
    if (*(*lgl).stats).reported % 22 as libc::c_int != 0 {
        lglrephead(lgl);
    } else {
        lglprt(lgl, 1 as libc::c_int, b"\0" as *const u8 as *const libc::c_char);
    };
}
unsafe extern "C" fn lglfitlir(mut lgl: *mut LGL, mut lir: *mut Stk) {
    lglfitstk(lgl, lir);
}
unsafe extern "C" fn lglchkred(mut lgl: *mut LGL) {}
unsafe extern "C" fn lglinitredl(mut lgl: *mut LGL) {
    (*(*lgl).limits).reduce.redlarge = (*(*lgl).opts).reduceinit.val;
    lglprt(
        lgl,
        2 as libc::c_int,
        b"[set-reduce-limit] initial reduce limit of %lld after %lld conflicts\0"
            as *const u8 as *const libc::c_char,
        (*(*lgl).limits).reduce.redlarge as libc::c_longlong,
        (*(*lgl).stats).confs as libc::c_longlong,
    );
}
unsafe extern "C" fn lglmemout(mut lgl: *mut LGL) -> libc::c_int {
    let mut cur: size_t = 0;
    let mut res: libc::c_int = 0;
    if (*(*lgl).opts).memlim.val < 0 as libc::c_int {
        return 0 as libc::c_int;
    }
    cur = (*(*lgl).stats).bytes.current;
    cur >>= 20 as libc::c_int;
    res = (cur >= (*(*lgl).opts).memlim.val as size_t) as libc::c_int;
    if res != 0 {
        lglprt(
            lgl,
            2 as libc::c_int,
            b"memory limit of %d MB hit after allocating %lld MB\0" as *const u8
                as *const libc::c_char,
            (*(*lgl).opts).memlim.val,
            cur as libc::c_longlong,
        );
    }
    return res;
}
unsafe extern "C" fn lgliphase(mut lgl: *mut LGL, mut lit: libc::c_int) -> Val {
    let mut res: Val = (*lglavar(lgl, lit)).phase() as Val;
    if lit < 0 as libc::c_int {
        res = -(res as libc::c_int) as Val;
    }
    return res;
}
unsafe extern "C" fn lglretire(mut lgl: *mut LGL) {
    let mut count: libc::c_int = 0;
    let mut ready: libc::c_int = 0;
    let mut inactive: libc::c_int = 0;
    let mut glue: libc::c_int = 0;
    let mut p: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut c: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut act: libc::c_int = 0;
    let retireint: libc::c_int = (*(*lgl).opts).retireint.val;
    let mut s: *mut Stk = 0 as *mut Stk;
    inactive = 0 as libc::c_int;
    ready = inactive;
    count = ready;
    glue = 0 as libc::c_int;
    while glue < ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int {
        s = ((*lgl).red).offset(glue as isize);
        c = (*s).start;
        while c < (*s).top {
            p = c;
            act = *p;
            if act <= (2147483647 as libc::c_int >> RMSHFT as libc::c_int) + retireint {
                count += 1;
                count;
                inactive += 1;
                inactive;
                if act
                    <= (2147483647 as libc::c_int >> RMSHFT as libc::c_int)
                        + 1 as libc::c_int
                {
                    act = 2147483647 as libc::c_int >> RMSHFT as libc::c_int;
                    ready += 1;
                    ready;
                } else {
                    act -= 1;
                    act;
                }
                let fresh66 = p;
                p = p.offset(1);
                *fresh66 = act;
            } else if act < 2147483647 as libc::c_int {
                count += 1;
                count;
                act = (2147483647 as libc::c_int >> RMSHFT as libc::c_int) + retireint
                    + (act - (2147483647 as libc::c_int >> RMSHFT as libc::c_int)
                        - retireint) / 2 as libc::c_int;
                let fresh67 = p;
                p = p.offset(1);
                *fresh67 = act;
            }
            while *p != 0 {
                p = p.offset(1);
                p;
            }
            c = p.offset(1 as libc::c_int as isize);
        }
        glue += 1;
        glue;
    }
    lglprt(
        lgl,
        2 as libc::c_int,
        b"[reduce-%d] %d ready to retire %.0f%%, %d inactive %.0f%%\0" as *const u8
            as *const libc::c_char,
        (*(*lgl).stats).reduced.count,
        ready,
        lglpcnt(ready as libc::c_double, count as libc::c_double),
        inactive,
        lglpcnt(inactive as libc::c_double, count as libc::c_double),
    );
}
unsafe extern "C" fn lglcmpagsl(
    mut lgl: *mut LGL,
    mut a: *mut PAGSL,
    mut b: *mut PAGSL,
) -> libc::c_int {
    let mut res: libc::c_int = 0;
    res = (*b).psm - (*a).psm;
    if res != 0 {
        return res;
    }
    res = (*b).glue - (*a).glue;
    if res != 0 {
        return res;
    }
    res = (*a).act - (*b).act;
    if res != 0 {
        return res;
    }
    res = (*b).size - (*a).size;
    if res != 0 {
        return res;
    }
    res = (*a).lidx - (*b).lidx;
    if res != 0 {
        return res;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn lglreduce(mut lgl: *mut LGL, mut forced: libc::c_int) {
    let mut p: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut q: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut start: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut c: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut maps: *mut *mut libc::c_int = 0 as *mut *mut libc::c_int;
    let mut sizes: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut map: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut eow: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut rsn: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut nlocked: libc::c_int = 0;
    let mut collected: libc::c_int = 0;
    let mut sumcollected: libc::c_int = 0;
    let mut nunlocked: libc::c_int = 0;
    let mut moved: libc::c_int = 0;
    let mut act: libc::c_int = 0;
    let mut psm: libc::c_int = 0;
    let mut glue: libc::c_int = 0;
    let mut target: libc::c_int = 0;
    let mut nkeep: libc::c_int = 0;
    let mut retired: libc::c_int = 0;
    let mut sumretired: libc::c_int = 0;
    let mut pagsls: *mut PAGSL = 0 as *mut PAGSL;
    let mut pagsl: *mut PAGSL = 0 as *mut PAGSL;
    let mut npagsls: libc::c_int = 0;
    let mut szpagsls: libc::c_int = 0;
    let retirenb: libc::c_int = (*(*lgl).opts).retirenb.val;
    let retiremin: libc::c_int = (*(*lgl).opts).retiremin.val;
    let mut size: libc::c_int = 0;
    let mut idx: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut red: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut blit: libc::c_int = 0;
    let mut r0: libc::c_int = 0;
    let mut lidx: libc::c_int = 0;
    let mut src: libc::c_int = 0;
    let mut dst: libc::c_int = 0;
    let mut lit: libc::c_int = 0;
    let mut inc: libc::c_int = 0;
    let mut delta: libc::c_int = 0;
    let mut npromoted: libc::c_int = 0;
    let mut type_0: libc::c_char = '-' as i32 as libc::c_char;
    let mut hts: *mut HTS = 0 as *mut HTS;
    let mut dv: *mut DVar = 0 as *mut DVar;
    let mut lir: *mut Stk = 0 as *mut Stk;
    lglchkred(lgl);
    lglstart(lgl, &mut (*(*lgl).times).reduce);
    (*(*lgl).stats).reduced.count += 1;
    (*(*lgl).stats).reduced.count;
    if retirenb != 0 {
        lglretire(lgl);
    }
    delta = (*(*lgl).stats).red.lrg;
    delta -= (*lgl).lrgluereasons;
    delta -= (*(*lgl).stats).lir[0 as libc::c_int as usize].clauses;
    if delta > 3 as libc::c_int * (*(*lgl).limits).reduce.redlarge / 2 as libc::c_int {
        target = delta - (*(*lgl).limits).reduce.redlarge / 2 as libc::c_int;
    } else {
        target = delta / 2 as libc::c_int;
    }
    if target < 0 as libc::c_int {
        target = 0 as libc::c_int;
    }
    lglprt(
        lgl,
        2 as libc::c_int,
        b"[reduce-%d] target is to collect %d clauses %.0f%%\0" as *const u8
            as *const libc::c_char,
        (*(*lgl).stats).reduced.count,
        target,
        lglpcnt(target as libc::c_double, (*(*lgl).stats).red.lrg as libc::c_double),
    );
    maps = lglnew(
        lgl,
        ((((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int) as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<*mut libc::c_int>() as libc::c_ulong),
    ) as *mut *mut libc::c_int;
    sizes = lglnew(
        lgl,
        ((((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int) as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
    ) as *mut libc::c_int;
    glue = 0 as libc::c_int;
    while glue < ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int {
        lir = ((*lgl).red).offset(glue as isize);
        size = lglcntstk(lir) as libc::c_int;
        size = (size + 5 as libc::c_int) / 6 as libc::c_int;
        *sizes.offset(glue as isize) = size;
        lglfitstk(lgl, lir);
        let ref mut fresh68 = *maps.offset(glue as isize);
        *fresh68 = lglnew(
            lgl,
            (size as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
        ) as *mut libc::c_int;
        map = *maps.offset(glue as isize);
        i = 0 as libc::c_int;
        while i < size {
            *map.offset(i as isize) = -(2 as libc::c_int);
            i += 1;
            i;
        }
        glue += 1;
        glue;
    }
    nlocked = 0 as libc::c_int;
    i = 0 as libc::c_int;
    while i < lglcntstk(&mut (*lgl).trail) as libc::c_int {
        lit = lglpeek(&mut (*lgl).trail, i);
        idx = abs(lit);
        rsn = lglrsn(lgl, idx);
        r0 = *rsn.offset(0 as libc::c_int as isize);
        red = r0 & REDCS as libc::c_int;
        if !(red == 0) {
            tag = r0 & MASKCS as libc::c_int;
            if !(tag != LRGCS as libc::c_int) {
                lidx = *rsn.offset(1 as libc::c_int as isize);
                glue = lidx
                    & ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int;
                if !(glue == ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int)
                {
                    lidx >>= 4 as libc::c_int;
                    lidx /= 6 as libc::c_int;
                    *(*maps.offset(glue as isize))
                        .offset(lidx as isize) = -(1 as libc::c_int);
                    nlocked += 1;
                    nlocked;
                }
            }
        }
        i += 1;
        i;
    }
    lglprt(
        lgl,
        2 as libc::c_int,
        b"[reduce-%d] locked %d learned reason clauses %.0f%%\0" as *const u8
            as *const libc::c_char,
        (*(*lgl).stats).reduced.count,
        nlocked,
        lglpcnt(nlocked as libc::c_double, (*(*lgl).stats).red.lrg as libc::c_double),
    );
    npromoted = 0 as libc::c_int;
    while lglmtstk(&mut (*lgl).promote) == 0 {
        lidx = lglpopstk(&mut (*lgl).promote);
        glue = lidx & ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int;
        if (*maps.offset(glue as isize)).is_null() {
            continue;
        }
        lidx >>= 4 as libc::c_int;
        lir = ((*lgl).red).offset(glue as isize);
        p = ((*lir).start).offset(lidx as isize);
        if p >= (*lir).top {
            continue;
        }
        if *p >= 2147483647 as libc::c_int >> RMSHFT as libc::c_int {
            continue;
        }
        if lglisact(*p.offset(-(1 as libc::c_int) as isize)) == 0 {
            continue;
        }
        if *(*maps.offset(glue as isize)).offset((lidx / 6 as libc::c_int) as isize)
            == -(1 as libc::c_int)
        {
            continue;
        }
        *(*maps.offset(glue as isize))
            .offset((lidx / 6 as libc::c_int) as isize) = -(1 as libc::c_int);
        (*(*lgl).stats).promote.locked += 1;
        (*(*lgl).stats).promote.locked;
        npromoted += 1;
        npromoted;
    }
    lglprt(
        lgl,
        2 as libc::c_int,
        b"[reduce-%d] locked %d promoted learned clauses %.0f%%\0" as *const u8
            as *const libc::c_char,
        (*(*lgl).stats).reduced.count,
        npromoted,
        lglpcnt(npromoted as libc::c_double, (*(*lgl).stats).red.lrg as libc::c_double),
    );
    szpagsls = (*(*lgl).stats).red.lrg;
    pagsls = lglnew(
        lgl,
        (szpagsls as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<PAGSL>() as libc::c_ulong),
    ) as *mut PAGSL;
    npagsls = 0 as libc::c_int;
    retired = npagsls;
    glue = 0 as libc::c_int;
    while glue < ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int {
        lir = ((*lgl).red).offset(glue as isize);
        start = (*lir).start;
        c = start;
        while c < (*lir).top {
            let fresh69 = c;
            c = c.offset(1);
            act = *fresh69;
            if act == 2147483647 as libc::c_int {
                p = c;
                while p < (*lir).top && *p == 2147483647 as libc::c_int {
                    p = p.offset(1);
                    p;
                }
                p = p.offset(-1);
                p;
            } else {
                lidx = c.offset_from(start) as libc::c_long as libc::c_int;
                act -= 2147483647 as libc::c_int >> RMSHFT as libc::c_int;
                psm = 0 as libc::c_int;
                p = c;
                loop {
                    lit = *p;
                    if !(lit != 0) {
                        break;
                    }
                    if lgliphase(lgl, lit) as libc::c_int >= 0 as libc::c_int {
                        psm += 1;
                        psm;
                    }
                    p = p.offset(1);
                    p;
                }
                size = p.offset_from(c) as libc::c_long as libc::c_int;
                if !(*(*maps.offset(glue as isize))
                    .offset((lidx / 6 as libc::c_int) as isize) == -(1 as libc::c_int))
                {
                    if retirenb != 0 && act == 0 && glue >= retiremin {
                        retired += 1;
                        retired;
                        *(*maps.offset(glue as isize))
                            .offset(
                                (lidx / 6 as libc::c_int) as isize,
                            ) = -(3 as libc::c_int);
                    } else if glue == 0 && size <= (*(*lgl).opts).gluekeepsize.val {
                        *(*maps.offset(glue as isize))
                            .offset(
                                (lidx / 6 as libc::c_int) as isize,
                            ) = -(1 as libc::c_int);
                    } else {
                        let fresh70 = npagsls;
                        npagsls = npagsls + 1;
                        pagsl = pagsls.offset(fresh70 as isize);
                        (*pagsl).psm = psm;
                        (*pagsl).act = act;
                        (*pagsl).glue = glue;
                        (*pagsl).size = size;
                        (*pagsl).lidx = lidx;
                    }
                }
            }
            c = p.offset(1 as libc::c_int as isize);
        }
        glue += 1;
        glue;
    }
    let mut AA: *mut PAGSL = pagsls;
    let NN: libc::c_int = npagsls;
    let mut L: libc::c_int = 0 as libc::c_int;
    let mut R: libc::c_int = NN - 1 as libc::c_int;
    let mut M: libc::c_int = 0;
    let mut LL: libc::c_int = 0;
    let mut RR: libc::c_int = 0;
    let mut I: libc::c_int = 0;
    if !(R - L <= 10 as libc::c_int) {
        loop {
            M = (L + R) / 2 as libc::c_int;
            let mut TMP: PAGSL = *AA.offset(M as isize);
            *AA.offset(M as isize) = *AA.offset((R - 1 as libc::c_int) as isize);
            *AA.offset((R - 1 as libc::c_int) as isize) = TMP;
            if lglcmpagsl(
                lgl,
                &mut *AA.offset(L as isize),
                &mut *AA.offset((R - 1 as libc::c_int) as isize),
            ) > 0 as libc::c_int
            {
                let mut TMP_0: PAGSL = *AA.offset(L as isize);
                *AA.offset(L as isize) = *AA.offset((R - 1 as libc::c_int) as isize);
                *AA.offset((R - 1 as libc::c_int) as isize) = TMP_0;
            }
            if lglcmpagsl(lgl, &mut *AA.offset(L as isize), &mut *AA.offset(R as isize))
                > 0 as libc::c_int
            {
                let mut TMP_1: PAGSL = *AA.offset(L as isize);
                *AA.offset(L as isize) = *AA.offset(R as isize);
                *AA.offset(R as isize) = TMP_1;
            }
            if lglcmpagsl(
                lgl,
                &mut *AA.offset((R - 1 as libc::c_int) as isize),
                &mut *AA.offset(R as isize),
            ) > 0 as libc::c_int
            {
                let mut TMP_2: PAGSL = *AA.offset((R - 1 as libc::c_int) as isize);
                *AA.offset((R - 1 as libc::c_int) as isize) = *AA.offset(R as isize);
                *AA.offset(R as isize) = TMP_2;
            }
            let mut PIVOT: PAGSL = PAGSL {
                psm: 0,
                act: 0,
                glue: 0,
                size: 0,
                lidx: 0,
            };
            let mut J: libc::c_int = R - 1 as libc::c_int;
            I = L + 1 as libc::c_int - 1 as libc::c_int;
            PIVOT = *AA.offset(J as isize);
            loop {
                loop {
                    I += 1;
                    if !(lglcmpagsl(lgl, &mut *AA.offset(I as isize), &mut PIVOT)
                        < 0 as libc::c_int)
                    {
                        break;
                    }
                }
                loop {
                    J -= 1;
                    if !(lglcmpagsl(lgl, &mut PIVOT, &mut *AA.offset(J as isize))
                        < 0 as libc::c_int)
                    {
                        break;
                    }
                    if J == L + 1 as libc::c_int {
                        break;
                    }
                }
                if I >= J {
                    break;
                }
                let mut TMP_3: PAGSL = *AA.offset(I as isize);
                *AA.offset(I as isize) = *AA.offset(J as isize);
                *AA.offset(J as isize) = TMP_3;
            }
            let mut TMP_4: PAGSL = *AA.offset(I as isize);
            *AA.offset(I as isize) = *AA.offset((R - 1 as libc::c_int) as isize);
            *AA.offset((R - 1 as libc::c_int) as isize) = TMP_4;
            if I - L < R - I {
                LL = I + 1 as libc::c_int;
                RR = R;
                R = I - 1 as libc::c_int;
            } else {
                LL = L;
                RR = I - 1 as libc::c_int;
                L = I + 1 as libc::c_int;
            }
            if R - L > 10 as libc::c_int {
                lglpushstk(lgl, &mut (*lgl).c2rust_unnamed_0.sortstk, LL);
                lglpushstk(lgl, &mut (*lgl).c2rust_unnamed_0.sortstk, RR);
            } else if RR - LL > 10 as libc::c_int {
                L = LL;
                R = RR;
            } else {
                if !(lglmtstk(&mut (*lgl).c2rust_unnamed_0.sortstk) == 0) {
                    break;
                }
                R = lglpopstk(&mut (*lgl).c2rust_unnamed_0.sortstk);
                L = lglpopstk(&mut (*lgl).c2rust_unnamed_0.sortstk);
            }
        }
    }
    let mut PIVOT_0: PAGSL = PAGSL {
        psm: 0,
        act: 0,
        glue: 0,
        size: 0,
        lidx: 0,
    };
    let mut L_0: libc::c_int = 0 as libc::c_int;
    let mut R_0: libc::c_int = NN - 1 as libc::c_int;
    let mut I_0: libc::c_int = 0;
    let mut J_0: libc::c_int = 0;
    I_0 = R_0;
    while I_0 > L_0 {
        if lglcmpagsl(
            lgl,
            &mut *AA.offset((I_0 - 1 as libc::c_int) as isize),
            &mut *AA.offset(I_0 as isize),
        ) > 0 as libc::c_int
        {
            let mut TMP_5: PAGSL = *AA.offset((I_0 - 1 as libc::c_int) as isize);
            *AA.offset((I_0 - 1 as libc::c_int) as isize) = *AA.offset(I_0 as isize);
            *AA.offset(I_0 as isize) = TMP_5;
        }
        I_0 -= 1;
        I_0;
    }
    I_0 = L_0 + 2 as libc::c_int;
    while I_0 <= R_0 {
        J_0 = I_0;
        PIVOT_0 = *AA.offset(I_0 as isize);
        while lglcmpagsl(
            lgl,
            &mut PIVOT_0,
            &mut *AA.offset((J_0 - 1 as libc::c_int) as isize),
        ) < 0 as libc::c_int
        {
            *AA.offset(J_0 as isize) = *AA.offset((J_0 - 1 as libc::c_int) as isize);
            J_0 -= 1;
            J_0;
        }
        *AA.offset(J_0 as isize) = PIVOT_0;
        I_0 += 1;
        I_0;
    }
    nkeep = 0 as libc::c_int;
    idx = target;
    while idx < npagsls {
        pagsl = pagsls.offset(idx as isize);
        lidx = (*pagsl).lidx;
        glue = (*pagsl).glue;
        *(*maps.offset(glue as isize))
            .offset((lidx / 6 as libc::c_int) as isize) = -(1 as libc::c_int);
        nkeep += 1;
        nkeep;
        idx += 1;
        idx;
    }
    lgldel(
        lgl,
        pagsls as *mut libc::c_void,
        (szpagsls as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<PAGSL>() as libc::c_ulong),
    );
    pagsls = 0 as *mut PAGSL;
    sumretired = 0 as libc::c_int;
    sumcollected = sumretired;
    glue = 0 as libc::c_int;
    while glue < ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int {
        lir = ((*lgl).red).offset(glue as isize);
        map = *maps.offset(glue as isize);
        start = (*lir).start;
        q = start;
        retired = 0 as libc::c_int;
        collected = retired;
        c = start;
        while c < (*lir).top {
            let fresh71 = c;
            c = c.offset(1);
            act = *fresh71;
            if act == 2147483647 as libc::c_int {
                p = c;
                while p < (*lir).top && *p == 2147483647 as libc::c_int {
                    p = p.offset(1);
                    p;
                }
                p = p.offset(-1);
                p;
            } else {
                p = c;
                src = (c.offset_from(start) as libc::c_long
                    / 6 as libc::c_int as libc::c_long) as libc::c_int;
                if *map.offset(src as isize) <= -(2 as libc::c_int) {
                    if *map.offset(src as isize) == -(2 as libc::c_int) {
                        collected += 1;
                        collected;
                    } else {
                        retired += 1;
                        retired;
                    }
                    lgldrupligdelclsaux(lgl, c);
                    while *p != 0 {
                        p = p.offset(1);
                        p;
                    }
                } else {
                    dst = (q.offset_from(start) as libc::c_long
                        + 1 as libc::c_int as libc::c_long) as libc::c_int;
                    *map.offset(src as isize) = dst;
                    if p == q {
                        while *p != 0 {
                            p = p.offset(1);
                            p;
                        }
                        q = p.offset(1 as libc::c_int as isize);
                    } else {
                        let fresh72 = q;
                        q = q.offset(1);
                        *fresh72 = act;
                        while *p != 0 {
                            let fresh73 = p;
                            p = p.offset(1);
                            let fresh74 = q;
                            q = q.offset(1);
                            *fresh74 = *fresh73;
                        }
                        let fresh75 = q;
                        q = q.offset(1);
                        *fresh75 = 0 as libc::c_int;
                    }
                }
            }
            c = p.offset(1 as libc::c_int as isize);
        }
        (*(*lgl).stats).lir[glue as usize].clauses -= collected + retired;
        (*(*lgl).stats).lir[glue as usize].reduced += collected as int64_t;
        (*(*lgl).stats).lir[glue as usize].retired += retired as int64_t;
        sumcollected += collected;
        sumretired += retired;
        (*lir).top = q;
        lglfitlir(lgl, lir);
        glue += 1;
        glue;
    }
    lglprt(
        lgl,
        2 as libc::c_int,
        b"[reduce-%d] collected %d clauses %.0f%%, retired %d clauses %.0f%%\0"
            as *const u8 as *const libc::c_char,
        (*(*lgl).stats).reduced.count,
        sumcollected,
        lglpcnt(
            sumcollected as libc::c_double,
            (*(*lgl).stats).red.lrg as libc::c_double,
        ),
        sumretired,
        lglpcnt(sumretired as libc::c_double, (*(*lgl).stats).red.lrg as libc::c_double),
    );
    (*(*lgl).stats).red.lrg -= sumcollected + sumretired;
    (*(*lgl).stats).reduced.collected += sumcollected as int64_t;
    (*(*lgl).stats).reduced.retired += sumretired as int64_t;
    nunlocked = 0 as libc::c_int;
    idx = 2 as libc::c_int;
    while idx < (*lgl).nvars {
        if !(lglval(lgl, idx) == 0) {
            rsn = lglrsn(lgl, idx);
            r0 = *rsn.offset(0 as libc::c_int as isize);
            red = r0 & REDCS as libc::c_int;
            if !(red == 0) {
                tag = r0 & MASKCS as libc::c_int;
                if !(tag != LRGCS as libc::c_int) {
                    lidx = *rsn.offset(1 as libc::c_int as isize);
                    glue = lidx
                        & ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int;
                    if !(glue
                        == ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int)
                    {
                        src = lidx >> 4 as libc::c_int;
                        dst = *(*maps.offset(glue as isize))
                            .offset((src / 6 as libc::c_int) as isize);
                        dst <<= 4 as libc::c_int;
                        dst
                            |= lidx
                                & ((1 as libc::c_int) << 4 as libc::c_int)
                                    - 1 as libc::c_int;
                        *rsn.offset(1 as libc::c_int as isize) = dst;
                        nunlocked += 1;
                        nunlocked;
                    }
                }
            }
        }
        idx += 1;
        idx;
    }
    moved = 0 as libc::c_int;
    collected = moved;
    idx = 2 as libc::c_int;
    while idx < (*lgl).nvars {
        dv = lgldvar(lgl, idx);
        i = 0 as libc::c_int;
        while i <= 1 as libc::c_int {
            hts = ((*dv).hts).as_mut_ptr().offset(i as isize);
            if !((*hts).offset == 0) {
                q = lglhts2wchs(lgl, hts);
                eow = q.offset((*hts).count as isize);
                p = q;
                while p < eow {
                    blit = *p;
                    red = blit & REDCS as libc::c_int;
                    tag = blit & MASKCS as libc::c_int;
                    if red != 0 && tag == LRGCS as libc::c_int {
                        p = p.offset(1);
                        lidx = *p;
                        glue = lidx
                            & ((1 as libc::c_int) << 4 as libc::c_int)
                                - 1 as libc::c_int;
                        if glue
                            == ((1 as libc::c_int) << 4 as libc::c_int)
                                - 1 as libc::c_int
                        {
                            dst = lidx >> 4 as libc::c_int;
                        } else {
                            src = lidx >> 4 as libc::c_int;
                            dst = *(*maps.offset(glue as isize))
                                .offset((src / 6 as libc::c_int) as isize);
                        }
                        if dst >= 0 as libc::c_int {
                            moved += 1;
                            moved;
                            let fresh76 = q;
                            q = q.offset(1);
                            *fresh76 = blit;
                            let fresh77 = q;
                            q = q.offset(1);
                            *fresh77 = dst << 4 as libc::c_int
                                | lidx
                                    & ((1 as libc::c_int) << 4 as libc::c_int)
                                        - 1 as libc::c_int;
                        } else {
                            collected += 1;
                            collected;
                        }
                    } else {
                        let fresh78 = q;
                        q = q.offset(1);
                        *fresh78 = blit;
                        if tag != BINCS as libc::c_int {
                            p = p.offset(1);
                            let fresh79 = q;
                            q = q.offset(1);
                            *fresh79 = *p;
                        }
                    }
                    p = p.offset(1);
                    p;
                }
                lglshrinkhts(
                    lgl,
                    hts,
                    ((*hts).count as libc::c_long - p.offset_from(q) as libc::c_long)
                        as libc::c_int,
                );
            }
            i += 1;
            i;
        }
        idx += 1;
        idx;
    }
    glue = 0 as libc::c_int;
    while glue < ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int {
        lgldel(
            lgl,
            *maps.offset(glue as isize) as *mut libc::c_void,
            (*sizes.offset(glue as isize) as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
        );
        let ref mut fresh80 = *maps.offset(glue as isize);
        *fresh80 = 0 as *mut libc::c_int;
        glue += 1;
        glue;
    }
    lgldel(
        lgl,
        sizes as *mut libc::c_void,
        ((((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int) as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
    );
    sizes = 0 as *mut libc::c_int;
    lgldel(
        lgl,
        maps as *mut libc::c_void,
        ((((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int) as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<*mut libc::c_int>() as libc::c_ulong),
    );
    maps = 0 as *mut *mut libc::c_int;
    if !((*(*lgl).opts).reducefixed.val != 0) {
        if (*(*lgl).limits).reduce.reset == 0 {
            (*(*lgl).limits).reduce.reset = 1 as libc::c_int;
        }
        if (*(*lgl).stats).reduced.count >= (*(*lgl).limits).reduce.reset {
            (*(*lgl).limits).reduce.reset <<= 1 as libc::c_int;
        }
        if (*(*lgl).opts).reducereset.val == 1 as libc::c_int
            && lglispow2((*(*lgl).stats).reduced.count) != 0
            || (*(*lgl).opts).reducereset.val == 2 as libc::c_int
                && lglispow2(
                    (*(*lgl).stats).reduced.count
                        & (*(*lgl).stats).reduced.count - 1 as libc::c_int,
                ) != 0
        {
            (*(*lgl).limits).reduce.redlarge = 0 as libc::c_int;
            inc = (*(*lgl).opts).reduceinc.val;
            (*(*lgl).stats).reduced.reset += 1;
            (*(*lgl).stats).reduced.reset;
            lglprt(
                lgl,
                2 as libc::c_int,
                b"[reduce-%d] reset\0" as *const u8 as *const libc::c_char,
                (*(*lgl).stats).reduced.count,
            );
        } else if lglmemout(lgl) != 0 {
            inc = 0 as libc::c_int;
            lglprt(
                lgl,
                2 as libc::c_int,
                b"[reduce-%d] no increase of reduce limit since memory limit was hit\0"
                    as *const u8 as *const libc::c_char,
                (*(*lgl).stats).reduced.count,
            );
            (*(*lgl).stats).reduced.memlim += 1;
            (*(*lgl).stats).reduced.memlim;
        } else {
            inc = (*(*lgl).opts).reduceinc.val;
            lglprt(
                lgl,
                2 as libc::c_int,
                b"[reduce-%d] increase of reduce limit by %d to %d\0" as *const u8
                    as *const libc::c_char,
                (*(*lgl).stats).reduced.count,
                inc,
                (*(*lgl).limits).reduce.redlarge + inc,
            );
            (*(*lgl).stats).reduced.arith += 1;
            (*(*lgl).stats).reduced.arith;
        }
        (*(*lgl).limits).reduce.redlarge += inc;
    }
    lglrelstk(lgl, &mut (*lgl).learned);
    lglrep(lgl, 1 as libc::c_int, type_0);
    lglchkred(lgl);
    lglstop(lgl);
}
#[no_mangle]
pub unsafe extern "C" fn lglreducecache(mut lgl: *mut LGL) {
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<
                &[u8; 15],
                &[libc::c_char; 15],
            >(b"lglreducecache\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).forked == 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<
                &[u8; 15],
                &[libc::c_char; 15],
            >(b"lglreducecache\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"forked manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if !((*lgl).apitrace).is_null() {
        lgltrapi(lgl, b"reduce\0" as *const u8 as *const libc::c_char);
    }
    if (*lgl).mt != 0 {
        return;
    }
    lglinitredl(lgl);
    lglreduce(lgl, 1 as libc::c_int);
    lglinitredl(lgl);
    lglprt(
        lgl,
        1 as libc::c_int,
        b"[reduce-cache] new limit %d\0" as *const u8 as *const libc::c_char,
        (*(*lgl).limits).reduce.redlarge,
    );
    if !((*lgl).clone).is_null() {
        lglreducecache((*lgl).clone);
    }
}
unsafe extern "C" fn lgliflushcache(mut lgl: *mut LGL, mut keep: libc::c_int) {
    let mut idx: libc::c_int = 0;
    let mut sign: libc::c_int = 0;
    let mut lit: libc::c_int = 0;
    let mut blit: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut red: libc::c_int = 0;
    let mut w: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut q: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut lidx: libc::c_int = 0;
    let mut glue: libc::c_int = 0;
    let druplig: libc::c_int = (*(*lgl).opts).druplig.val;
    let mut bin: libc::c_int = 0;
    let mut trn: libc::c_int = 0;
    let mut lrg: libc::c_int = 0;
    let mut start: libc::c_int = 0;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut eow: *const libc::c_int = 0 as *const libc::c_int;
    let mut hts: *mut HTS = 0 as *mut HTS;
    if (*lgl).level != 0 {
        lglbacktrack(lgl, 0 as libc::c_int);
    }
    lrg = 0 as libc::c_int;
    trn = lrg;
    bin = trn;
    idx = 2 as libc::c_int;
    while idx < (*lgl).nvars {
        sign = -(1 as libc::c_int);
        while sign <= 1 as libc::c_int {
            lit = sign * idx;
            hts = lglhts(lgl, lit);
            w = lglhts2wchs(lgl, hts);
            eow = w.offset((*hts).count as isize);
            q = w;
            let mut current_block_36: u64;
            p = q;
            while p < eow {
                blit = *p;
                tag = blit & MASKCS as libc::c_int;
                if tag == TRNCS as libc::c_int || tag == LRGCS as libc::c_int {
                    p = p.offset(1);
                    p;
                }
                red = blit & REDCS as libc::c_int;
                if red != 0 {
                    if tag == BINCS as libc::c_int {
                        if keep < 2 as libc::c_int {
                            if druplig != 0 {
                                let mut other: libc::c_int = blit >> RMSHFT as libc::c_int;
                                if idx < abs(other) {
                                    lgldrupligdelclsarg(lgl, lit, other, 0 as libc::c_int);
                                }
                            }
                            current_block_36 = 7651349459974463963;
                        } else {
                            current_block_36 = 572715077006366937;
                        }
                    } else if tag == TRNCS as libc::c_int {
                        if keep < 3 as libc::c_int {
                            if druplig != 0 {
                                let mut other_0: libc::c_int = blit
                                    >> RMSHFT as libc::c_int;
                                if idx < abs(other_0) {
                                    let mut other2: libc::c_int = *p;
                                    if idx < abs(other2) {
                                        lgldrupligdelclsarg(
                                            lgl,
                                            lit,
                                            other_0,
                                            other2,
                                            0 as libc::c_int,
                                        );
                                    }
                                }
                            }
                            current_block_36 = 7651349459974463963;
                        } else {
                            current_block_36 = 572715077006366937;
                        }
                    } else {
                        lidx = *p;
                        glue = lidx
                            & ((1 as libc::c_int) << 4 as libc::c_int)
                                - 1 as libc::c_int;
                        if keep < 4 as libc::c_int || glue > 0 as libc::c_int {
                            if druplig != 0 {
                                let mut c: *const libc::c_int = lglidx2lits(lgl, red, lidx);
                                if *c == lit {
                                    lgldrupligdelclsaux(lgl, c);
                                }
                            }
                            current_block_36 = 7651349459974463963;
                        } else {
                            current_block_36 = 572715077006366937;
                        }
                    }
                } else {
                    current_block_36 = 572715077006366937;
                }
                match current_block_36 {
                    572715077006366937 => {
                        let fresh81 = q;
                        q = q.offset(1);
                        *fresh81 = blit;
                        if tag == TRNCS as libc::c_int || tag == LRGCS as libc::c_int {
                            let fresh82 = q;
                            q = q.offset(1);
                            *fresh82 = *p;
                        }
                    }
                    _ => {}
                }
                p = p.offset(1);
                p;
            }
            lglshrinkhts(lgl, hts, q.offset_from(w) as libc::c_long as libc::c_int);
            sign += 2 as libc::c_int;
        }
        idx += 1;
        idx;
    }
    if keep < 2 as libc::c_int {
        bin = (*(*lgl).stats).red.bin;
        (*(*lgl).stats).red.bin = 0 as libc::c_int;
    }
    if keep < 3 as libc::c_int {
        trn = (*(*lgl).stats).red.trn;
        (*(*lgl).stats).red.trn = 0 as libc::c_int;
    }
    start = (keep >= 4 as libc::c_int) as libc::c_int;
    glue = start;
    while glue < ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int {
        lrg += (*(*lgl).stats).lir[glue as usize].clauses;
        (*(*lgl).stats).lir[glue as usize].clauses = 0 as libc::c_int;
        glue += 1;
        glue;
    }
    (*(*lgl).stats).red.lrg -= lrg;
    lglrelstk(lgl, &mut (*lgl).learned);
    glue = start;
    while glue < ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int {
        lglrelstk(lgl, ((*lgl).red).offset(glue as isize));
        glue += 1;
        glue;
    }
    lglprt(
        lgl,
        1 as libc::c_int,
        b"[flush-cache] %d binary, %d ternary, %d large\0" as *const u8
            as *const libc::c_char,
        bin,
        trn,
        lrg,
    );
}
#[no_mangle]
pub unsafe extern "C" fn lglflushcache(mut lgl: *mut LGL) {
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<
                &[u8; 14],
                &[libc::c_char; 14],
            >(b"lglflushcache\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).forked == 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<
                &[u8; 14],
                &[libc::c_char; 14],
            >(b"lglflushcache\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"forked manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if !((*lgl).apitrace).is_null() {
        lgltrapi(lgl, b"flush\0" as *const u8 as *const libc::c_char);
    }
    if (*lgl).mt != 0 {
        return;
    }
    lglinitredl(lgl);
    lgliflushcache(lgl, 3 as libc::c_int);
    lglinitscores(lgl);
    lglinitredl(lgl);
    lglprt(
        lgl,
        1 as libc::c_int,
        b"[flush-cache] new limit %d\0" as *const u8 as *const libc::c_char,
        (*(*lgl).limits).reduce.redlarge,
    );
    if !((*lgl).clone).is_null() {
        lglflushcache((*lgl).clone);
    }
}
unsafe extern "C" fn lglrmbwch(
    mut lgl: *mut LGL,
    mut lit: libc::c_int,
    mut other: libc::c_int,
    mut red: libc::c_int,
) {
    let mut p: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut blit: libc::c_int = 0;
    let mut blit1: libc::c_int = 0;
    let mut w: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut eow: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tag: libc::c_int = 0;
    let mut hts: *mut HTS = 0 as *mut HTS;
    hts = lglhts(lgl, lit);
    w = lglhts2wchs(lgl, hts);
    p = w;
    eow = w.offset((*hts).count as isize);
    lglrminc(lgl, w, eow);
    blit1 = ((other as libc::c_uint) << RMSHFT as libc::c_int) as libc::c_int | red
        | BINCS as libc::c_int;
    loop {
        let fresh83 = p;
        p = p.offset(1);
        blit = *fresh83;
        tag = blit & MASKCS as libc::c_int;
        if tag == TRNCS as libc::c_int || tag == LRGCS as libc::c_int {
            p = p.offset(1);
            p;
        } else {
            if tag == OCCS as libc::c_int {
                continue;
            }
            if blit == blit1 {
                break;
            }
        }
    }
    while p < eow {
        *p.offset(-(1 as libc::c_int) as isize) = *p.offset(0 as libc::c_int as isize);
        p = p.offset(1);
        p;
    }
    lglshrinkhts(
        lgl,
        hts,
        (p.offset_from(w) as libc::c_long - 1 as libc::c_int as libc::c_long)
            as libc::c_int,
    );
}
unsafe extern "C" fn lglpopesched(mut lgl: *mut LGL) -> libc::c_int {
    let mut s: *mut Stk = &mut (*lgl).esched;
    let mut res: libc::c_int = 0;
    let mut last: libc::c_int = 0;
    let mut cnt: libc::c_int = 0;
    let mut p: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut ev: *mut EVar = 0 as *mut EVar;
    res = *(*s).start;
    ev = lglevar(lgl, res);
    (*ev).pos = -(1 as libc::c_int);
    last = lglpopstk(s);
    cnt = lglcntstk(s) as libc::c_int;
    if cnt == 0 {
        return res;
    }
    p = lglepos(lgl, last);
    *p = 0 as libc::c_int;
    *(*s).start = last;
    lgledown(lgl, last);
    return res;
}
unsafe extern "C" fn lgldecocc(mut lgl: *mut LGL, mut lit: libc::c_int) {
    let mut idx: libc::c_int = 0;
    let mut sign: libc::c_int = 0;
    let mut change: libc::c_int = 0;
    let mut ev: *mut EVar = 0 as *mut EVar;
    if (*lgl).occs == 0 {
        return;
    }
    idx = abs(lit);
    sign = (lit < 0 as libc::c_int) as libc::c_int;
    ev = lglevar(lgl, lit);
    (*ev).occ[sign as usize] -= 1 as libc::c_int;
    if lglisfree(lgl, lit) == 0 {
        return;
    }
    change = lglecalc(lgl, ev);
    if (*ev).pos < 0 as libc::c_int {
        lglesched(lgl, idx);
    } else if change < 0 as libc::c_int {
        lgleup(lgl, idx);
    } else if change > 0 as libc::c_int {
        lgledown(lgl, idx);
    }
}
unsafe extern "C" fn lglrmbcls(
    mut lgl: *mut LGL,
    mut a: libc::c_int,
    mut b: libc::c_int,
    mut red: libc::c_int,
) {
    lglrmbwch(lgl, a, b, red);
    lglrmbwch(lgl, b, a, red);
    lgldeclscnt(lgl, 2 as libc::c_int, red, 0 as libc::c_int);
    if red == 0 && (*lgl).dense as libc::c_int != 0 {
        lgldecocc(lgl, a);
        lgldecocc(lgl, b);
    }
}
unsafe extern "C" fn lglrmtcls(
    mut lgl: *mut LGL,
    mut a: libc::c_int,
    mut b: libc::c_int,
    mut c: libc::c_int,
    mut red: libc::c_int,
) {
    lglrmtwch(lgl, a, b, c, red);
    lglrmtwch(lgl, b, a, c, red);
    lglrmtwch(lgl, c, a, b, red);
    lgldeclscnt(lgl, 3 as libc::c_int, red, 0 as libc::c_int);
    if red == 0 && (*lgl).dense as libc::c_int != 0 {
        lgldecocc(lgl, a);
        lgldecocc(lgl, b);
        lgldecocc(lgl, c);
    }
}
unsafe extern "C" fn lgltrimlitstk(
    mut lgl: *mut LGL,
    mut red: libc::c_int,
    mut lidx: libc::c_int,
) {
    let mut s: *mut Stk = 0 as *mut Stk;
    let mut p: *mut libc::c_int = 0 as *mut libc::c_int;
    if (*lgl).notrim != 0 {
        return;
    }
    s = lglidx2stk(lgl, red, lidx);
    p = (*s).top;
    while p > (*s).start
        && *p.offset(-(1 as libc::c_int) as isize) == 2147483647 as libc::c_int
    {
        p = p.offset(-1);
        p;
    }
    if p < (*s).top {
        let mut trimmed: int64_t = ((*s).top).offset_from(p) as libc::c_long;
        (*(*lgl).stats).trims += trimmed;
        (*s).top = p;
        if red != 0 {
            let mut glue: libc::c_int = lidx
                & ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int;
            let mut maxlidx: libc::c_int = 0;
            maxlidx = (lglcntstk(s) << 4 as libc::c_int | glue as size_t) as libc::c_int;
            p = (*lgl).learned.start;
            while p < (*lgl).learned.top {
                let mut olidx: libc::c_int = *p;
                let mut oglue: libc::c_int = olidx
                    & ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int;
                if oglue == glue && olidx >= maxlidx {
                    *p = -(2147483647 as libc::c_int) - 1 as libc::c_int;
                }
                p = p.offset(3 as libc::c_int as isize);
            }
        }
    }
}
unsafe extern "C" fn lglrmlcls(
    mut lgl: *mut LGL,
    mut lidx: libc::c_int,
    mut red: libc::c_int,
) {
    let mut c: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut p: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut glue: libc::c_int = 0;
    let mut lit: libc::c_int = 0;
    glue = if red != 0 {
        lidx & ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int
    } else {
        0 as libc::c_int
    };
    c = lglidx2lits(lgl, red, lidx);
    if red == 0 || glue < ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int {
        lglrmlwch(lgl, *c.offset(0 as libc::c_int as isize), red, lidx);
        lglrmlwch(lgl, *c.offset(1 as libc::c_int as isize), red, lidx);
    }
    if red == 0 && (*lgl).dense as libc::c_int != 0 {
        p = c;
        loop {
            lit = *p;
            if !(lit != 0) {
                break;
            }
            lglrmlocc(lgl, lit, red, lidx);
            lgldecocc(lgl, lit);
            p = p.offset(1);
            p;
        }
    }
    if red != 0 && glue < ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int {
        *c.offset(-(1 as libc::c_int) as isize) = 2147483647 as libc::c_int;
    }
    p = c;
    while *p != 0 {
        *p = 2147483647 as libc::c_int;
        p = p.offset(1);
        p;
    }
    *p = 2147483647 as libc::c_int;
    if glue != ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int {
        lgldeclscnt(lgl, p.offset_from(c) as libc::c_long as libc::c_int, red, glue);
    }
    lgltrimlitstk(lgl, red, lidx);
}
unsafe extern "C" fn lgldynsub(
    mut lgl: *mut LGL,
    mut lit: libc::c_int,
    mut r0: libc::c_int,
    mut r1: libc::c_int,
) {
    let mut red: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut other2: libc::c_int = 0;
    let mut c: *const libc::c_int = 0 as *const libc::c_int;
    tag = r0 & MASKCS as libc::c_int;
    red = r0 & REDCS as libc::c_int;
    if red != 0 {
        (*(*lgl).stats).otfs.sub.red += 1;
        (*(*lgl).stats).otfs.sub.red;
    } else {
        (*(*lgl).stats).otfs.sub.irr += 1;
        (*(*lgl).stats).otfs.sub.irr;
    }
    if tag == BINCS as libc::c_int {
        (*(*lgl).stats).otfs.sub.bin += 1;
        (*(*lgl).stats).otfs.sub.bin;
        other = r0 >> RMSHFT as libc::c_int;
        lgldrupligdelclsarg(lgl, lit, other, 0 as libc::c_int);
        lglrmbcls(lgl, lit, other, red);
    } else if tag == TRNCS as libc::c_int {
        (*(*lgl).stats).otfs.sub.trn += 1;
        (*(*lgl).stats).otfs.sub.trn;
        other = r0 >> RMSHFT as libc::c_int;
        other2 = r1;
        lgldrupligdelclsarg(lgl, lit, other, other2, 0 as libc::c_int);
        lglrmtcls(lgl, lit, other, other2, red);
    } else {
        (*(*lgl).stats).otfs.sub.lrg += 1;
        (*(*lgl).stats).otfs.sub.lrg;
        c = lglidx2lits(lgl, red, r1);
        lgldrupligdelclsaux(lgl, c);
        lglrmlcls(lgl, r1, red);
    };
}
unsafe extern "C" fn lglunflict(mut lgl: *mut LGL, mut lit: libc::c_int) {
    (*lgl).conf.lit = lit;
    (*lgl)
        .conf
        .rsn[0 as libc::c_int
        as usize] = ((lit as libc::c_uint) << RMSHFT as libc::c_int) as libc::c_int
        | UNITCS as libc::c_int;
}
unsafe extern "C" fn lgldynstr(
    mut lgl: *mut LGL,
    mut del: libc::c_int,
    mut lit: libc::c_int,
    mut r0: libc::c_int,
    mut r1: libc::c_int,
) {
    let mut p: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut c: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut lidx: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut red: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut glue: libc::c_int = 0;
    let mut other2: libc::c_int = 0;
    let mut other3: libc::c_int = 0;
    let mut blit: libc::c_int = 0;
    tag = r0 & MASKCS as libc::c_int;
    red = r0 & REDCS as libc::c_int;
    if red != 0 {
        (*(*lgl).stats).otfs.str_0.red += 1;
        (*(*lgl).stats).otfs.str_0.red;
    } else {
        (*(*lgl).stats).otfs.str_0.irr += 1;
        (*(*lgl).stats).otfs.str_0.irr;
    }
    (*(*lgl).stats).otfs.total += 1;
    (*(*lgl).stats).otfs.total;
    (*(*lgl).stats).prgss += 1;
    (*(*lgl).stats).prgss;
    if red == 0 {
        (*(*lgl).stats).irrprgss += 1;
        (*(*lgl).stats).irrprgss;
    }
    if tag == BINCS as libc::c_int {
        (*(*lgl).stats).otfs.str_0.bin += 1;
        (*(*lgl).stats).otfs.str_0.bin;
        other = if del == lit { r0 >> RMSHFT as libc::c_int } else { lit };
        lgldrupligaddclsarg(lgl, REDCS as libc::c_int, other, 0 as libc::c_int);
        lgldrupligdelclsarg(lgl, del, other, 0 as libc::c_int);
        lglrmbcls(lgl, del, other, red);
        lglunflict(lgl, other);
        return;
    }
    if tag == TRNCS as libc::c_int {
        (*(*lgl).stats).otfs.str_0.trn += 1;
        (*(*lgl).stats).otfs.str_0.trn;
        if lit == del {
            other = r0 >> RMSHFT as libc::c_int;
            other2 = r1;
        } else if del == r1 {
            other = lit;
            other2 = r0 >> RMSHFT as libc::c_int;
        } else {
            other = lit;
            other2 = r1;
        }
        lgldrupligaddclsarg(lgl, REDCS as libc::c_int, other, other2, 0 as libc::c_int);
        lgldrupligdelclsarg(lgl, del, other, other2, 0 as libc::c_int);
        lglrmtcls(lgl, del, other, other2, red);
        if red == 0 {
            lglincirr(lgl, 2 as libc::c_int);
        } else {
            (*(*lgl).stats).red.bin += 1;
            (*(*lgl).stats).red.bin;
        }
        lglwchbin(lgl, other, other2, red);
        lglwchbin(lgl, other2, other, red);
        if lglevel(lgl, other) < lglevel(lgl, other2) {
            let mut TMP: libc::c_int = other;
            other = other2;
            other2 = TMP;
        }
        blit = ((other2 as libc::c_uint) << RMSHFT as libc::c_int) as libc::c_int
            | BINCS as libc::c_int | red;
        lglbonflict(lgl, other, blit);
        return;
    }
    (*(*lgl).stats).otfs.str_0.lrg += 1;
    (*(*lgl).stats).otfs.str_0.lrg;
    lidx = r1;
    glue = if red != 0 {
        lidx & ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int
    } else {
        0 as libc::c_int
    };
    c = lglidx2lits(lgl, red, lidx);
    p = c;
    while *p != del {
        p = p.offset(1);
        p;
    }
    if glue < ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int {
        lglrmlwch(lgl, *c.offset(0 as libc::c_int as isize), red, lidx);
        lglrmlwch(lgl, *c.offset(1 as libc::c_int as isize), red, lidx);
    }
    loop {
        p = p.offset(1);
        other = *p;
        if !(other != 0) {
            break;
        }
        *p.offset(-(1 as libc::c_int) as isize) = other;
    }
    *p.offset(-(1 as libc::c_int) as isize) = 0 as libc::c_int;
    *p = 2147483647 as libc::c_int;
    lgltrimlitstk(lgl, red, lidx);
    if red == 0 {
        (*(*lgl).stats).irr.lits.cur -= 1;
        (*(*lgl).stats).irr.lits.cur;
    }
    lglorderclsaux(lgl, c.offset(0 as libc::c_int as isize));
    lglorderclsaux(lgl, c.offset(1 as libc::c_int as isize));
    lgldrupligaddclsaux(lgl, REDCS as libc::c_int, c);
    if p.offset_from(c) as libc::c_long == 4 as libc::c_int as libc::c_long {
        other = *c.offset(0 as libc::c_int as isize);
        other2 = *c.offset(1 as libc::c_int as isize);
        other3 = *c.offset(2 as libc::c_int as isize);
        if red != 0 && glue < ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int
        {
            *c.offset(-(1 as libc::c_int) as isize) = 2147483647 as libc::c_int;
        }
        let ref mut fresh84 = *c.offset(3 as libc::c_int as isize);
        *fresh84 = 2147483647 as libc::c_int;
        let ref mut fresh85 = *c.offset(2 as libc::c_int as isize);
        *fresh85 = *fresh84;
        let ref mut fresh86 = *c.offset(1 as libc::c_int as isize);
        *fresh86 = *fresh85;
        *c.offset(0 as libc::c_int as isize) = *fresh86;
        lgltrimlitstk(lgl, red, lidx);
        if lglevel(lgl, other2) < lglevel(lgl, other3) {
            let mut TMP_0: libc::c_int = other2;
            other2 = other3;
            other3 = TMP_0;
        }
        if lglevel(lgl, other) < lglevel(lgl, other2) {
            let mut TMP_1: libc::c_int = other;
            other = other2;
            other2 = TMP_1;
        }
        lglwchtrn(lgl, other, other2, other3, red);
        lglwchtrn(lgl, other2, other, other3, red);
        lglwchtrn(lgl, other3, other, other2, red);
        if red != 0 {
            if glue < ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int {
                (*(*lgl).stats).red.lrg -= 1;
                (*(*lgl).stats).red.lrg;
                (*(*lgl).stats).lir[glue as usize].clauses -= 1;
                (*(*lgl).stats).lir[glue as usize].clauses;
            }
            (*(*lgl).stats).red.trn += 1;
            (*(*lgl).stats).red.trn;
        }
        lgltonflict(
            lgl,
            other,
            ((other2 as libc::c_uint) << RMSHFT as libc::c_int) as libc::c_int | red
                | TRNCS as libc::c_int,
            other3,
        );
    } else {
        if glue < ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int {
            lglwchlrg(
                lgl,
                *c.offset(0 as libc::c_int as isize),
                *c.offset(1 as libc::c_int as isize),
                red,
                lidx,
            );
            lglwchlrg(
                lgl,
                *c.offset(1 as libc::c_int as isize),
                *c.offset(0 as libc::c_int as isize),
                red,
                lidx,
            );
        }
        lglonflict(
            lgl,
            0 as libc::c_int,
            *c.offset(0 as libc::c_int as isize),
            red,
            lidx,
        );
    };
}
unsafe extern "C" fn lglclnframes(mut lgl: *mut LGL) {
    while lglmtstk(&mut (*lgl).frames) == 0 {
        lglunuselevel(lgl, lglpopstk(&mut (*lgl).frames));
    }
}
unsafe extern "C" fn lglclnpoisoned(mut lgl: *mut LGL) {
    while lglmtstk(&mut (*lgl).poisoned) == 0 {
        let mut lit: libc::c_int = lglpopstk(&mut (*lgl).poisoned);
        let mut av: *mut AVar = lglavar(lgl, lit);
        (*av).set_poisoned(0 as libc::c_int as libc::c_uint);
    }
}
unsafe extern "C" fn lglclnana(mut lgl: *mut LGL) {
    lglclnstk(&mut (*lgl).clause);
    lglpopnunmarkstk(lgl, &mut (*lgl).seen);
    lglclnframes(lgl);
}
unsafe extern "C" fn lglbumpdlit(mut lgl: *mut LGL, mut lit: libc::c_int) {
    let mut idx: libc::c_int = abs(lit);
    let mut mightneedtorescore: libc::c_int = 0 as libc::c_int;
    let mut qv: *mut QVar = lglqvar(lgl, idx);
    let mut oldscore: Flt = 0;
    let mut newscore: Flt = 0;
    if (*lgl).simp as libc::c_int != 0 && (*(*lgl).opts).bumpsimp.val == 0 {
        return;
    }
    if (*qv).enqueued() != 0 {
        lglpoke(&mut (*lgl).queue.stk, (*qv).pos, 0 as libc::c_int);
        (*lgl).queue.mt += 1;
        (*lgl).queue.mt;
        (*qv).set_enqueued(0 as libc::c_int as libc::c_uint);
        (*qv).pos = -(1 as libc::c_int);
        if lglval(lgl, lit) == 0 {
            lgldsched(lgl, idx);
        }
    }
    oldscore = (*qv).score;
    newscore = lgladdflt(oldscore, (*lgl).scinc);
    mightneedtorescore = 1 as libc::c_int;
    (*qv).score = newscore;
    if lgldscheduled(lgl, idx) != 0 {
        lgldup(lgl, idx);
    }
    if mightneedtorescore != 0 && newscore >= (*lgl).maxscore {
        lglrescorevars(lgl);
    }
}
unsafe extern "C" fn lglbumpreasonlit(mut lgl: *mut LGL, mut lit: libc::c_int) {
    let mut av: *mut AVar = lglavar(lgl, lit);
    if (*av).mark != 0 {
        return;
    }
    if lglevel(lgl, lit) == 0 {
        return;
    }
    (*av).mark = 1 as libc::c_int;
    lglpushstk(lgl, &mut (*lgl).seen, lit);
}
unsafe extern "C" fn lglbumpreason(mut lgl: *mut LGL, mut lit: libc::c_int) {
    let mut rsn: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tag: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut found: libc::c_int = 0;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    rsn = lglrsn(lgl, lit);
    tag = *rsn.offset(0 as libc::c_int as isize) & MASKCS as libc::c_int;
    if tag == DECISION as libc::c_int {
        return;
    }
    if tag == BINCS as libc::c_int || tag == TRNCS as libc::c_int {
        lglbumpreasonlit(
            lgl,
            *rsn.offset(0 as libc::c_int as isize) >> RMSHFT as libc::c_int,
        );
        if tag == TRNCS as libc::c_int {
            lglbumpreasonlit(lgl, *rsn.offset(1 as libc::c_int as isize));
        }
    } else {
        p = lglidx2lits(
            lgl,
            *rsn.offset(0 as libc::c_int as isize) & REDCS as libc::c_int,
            *rsn.offset(1 as libc::c_int as isize),
        );
        found = 0 as libc::c_int;
        loop {
            let fresh87 = p;
            p = p.offset(1);
            other = *fresh87;
            if !(other != 0) {
                break;
            }
            if other == -lit {
                found += 1;
                found;
            } else {
                lglbumpreasonlit(lgl, other);
            }
        }
    };
}
unsafe extern "C" fn lglbumpreasonlits(mut lgl: *mut LGL) {
    let mut n: libc::c_int = lglcntstk(&mut (*lgl).seen) as libc::c_int;
    let mut p: *const libc::c_int = (*lgl).clause.start;
    while *p != 0 {
        let fresh88 = p;
        p = p.offset(1);
        lglbumpreason(lgl, *fresh88);
    }
    p = ((*lgl).seen.start).offset(n as isize);
    while p < (*lgl).seen.top as *const libc::c_int {
        let mut av: *mut AVar = lglavar(lgl, *p);
        (*av).mark = 0 as libc::c_int;
        p = p.offset(1);
        p;
    }
}
unsafe extern "C" fn lglcmpbump(
    mut lgl: *mut LGL,
    mut a: libc::c_int,
    mut b: libc::c_int,
) -> libc::c_int {
    return lgldcmp(lgl, a, b);
}
unsafe extern "C" fn lglbumpseenlits(mut lgl: *mut LGL) {
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    if (*lgl).simp as libc::c_int != 0 && (*(*lgl).opts).bumpsimp.val == 0 {
        return;
    }
    lglstart(lgl, &mut (*(*lgl).times).bump);
    (*(*lgl).stats).bump.count += 1;
    (*(*lgl).stats).bump.count;
    if (*(*lgl).opts).bumpreasonlits.val != 0 {
        lglbumpreasonlits(lgl);
    }
    let mut AA: *mut libc::c_int = (*lgl).seen.start;
    let NN: libc::c_int = lglcntstk(&mut (*lgl).seen) as libc::c_int;
    let mut L: libc::c_int = 0 as libc::c_int;
    let mut R: libc::c_int = NN - 1 as libc::c_int;
    let mut M: libc::c_int = 0;
    let mut LL: libc::c_int = 0;
    let mut RR: libc::c_int = 0;
    let mut I: libc::c_int = 0;
    if !(R - L <= 10 as libc::c_int) {
        loop {
            M = (L + R) / 2 as libc::c_int;
            let mut TMP: libc::c_int = *AA.offset(M as isize);
            *AA.offset(M as isize) = *AA.offset((R - 1 as libc::c_int) as isize);
            *AA.offset((R - 1 as libc::c_int) as isize) = TMP;
            if lglcmpbump(
                lgl,
                *AA.offset(L as isize),
                *AA.offset((R - 1 as libc::c_int) as isize),
            ) > 0 as libc::c_int
            {
                let mut TMP_0: libc::c_int = *AA.offset(L as isize);
                *AA.offset(L as isize) = *AA.offset((R - 1 as libc::c_int) as isize);
                *AA.offset((R - 1 as libc::c_int) as isize) = TMP_0;
            }
            if lglcmpbump(lgl, *AA.offset(L as isize), *AA.offset(R as isize))
                > 0 as libc::c_int
            {
                let mut TMP_1: libc::c_int = *AA.offset(L as isize);
                *AA.offset(L as isize) = *AA.offset(R as isize);
                *AA.offset(R as isize) = TMP_1;
            }
            if lglcmpbump(
                lgl,
                *AA.offset((R - 1 as libc::c_int) as isize),
                *AA.offset(R as isize),
            ) > 0 as libc::c_int
            {
                let mut TMP_2: libc::c_int = *AA.offset((R - 1 as libc::c_int) as isize);
                *AA.offset((R - 1 as libc::c_int) as isize) = *AA.offset(R as isize);
                *AA.offset(R as isize) = TMP_2;
            }
            let mut PIVOT: libc::c_int = 0;
            let mut J: libc::c_int = R - 1 as libc::c_int;
            I = L + 1 as libc::c_int - 1 as libc::c_int;
            PIVOT = *AA.offset(J as isize);
            loop {
                loop {
                    I += 1;
                    if !(lglcmpbump(lgl, *AA.offset(I as isize), PIVOT)
                        < 0 as libc::c_int)
                    {
                        break;
                    }
                }
                loop {
                    J -= 1;
                    if !(lglcmpbump(lgl, PIVOT, *AA.offset(J as isize))
                        < 0 as libc::c_int)
                    {
                        break;
                    }
                    if J == L + 1 as libc::c_int {
                        break;
                    }
                }
                if I >= J {
                    break;
                }
                let mut TMP_3: libc::c_int = *AA.offset(I as isize);
                *AA.offset(I as isize) = *AA.offset(J as isize);
                *AA.offset(J as isize) = TMP_3;
            }
            let mut TMP_4: libc::c_int = *AA.offset(I as isize);
            *AA.offset(I as isize) = *AA.offset((R - 1 as libc::c_int) as isize);
            *AA.offset((R - 1 as libc::c_int) as isize) = TMP_4;
            if I - L < R - I {
                LL = I + 1 as libc::c_int;
                RR = R;
                R = I - 1 as libc::c_int;
            } else {
                LL = L;
                RR = I - 1 as libc::c_int;
                L = I + 1 as libc::c_int;
            }
            if R - L > 10 as libc::c_int {
                lglpushstk(lgl, &mut (*lgl).c2rust_unnamed_0.sortstk, LL);
                lglpushstk(lgl, &mut (*lgl).c2rust_unnamed_0.sortstk, RR);
            } else if RR - LL > 10 as libc::c_int {
                L = LL;
                R = RR;
            } else {
                if !(lglmtstk(&mut (*lgl).c2rust_unnamed_0.sortstk) == 0) {
                    break;
                }
                R = lglpopstk(&mut (*lgl).c2rust_unnamed_0.sortstk);
                L = lglpopstk(&mut (*lgl).c2rust_unnamed_0.sortstk);
            }
        }
    }
    let mut PIVOT_0: libc::c_int = 0;
    let mut L_0: libc::c_int = 0 as libc::c_int;
    let mut R_0: libc::c_int = NN - 1 as libc::c_int;
    let mut I_0: libc::c_int = 0;
    let mut J_0: libc::c_int = 0;
    I_0 = R_0;
    while I_0 > L_0 {
        if lglcmpbump(
            lgl,
            *AA.offset((I_0 - 1 as libc::c_int) as isize),
            *AA.offset(I_0 as isize),
        ) > 0 as libc::c_int
        {
            let mut TMP_5: libc::c_int = *AA.offset((I_0 - 1 as libc::c_int) as isize);
            *AA.offset((I_0 - 1 as libc::c_int) as isize) = *AA.offset(I_0 as isize);
            *AA.offset(I_0 as isize) = TMP_5;
        }
        I_0 -= 1;
        I_0;
    }
    I_0 = L_0 + 2 as libc::c_int;
    while I_0 <= R_0 {
        J_0 = I_0;
        PIVOT_0 = *AA.offset(I_0 as isize);
        while lglcmpbump(lgl, PIVOT_0, *AA.offset((J_0 - 1 as libc::c_int) as isize))
            < 0 as libc::c_int
        {
            *AA.offset(J_0 as isize) = *AA.offset((J_0 - 1 as libc::c_int) as isize);
            J_0 -= 1;
            J_0;
        }
        *AA.offset(J_0 as isize) = PIVOT_0;
        I_0 += 1;
        I_0;
    }
    p = (*lgl).seen.start;
    while p < (*lgl).seen.top as *const libc::c_int {
        lglbumpdlit(lgl, *p);
        p = p.offset(1);
        p;
    }
    (*(*lgl).stats)
        .bump
        .lits = ((*(*lgl).stats).bump.lits as size_t)
        .wrapping_add(lglcntstk(&mut (*lgl).seen)) as int64_t as int64_t;
    lglstop(lgl);
}
unsafe extern "C" fn lglmincls(
    mut lgl: *mut LGL,
    mut uip: libc::c_int,
    mut glue: libc::c_int,
) {
    let mut origsize: libc::c_int = (lglcntstk(&mut (*lgl).clause))
        .wrapping_sub(1 as libc::c_int as size_t) as libc::c_int;
    let mut p: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut q: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut other: libc::c_int = 0;
    let mut minimized: libc::c_int = 0;
    let mut local: libc::c_int = 0;
    if (*(*lgl).opts).minimize.val == 0 {
        return;
    }
    if glue > (*(*lgl).opts).minlocalgluelim.val {
        return;
    }
    if origsize > (*(*lgl).opts).minlocalsizelim.val {
        return;
    }
    lglstart(lgl, &mut (*(*lgl).times).mincls);
    (*(*lgl).stats).mincls.min += 1;
    (*(*lgl).stats).mincls.min;
    q = (*lgl).clause.start;
    minimized = 0 as libc::c_int;
    local = ((*(*lgl).opts).minimize.val <= 1 as libc::c_int
        || glue > (*(*lgl).opts).minrecgluelim.val
        || origsize > (*(*lgl).opts).minrecsizelim.val) as libc::c_int;
    p = q;
    loop {
        other = *p;
        if !(other != 0) {
            break;
        }
        if other != uip && lglminclslit(lgl, other, local) != 0 {
            minimized += 1;
            minimized;
        } else {
            let fresh89 = q;
            q = q.offset(1);
            *fresh89 = other;
        }
        p = p.offset(1);
        p;
    }
    let fresh90 = q;
    q = q.offset(1);
    *fresh90 = 0 as libc::c_int;
    lglclnpoisoned(lgl);
    if !(glue + 1 as libc::c_int >= origsize && minimized > 0 as libc::c_int) {} else {
        fprintf(
            stderr,
            b"liblgl.a: %s:%d: %s: Coverage target `%s' reached.\0" as *const u8
                as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 10], &[libc::c_char; 10]>(b"lglmincls\0"))
                .as_ptr(),
            7160 as libc::c_int,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            b"glue + 1 >= origsize && minimized > 0\0" as *const u8
                as *const libc::c_char,
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputc('\n' as i32, stderr);
        fflush(stderr);
        abort();
    }
    (*lgl).clause.top = q;
    lglstop(lgl);
}
unsafe extern "C" fn lglcmpuiplitrail(
    mut lgl: *mut LGL,
    mut uip: libc::c_int,
    mut a: libc::c_int,
    mut b: libc::c_int,
) -> libc::c_int {
    if a == uip {
        return -(1 as libc::c_int);
    }
    if b == uip {
        return 1 as libc::c_int;
    }
    return lgltrail(lgl, a) - lgltrail(lgl, b);
}
unsafe extern "C" fn lglredclsassign(mut lgl: *mut LGL, mut lit: libc::c_int) {
    lglmark(lgl, lit);
    lglpushstk(lgl, &mut (*lgl).seen, lit);
}
unsafe extern "C" fn lglredclsmarked(
    mut lgl: *mut LGL,
    mut lit: libc::c_int,
) -> libc::c_int {
    let mut mark: libc::c_int = 0;
    let mut val: libc::c_int = 0;
    mark = lglmarked(lgl, lit);
    if mark != 0 {
        return mark;
    }
    val = lglifixed(lgl, lit) as libc::c_int;
    if val != 0 {
        return val;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn lglredcls(
    mut lgl: *mut LGL,
    mut uip: libc::c_int,
    mut glue: libc::c_int,
    mut jlevelptr: *mut libc::c_int,
) {
    let mut lit: libc::c_int = 0;
    let mut cand: libc::c_int = 0;
    let mut blit: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut other2: libc::c_int = 0;
    let mut count: libc::c_int = 0;
    let mut size: libc::c_int = 0;
    let mut reduced: libc::c_int = 0;
    let mut q: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut newjlevel: libc::c_int = 0;
    let mut oldjlevel: libc::c_int = 0;
    let mut level: libc::c_int = 0;
    let mut sat: libc::c_int = 0;
    let mut red: libc::c_int = 0;
    let mut lidx: libc::c_int = 0;
    let mut unit: libc::c_int = 0;
    let mut dec: libc::c_int = 0;
    let mut depth: libc::c_int = 0;
    let mut props: libc::c_int = 0;
    let mut mark: libc::c_int = 0;
    let mut mark2: libc::c_int = 0;
    let mut markcand: libc::c_int = 0;
    let mut lrg: libc::c_int = 0;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut w: *const libc::c_int = 0 as *const libc::c_int;
    let mut eow: *const libc::c_int = 0 as *const libc::c_int;
    let mut r: *const libc::c_int = 0 as *const libc::c_int;
    let mut l: *const libc::c_int = 0 as *const libc::c_int;
    let mut c: *const libc::c_int = 0 as *const libc::c_int;
    let mut hts: *mut HTS = 0 as *mut HTS;
    let maxdepth: libc::c_int = (*(*lgl).opts).redclsmaxdepth.val;
    let maxprops: libc::c_int = (*(*lgl).opts).redclsmaxprops.val;
    let maxlrg: libc::c_int = (*(*lgl).opts).redclsmaxlrg.val;
    let maxdec: libc::c_int = (*(*lgl).opts).redclsmaxdec.val;
    let type_0: libc::c_int = (*(*lgl).opts).redclstype.val;
    if (*(*lgl).opts).redcls.val == 0 {
        return;
    }
    if glue > (*(*lgl).opts).redclsglue.val {
        return;
    }
    if lglcntstk(&mut (*lgl).clause)
        >= (*(*lgl).opts).redclsize.val as libc::c_uint as size_t
    {
        return;
    }
    lglstart(lgl, &mut (*(*lgl).times).redcls);
    (*(*lgl).stats).redcls.cls.tried += 1;
    (*(*lgl).stats).redcls.cls.tried;
    lglpopnunmarkstk(lgl, &mut (*lgl).seen);
    size = (lglcntstk(&mut (*lgl).clause)).wrapping_sub(1 as libc::c_int as size_t)
        as libc::c_int;
    let mut AA: *mut libc::c_int = (*lgl).clause.start;
    let NN: libc::c_int = size;
    let mut L: libc::c_int = 0 as libc::c_int;
    let mut R: libc::c_int = NN - 1 as libc::c_int;
    let mut M: libc::c_int = 0;
    let mut LL: libc::c_int = 0;
    let mut RR: libc::c_int = 0;
    let mut I: libc::c_int = 0;
    if !(R - L <= 10 as libc::c_int) {
        loop {
            M = (L + R) / 2 as libc::c_int;
            let mut TMP: libc::c_int = *AA.offset(M as isize);
            *AA.offset(M as isize) = *AA.offset((R - 1 as libc::c_int) as isize);
            *AA.offset((R - 1 as libc::c_int) as isize) = TMP;
            if lglcmpuiplitrail(
                lgl,
                uip,
                *AA.offset(L as isize),
                *AA.offset((R - 1 as libc::c_int) as isize),
            ) > 0 as libc::c_int
            {
                let mut TMP_0: libc::c_int = *AA.offset(L as isize);
                *AA.offset(L as isize) = *AA.offset((R - 1 as libc::c_int) as isize);
                *AA.offset((R - 1 as libc::c_int) as isize) = TMP_0;
            }
            if lglcmpuiplitrail(lgl, uip, *AA.offset(L as isize), *AA.offset(R as isize))
                > 0 as libc::c_int
            {
                let mut TMP_1: libc::c_int = *AA.offset(L as isize);
                *AA.offset(L as isize) = *AA.offset(R as isize);
                *AA.offset(R as isize) = TMP_1;
            }
            if lglcmpuiplitrail(
                lgl,
                uip,
                *AA.offset((R - 1 as libc::c_int) as isize),
                *AA.offset(R as isize),
            ) > 0 as libc::c_int
            {
                let mut TMP_2: libc::c_int = *AA.offset((R - 1 as libc::c_int) as isize);
                *AA.offset((R - 1 as libc::c_int) as isize) = *AA.offset(R as isize);
                *AA.offset(R as isize) = TMP_2;
            }
            let mut PIVOT: libc::c_int = 0;
            let mut J: libc::c_int = R - 1 as libc::c_int;
            I = L + 1 as libc::c_int - 1 as libc::c_int;
            PIVOT = *AA.offset(J as isize);
            loop {
                loop {
                    I += 1;
                    if !(lglcmpuiplitrail(lgl, uip, *AA.offset(I as isize), PIVOT)
                        < 0 as libc::c_int)
                    {
                        break;
                    }
                }
                loop {
                    J -= 1;
                    if !(lglcmpuiplitrail(lgl, uip, PIVOT, *AA.offset(J as isize))
                        < 0 as libc::c_int)
                    {
                        break;
                    }
                    if J == L + 1 as libc::c_int {
                        break;
                    }
                }
                if I >= J {
                    break;
                }
                let mut TMP_3: libc::c_int = *AA.offset(I as isize);
                *AA.offset(I as isize) = *AA.offset(J as isize);
                *AA.offset(J as isize) = TMP_3;
            }
            let mut TMP_4: libc::c_int = *AA.offset(I as isize);
            *AA.offset(I as isize) = *AA.offset((R - 1 as libc::c_int) as isize);
            *AA.offset((R - 1 as libc::c_int) as isize) = TMP_4;
            if I - L < R - I {
                LL = I + 1 as libc::c_int;
                RR = R;
                R = I - 1 as libc::c_int;
            } else {
                LL = L;
                RR = I - 1 as libc::c_int;
                L = I + 1 as libc::c_int;
            }
            if R - L > 10 as libc::c_int {
                lglpushstk(lgl, &mut (*lgl).c2rust_unnamed_0.sortstk, LL);
                lglpushstk(lgl, &mut (*lgl).c2rust_unnamed_0.sortstk, RR);
            } else if RR - LL > 10 as libc::c_int {
                L = LL;
                R = RR;
            } else {
                if !(lglmtstk(&mut (*lgl).c2rust_unnamed_0.sortstk) == 0) {
                    break;
                }
                R = lglpopstk(&mut (*lgl).c2rust_unnamed_0.sortstk);
                L = lglpopstk(&mut (*lgl).c2rust_unnamed_0.sortstk);
            }
        }
    }
    let mut PIVOT_0: libc::c_int = 0;
    let mut L_0: libc::c_int = 0 as libc::c_int;
    let mut R_0: libc::c_int = NN - 1 as libc::c_int;
    let mut I_0: libc::c_int = 0;
    let mut J_0: libc::c_int = 0;
    I_0 = R_0;
    while I_0 > L_0 {
        if lglcmpuiplitrail(
            lgl,
            uip,
            *AA.offset((I_0 - 1 as libc::c_int) as isize),
            *AA.offset(I_0 as isize),
        ) > 0 as libc::c_int
        {
            let mut TMP_5: libc::c_int = *AA.offset((I_0 - 1 as libc::c_int) as isize);
            *AA.offset((I_0 - 1 as libc::c_int) as isize) = *AA.offset(I_0 as isize);
            *AA.offset(I_0 as isize) = TMP_5;
        }
        I_0 -= 1;
        I_0;
    }
    I_0 = L_0 + 2 as libc::c_int;
    while I_0 <= R_0 {
        J_0 = I_0;
        PIVOT_0 = *AA.offset(I_0 as isize);
        while lglcmpuiplitrail(
            lgl,
            uip,
            PIVOT_0,
            *AA.offset((J_0 - 1 as libc::c_int) as isize),
        ) < 0 as libc::c_int
        {
            *AA.offset(J_0 as isize) = *AA.offset((J_0 - 1 as libc::c_int) as isize);
            J_0 -= 1;
            J_0;
        }
        *AA.offset(J_0 as isize) = PIVOT_0;
        I_0 += 1;
        I_0;
    }
    reduced = 0 as libc::c_int;
    sat = reduced;
    dec = 0 as libc::c_int;
    q = (*lgl).clause.start;
    p = q;
    while p < (*lgl).clause.top as *const libc::c_int {
        cand = *p;
        if cand == 0 {
            let fresh91 = q;
            q = q.offset(1);
            *fresh91 = cand;
        } else {
            (*(*lgl).stats).redcls.lits.tried += 1;
            (*(*lgl).stats).redcls.lits.tried;
            markcand = lglredclsmarked(lgl, cand);
            if markcand > 0 as libc::c_int {
                (*(*lgl).stats).redcls.lits.sat += 1;
                (*(*lgl).stats).redcls.lits.sat;
                let fresh92 = q;
                q = q.offset(1);
                *fresh92 = cand;
                sat = 1 as libc::c_int;
            } else if markcand < 0 as libc::c_int {
                (*(*lgl).stats).redcls.lits.red += 1;
                (*(*lgl).stats).redcls.lits.red;
                reduced += 1;
                reduced;
            } else {
                let fresh93 = q;
                q = q.offset(1);
                *fresh93 = cand;
                if !(*p.offset(1 as libc::c_int as isize) == 0) {
                    dec += 1;
                    if !(dec > maxdec) {
                        lrg = 0 as libc::c_int;
                        props = lrg;
                        depth = props;
                        count = lglcntstk(&mut (*lgl).seen) as libc::c_int;
                        lglredclsassign(lgl, -cand);
                        while count < lglcntstk(&mut (*lgl).seen) as libc::c_int {
                            if props >= maxprops {
                                break;
                            }
                            if depth >= maxdepth {
                                break;
                            }
                            let fresh94 = count;
                            count = count + 1;
                            lit = lglpeek(&mut (*lgl).seen, fresh94);
                            if lit != 0 {
                                props += 1;
                                props;
                                hts = lglhts(lgl, -lit);
                                w = lglhts2wchs(lgl, hts);
                                eow = w.offset((*hts).count as isize);
                                r = w;
                                while r < eow {
                                    blit = *r;
                                    tag = blit & MASKCS as libc::c_int;
                                    if tag == TRNCS as libc::c_int
                                        || tag == LRGCS as libc::c_int
                                    {
                                        r = r.offset(1);
                                        r;
                                    }
                                    if tag == BINCS as libc::c_int {
                                        other = blit >> RMSHFT as libc::c_int;
                                        if !(lglredclsmarked(lgl, other) != 0) {
                                            lglredclsassign(lgl, other);
                                        }
                                    } else if tag == TRNCS as libc::c_int {
                                        if !(cand != uip || type_0 < 3 as libc::c_int) {
                                            other = blit >> RMSHFT as libc::c_int;
                                            mark = lglredclsmarked(lgl, other);
                                            if !(mark > 0 as libc::c_int) {
                                                other2 = *r;
                                                mark2 = lglredclsmarked(lgl, other2);
                                                if !(mark2 > 0 as libc::c_int) {
                                                    if mark2 < 0 as libc::c_int && mark == 0 {
                                                        lglredclsassign(lgl, other);
                                                    }
                                                    if mark < 0 as libc::c_int && mark2 == 0 {
                                                        lglredclsassign(lgl, other2);
                                                    }
                                                }
                                            }
                                        }
                                    } else if !(type_0 < 4 as libc::c_int || cand != uip) {
                                        lrg += 1;
                                        if !(lrg >= maxlrg) {
                                            other = blit >> RMSHFT as libc::c_int;
                                            mark = lglredclsmarked(lgl, other);
                                            if !(mark > 0 as libc::c_int) {
                                                red = blit & REDCS as libc::c_int;
                                                lidx = *r;
                                                c = lglidx2lits(lgl, red, lidx);
                                                unit = 0 as libc::c_int;
                                                l = c;
                                                loop {
                                                    other = *l;
                                                    if !(other != 0) {
                                                        break;
                                                    }
                                                    if !(other == -lit) {
                                                        mark = lglredclsmarked(lgl, other);
                                                        if mark > 0 as libc::c_int {
                                                            break;
                                                        }
                                                        if !(mark < 0 as libc::c_int) {
                                                            if unit != 0 {
                                                                break;
                                                            }
                                                            unit = other;
                                                        }
                                                    }
                                                    l = l.offset(1);
                                                    l;
                                                }
                                                if !(other != 0 || unit == 0) {
                                                    lglredclsassign(lgl, unit);
                                                }
                                            }
                                        }
                                    }
                                    r = r.offset(1);
                                    r;
                                }
                                lglpushstk(lgl, &mut (*lgl).seen, 0 as libc::c_int);
                            } else {
                                depth += 1;
                                depth;
                            }
                        }
                    }
                }
            }
        }
        p = p.offset(1);
        p;
    }
    if sat != 0 {
        (*(*lgl).stats).redcls.cls.sat += 1;
        (*(*lgl).stats).redcls.cls.sat;
    }
    (*lgl).clause.top = q;
    if reduced != 0 {
        (*(*lgl).stats).redcls.cls.red += 1;
        (*(*lgl).stats).redcls.cls.red;
    }
    oldjlevel = *jlevelptr;
    newjlevel = 0 as libc::c_int;
    p = (*lgl).clause.start;
    while p < (*lgl).clause.top as *const libc::c_int {
        lit = *p;
        if !(lit == 0 || lit == uip) {
            level = lglevel(lgl, lit);
            if level > newjlevel {
                newjlevel = level;
            }
        }
        p = p.offset(1);
        p;
    }
    if !(oldjlevel == newjlevel) {
        *jlevelptr = newjlevel;
        (*(*lgl).stats).redcls.jlevel.red += 1;
        (*(*lgl).stats).redcls.jlevel.red;
        (*(*lgl).stats).redcls.jlevel.sum += (oldjlevel - newjlevel) as int64_t;
    }
    lglstop(lgl);
}
unsafe extern "C" fn lgliassume(mut lgl: *mut LGL, mut lit: libc::c_int) {
    (*lgl).level += 1;
    (*lgl).level;
    lglpushcontrol(lgl, lit);
    lglassign(lgl, lit, DECISION as libc::c_int, 0 as libc::c_int);
}
unsafe extern "C" fn lgldassume(mut lgl: *mut LGL, mut lit: libc::c_int) {
    (*(*lgl).stats).decisions += 1;
    (*(*lgl).stats).decisions;
    lgliassume(lgl, lit);
}
unsafe extern "C" fn lglsubl(
    mut lgl: *mut LGL,
    mut lidx: libc::c_int,
    mut size: libc::c_int,
    mut glue: libc::c_int,
) -> libc::c_int {
    let mut c: *const libc::c_int = 0 as *const libc::c_int;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut count: libc::c_int = 0;
    let mut lit: libc::c_int = 0;
    c = lglidx2lits(lgl, REDCS as libc::c_int, lidx);
    count = 0 as libc::c_int;
    p = c;
    while count < size
        && {
            lit = *p;
            lit != 0
        }
    {
        if lit == 2147483647 as libc::c_int {
            return 1 as libc::c_int;
        }
        if lglmarked(lgl, lit) > 0 as libc::c_int {
            count += 1;
            count;
        }
        p = p.offset(1);
        p;
    }
    (*(*lgl).stats).subl.tried += 1;
    (*(*lgl).stats).subl.tried;
    if count < size {
        return 0 as libc::c_int;
    }
    (*(*lgl).stats).subl.sub += 1;
    (*(*lgl).stats).subl.sub;
    lgldrupligdelclsaux(lgl, c);
    lglrmlcls(lgl, lidx, REDCS as libc::c_int);
    return 1 as libc::c_int;
}
unsafe extern "C" fn lgldrive(
    mut lgl: *mut LGL,
    mut type_0: *const libc::c_char,
    mut forcedptr: *mut libc::c_int,
    mut glueptr: *mut libc::c_int,
    mut realglueptr: *mut libc::c_int,
    mut jlevelptr: *mut libc::c_int,
) {
    let mut lit: libc::c_int = 0;
    let mut jlevel: libc::c_int = 0;
    let mut level: libc::c_int = 0;
    let mut minlevel: libc::c_int = 0;
    let mut maxlevel: libc::c_int = 0;
    let mut glue: libc::c_int = 0;
    let mut realglue: libc::c_int = 0;
    let mut forced: libc::c_int = 0;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut soc: *const libc::c_int = (*lgl).clause.start;
    let mut eoc: *const libc::c_int = ((*lgl).clause.top)
        .offset(-(1 as libc::c_int as isize));
    let mut c: *mut Ctr = 0 as *mut Ctr;
    forced = if !forcedptr.is_null() { *forcedptr } else { 0 as libc::c_int };
    maxlevel = -(1 as libc::c_int);
    minlevel = (*lgl).level + 1 as libc::c_int;
    p = soc;
    while p < eoc {
        level = lglevel(lgl, *p);
        c = ((*lgl).control.start).offset(level as isize);
        if (*c).used2() == 0 {
            if level < minlevel {
                minlevel = level;
            }
            if level > maxlevel {
                maxlevel = level;
            }
            (*c).set_used2(1 as libc::c_int as libc::c_uint);
        } else if (*c).used2() as libc::c_int == 1 as libc::c_int {
            (*c).set_used2(2 as libc::c_int as libc::c_uint);
        }
        p = p.offset(1);
        p;
    }
    if maxlevel >= 0 as libc::c_int {
        c = ((*lgl).control.start).offset(maxlevel as isize);
        if (*c).used2() as libc::c_int > 1 as libc::c_int {
            jlevel = maxlevel;
            glue = -(1 as libc::c_int);
            realglue = glue;
            p = soc;
            while p < eoc {
                lit = *p;
                level = lglevel(lgl, lit);
                c = ((*lgl).control.start).offset(level as isize);
                if (*c).used2() as libc::c_int != 0 || level == jlevel {
                    if level >= (*lgl).alevel {
                        realglue += 1;
                        realglue;
                    }
                    glue += 1;
                    glue;
                }
                (*c).set_used2(0 as libc::c_int as libc::c_uint);
                p = p.offset(1);
                p;
            }
        } else {
            forced = 0 as libc::c_int;
            level = forced;
            jlevel = level;
            glue = jlevel;
            realglue = glue;
            p = soc;
            while p < eoc {
                lit = *p;
                level = lglevel(lgl, lit);
                c = ((*lgl).control.start).offset(level as isize);
                if level == maxlevel {
                    forced = lit;
                } else if (*c).used2() != 0 {
                    if level > jlevel {
                        jlevel = level;
                    }
                    if level >= (*lgl).alevel {
                        realglue += 1;
                        realglue;
                    }
                    glue += 1;
                    glue;
                }
                (*c).set_used2(0 as libc::c_int as libc::c_uint);
                p = p.offset(1);
                p;
            }
        }
    } else {
        maxlevel = 0 as libc::c_int;
        minlevel = maxlevel;
        forced = minlevel;
        jlevel = forced;
        realglue = jlevel;
        glue = realglue;
    }
    p = soc;
    while p < eoc {
        lit = *p;
        level = lglevel(lgl, lit);
        c = ((*lgl).control.start).offset(level as isize);
        if (*c).used2() != 0 {
            (*c).set_used2(0 as libc::c_int as libc::c_uint);
        }
        p = p.offset(1);
        p;
    }
    if !glueptr.is_null() {
        *glueptr = glue;
    }
    if !realglueptr.is_null() {
        *realglueptr = realglue;
    }
    if !jlevelptr.is_null() {
        *jlevelptr = jlevel;
    }
    if !forcedptr.is_null() {
        *forcedptr = forced;
    }
}
unsafe extern "C" fn lgldeco(
    mut lgl: *mut LGL,
    mut jlevel: libc::c_int,
    mut uip: libc::c_int,
) {
    let mut q: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut r: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut lit: libc::c_int = 0;
    let mut level: libc::c_int = 0;
    let mut limlevel: libc::c_int = 0;
    let mut p: *mut Ctr = 0 as *mut Ctr;
    if (*(*lgl).opts).deco1opt.val != 0 {
        limlevel = jlevel;
        while limlevel > 1 as libc::c_int {
            p = ((*lgl).control.start).offset(limlevel as isize);
            if (*p).used() as libc::c_int > 1 as libc::c_int {
                break;
            }
            limlevel -= 1;
            limlevel;
        }
    } else {
        limlevel = jlevel;
    }
    r = (*lgl).clause.start;
    q = r;
    while q < (*lgl).clause.top {
        lit = *q;
        if !(lit == 0) {
            level = lglevel(lgl, lit);
            if !(level > jlevel) {
                p = ((*lgl).control.start).offset(level as isize);
                if level > limlevel && (*p).used() as libc::c_int == 1 as libc::c_int {
                    let fresh95 = r;
                    r = r.offset(1);
                    *fresh95 = lit;
                } else {
                    (*p).decision() != -lit;
                }
            }
        }
        q = q.offset(1);
        q;
    }
    (*lgl).clause.top = r;
    level = 1 as libc::c_int;
    while level <= jlevel {
        p = ((*lgl).control.start).offset(level as isize);
        if !(level > limlevel && (*p).used() as libc::c_int == 1 as libc::c_int) {
            lit = -(*p).decision();
            lglpushstk(lgl, &mut (*lgl).clause, lit);
        }
        level += 1;
        level;
    }
}
static mut INT64MIN: int64_t = (-(9223372036854775807 as libc::c_longlong)
    - 1 as libc::c_longlong) as int64_t;
static mut INT64MAX: int64_t = 9223372036854775807 as libc::c_longlong as int64_t;
unsafe extern "C" fn lgleftshiftint64(
    mut val: int64_t,
    mut shift: libc::c_int,
) -> int64_t {
    let mut res: int64_t = 0;
    if val == INT64MIN {
        res = INT64MIN;
    } else if val == INT64MAX {
        res = INT64MAX;
    } else if val > INT64MAX >> shift {
        res = INT64MAX;
    } else if val < INT64MIN >> shift {
        res = INT64MIN;
    } else {
        res = ((val as uint64_t) << shift) as int64_t;
    }
    return res;
}
unsafe extern "C" fn lglrightshiftint64(
    mut val: int64_t,
    mut shift: libc::c_int,
) -> int64_t {
    let mut res: int64_t = 0;
    if val == INT64MIN {
        res = INT64MIN;
    } else if val == INT64MAX {
        res = INT64MAX;
    } else {
        res = val >> shift;
    }
    return res;
}
unsafe extern "C" fn lgladdint64(mut a: int64_t, mut b: int64_t) -> int64_t {
    let mut res: int64_t = 0;
    if a == INT64MIN {
        res = INT64MIN;
    } else if b == INT64MIN {
        res = INT64MIN;
    } else if a == INT64MAX {
        res = INT64MAX;
    } else if b == INT64MAX {
        res = INT64MAX;
    } else if a >= 0 as libc::c_int as int64_t && b <= 0 as libc::c_int as int64_t {
        res = a + b;
    } else if a <= 0 as libc::c_int as int64_t && b >= 0 as libc::c_int as int64_t {
        res = a + b;
    } else if a < 0 as libc::c_int as int64_t {
        if b < INT64MIN - a {
            res = INT64MIN;
        } else {
            res = a + b;
        }
    } else if b > INT64MAX - a {
        res = INT64MAX;
    } else {
        res = a + b;
    }
    return res;
}
unsafe extern "C" fn lglsubint64(mut a: int64_t, mut b: int64_t) -> int64_t {
    let mut res: int64_t = 0;
    if b == INT64MIN {
        res = INT64MIN;
    } else {
        res = lgladdint64(a, -b);
    }
    return res;
}
unsafe extern "C" fn lglvalidint64(mut a: int64_t) -> libc::c_int {
    return (a != INT64MIN && a != INT64MAX) as libc::c_int;
}
unsafe extern "C" fn lglinitema(
    mut lgl: *mut LGL,
    mut ema: *mut EMA,
    mut shift: libc::c_int,
) {
    (*ema).shift = shift;
    (*ema).count = 0 as libc::c_int;
}
unsafe extern "C" fn lglupdatema(
    mut lgl: *mut LGL,
    mut ema: *mut EMA,
    mut input: int64_t,
    mut left: libc::c_int,
) {
    let mut oldval: int64_t = 0;
    let mut tmpval: int64_t = 0;
    let mut newval: int64_t = 0;
    let mut add: int64_t = 0;
    let mut sub: int64_t = 0;
    let shift: libc::c_int = (*ema).count;
    oldval = (*ema).val;
    if shift < (*ema).shift {
        (*ema).count += 1;
        (*ema).count;
    }
    if !(lglvalidint64(input) == 0) {
        sub = lglrightshiftint64(oldval, shift);
        if !(lglvalidint64(sub) == 0) {
            tmpval = lglsubint64(oldval, sub);
            if !(lglvalidint64(tmpval) == 0) {
                if left != 0 {
                    add = lgleftshiftint64(input, 32 as libc::c_int - shift);
                } else {
                    add = lglrightshiftint64(input, shift);
                }
                if !(lglvalidint64(add) == 0) {
                    newval = lgladdint64(tmpval, add);
                    if !(lglvalidint64(newval) == 0) {
                        (*ema).val = newval;
                    }
                }
            }
        }
    }
}
unsafe extern "C" fn lglinitmacd(
    mut lgl: *mut LGL,
    mut macd: *mut MACD,
    mut fast: libc::c_int,
    mut slow: libc::c_int,
    mut smooth: libc::c_int,
) {
    lglinitema(lgl, &mut (*macd).fast, fast);
    lglinitema(lgl, &mut (*macd).slow, slow);
    lglinitema(lgl, &mut (*macd).diff.smoothed, smooth);
}
unsafe extern "C" fn lglupdatemacd(
    mut lgl: *mut LGL,
    mut macd: *mut MACD,
    mut input: int64_t,
) {
    let mut newactual: int64_t = 0;
    lglupdatema(lgl, &mut (*macd).fast, input, 1 as libc::c_int);
    lglupdatema(lgl, &mut (*macd).slow, input, 1 as libc::c_int);
    newactual = lglsubint64((*macd).fast.val, (*macd).slow.val);
    if !(lglvalidint64(newactual) == 0) {
        (*macd).diff.actual = newactual;
        lglupdatema(lgl, &mut (*macd).diff.smoothed, newactual, 0 as libc::c_int);
    }
}
unsafe extern "C" fn lglupdstab(mut lgl: *mut LGL) {
    let mut assigned: libc::c_int = lglcntstk(&mut (*lgl).trail) as libc::c_int;
    let mut changed: libc::c_int = (*(*lgl).stats).stability.changed;
    let mut topassigned: libc::c_int = lglevel2trail(lgl, 1 as libc::c_int);
    let mut nontopassigned: libc::c_int = assigned - topassigned;
    let mut difference: int64_t = 0;
    let mut shifted: int64_t = 0;
    let mut fraction: int64_t = 0;
    (*(*lgl).stats).stability.count += 1;
    (*(*lgl).stats).stability.count;
    lglprt(
        lgl,
        2 as libc::c_int,
        b"[stability-%lld] %d assigned, %d non-top %.1f%%, %d changed %.2f%%\0"
            as *const u8 as *const libc::c_char,
        (*(*lgl).stats).stability.count as libc::c_longlong,
        assigned,
        nontopassigned,
        lglpcnt(nontopassigned as libc::c_double, assigned as libc::c_double),
        changed,
        lglpcnt(changed as libc::c_double, nontopassigned as libc::c_double),
    );
    if nontopassigned == 0 {
        fraction = 0 as libc::c_int as int64_t;
    } else {
        difference = (nontopassigned - changed) as int64_t;
        shifted = difference << 32 as libc::c_int;
        fraction = shifted / nontopassigned as int64_t;
    }
    lglupdatema(lgl, &mut (*(*lgl).stats).stability.avg, fraction, 0 as libc::c_int);
    (*(*lgl).stats).stability.level = 0 as libc::c_int;
    lglprt(
        lgl,
        2 as libc::c_int,
        b"[stability-%lld] unchanged fraction %.3f%% new stability %.3f%%\0" as *const u8
            as *const libc::c_char,
        (*(*lgl).stats).stability.count as libc::c_longlong,
        100.0f64 * fraction as libc::c_double
            / ((1 as libc::c_longlong) << 32 as libc::c_int) as libc::c_double,
        100.0f64 * (*(*lgl).stats).stability.avg.val as libc::c_double
            / ((1 as libc::c_longlong) << 32 as libc::c_int) as libc::c_double,
    );
}
unsafe extern "C" fn lglinitavg(mut avg: *mut AVG) {
    (*avg).count = 0 as libc::c_int as int64_t;
    (*avg).val = (*avg).count;
}
unsafe extern "C" fn lglupdateavg(
    mut lgl: *mut LGL,
    mut avg: *mut AVG,
    mut input: libc::c_int,
) {
    let mut oldval: int64_t = (*avg).val;
    let mut newval: int64_t = oldval;
    let mut shifted: int64_t = 0;
    let mut diff: int64_t = 0;
    shifted = lgleftshiftint64(input as int64_t, 32 as libc::c_int);
    if !(lglvalidint64(shifted) == 0) {
        diff = lglsubint64(shifted, oldval);
        if !(lglvalidint64(diff) == 0) {
            (*avg).count += 1;
            diff /= (*avg).count;
            newval = lgladdint64(oldval, diff);
            if !(lglvalidint64(newval) == 0) {
                (*avg).val = newval;
            }
        }
    }
}
unsafe extern "C" fn lglblockrestart(mut lgl: *mut LGL) -> libc::c_int {
    let actual: int64_t = (lglcntstk(&mut (*lgl).trail) as int64_t) << 32 as libc::c_int;
    let smoothed: int64_t = (*(*lgl).stats).tlevel.val;
    let percent: int64_t = (*(*lgl).opts).restartblocklim.val as int64_t;
    let mut limit: int64_t = 0;
    let mut blocking: libc::c_int = 0;
    if (*(*lgl).stats).confs < (*(*lgl).limits).restart.confs {
        return 0 as libc::c_int;
    }
    if (*(*lgl).stats).confs < (*(*lgl).opts).restartblockbound.val as int64_t {
        return 0 as libc::c_int;
    }
    limit = if smoothed < 0 as libc::c_int as int64_t { -smoothed } else { smoothed };
    if lglvalidint64(limit) == 0 {
        return 0 as libc::c_int;
    }
    limit /= 100 as libc::c_int as int64_t;
    if INT64MAX / percent < limit {
        return 0 as libc::c_int;
    }
    limit *= percent;
    blocking = (limit < actual) as libc::c_int;
    return blocking;
}
unsafe extern "C" fn lglrndcls(
    mut lgl: *mut LGL,
    mut len: libc::c_int,
    mut prune: libc::c_int,
) {
    let mut delta: int64_t = 0;
    if len == 2 as libc::c_int {
        lglrep(
            lgl,
            1 as libc::c_int + (prune == 0) as libc::c_int,
            (if prune != 0 { 'B' as i32 } else { 'b' as i32 }) as libc::c_char,
        );
        (*(*lgl).stats).bins += 1;
        (*(*lgl).stats).bins;
    }
    if len == 3 as libc::c_int {
        lglrep(
            lgl,
            1 as libc::c_int + (prune == 0) as libc::c_int,
            (if prune != 0 { 'T' as i32 } else { 't' as i32 }) as libc::c_char,
        );
        (*(*lgl).stats).trns += 1;
        (*(*lgl).stats).trns;
    }
    delta = (*(*lgl).stats).confs - (*lgl).confatlastit;
    lglupdatemacd(lgl, &mut (*(*lgl).stats).its.avg, delta);
    if len == 1 as libc::c_int {
        let mut delay: libc::c_int = (*(*lgl).opts).simpitdelay.val;
        (*lgl).confatlastit = (*(*lgl).stats).confs;
        (*(*lgl).stats).its.count += 1;
        (*(*lgl).stats).its.count;
        lglrep(
            lgl,
            1 as libc::c_int,
            (if prune != 0 { 'I' as i32 } else { 'i' as i32 }) as libc::c_char,
        );
        if delta > 0 as libc::c_int as int64_t {
            delay = (delay as int64_t / delta) as libc::c_int;
        }
        if delay > 0 as libc::c_int {
            (*(*lgl).limits).simp.confs += delay as int64_t;
        }
    }
}
unsafe extern "C" fn lglana(mut lgl: *mut LGL) -> libc::c_int {
    let mut open: libc::c_int = 0;
    let mut resolved: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut lit: libc::c_int = 0;
    let mut uip: libc::c_int = 0;
    let mut r0: libc::c_int = 0;
    let mut r1: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut other2: libc::c_int = 0;
    let mut p: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut q: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut lidx: libc::c_int = 0;
    let mut size: libc::c_int = 0;
    let mut savedsize: libc::c_int = 0;
    let mut resolventsize: libc::c_int = 0;
    let mut level: libc::c_int = 0;
    let mut red: libc::c_int = 0;
    let mut glue: libc::c_int = 0;
    let mut realglue: libc::c_int = 0;
    let mut jlevel: libc::c_int = 0;
    let mut mlevel: libc::c_int = 0;
    let mut nmlevel: libc::c_int = 0;
    let mut origsize: libc::c_int = 0;
    let mut redsize: libc::c_int = 0;
    let mut tlevel: libc::c_int = 0;
    let mut len: libc::c_int = 0;
    let mut rsn: *mut libc::c_int = 0 as *mut libc::c_int;
    if (*lgl).mt != 0 {
        return 0 as libc::c_int;
    }
    if (*lgl).failed != 0 {
        return 0 as libc::c_int;
    }
    if (*lgl).conf.lit == 0 {
        return 1 as libc::c_int;
    }
    if (*lgl).level == 0 {
        lglmt(lgl);
        return 0 as libc::c_int;
    }
    lglstart(lgl, &mut (*(*lgl).times).analysis);
    if (*lgl).sweeping != 0 {
        (*(*lgl).stats).sweep.confs += 1;
        (*(*lgl).stats).sweep.confs;
    } else {
        (*(*lgl).stats).confs += 1;
        (*(*lgl).stats).confs;
    }
    '_RESTART: loop {
        tlevel = lglcntstk(&mut (*lgl).trail) as libc::c_int;
        open = 0 as libc::c_int;
        lit = (*lgl).conf.lit;
        r0 = (*lgl).conf.rsn[0 as libc::c_int as usize];
        r1 = (*lgl).conf.rsn[1 as libc::c_int as usize];
        resolved = 0 as libc::c_int;
        savedsize = resolved;
        open += lglpull(lgl, lit);
        loop {
            let fresh96 = resolved;
            resolved = resolved + 1;
            fresh96 != 0;
            tag = r0 & MASKCS as libc::c_int;
            if tag == BINCS as libc::c_int || tag == TRNCS as libc::c_int {
                other = r0 >> RMSHFT as libc::c_int;
                size = if lglevel(lgl, other) != 0 {
                    2 as libc::c_int
                } else {
                    1 as libc::c_int
                };
                if lglpull(lgl, other) != 0 {
                    open += 1;
                    open;
                }
                if tag == TRNCS as libc::c_int {
                    if lglevel(lgl, r1) != 0 {
                        size += 1;
                        size;
                    }
                    if lglpull(lgl, r1) != 0 {
                        open += 1;
                        open;
                    }
                }
            } else {
                red = r0 & REDCS as libc::c_int;
                p = lglidx2lits(lgl, red, r1);
                size = 0 as libc::c_int;
                loop {
                    let fresh97 = p;
                    p = p.offset(1);
                    other = *fresh97;
                    if !(other != 0) {
                        break;
                    }
                    if lglevel(lgl, other) != 0 {
                        size += 1;
                        size;
                    }
                    if lglpull(lgl, other) != 0 {
                        open += 1;
                        open;
                    }
                }
                if red != 0 {
                    lglbumpnupdatelidx(lgl, r1);
                }
            }
            resolventsize = (open as size_t).wrapping_add(lglcntstk(&mut (*lgl).clause))
                as libc::c_int;
            if (*(*lgl).opts).otfs.val != 0 && resolved >= 2 as libc::c_int
                && resolventsize > 1 as libc::c_int
                && (resolventsize < size
                    || resolved == 2 as libc::c_int && resolventsize < savedsize)
            {
                let mut sl: libc::c_int = 0 as libc::c_int;
                let mut s0: libc::c_int = 0 as libc::c_int;
                let mut s1: libc::c_int = 0 as libc::c_int;
                let mut del: libc::c_int = 0;
                let mut cl: libc::c_int = (*lgl).conf.lit;
                let mut c0: libc::c_int = (*lgl).conf.rsn[0 as libc::c_int as usize];
                let mut c1: libc::c_int = (*lgl).conf.rsn[1 as libc::c_int as usize];
                del = lit;
                if !(resolved > 2 as libc::c_int) {
                    if resolventsize >= size {
                        del = -lit;
                        lit = cl;
                        r0 = c0;
                        r1 = c1;
                    } else if !(resolventsize >= savedsize) {
                        if r0 & REDCS as libc::c_int != 0 {
                            sl = lit;
                            s0 = r0;
                            s1 = r1;
                            del = -lit;
                            lit = cl;
                            r0 = c0;
                            r1 = c1;
                        } else {
                            sl = cl;
                            s0 = c0;
                            s1 = c1;
                        }
                    }
                }
                lgldynstr(lgl, del, lit, r0, r1);
                if sl != 0 {
                    lgldynsub(lgl, sl, s0, s1);
                }
                lit = (*lgl).conf.lit;
                r0 = (*lgl).conf.rsn[0 as libc::c_int as usize];
                r1 = (*lgl).conf.rsn[1 as libc::c_int as usize];
                tag = r0 & MASKCS as libc::c_int;
                if tag == UNITCS as libc::c_int {
                    mlevel = lglevel(lgl, lit);
                    nmlevel = 1 as libc::c_int;
                    jlevel = 0 as libc::c_int;
                } else if tag == BINCS as libc::c_int {
                    jlevel = lglevel(lgl, lit);
                    other = r0 >> RMSHFT as libc::c_int;
                    mlevel = lglevel(lgl, other);
                    if jlevel > mlevel {
                        nmlevel = 1 as libc::c_int;
                        let mut TMP: libc::c_int = mlevel;
                        mlevel = jlevel;
                        jlevel = TMP;
                    } else if jlevel == mlevel {
                        nmlevel = 2 as libc::c_int;
                    } else {
                        nmlevel = 1 as libc::c_int;
                    }
                } else if tag == TRNCS as libc::c_int {
                    jlevel = lglevel(lgl, lit);
                    other = r0 >> RMSHFT as libc::c_int;
                    level = lglevel(lgl, other);
                    other2 = r1;
                    mlevel = lglevel(lgl, other2);
                    if jlevel > mlevel {
                        let mut TMP_0: libc::c_int = jlevel;
                        jlevel = mlevel;
                        mlevel = TMP_0;
                    }
                    if level > mlevel {
                        let mut TMP_1: libc::c_int = level;
                        level = mlevel;
                        mlevel = TMP_1;
                    }
                    if level > jlevel {
                        let mut TMP_2: libc::c_int = level;
                        level = jlevel;
                        jlevel = TMP_2;
                    }
                    if mlevel == jlevel {
                        nmlevel = 2 as libc::c_int + (jlevel == level) as libc::c_int;
                    } else {
                        nmlevel = 1 as libc::c_int;
                    }
                } else {
                    mlevel = lglevel(lgl, lit);
                    nmlevel = 1 as libc::c_int;
                    jlevel = 0 as libc::c_int;
                    red = r0 & REDCS as libc::c_int;
                    p = lglidx2lits(lgl, red, r1);
                    while jlevel < (*lgl).level
                        && {
                            let fresh98 = p;
                            p = p.offset(1);
                            other = *fresh98;
                            other != 0
                        }
                    {
                        if other == lit {
                            continue;
                        }
                        level = lglevel(lgl, other);
                        if level < mlevel {
                            if level > jlevel {
                                jlevel = level;
                            }
                        } else if level == mlevel {
                            nmlevel += 1;
                            nmlevel;
                        } else {
                            jlevel = mlevel;
                            mlevel = level;
                            nmlevel = 1 as libc::c_int;
                        }
                    }
                    if red != 0 {
                        lglbumpnupdatelidx(lgl, r1);
                    }
                }
                if nmlevel >= 2 as libc::c_int {
                    (*(*lgl).stats).otfs.restarting += 1;
                    (*(*lgl).stats).otfs.restarting;
                    lglclnana(lgl);
                    if (*lgl).level > mlevel {
                        lglbacktrack(lgl, mlevel);
                    }
                    continue '_RESTART;
                } else {
                    (*(*lgl).stats).otfs.driving += 1;
                    (*(*lgl).stats).otfs.driving;
                    lglbacktrack(lgl, jlevel);
                    if tag == LRGCS as libc::c_int && r0 & REDCS as libc::c_int != 0
                        && r1
                            & ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int
                            == ((1 as libc::c_int) << 4 as libc::c_int)
                                - 1 as libc::c_int
                    {
                        p = lglidx2lits(lgl, REDCS as libc::c_int, r1);
                        if p
                            > (*((*lgl).red)
                                .offset(
                                    (((1 as libc::c_int) << 4 as libc::c_int)
                                        - 1 as libc::c_int) as isize,
                                ))
                                .top
                        {
                            rsn = lglrsn(lgl, lit);
                            r1 = lglcntstk(
                                &mut *((*lgl).red)
                                    .offset(
                                        (((1 as libc::c_int) << 4 as libc::c_int)
                                            - 1 as libc::c_int) as isize,
                                    ),
                            ) as libc::c_int;
                            r1 <<= 4 as libc::c_int;
                            r1
                                |= ((1 as libc::c_int) << 4 as libc::c_int)
                                    - 1 as libc::c_int;
                            *rsn.offset(1 as libc::c_int as isize) = r1;
                            q = (*((*lgl).red)
                                .offset(
                                    (((1 as libc::c_int) << 4 as libc::c_int)
                                        - 1 as libc::c_int) as isize,
                                ))
                                .top;
                            while *p != 0 {
                                let fresh99 = q;
                                q = q.offset(1);
                                *fresh99 = *p;
                                p = p.offset(1);
                                p;
                            }
                            let fresh100 = q;
                            q = q.offset(1);
                            *fresh100 = 0 as libc::c_int;
                            let ref mut fresh101 = (*((*lgl).red)
                                .offset(
                                    (((1 as libc::c_int) << 4 as libc::c_int)
                                        - 1 as libc::c_int) as isize,
                                ))
                                .top;
                            *fresh101 = q;
                        } else if p
                            == (*((*lgl).red)
                                .offset(
                                    (((1 as libc::c_int) << 4 as libc::c_int)
                                        - 1 as libc::c_int) as isize,
                                ))
                                .top
                        {
                            while *p != 0 {
                                p = p.offset(1);
                                p;
                            }
                            p = p.offset(1);
                            if p
                                > (*((*lgl).red)
                                    .offset(
                                        (((1 as libc::c_int) << 4 as libc::c_int)
                                            - 1 as libc::c_int) as isize,
                                    ))
                                    .top
                            {
                                let ref mut fresh102 = (*((*lgl).red)
                                    .offset(
                                        (((1 as libc::c_int) << 4 as libc::c_int)
                                            - 1 as libc::c_int) as isize,
                                    ))
                                    .top;
                                *fresh102 = p;
                            }
                        }
                    }
                    lglassign(lgl, lit, r0, r1);
                    len = 2147483647 as libc::c_int;
                    break '_RESTART;
                }
            } else {
                savedsize = size;
                loop {
                    lit = lglpopstk(&mut (*lgl).trail);
                    if !(lglmarked(lgl, lit) == 0) {
                        break;
                    }
                    lglunassign(lgl, lit);
                }
                lglunassign(lgl, lit);
                open -= 1;
                if open == 0 {
                    uip = -lit;
                    break;
                } else {
                    rsn = lglrsn(lgl, lit);
                    r0 = *rsn.offset(0 as libc::c_int as isize);
                    r1 = *rsn.offset(1 as libc::c_int as isize);
                }
            }
        }
        lglpushstk(lgl, &mut (*lgl).clause, uip);
        lglpushstk(lgl, &mut (*lgl).clause, 0 as libc::c_int);
        lgldrive(
            lgl,
            b"preliminary\0" as *const u8 as *const libc::c_char,
            0 as *mut libc::c_int,
            &mut glue,
            0 as *mut libc::c_int,
            &mut jlevel,
        );
        origsize = (lglcntstk(&mut (*lgl).clause))
            .wrapping_sub(1 as libc::c_int as size_t) as libc::c_int;
        lglbumpseenlits(lgl);
        (*(*lgl).stats).lits.nonmin += origsize as int64_t;
        redsize = jlevel + 1 as libc::c_int;
        if origsize == 2 as libc::c_int {
            (*(*lgl).stats).mincls.bin += 1;
            (*(*lgl).stats).mincls.bin;
        } else if glue + 1 as libc::c_int == origsize {
            (*(*lgl).stats).mincls.size += 1;
            (*(*lgl).stats).mincls.size;
        } else if jlevel > 1 as libc::c_int && (*(*lgl).opts).deco.val != 0
            && redsize < 2 as libc::c_int * origsize / 3 as libc::c_int
            && glue > (*(*lgl).opts).decolim.val
        {
            (*(*lgl).stats).mincls.deco += 1;
            (*(*lgl).stats).mincls.deco;
            (*(*lgl).stats).deco.sum.orig += origsize as int64_t;
            lgldeco(lgl, jlevel, uip);
            lglpushstk(lgl, &mut (*lgl).clause, uip);
            (*(*lgl).stats)
                .deco
                .sum
                .red = ((*(*lgl).stats).deco.sum.red as size_t)
                .wrapping_add(lglcntstk(&mut (*lgl).clause)) as int64_t as int64_t;
            lglpushstk(lgl, &mut (*lgl).clause, 0 as libc::c_int);
        } else {
            lglmincls(lgl, uip, glue);
            lglredcls(lgl, uip, glue, &mut jlevel);
        }
        lgldrive(
            lgl,
            b"final\0" as *const u8 as *const libc::c_char,
            &mut uip,
            &mut glue,
            &mut realglue,
            &mut jlevel,
        );
        if uip != 0 && *(lglrsn(lgl, uip)).offset(0 as libc::c_int as isize) != 0 {
            (*(*lgl).stats).uips += 1;
            (*(*lgl).stats).uips;
        } else if jlevel + 1 as libc::c_int == (*lgl).level {
            (*(*lgl).stats).decflipped += 1;
            (*(*lgl).stats).decflipped;
        }
        lglbumpscinc(lgl);
        lglbacktrack(lgl, jlevel);
        len = (lglcntstk(&mut (*lgl).clause)).wrapping_sub(1 as libc::c_int as size_t)
            as libc::c_int;
        (*(*lgl).stats).clauses.glue += glue as int64_t;
        (*(*lgl).stats).clauses.realglue += realglue as int64_t;
        (*(*lgl).stats).lits.learned += len as int64_t;
        (*(*lgl).stats).clauses.learned += 1;
        (*(*lgl).stats).clauses.learned;
        if (*lgl).simp == 0 {
            lglupdateavg(lgl, &mut (*(*lgl).stats).avglue, realglue);
            lglupdatemacd(lgl, &mut (*(*lgl).stats).glue, realglue as int64_t);
            lglupdatemacd(lgl, &mut (*(*lgl).stats).jlevel, jlevel as int64_t);
            lglupdatema(
                lgl,
                &mut (*(*lgl).stats).tlevel,
                tlevel as int64_t,
                1 as libc::c_int,
            );
            if (*(*lgl).opts).restartblock.val == 1 as libc::c_int
                && lglblockrestart(lgl) != 0
            {
                (*(*lgl).limits)
                    .restart
                    .confs = (*(*lgl).stats).confs
                    + (*(*lgl).opts).restartint.val as int64_t;
                (*(*lgl).stats).restarts.blocked += 1;
                (*(*lgl).stats).restarts.blocked;
            }
        }
        lgldrupligaddcls(lgl, REDCS as libc::c_int);
        lidx = lgladdcls(lgl, REDCS as libc::c_int, realglue, 1 as libc::c_int);
        if (*(*lgl).opts).subl.val != 0 {
            lglstart(lgl, &mut (*(*lgl).times).subl);
            (*(*lgl).stats).subl.count += 1;
            (*(*lgl).stats).subl.count;
            lglpopnunmarkstk(lgl, &mut (*lgl).seen);
            size = (lglcntstk(&mut (*lgl).clause))
                .wrapping_sub(1 as libc::c_int as size_t) as libc::c_int;
            if size > 1 as libc::c_int {
                let mut sig: libc::c_uint = 0 as libc::c_int as libc::c_uint;
                p = (*lgl).clause.start;
                loop {
                    let fresh103 = p;
                    p = p.offset(1);
                    lit = *fresh103;
                    if !(lit != 0) {
                        break;
                    }
                    sig |= (1 as libc::c_uint) << (lglulit(lit) & 31 as libc::c_int);
                    lglmark(lgl, lit);
                }
                q = (*lgl).learned.start;
                p = q;
                while p < (*lgl).learned.top {
                    let mut olidx: libc::c_int = *p.offset(0 as libc::c_int as isize);
                    let mut osize: libc::c_int = *p.offset(1 as libc::c_int as isize);
                    let mut osig: libc::c_uint = *p.offset(2 as libc::c_int as isize)
                        as libc::c_uint;
                    if !(olidx < 0 as libc::c_int) {
                        if osize <= size || sig & !osig != 0
                            || lglsubl(lgl, olidx, size, glue) == 0
                        {
                            let fresh104 = q;
                            q = q.offset(1);
                            *fresh104 = olidx;
                            let fresh105 = q;
                            q = q.offset(1);
                            *fresh105 = osize;
                            let fresh106 = q;
                            q = q.offset(1);
                            *fresh106 = osig as libc::c_int;
                        }
                    }
                    p = p.offset(3 as libc::c_int as isize);
                }
                (*lgl).learned.top = q;
                if lidx != 0
                    && (lidx
                        & ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int)
                        < ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int
                {
                    (*(*lgl).stats).subl.cands += 1;
                    (*(*lgl).stats).subl.cands;
                    lglpushstk(lgl, &mut (*lgl).learned, lidx);
                    lglpushstk(lgl, &mut (*lgl).learned, size);
                    lglpushstk(lgl, &mut (*lgl).learned, sig as libc::c_int);
                    if lglcntstk(&mut (*lgl).learned) as libc::c_int / 3 as libc::c_int
                        > (*(*lgl).opts).subl.val
                    {
                        q = (*lgl).learned.start;
                        p = q.offset(3 as libc::c_int as isize);
                        while p < (*lgl).learned.top {
                            let fresh107 = q;
                            q = q.offset(1);
                            *fresh107 = *p;
                            p = p.offset(1);
                            p;
                        }
                        (*lgl).learned.top = q;
                    }
                }
                p = (*lgl).clause.start;
                loop {
                    let fresh108 = p;
                    p = p.offset(1);
                    lit = *fresh108;
                    if !(lit != 0) {
                        break;
                    }
                    lglunmark(lgl, lit);
                }
            }
            lglstop(lgl);
        }
        if !((*lgl).cbs).is_null() && ((*(*lgl).cbs).cls.produce.fun).is_some()
            && glue <= (*(*lgl).opts).synclsglue.val
            && lglcntstk(&mut (*lgl).clause) as libc::c_int - 1 as libc::c_int
                <= (*(*lgl).opts).synclslen.val
        {
            p = (*lgl).clause.start;
            while *p != 0 {
                lglpushstk(lgl, &mut (*lgl).eclause, lglexport(lgl, *p));
                p = p.offset(1);
                p;
            }
            lglpushstk(lgl, &mut (*lgl).eclause, 0 as libc::c_int);
            (*(*lgl).stats).sync.cls.produced += 1;
            (*(*lgl).stats).sync.cls.produced;
            ((*(*lgl).cbs).cls.produce.fun)
                .expect(
                    "non-null function pointer",
                )((*(*lgl).cbs).cls.produce.state, (*lgl).eclause.start, glue);
            lglclnstk(&mut (*lgl).eclause);
        }
        break;
    }
    if (*lgl).simp == 0 {
        lglrndcls(lgl, len, 0 as libc::c_int);
    }
    lglclnana(lgl);
    lglstop(lgl);
    return 1 as libc::c_int;
}
unsafe extern "C" fn lglincrestart(mut lgl: *mut LGL) {
    let mut s: *mut Stats = (*lgl).stats;
    let mut delta: int64_t = 0;
    let mut pen: libc::c_int = 0 as libc::c_int;
    delta = (*(*lgl).opts).restartint.val as int64_t;
    if !((*(*lgl).opts).restartfixed.val != 0) {
        if (*(*lgl).opts).restartpen1.val != 0
            && (*s).confs > 500000 as libc::c_int as int64_t
            && ((*s).its.count == 0
                || (*s).confs / (*s).its.count as int64_t
                    > 100000 as libc::c_int as int64_t)
        {
            lglprt(
                lgl,
                2 as libc::c_int,
                b"[restart-%lld] few iterations after 500000 conflicts\0" as *const u8
                    as *const libc::c_char,
                (*(*lgl).stats).restarts.count as libc::c_longlong,
            );
            pen += 1;
            pen;
        }
        if (*(*lgl).opts).restartpen2.val != 0
            && (*s).confs > 50000 as libc::c_int as int64_t
            && ((*s).bins == 0
                || (*s).confs / (*s).bins > 10000 as libc::c_int as int64_t)
        {
            lglprt(
                lgl,
                2 as libc::c_int,
                b"[restart-%lld] few binaries after 50000 conflicts\0" as *const u8
                    as *const libc::c_char,
                (*(*lgl).stats).restarts.count as libc::c_longlong,
            );
            pen += 1;
            pen;
        }
        if (*(*lgl).opts).restartpen3.val != 0
            && (*s).confs > 5000 as libc::c_int as int64_t
            && ((*s).trns == 0
                || (*s).confs / (*s).trns > 1000 as libc::c_int as int64_t)
        {
            lglprt(
                lgl,
                2 as libc::c_int,
                b"[restart-%lld] few ternaries after 5000 conflicts\0" as *const u8
                    as *const libc::c_char,
                (*(*lgl).stats).restarts.count as libc::c_longlong,
            );
            pen += 1;
            pen;
        }
        if (*(*lgl).opts).restartpenstab.val != 0
            && (*s).confs > 50000 as libc::c_int as int64_t
        {
            let mut glue: int64_t = (*s).glue.slow.val >> 32 as libc::c_int;
            if glue < 20 as libc::c_int as int64_t {
                let mut stab: int64_t = (*s).stability.avg.val;
                let mut peninc: libc::c_int = 0 as libc::c_int;
                stab *= 100000 as libc::c_int as int64_t;
                stab >>= 32 as libc::c_int;
                if stab > 98000 as libc::c_int as int64_t {
                    peninc += 1;
                    peninc;
                }
                if stab > 99000 as libc::c_int as int64_t {
                    peninc += 1;
                    peninc;
                }
                if stab > 99500 as libc::c_int as int64_t {
                    peninc += 1;
                    peninc;
                }
                if stab > 99750 as libc::c_int as int64_t {
                    peninc += 1;
                    peninc;
                }
                if stab > 99875 as libc::c_int as int64_t {
                    peninc += 1;
                    peninc;
                }
                pen += peninc;
                lglprt(
                    lgl,
                    2 as libc::c_int,
                    b"[restart-%lld] stability %lld glue %d after 50000 conflicts (penalty increase %d)\0"
                        as *const u8 as *const libc::c_char,
                    (*(*lgl).stats).restarts.count as libc::c_longlong,
                    stab,
                    glue,
                    peninc,
                );
            }
        }
    }
    delta <<= pen;
    (*(*lgl).stats).restarts.delta.pen += pen as int64_t;
    (*(*lgl).stats).restarts.delta.delta += delta;
    (*(*lgl).stats).restarts.delta.count += 1;
    (*(*lgl).stats).restarts.delta.count;
    (*(*lgl).limits).restart.confs = (*(*lgl).stats).confs + delta;
    lglprt(
        lgl,
        2 as libc::c_int,
        b"[restart-%lld] next restart %lld delta %lld (penalty %d)\0" as *const u8
            as *const libc::c_char,
        (*(*lgl).stats).restarts.count as libc::c_longlong,
        (*(*lgl).limits).restart.confs as libc::c_longlong,
        delta as libc::c_longlong,
        pen,
    );
    lglrep(lgl, 2 as libc::c_int, 'R' as i32 as libc::c_char);
}
unsafe extern "C" fn lglqueueflush(mut lgl: *mut LGL) {
    let mut before: libc::c_int = 0;
    let mut mt: libc::c_int = 0;
    let mut after: libc::c_int = 0;
    let mut nonfree: libc::c_int = 0;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut start: *const libc::c_int = 0 as *const libc::c_int;
    let mut q: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut lit: libc::c_int = 0;
    let mut found: libc::c_int = 0;
    let mut qv: *mut QVar = 0 as *mut QVar;
    (*(*lgl).stats).queue.flushed += 1;
    (*(*lgl).stats).queue.flushed;
    mt = 0 as libc::c_int;
    nonfree = mt;
    found = nonfree;
    before = lglcntstk(&mut (*lgl).queue.stk) as libc::c_int;
    q = (*lgl).queue.stk.start;
    start = q;
    p = q;
    while p < (*lgl).queue.stk.top as *const libc::c_int {
        lit = *p;
        if lit == 0 {
            mt += 1;
            mt;
        } else {
            qv = lglqvar(lgl, lit);
            if lglisfree(lgl, lit) == 0 {
                (*qv).set_enqueued(0 as libc::c_int as libc::c_uint);
                (*qv).pos = -(1 as libc::c_int);
                nonfree += 1;
                nonfree;
            } else {
                (*qv).pos = q.offset_from(start) as libc::c_long as libc::c_int;
                if found == 0
                    && (*lgl).queue.next as libc::c_long
                        >= p.offset_from(start) as libc::c_long
                {
                    found = 1 as libc::c_int;
                    (*lgl).queue.next = (*qv).pos;
                }
                let fresh109 = q;
                q = q.offset(1);
                *fresh109 = lit;
            }
        }
        p = p.offset(1);
        p;
    }
    (*lgl).queue.stk.top = q;
    if found == 0 {
        (*lgl)
            .queue
            .next = (lglcntstk(&mut (*lgl).queue.stk))
            .wrapping_sub(1 as libc::c_int as size_t) as libc::c_int;
    }
    (*lgl).queue.mt = 0 as libc::c_int;
    after = lglcntstk(&mut (*lgl).queue.stk) as libc::c_int;
    lglprt(
        lgl,
        2 as libc::c_int,
        b"[flush-queue-%d] flushed %d = %d mt + %d nonfree (resized %d to %d)\0"
            as *const u8 as *const libc::c_char,
        (*(*lgl).stats).queue.flushed,
        mt + nonfree,
        mt,
        nonfree,
        before,
        after,
    );
}
unsafe extern "C" fn lglnextdecision(
    mut lgl: *mut LGL,
    mut updatestats: libc::c_int,
) -> libc::c_int {
    let mut res: libc::c_int = 0 as libc::c_int;
    let mut qv: *mut QVar = 0 as *mut QVar;
    if (*lgl).unassigned == 0 {
        return 0 as libc::c_int;
    }
    lglstart(lgl, &mut (*(*lgl).times).decide);
    lglstart(lgl, &mut (*(*lgl).times).heapdecision);
    while res == 0 && lglmtstk(&mut (*lgl).dsched) == 0 {
        let mut next: libc::c_int = lgltopdsched(lgl);
        if lglval(lgl, next) == 0 && lglisfree(lgl, next) != 0 {
            res = next;
        } else {
            lglpopdsched(lgl);
        }
    }
    lglstop(lgl);
    if res == 0 {
        lglstart(lgl, &mut (*(*lgl).times).queuedecision);
        if (lglcntstk(&mut (*lgl).queue.stk) as libc::c_int)
            < 2 as libc::c_int * (*lgl).queue.mt
        {
            lglqueueflush(lgl);
        }
        loop {
            res = lglpeek(&mut (*lgl).queue.stk, (*lgl).queue.next);
            if res != 0 {
                qv = lglqvar(lgl, res);
                if lglisfree(lgl, res) == 0 {
                    lglpoke(&mut (*lgl).queue.stk, (*lgl).queue.next, 0 as libc::c_int);
                    (*lgl).queue.mt += 1;
                    (*lgl).queue.mt;
                    (*qv).set_enqueued(0 as libc::c_int as libc::c_uint);
                    (*qv).pos = -(1 as libc::c_int);
                } else if lglval(lgl, res) == 0 {
                    if updatestats != 0 {
                        (*(*lgl).stats).qdecs += 1;
                        (*(*lgl).stats).qdecs;
                    }
                    break;
                }
            }
            (*lgl).queue.next -= 1;
            (*lgl).queue.next;
            if (*lgl).queue.next < 0 as libc::c_int {
                (*lgl)
                    .queue
                    .next = (lglcntstk(&mut (*lgl).queue.stk))
                    .wrapping_sub(1 as libc::c_int as size_t) as libc::c_int;
            }
        }
        lglstop(lgl);
    } else if updatestats != 0 {
        (*(*lgl).stats).hdecs += 1;
        (*(*lgl).stats).hdecs;
    }
    lglstop(lgl);
    return res;
}
unsafe extern "C" fn lglreusetrail(mut lgl: *mut LGL) -> libc::c_int {
    let mut next: libc::c_int = 0 as libc::c_int;
    let mut res: libc::c_int = 0 as libc::c_int;
    let mut prev: libc::c_int = 0;
    let mut level: libc::c_int = 0;
    let mut p: *const Ctr = 0 as *const Ctr;
    if (*(*lgl).opts).reusetrail.val == 0 {
        return 0 as libc::c_int;
    }
    next = lglnextdecision(lgl, 0 as libc::c_int);
    if next == 0 {
        return 0 as libc::c_int;
    }
    p = ((*lgl).control.start).offset(1 as libc::c_int as isize);
    while p < (*lgl).control.top as *const Ctr {
        prev = (*p).decision();
        if lglassumption(lgl, prev) == 0 && lgldcmp(lgl, prev, next) < 0 as libc::c_int {
            break;
        }
        level = lglevel(lgl, prev);
        res = level;
        p = p.offset(1);
        p;
    }
    if res != 0 {
        lglprt(
            lgl,
            3 as libc::c_int,
            b"[reuse-trail] reusing level %d from current level %d\0" as *const u8
                as *const libc::c_char,
            res,
            (*lgl).level,
        );
    } else {
        lglprt(
            lgl,
            3 as libc::c_int,
            b"[reuse-trail] can not reuse any level from current level %d\0" as *const u8
                as *const libc::c_char,
            (*lgl).level,
        );
    }
    return res;
}
unsafe extern "C" fn lglrestart(mut lgl: *mut LGL) {
    let mut level: libc::c_int = 0;
    let mut kept: libc::c_int = 0;
    lglstart(lgl, &mut (*(*lgl).times).restart);
    level = lglreusetrail(lgl);
    if level < (*lgl).alevel {
        level = (*lgl).alevel;
    } else if level > (*lgl).alevel {
        kept = 100 as libc::c_int * level / (*lgl).level;
        (*(*lgl).stats).restarts.kept.sum += kept as int64_t;
        (*(*lgl).stats).restarts.kept.count += 1;
        (*(*lgl).stats).restarts.kept.count;
    }
    if level < (*lgl).level {
        let mut oldlevel: libc::c_int = (*lgl).level;
        lglbacktrack(lgl, level);
        (*(*lgl).stats).stability.level = oldlevel;
        (*(*lgl).stats).stability.changed = 0 as libc::c_int;
        (*(*lgl).stats).restarts.count += 1;
        (*(*lgl).stats).restarts.count;
    } else {
        (*(*lgl).stats).restarts.reused += 1;
        (*(*lgl).stats).restarts.reused;
        (*(*lgl).stats).restarts.skipped += 1;
        (*(*lgl).stats).restarts.skipped;
    }
    lglincrestart(lgl);
    lglstop(lgl);
}
unsafe extern "C" fn lgldefrag(mut lgl: *mut LGL) {
    let mut wchs: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut i: libc::c_int = 0;
    let mut idx: libc::c_int = 0;
    let mut bit: libc::c_int = 0;
    let mut ldsize: libc::c_int = 0;
    let mut size: libc::c_int = 0;
    let mut start: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut q: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut end: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut eow: *const libc::c_int = 0 as *const libc::c_int;
    let mut w: *const libc::c_int = 0 as *const libc::c_int;
    let mut offset: libc::c_uint = 0;
    let mut nwchs: libc::c_long = 0;
    let mut hts: *mut HTS = 0 as *mut HTS;
    lglstart(lgl, &mut (*(*lgl).times).defrag);
    (*(*lgl).stats).defrags += 1;
    (*(*lgl).stats).defrags;
    nwchs = lglcntstk(&mut (*(*lgl).wchs).stk) as libc::c_long;
    wchs = lglnew(
        lgl,
        (nwchs as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
    ) as *mut libc::c_int;
    memcpy(
        wchs as *mut libc::c_void,
        (*(*lgl).wchs).stk.start as *const libc::c_void,
        (nwchs as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
    );
    i = 0 as libc::c_int;
    while i < 31 as libc::c_int {
        (*(*lgl).wchs)
            .start[i
            as usize] = (2147483647 as libc::c_int as libc::c_uint)
            .wrapping_mul(2 as libc::c_uint)
            .wrapping_add(1 as libc::c_uint);
        i += 1;
        i;
    }
    (*(*lgl).wchs).free = 0 as libc::c_int;
    start = (*(*lgl).wchs).stk.start;
    offset = 1 as libc::c_int as libc::c_uint;
    idx = 2 as libc::c_int;
    while idx < (*lgl).nvars {
        bit = 0 as libc::c_int;
        while bit <= 1 as libc::c_int {
            hts = ((*((*lgl).dvars).offset(idx as isize)).hts)
                .as_mut_ptr()
                .offset(bit as isize);
            if !((*hts).offset == 0) {
                ldsize = lglceild((*hts).count as libc::c_int);
                size = (1 as libc::c_int) << ldsize;
                w = wchs.offset((*hts).offset as isize);
                (*hts).offset = offset;
                eow = w.offset((*hts).count as isize);
                q = start.offset(offset as isize);
                p = w;
                while p < eow {
                    let fresh110 = q;
                    q = q.offset(1);
                    *fresh110 = *p;
                    p = p.offset(1);
                    p;
                }
                offset = offset.wrapping_add(size as libc::c_uint);
                end = start.offset(offset as isize);
                while q < end {
                    let fresh111 = q;
                    q = q.offset(1);
                    *fresh111 = 0 as libc::c_int;
                }
            }
            bit += 1;
            bit;
        }
        idx += 1;
        idx;
    }
    lgldel(
        lgl,
        wchs as *mut libc::c_void,
        (nwchs as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
    );
    wchs = 0 as *mut libc::c_int;
    q = start.offset(offset as isize);
    let fresh112 = q;
    q = q.offset(1);
    *fresh112 = (2147483647 as libc::c_int as libc::c_uint)
        .wrapping_mul(2 as libc::c_uint)
        .wrapping_add(1 as libc::c_uint) as libc::c_int;
    (*(*lgl).wchs).stk.top = q;
    lglfitstk(lgl, &mut (*(*lgl).wchs).stk);
    (*(*lgl).limits)
        .dfg = (*(*lgl).stats).pshwchs + (*(*lgl).opts).defragint.val as int64_t;
    lglrep(lgl, 2 as libc::c_int, 'F' as i32 as libc::c_char);
    lglstop(lgl);
}
unsafe extern "C" fn lgldis(mut lgl: *mut LGL) {
    let mut blit: libc::c_int = 0;
    let mut nblit: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut red: libc::c_int = 0;
    let mut p: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut q: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut eow: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut w: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut idx: libc::c_int = 0;
    let mut sign: libc::c_int = 0;
    let mut lit: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut other2: libc::c_int = 0;
    let mut bins: Stk = Stk {
        start: 0 as *mut libc::c_int,
        top: 0 as *mut libc::c_int,
        end: 0 as *mut libc::c_int,
    };
    let mut trns: Stk = Stk {
        start: 0 as *mut libc::c_int,
        top: 0 as *mut libc::c_int,
        end: 0 as *mut libc::c_int,
    };
    let mut val: Val = 0;
    let mut val2: Val = 0;
    let mut hts: *mut HTS = 0 as *mut HTS;
    memset(
        &mut bins as *mut Stk as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<Stk>() as libc::c_ulong,
    );
    memset(
        &mut trns as *mut Stk as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<Stk>() as libc::c_ulong,
    );
    idx = 2 as libc::c_int;
    while idx < (*lgl).nvars {
        sign = -(1 as libc::c_int);
        while sign <= 1 as libc::c_int {
            lit = idx * sign;
            hts = lglhts(lgl, lit);
            if !((*hts).offset == 0) {
                val = lglval(lgl, lit);
                if (*lgl).mt != 0 || val as libc::c_int != 0 || lgliselim(lgl, lit) != 0
                {
                    lglshrinkhts(lgl, hts, 0 as libc::c_int);
                } else {
                    w = lglhts2wchs(lgl, hts);
                    eow = w.offset((*hts).count as isize);
                    p = w;
                    while p < eow {
                        blit = *p;
                        tag = blit & MASKCS as libc::c_int;
                        red = blit & REDCS as libc::c_int;
                        if !(tag == OCCS as libc::c_int) {
                            if tag == TRNCS as libc::c_int || tag == LRGCS as libc::c_int
                            {
                                p = p.offset(1);
                                p;
                            }
                            if !(tag == LRGCS as libc::c_int) {
                                other = blit >> RMSHFT as libc::c_int;
                                val = lglval(lgl, other);
                                if !(val as libc::c_int > 0 as libc::c_int) {
                                    if !(lgliselim(lgl, other) != 0) {
                                        if tag == BINCS as libc::c_int {
                                            lglpushstk(lgl, &mut bins, blit);
                                        } else {
                                            other2 = *p;
                                            val2 = lglval(lgl, other2);
                                            if !(val2 as libc::c_int > 0 as libc::c_int) {
                                                if !(lgliselim(lgl, other2) != 0) {
                                                    if (val as libc::c_int) < 0 as libc::c_int {
                                                        nblit = red
                                                            | ((other2 as libc::c_uint) << RMSHFT as libc::c_int)
                                                                as libc::c_int | BINCS as libc::c_int;
                                                        lglpushstk(lgl, &mut bins, nblit);
                                                        if abs(lit) < abs(other2) {
                                                            lgldrupligaddclsarg(
                                                                lgl,
                                                                REDCS as libc::c_int,
                                                                lit,
                                                                other2,
                                                                0 as libc::c_int,
                                                            );
                                                            lgldrupligdelclsarg(
                                                                lgl,
                                                                lit,
                                                                other,
                                                                other2,
                                                                0 as libc::c_int,
                                                            );
                                                        }
                                                    } else if (val2 as libc::c_int) < 0 as libc::c_int {
                                                        nblit = red
                                                            | ((other as libc::c_uint) << RMSHFT as libc::c_int)
                                                                as libc::c_int | BINCS as libc::c_int;
                                                        lglpushstk(lgl, &mut bins, nblit);
                                                        if abs(lit) < abs(other) {
                                                            lgldrupligaddclsarg(
                                                                lgl,
                                                                REDCS as libc::c_int,
                                                                lit,
                                                                other,
                                                                0 as libc::c_int,
                                                            );
                                                            lgldrupligdelclsarg(
                                                                lgl,
                                                                lit,
                                                                other,
                                                                other2,
                                                                0 as libc::c_int,
                                                            );
                                                        }
                                                    } else {
                                                        lglpushstk(lgl, &mut trns, blit);
                                                        lglpushstk(lgl, &mut trns, other2);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        p = p.offset(1);
                        p;
                    }
                    q = w;
                    p = bins.start;
                    while p != bins.top {
                        let fresh113 = q;
                        q = q.offset(1);
                        *fresh113 = *p;
                        p = p.offset(1);
                        p;
                    }
                    p = trns.start;
                    while p != trns.top {
                        let fresh114 = q;
                        q = q.offset(1);
                        *fresh114 = *p;
                        p = p.offset(1);
                        p;
                    }
                    lglshrinkhts(
                        lgl,
                        hts,
                        q.offset_from(w) as libc::c_long as libc::c_int,
                    );
                    lglclnstk(&mut bins);
                    lglclnstk(&mut trns);
                }
            }
            sign += 2 as libc::c_int;
        }
        idx += 1;
        idx;
    }
    lglrelstk(lgl, &mut bins);
    lglrelstk(lgl, &mut trns);
    lglrelstk(lgl, &mut (*lgl).learned);
}
unsafe extern "C" fn lglcmphase(
    mut lgl: *mut LGL,
    mut a: libc::c_int,
    mut b: libc::c_int,
) -> libc::c_int {
    return lgliphase(lgl, b) as libc::c_int - lgliphase(lgl, a) as libc::c_int;
}
unsafe extern "C" fn lglconnaux(mut lgl: *mut LGL, mut glue: libc::c_int) {
    let mut lit: libc::c_int = 0;
    let mut collect: libc::c_int = 0;
    let mut lidx: libc::c_int = 0;
    let mut size: libc::c_int = 0;
    let mut origsize: libc::c_int = 0;
    let mut red: libc::c_int = 0;
    let mut act: libc::c_int = 0;
    let druplig: libc::c_int = (*(*lgl).opts).druplig.val;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut c: *const libc::c_int = 0 as *const libc::c_int;
    let mut start: *const libc::c_int = 0 as *const libc::c_int;
    let mut top: *const libc::c_int = 0 as *const libc::c_int;
    let mut stk: *mut Stk = 0 as *mut Stk;
    let mut saved: Stk = Stk {
        start: 0 as *mut libc::c_int,
        top: 0 as *mut libc::c_int,
        end: 0 as *mut libc::c_int,
    };
    let mut q: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut d: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut val: Val = 0;
    if glue >= 0 as libc::c_int {
        red = REDCS as libc::c_int;
        stk = ((*lgl).red).offset(glue as isize);
    } else {
        red = 0 as libc::c_int;
        stk = &mut (*lgl).irr;
    }
    q = (*stk).start;
    start = q;
    top = (*stk).top;
    memset(
        &mut saved as *mut Stk as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<Stk>() as libc::c_ulong,
    );
    c = q;
    while c < top {
        act = *c;
        if act == 2147483647 as libc::c_int {
            p = c.offset(1 as libc::c_int as isize);
            while p < top && *p == 2147483647 as libc::c_int {
                p = p.offset(1);
                p;
            }
            p = p.offset(-1);
            p;
        } else {
            if lglisact(act) != 0 {
                let fresh115 = c;
                c = c.offset(1);
                let fresh116 = q;
                q = q.offset(1);
                *fresh116 = *fresh115;
            } else {
                act = -(1 as libc::c_int);
            }
            d = q;
            collect = 0 as libc::c_int;
            lglclnstk(&mut saved);
            p = c;
            loop {
                lit = *p;
                if !(lit != 0) {
                    break;
                }
                if druplig != 0 {
                    lglpushstk(lgl, &mut saved, lit);
                }
                if !(collect != 0) {
                    val = lglval(lgl, lit);
                    if lgliselim(lgl, lit) != 0 {
                        collect = 1 as libc::c_int;
                    } else if val as libc::c_int > 0 as libc::c_int {
                        collect = 1 as libc::c_int;
                    } else if val == 0 {
                        let fresh117 = q;
                        q = q.offset(1);
                        *fresh117 = lit;
                    }
                }
                p = p.offset(1);
                p;
            }
            size = q.offset_from(d) as libc::c_long as libc::c_int;
            origsize = p.offset_from(c) as libc::c_long as libc::c_int;
            if druplig != 0 && collect == 0 && size > 1 as libc::c_int && size < origsize
            {
                *q = 0 as libc::c_int;
                lgldrupligaddclsaux(lgl, REDCS as libc::c_int, d);
            }
            if collect != 0 || p == c.offset(1 as libc::c_int as isize) {
                q = d.offset(-((act >= 0 as libc::c_int) as libc::c_int as isize));
            } else if size == 0 {
                q = d.offset(-((act >= 0 as libc::c_int) as libc::c_int as isize));
                if (*lgl).mt == 0 {
                    lglmt(lgl);
                }
            } else if size == 1 as libc::c_int {
                q = d.offset(-((act >= 0 as libc::c_int) as libc::c_int as isize));
                lglunit(lgl, *d.offset(0 as libc::c_int as isize));
            } else if size == 2 as libc::c_int {
                q = d.offset(-((act >= 0 as libc::c_int) as libc::c_int as isize));
                lglwchbin(
                    lgl,
                    *d.offset(0 as libc::c_int as isize),
                    *d.offset(1 as libc::c_int as isize),
                    red,
                );
                lglwchbin(
                    lgl,
                    *d.offset(1 as libc::c_int as isize),
                    *d.offset(0 as libc::c_int as isize),
                    red,
                );
            } else if size == 3 as libc::c_int {
                q = d.offset(-((act >= 0 as libc::c_int) as libc::c_int as isize));
                lglwchtrn(
                    lgl,
                    *d.offset(0 as libc::c_int as isize),
                    *d.offset(1 as libc::c_int as isize),
                    *d.offset(2 as libc::c_int as isize),
                    red,
                );
                lglwchtrn(
                    lgl,
                    *d.offset(1 as libc::c_int as isize),
                    *d.offset(0 as libc::c_int as isize),
                    *d.offset(2 as libc::c_int as isize),
                    red,
                );
                lglwchtrn(
                    lgl,
                    *d.offset(2 as libc::c_int as isize),
                    *d.offset(0 as libc::c_int as isize),
                    *d.offset(1 as libc::c_int as isize),
                    red,
                );
            } else {
                if (*(*lgl).opts).sortlits.val != 0 {
                    let mut AA: *mut libc::c_int = d;
                    let NN: libc::c_int = size;
                    let mut L: libc::c_int = 0 as libc::c_int;
                    let mut R: libc::c_int = NN - 1 as libc::c_int;
                    let mut M: libc::c_int = 0;
                    let mut LL: libc::c_int = 0;
                    let mut RR: libc::c_int = 0;
                    let mut I: libc::c_int = 0;
                    if !(R - L <= 10 as libc::c_int) {
                        loop {
                            M = (L + R) / 2 as libc::c_int;
                            let mut TMP: libc::c_int = *AA.offset(M as isize);
                            *AA
                                .offset(
                                    M as isize,
                                ) = *AA.offset((R - 1 as libc::c_int) as isize);
                            *AA.offset((R - 1 as libc::c_int) as isize) = TMP;
                            if lglcmphase(
                                lgl,
                                *AA.offset(L as isize),
                                *AA.offset((R - 1 as libc::c_int) as isize),
                            ) > 0 as libc::c_int
                            {
                                let mut TMP_0: libc::c_int = *AA.offset(L as isize);
                                *AA
                                    .offset(
                                        L as isize,
                                    ) = *AA.offset((R - 1 as libc::c_int) as isize);
                                *AA.offset((R - 1 as libc::c_int) as isize) = TMP_0;
                            }
                            if lglcmphase(
                                lgl,
                                *AA.offset(L as isize),
                                *AA.offset(R as isize),
                            ) > 0 as libc::c_int
                            {
                                let mut TMP_1: libc::c_int = *AA.offset(L as isize);
                                *AA.offset(L as isize) = *AA.offset(R as isize);
                                *AA.offset(R as isize) = TMP_1;
                            }
                            if lglcmphase(
                                lgl,
                                *AA.offset((R - 1 as libc::c_int) as isize),
                                *AA.offset(R as isize),
                            ) > 0 as libc::c_int
                            {
                                let mut TMP_2: libc::c_int = *AA
                                    .offset((R - 1 as libc::c_int) as isize);
                                *AA
                                    .offset(
                                        (R - 1 as libc::c_int) as isize,
                                    ) = *AA.offset(R as isize);
                                *AA.offset(R as isize) = TMP_2;
                            }
                            let mut PIVOT: libc::c_int = 0;
                            let mut J: libc::c_int = R - 1 as libc::c_int;
                            I = L + 1 as libc::c_int - 1 as libc::c_int;
                            PIVOT = *AA.offset(J as isize);
                            loop {
                                loop {
                                    I += 1;
                                    if !(lglcmphase(lgl, *AA.offset(I as isize), PIVOT)
                                        < 0 as libc::c_int)
                                    {
                                        break;
                                    }
                                }
                                loop {
                                    J -= 1;
                                    if !(lglcmphase(lgl, PIVOT, *AA.offset(J as isize))
                                        < 0 as libc::c_int)
                                    {
                                        break;
                                    }
                                    if J == L + 1 as libc::c_int {
                                        break;
                                    }
                                }
                                if I >= J {
                                    break;
                                }
                                let mut TMP_3: libc::c_int = *AA.offset(I as isize);
                                *AA.offset(I as isize) = *AA.offset(J as isize);
                                *AA.offset(J as isize) = TMP_3;
                            }
                            let mut TMP_4: libc::c_int = *AA.offset(I as isize);
                            *AA
                                .offset(
                                    I as isize,
                                ) = *AA.offset((R - 1 as libc::c_int) as isize);
                            *AA.offset((R - 1 as libc::c_int) as isize) = TMP_4;
                            if I - L < R - I {
                                LL = I + 1 as libc::c_int;
                                RR = R;
                                R = I - 1 as libc::c_int;
                            } else {
                                LL = L;
                                RR = I - 1 as libc::c_int;
                                L = I + 1 as libc::c_int;
                            }
                            if R - L > 10 as libc::c_int {
                                lglpushstk(lgl, &mut (*lgl).c2rust_unnamed_0.sortstk, LL);
                                lglpushstk(lgl, &mut (*lgl).c2rust_unnamed_0.sortstk, RR);
                            } else if RR - LL > 10 as libc::c_int {
                                L = LL;
                                R = RR;
                            } else {
                                if !(lglmtstk(&mut (*lgl).c2rust_unnamed_0.sortstk) == 0) {
                                    break;
                                }
                                R = lglpopstk(&mut (*lgl).c2rust_unnamed_0.sortstk);
                                L = lglpopstk(&mut (*lgl).c2rust_unnamed_0.sortstk);
                            }
                        }
                    }
                    let mut PIVOT_0: libc::c_int = 0;
                    let mut L_0: libc::c_int = 0 as libc::c_int;
                    let mut R_0: libc::c_int = NN - 1 as libc::c_int;
                    let mut I_0: libc::c_int = 0;
                    let mut J_0: libc::c_int = 0;
                    I_0 = R_0;
                    while I_0 > L_0 {
                        if lglcmphase(
                            lgl,
                            *AA.offset((I_0 - 1 as libc::c_int) as isize),
                            *AA.offset(I_0 as isize),
                        ) > 0 as libc::c_int
                        {
                            let mut TMP_5: libc::c_int = *AA
                                .offset((I_0 - 1 as libc::c_int) as isize);
                            *AA
                                .offset(
                                    (I_0 - 1 as libc::c_int) as isize,
                                ) = *AA.offset(I_0 as isize);
                            *AA.offset(I_0 as isize) = TMP_5;
                        }
                        I_0 -= 1;
                        I_0;
                    }
                    I_0 = L_0 + 2 as libc::c_int;
                    while I_0 <= R_0 {
                        J_0 = I_0;
                        PIVOT_0 = *AA.offset(I_0 as isize);
                        while lglcmphase(
                            lgl,
                            PIVOT_0,
                            *AA.offset((J_0 - 1 as libc::c_int) as isize),
                        ) < 0 as libc::c_int
                        {
                            *AA
                                .offset(
                                    J_0 as isize,
                                ) = *AA.offset((J_0 - 1 as libc::c_int) as isize);
                            J_0 -= 1;
                            J_0;
                        }
                        *AA.offset(J_0 as isize) = PIVOT_0;
                        I_0 += 1;
                        I_0;
                    }
                }
                let fresh118 = q;
                q = q.offset(1);
                *fresh118 = 0 as libc::c_int;
                lidx = d.offset_from(start) as libc::c_long as libc::c_int;
                if red != 0 {
                    lidx <<= 4 as libc::c_int;
                    lidx |= glue;
                }
                lglwchlrg(
                    lgl,
                    *d.offset(0 as libc::c_int as isize),
                    *d.offset(1 as libc::c_int as isize),
                    red,
                    lidx,
                );
                lglwchlrg(
                    lgl,
                    *d.offset(1 as libc::c_int as isize),
                    *d.offset(0 as libc::c_int as isize),
                    red,
                    lidx,
                );
            }
            if druplig != 0 && (collect != 0 || origsize != size) {
                lglpushstk(lgl, &mut saved, 0 as libc::c_int);
                lgldrupligdelclsaux(lgl, saved.start);
            }
        }
        c = p.offset(1 as libc::c_int as isize);
    }
    (*stk).top = q;
    lglrelstk(lgl, &mut saved);
}
unsafe extern "C" fn lglconsavedbin(mut lgl: *mut LGL) {
    let mut satisfied: libc::c_int = 0;
    let mut eliminated: libc::c_int = 0;
    let mut size: libc::c_int = 0;
    let mut val0: libc::c_int = 0;
    let mut val1: libc::c_int = 0;
    let mut nunits: libc::c_int = 0 as libc::c_int;
    let mut nmt: libc::c_int = 0 as libc::c_int;
    let druplig: libc::c_int = (*(*lgl).opts).druplig.val;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    p = (*lgl).saved.bin.start;
    while p < (*lgl).saved.bin.top as *const libc::c_int {
        val1 = 0 as libc::c_int;
        val0 = val1;
        eliminated = val0;
        satisfied = eliminated;
        val0 = lglval(lgl, *p.offset(0 as libc::c_int as isize)) as libc::c_int;
        if val0 > 0 as libc::c_int {
            satisfied = 1 as libc::c_int;
        } else {
            val1 = lglval(lgl, *p.offset(1 as libc::c_int as isize)) as libc::c_int;
            if val1 > 0 as libc::c_int {
                satisfied = 1 as libc::c_int;
            } else if lgliselim(lgl, *p.offset(0 as libc::c_int as isize)) != 0 {
                eliminated = 1 as libc::c_int;
            } else if lgliselim(lgl, *p.offset(1 as libc::c_int as isize)) != 0 {
                eliminated = 1 as libc::c_int;
            }
        }
        if satisfied != 0 || eliminated != 0 {
            size = 2147483647 as libc::c_int;
        } else if val0 < 0 as libc::c_int && val1 < 0 as libc::c_int {
            nmt += 1;
            nmt;
            size = 0 as libc::c_int;
            if (*lgl).mt == 0 {
                lglmt(lgl);
            }
        } else if val0 == 0 && val1 < 0 as libc::c_int {
            size = 1 as libc::c_int;
            lglunit(lgl, *p.offset(0 as libc::c_int as isize));
            nunits += 1;
            nunits;
        } else if val0 < 0 as libc::c_int && val1 == 0 {
            size = 1 as libc::c_int;
            lglunit(lgl, *p.offset(1 as libc::c_int as isize));
            nunits += 1;
            nunits;
        } else {
            size = 2 as libc::c_int;
            lglwchbin(
                lgl,
                *p.offset(0 as libc::c_int as isize),
                *p.offset(1 as libc::c_int as isize),
                REDCS as libc::c_int,
            );
            lglwchbin(
                lgl,
                *p.offset(1 as libc::c_int as isize),
                *p.offset(0 as libc::c_int as isize),
                REDCS as libc::c_int,
            );
        }
        if druplig != 0 && (satisfied != 0 || eliminated != 0 || size < 2 as libc::c_int)
        {
            lgldrupligdelclsarg(
                lgl,
                *p.offset(0 as libc::c_int as isize),
                *p.offset(1 as libc::c_int as isize),
                0 as libc::c_int,
            );
        }
        p = p.offset(2 as libc::c_int as isize);
    }
    lglprt(
        lgl,
        2 as libc::c_int - (nmt != 0 || nunits != 0) as libc::c_int,
        b"[gc-%d] reconnected %d binary clauses (produced %d empty %d units)\0"
            as *const u8 as *const libc::c_char,
        (*(*lgl).stats).gcs,
        lglcntstk(&mut (*lgl).saved.bin) / 2 as libc::c_int as size_t,
        nmt,
        nunits,
    );
    lglrelstk(lgl, &mut (*lgl).saved.bin);
}
unsafe extern "C" fn lglconsavedtrn(mut lgl: *mut LGL) {
    let druplig: libc::c_int = (*(*lgl).opts).druplig.val;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut satisfied: libc::c_int = 0;
    let mut eliminated: libc::c_int = 0;
    let mut size: libc::c_int = 0;
    let mut val0: libc::c_int = 0;
    let mut val1: libc::c_int = 0;
    let mut val2: libc::c_int = 0;
    let mut nmt: libc::c_int = 0 as libc::c_int;
    let mut nunits: libc::c_int = 0 as libc::c_int;
    let mut nbins: libc::c_int = 0 as libc::c_int;
    p = (*lgl).saved.trn.start;
    while p < (*lgl).saved.trn.top as *const libc::c_int {
        val2 = 0 as libc::c_int;
        val1 = val2;
        val0 = val1;
        eliminated = val0;
        satisfied = eliminated;
        val0 = lglval(lgl, *p.offset(0 as libc::c_int as isize)) as libc::c_int;
        if val0 > 0 as libc::c_int {
            satisfied = 1 as libc::c_int;
        } else {
            val1 = lglval(lgl, *p.offset(1 as libc::c_int as isize)) as libc::c_int;
            if val1 > 0 as libc::c_int {
                satisfied = 1 as libc::c_int;
            } else {
                val2 = lglval(lgl, *p.offset(2 as libc::c_int as isize)) as libc::c_int;
                if val2 > 0 as libc::c_int {
                    satisfied = 1 as libc::c_int;
                } else if lgliselim(lgl, *p.offset(0 as libc::c_int as isize)) != 0 {
                    eliminated = 1 as libc::c_int;
                } else if lgliselim(lgl, *p.offset(1 as libc::c_int as isize)) != 0 {
                    eliminated = 1 as libc::c_int;
                } else if lgliselim(lgl, *p.offset(2 as libc::c_int as isize)) != 0 {
                    eliminated = 1 as libc::c_int;
                }
            }
        }
        if satisfied != 0 || eliminated != 0 {
            size = 2147483647 as libc::c_int;
        } else if val0 < 0 as libc::c_int && val1 < 0 as libc::c_int
            && val2 < 0 as libc::c_int
        {
            nmt += 1;
            nmt;
            size = 0 as libc::c_int;
            if (*lgl).mt == 0 {
                lglmt(lgl);
            }
        } else if val0 == 0 && val1 < 0 as libc::c_int && val2 < 0 as libc::c_int {
            size = 1 as libc::c_int;
            lglunit(lgl, *p.offset(0 as libc::c_int as isize));
            nunits += 1;
            nunits;
        } else if val0 < 0 as libc::c_int && val1 == 0 && val2 < 0 as libc::c_int {
            size = 1 as libc::c_int;
            lglunit(lgl, *p.offset(1 as libc::c_int as isize));
            nunits += 1;
            nunits;
        } else if val0 < 0 as libc::c_int && val1 < 0 as libc::c_int && val2 == 0 {
            size = 1 as libc::c_int;
            lglunit(lgl, *p.offset(2 as libc::c_int as isize));
            nunits += 1;
            nunits;
        } else if val0 == 0 && val1 == 0 && val2 < 0 as libc::c_int {
            size = 2 as libc::c_int;
            nbins += 1;
            nbins;
            lglwchbin(
                lgl,
                *p.offset(0 as libc::c_int as isize),
                *p.offset(1 as libc::c_int as isize),
                REDCS as libc::c_int,
            );
            lglwchbin(
                lgl,
                *p.offset(1 as libc::c_int as isize),
                *p.offset(0 as libc::c_int as isize),
                REDCS as libc::c_int,
            );
            if druplig != 0 {
                lgldrupligaddclsarg(
                    lgl,
                    REDCS as libc::c_int,
                    *p.offset(0 as libc::c_int as isize),
                    *p.offset(1 as libc::c_int as isize),
                    0 as libc::c_int,
                );
            }
        } else if val0 == 0 && val1 < 0 as libc::c_int && val2 == 0 {
            size = 2 as libc::c_int;
            nbins += 1;
            nbins;
            lglwchbin(
                lgl,
                *p.offset(0 as libc::c_int as isize),
                *p.offset(2 as libc::c_int as isize),
                REDCS as libc::c_int,
            );
            lglwchbin(
                lgl,
                *p.offset(2 as libc::c_int as isize),
                *p.offset(0 as libc::c_int as isize),
                REDCS as libc::c_int,
            );
            if druplig != 0 {
                lgldrupligaddclsarg(
                    lgl,
                    REDCS as libc::c_int,
                    *p.offset(0 as libc::c_int as isize),
                    *p.offset(2 as libc::c_int as isize),
                    0 as libc::c_int,
                );
            }
        } else if val0 < 0 as libc::c_int && val1 == 0 && val2 == 0 {
            size = 2 as libc::c_int;
            nbins += 1;
            nbins;
            lglwchbin(
                lgl,
                *p.offset(1 as libc::c_int as isize),
                *p.offset(2 as libc::c_int as isize),
                REDCS as libc::c_int,
            );
            lglwchbin(
                lgl,
                *p.offset(2 as libc::c_int as isize),
                *p.offset(1 as libc::c_int as isize),
                REDCS as libc::c_int,
            );
            if druplig != 0 {
                lgldrupligaddclsarg(
                    lgl,
                    REDCS as libc::c_int,
                    *p.offset(1 as libc::c_int as isize),
                    *p.offset(2 as libc::c_int as isize),
                    0 as libc::c_int,
                );
            }
        } else {
            size = 3 as libc::c_int;
            lglwchtrn(
                lgl,
                *p.offset(0 as libc::c_int as isize),
                *p.offset(1 as libc::c_int as isize),
                *p.offset(2 as libc::c_int as isize),
                REDCS as libc::c_int,
            );
            lglwchtrn(
                lgl,
                *p.offset(1 as libc::c_int as isize),
                *p.offset(0 as libc::c_int as isize),
                *p.offset(2 as libc::c_int as isize),
                REDCS as libc::c_int,
            );
            lglwchtrn(
                lgl,
                *p.offset(2 as libc::c_int as isize),
                *p.offset(0 as libc::c_int as isize),
                *p.offset(1 as libc::c_int as isize),
                REDCS as libc::c_int,
            );
        }
        if druplig != 0 && (satisfied != 0 || eliminated != 0 || size < 3 as libc::c_int)
        {
            lgldrupligdelclsarg(
                lgl,
                *p.offset(0 as libc::c_int as isize),
                *p.offset(1 as libc::c_int as isize),
                *p.offset(2 as libc::c_int as isize),
                0 as libc::c_int,
            );
        }
        p = p.offset(3 as libc::c_int as isize);
    }
    lglprt(
        lgl,
        2 as libc::c_int - (nmt != 0 || nunits != 0) as libc::c_int,
        b"[gc-%d] reconnected %d ternary clauses  (produced %d empty %d units %d binary)\0"
            as *const u8 as *const libc::c_char,
        (*(*lgl).stats).gcs,
        lglcntstk(&mut (*lgl).saved.trn) / 3 as libc::c_int as size_t,
        nmt,
        nunits,
        nbins,
    );
    lglrelstk(lgl, &mut (*lgl).saved.trn);
}
unsafe extern "C" fn lglfullyconnected(mut lgl: *mut LGL) {
    if (*lgl).notfullyconnected == 0 {
        return;
    }
    (*lgl).notfullyconnected = 0 as libc::c_int as libc::c_char;
}
unsafe extern "C" fn lglcon(mut lgl: *mut LGL) {
    let mut glue: libc::c_int = 0;
    glue = -(1 as libc::c_int);
    while glue < ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int {
        lglconnaux(lgl, glue);
        glue += 1;
        glue;
    }
    lglfullyconnected(lgl);
}
unsafe extern "C" fn lglconsaved(mut lgl: *mut LGL) {
    if (*lgl).rmredbintrn != 0 {
        lglconsavedbin(lgl);
        lglconsavedtrn(lgl);
        (*lgl).rmredbintrn = 0 as libc::c_int as libc::c_char;
        if (*lgl).mt == 0 && lglbcpcomplete(lgl) == 0 {
            lglfullyconnected(lgl);
            if lglbcp(lgl) == 0 {
                lglmt(lgl);
            }
        }
    }
}
unsafe extern "C" fn lglcount(mut lgl: *mut LGL) {
    let mut idx: libc::c_int = 0;
    let mut sign: libc::c_int = 0;
    let mut lit: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut blit: libc::c_int = 0;
    let mut red: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut other2: libc::c_int = 0;
    let mut glue: libc::c_int = 0;
    let mut count: libc::c_int = 0;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut w: *const libc::c_int = 0 as *const libc::c_int;
    let mut c: *const libc::c_int = 0 as *const libc::c_int;
    let mut eow: *const libc::c_int = 0 as *const libc::c_int;
    let mut hts: *mut HTS = 0 as *mut HTS;
    let mut lir: *mut Stk = 0 as *mut Stk;
    (*(*lgl).stats).irr.clauses.cur = 0 as libc::c_int;
    (*(*lgl).stats).irr.lits.cur = 0 as libc::c_int;
    (*(*lgl).stats).red.bin = 0 as libc::c_int;
    (*(*lgl).stats).red.trn = 0 as libc::c_int;
    (*(*lgl).stats).red.lrg = 0 as libc::c_int;
    idx = 2 as libc::c_int;
    while idx < (*lgl).nvars {
        sign = -(1 as libc::c_int);
        while sign <= 1 as libc::c_int {
            lit = sign * idx;
            hts = lglhts(lgl, lit);
            if !((*hts).offset == 0) {
                w = lglhts2wchs(lgl, hts);
                eow = w.offset((*hts).count as isize);
                let mut current_block_32: u64;
                p = w;
                while p < eow {
                    blit = *p;
                    red = blit & REDCS as libc::c_int;
                    tag = blit & MASKCS as libc::c_int;
                    if tag == LRGCS as libc::c_int || tag == TRNCS as libc::c_int {
                        p = p.offset(1);
                        p;
                    }
                    if !(tag == LRGCS as libc::c_int) {
                        other = blit >> RMSHFT as libc::c_int;
                        if !(abs(lit) >= abs(other)) {
                            if tag == TRNCS as libc::c_int {
                                other2 = *p;
                                if abs(lit) >= abs(other2) {
                                    current_block_32 = 7651349459974463963;
                                } else {
                                    current_block_32 = 15768484401365413375;
                                }
                            } else {
                                current_block_32 = 15768484401365413375;
                            }
                            match current_block_32 {
                                7651349459974463963 => {}
                                _ => {
                                    if red == 0 {
                                        (*(*lgl).stats).irr.clauses.cur += 1;
                                        (*(*lgl).stats).irr.clauses.cur;
                                        if tag == BINCS as libc::c_int {
                                            (*(*lgl).stats).irr.lits.cur += 2 as libc::c_int;
                                        } else {
                                            (*(*lgl).stats).irr.lits.cur += 3 as libc::c_int;
                                        }
                                    } else if tag == BINCS as libc::c_int {
                                        (*(*lgl).stats).red.bin += 1;
                                        (*(*lgl).stats).red.bin;
                                    } else {
                                        (*(*lgl).stats).red.trn += 1;
                                        (*(*lgl).stats).red.trn;
                                    }
                                }
                            }
                        }
                    }
                    p = p.offset(1);
                    p;
                }
            }
            sign += 2 as libc::c_int;
        }
        idx += 1;
        idx;
    }
    c = (*lgl).irr.start;
    while c < (*lgl).irr.top as *const libc::c_int {
        p = c;
        if !(*p >= 2147483647 as libc::c_int) {
            while *p != 0 {
                p = p.offset(1);
                p;
            }
            (*(*lgl).stats)
                .irr
                .lits
                .cur = ((*(*lgl).stats).irr.lits.cur as libc::c_long
                + p.offset_from(c) as libc::c_long) as libc::c_int;
            (*(*lgl).stats).irr.clauses.cur += 1;
            (*(*lgl).stats).irr.clauses.cur;
        }
        c = p.offset(1 as libc::c_int as isize);
    }
    glue = 0 as libc::c_int;
    while glue < ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int {
        lir = ((*lgl).red).offset(glue as isize);
        count = 0 as libc::c_int;
        c = (*lir).start;
        while c < (*lir).top as *const libc::c_int {
            if *c == 0 {
                count += 1;
                count;
            }
            c = c.offset(1);
            c;
        }
        count != 0;
        (*(*lgl).stats).red.lrg += count;
        (*(*lgl).stats).lir[glue as usize].clauses = count;
        glue += 1;
        glue;
    }
    (*(*lgl).stats).red.bin != 0;
    (*(*lgl).stats).red.trn != 0;
    (*(*lgl).stats).red.lrg != 0;
}
unsafe extern "C" fn lglilit(mut ulit: libc::c_int) -> libc::c_int {
    let mut res: libc::c_int = ulit / 2 as libc::c_int;
    if ulit & 1 as libc::c_int != 0 {
        res = -res;
    }
    return res;
}
unsafe extern "C" fn lgljwh(mut lgl: *mut LGL) {
    let mut idx: libc::c_int = 0;
    let mut sign: libc::c_int = 0;
    let mut lit: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut blit: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut other2: libc::c_int = 0;
    let mut red: libc::c_int = 0;
    let mut size: libc::c_int = 0;
    let mut glue: libc::c_int = 0;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut w: *const libc::c_int = 0 as *const libc::c_int;
    let mut eow: *const libc::c_int = 0 as *const libc::c_int;
    let mut c: *const libc::c_int = 0 as *const libc::c_int;
    let mut val: Val = 0;
    let mut tmp: Val = 0;
    let mut tmp2: Val = 0;
    let mut hts: *mut HTS = 0 as *mut HTS;
    let mut s: *mut Stk = 0 as *mut Stk;
    let mut inc: Flt = 0;
    memset(
        (*lgl).jwh as *mut libc::c_void,
        0 as libc::c_int,
        ((2 as libc::c_int * (*lgl).nvars) as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Flt>() as libc::c_ulong),
    );
    idx = 2 as libc::c_int;
    while idx < (*lgl).nvars {
        sign = -(1 as libc::c_int);
        while sign <= 1 as libc::c_int {
            lit = sign * idx;
            val = lglval(lgl, lit);
            if !(val as libc::c_int > 0 as libc::c_int) {
                hts = lglhts(lgl, lit);
                if !((*hts).offset == 0) {
                    w = lglhts2wchs(lgl, hts);
                    eow = w.offset((*hts).count as isize);
                    p = w;
                    while p < eow {
                        blit = *p;
                        tag = blit & MASKCS as libc::c_int;
                        if tag == TRNCS as libc::c_int || tag == LRGCS as libc::c_int {
                            p = p.offset(1);
                            p;
                        }
                        if !(tag == LRGCS as libc::c_int) {
                            red = blit & REDCS as libc::c_int;
                            if !((*(*lgl).opts).jwhred.val == 0 && red != 0) {
                                if !((*(*lgl).opts).jwhred.val == 2 as libc::c_int
                                    && red == 0)
                                {
                                    other = blit >> RMSHFT as libc::c_int;
                                    if !(abs(other) < abs(lit)) {
                                        tmp = lglval(lgl, other);
                                        if !(tmp as libc::c_int > 0 as libc::c_int) {
                                            if tag == BINCS as libc::c_int {
                                                inc = lglflt(-(2 as libc::c_int), 1 as libc::c_int as Mnt);
                                                lglincjwh(lgl, lit, inc);
                                                lglincjwh(lgl, other, inc);
                                            } else {
                                                other2 = *p;
                                                if !(abs(other2) < abs(lit)) {
                                                    tmp2 = lglval(lgl, other2);
                                                    if !(tmp2 as libc::c_int > 0 as libc::c_int) {
                                                        size = 3 as libc::c_int + val as libc::c_int
                                                            + tmp as libc::c_int + tmp2 as libc::c_int;
                                                        inc = lglflt(-size, 1 as libc::c_int as Mnt);
                                                        if val == 0 {
                                                            lglincjwh(lgl, lit, inc);
                                                        }
                                                        if tmp == 0 {
                                                            lglincjwh(lgl, other, inc);
                                                        }
                                                        if tmp2 == 0 {
                                                            lglincjwh(lgl, other2, inc);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        p = p.offset(1);
                        p;
                    }
                }
            }
            sign += 2 as libc::c_int;
        }
        idx += 1;
        idx;
    }
    glue = -(1 as libc::c_int);
    while glue < ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int {
        if !((*(*lgl).opts).jwhred.val == 0 && glue >= 0 as libc::c_int) {
            if !((*(*lgl).opts).jwhred.val == 2 as libc::c_int
                && glue < 0 as libc::c_int)
            {
                if glue < 0 as libc::c_int {
                    s = &mut (*lgl).irr;
                } else {
                    s = &mut *((*lgl).red).offset(glue as isize) as *mut Stk;
                }
                c = (*s).start;
                while c < (*s).top as *const libc::c_int {
                    p = c;
                    if !(*p >= 2147483647 as libc::c_int >> RMSHFT as libc::c_int) {
                        val = -(1 as libc::c_int) as Val;
                        size = 0 as libc::c_int;
                        loop {
                            other = *p;
                            if !(other != 0) {
                                break;
                            }
                            tmp = lglval(lgl, other);
                            if tmp as libc::c_int > val as libc::c_int {
                                val = tmp;
                            }
                            if tmp == 0 {
                                size += 1;
                                size;
                            }
                            p = p.offset(1);
                            p;
                        }
                        if !(val as libc::c_int > 0 as libc::c_int) {
                            inc = lglflt(-size, 1 as libc::c_int as Mnt);
                            p = c;
                            loop {
                                other = *p;
                                if !(other != 0) {
                                    break;
                                }
                                if lglval(lgl, other) == 0 {
                                    lglincjwh(lgl, other, inc);
                                }
                                p = p.offset(1);
                                p;
                            }
                        }
                    }
                    c = p.offset(1 as libc::c_int as isize);
                }
            }
        }
        glue += 1;
        glue;
    }
}
unsafe extern "C" fn lglis(mut lgl: *mut LGL) -> *mut libc::c_int {
    let mut idx: libc::c_int = 0;
    let mut sign: libc::c_int = 0;
    let mut lit: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut blit: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut other2: libc::c_int = 0;
    let mut red: libc::c_int = 0;
    let mut res: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut w: *const libc::c_int = 0 as *const libc::c_int;
    let mut eow: *const libc::c_int = 0 as *const libc::c_int;
    let mut c: *const libc::c_int = 0 as *const libc::c_int;
    let mut val: Val = 0;
    let mut tmp: Val = 0;
    let mut tmp2: Val = 0;
    let mut hts: *mut HTS = 0 as *mut HTS;
    let mut s: *mut Stk = 0 as *mut Stk;
    res = lglnew(
        lgl,
        ((2 as libc::c_int * (*lgl).nvars) as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
    ) as *mut libc::c_int;
    res = res.offset((*lgl).nvars as isize);
    idx = 2 as libc::c_int;
    while idx < (*lgl).nvars {
        sign = -(1 as libc::c_int);
        while sign <= 1 as libc::c_int {
            lit = sign * idx;
            val = lglval(lgl, lit);
            if !(val as libc::c_int > 0 as libc::c_int) {
                hts = lglhts(lgl, lit);
                if !((*hts).offset == 0) {
                    w = lglhts2wchs(lgl, hts);
                    eow = w.offset((*hts).count as isize);
                    p = w;
                    while p < eow {
                        blit = *p;
                        tag = blit & MASKCS as libc::c_int;
                        if tag == TRNCS as libc::c_int || tag == LRGCS as libc::c_int {
                            p = p.offset(1);
                            p;
                        }
                        if !(tag == LRGCS as libc::c_int) {
                            red = blit & REDCS as libc::c_int;
                            if !(red != 0) {
                                other = blit >> RMSHFT as libc::c_int;
                                if !(abs(other) < abs(lit)) {
                                    tmp = lglval(lgl, other);
                                    if !(tmp as libc::c_int > 0 as libc::c_int) {
                                        if tag == BINCS as libc::c_int {
                                            let ref mut fresh119 = *res.offset(lit as isize);
                                            *fresh119 += 1;
                                            *fresh119;
                                            let ref mut fresh120 = *res.offset(other as isize);
                                            *fresh120 += 1;
                                            *fresh120;
                                        } else {
                                            other2 = *p;
                                            if !(abs(other2) < abs(lit)) {
                                                tmp2 = lglval(lgl, other2);
                                                if !(tmp2 as libc::c_int > 0 as libc::c_int) {
                                                    if val == 0 {
                                                        let ref mut fresh121 = *res.offset(lit as isize);
                                                        *fresh121 += 1;
                                                        *fresh121;
                                                    }
                                                    if tmp == 0 {
                                                        let ref mut fresh122 = *res.offset(other as isize);
                                                        *fresh122 += 1;
                                                        *fresh122;
                                                    }
                                                    if tmp2 == 0 {
                                                        let ref mut fresh123 = *res.offset(other2 as isize);
                                                        *fresh123 += 1;
                                                        *fresh123;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        p = p.offset(1);
                        p;
                    }
                }
            }
            sign += 2 as libc::c_int;
        }
        idx += 1;
        idx;
    }
    s = &mut (*lgl).irr;
    c = (*s).start;
    while c < (*s).top as *const libc::c_int {
        p = c;
        if !(*p >= 2147483647 as libc::c_int >> RMSHFT as libc::c_int) {
            val = -(1 as libc::c_int) as Val;
            loop {
                other = *p;
                if !(other != 0) {
                    break;
                }
                tmp = lglval(lgl, other);
                if tmp as libc::c_int > val as libc::c_int {
                    val = tmp;
                }
                p = p.offset(1);
                p;
            }
            if !(val as libc::c_int > 0 as libc::c_int) {
                p = c;
                loop {
                    other = *p;
                    if !(other != 0) {
                        break;
                    }
                    if lglval(lgl, other) == 0 {
                        let ref mut fresh124 = *res.offset(other as isize);
                        *fresh124 += 1;
                        *fresh124;
                    }
                    p = p.offset(1);
                    p;
                }
            }
        }
        c = p.offset(1 as libc::c_int as isize);
    }
    return res;
}
unsafe extern "C" fn lglsetjwhbias(
    mut lgl: *mut LGL,
    mut idx: libc::c_int,
) -> libc::c_int {
    let mut av: *mut AVar = lglavar(lgl, idx);
    let mut pos: Flt = 0;
    let mut neg: Flt = 0;
    let mut bias: libc::c_int = 0;
    idx = abs(idx);
    pos = *((*lgl).jwh).offset(lglulit(idx) as isize);
    neg = *((*lgl).jwh).offset(lglulit(-idx) as isize);
    if (*av).phase() != 0 {
        return (*av).phase();
    }
    bias = if pos > neg { 1 as libc::c_int } else { -(1 as libc::c_int) };
    if (*av).bias() == bias {
        return bias;
    }
    (*av).set_bias(bias);
    (*(*lgl).stats).phase.set += 1;
    (*(*lgl).stats).phase.set;
    if bias > 0 as libc::c_int {
        (*(*lgl).stats).phase.pos += 1;
        (*(*lgl).stats).phase.pos;
    } else {
        (*(*lgl).stats).phase.neg += 1;
        (*(*lgl).stats).phase.neg;
    }
    return bias;
}
unsafe extern "C" fn lglsetbias(
    mut lgl: *mut LGL,
    mut idx: libc::c_int,
    mut bias: libc::c_int,
) {
    let mut av: *mut AVar = lglavar(lgl, idx);
    if (*av).phase() != 0 {
        return;
    }
    (*av).set_bias(bias);
    (*(*lgl).stats).phase.set += 1;
    (*(*lgl).stats).phase.set;
    if bias > 0 as libc::c_int {
        (*(*lgl).stats).phase.pos += 1;
        (*(*lgl).stats).phase.pos;
    } else {
        (*(*lgl).stats).phase.neg += 1;
        (*(*lgl).stats).phase.neg;
    };
}
unsafe extern "C" fn lglsetallphases(mut lgl: *mut LGL) {
    let mut res: libc::c_int = 1 as libc::c_int;
    let mut idx: libc::c_int = 0;
    idx = 2 as libc::c_int;
    while res != 0 && idx < (*lgl).nvars {
        res = (lglisfree(lgl, idx) == 0 || (*lglavar(lgl, idx)).phase() != 0)
            as libc::c_int;
        idx += 1;
        idx;
    }
    (*lgl).allphaseset = res as libc::c_char;
}
unsafe extern "C" fn lglflushphases(mut lgl: *mut LGL) {
    let mut idx: libc::c_int = 0;
    let mut flushed: libc::c_int = 0 as libc::c_int;
    let mut av: *mut AVar = 0 as *mut AVar;
    idx = 2 as libc::c_int;
    while idx < (*lgl).nvars {
        if !(lglisfree(lgl, idx) == 0) {
            av = lglavar(lgl, idx);
            (*av).set_phase(0 as libc::c_int);
            flushed += 1;
            flushed;
        }
        idx += 1;
        idx;
    }
    lglprt(
        lgl,
        1 as libc::c_int,
        b"[flushphases] %d phases reset\0" as *const u8 as *const libc::c_char,
        flushed,
    );
    (*lgl).allphaseset = (flushed == 0) as libc::c_int as libc::c_char;
    (*lgl).flushphases = 0 as libc::c_int as libc::c_char;
}
unsafe extern "C" fn lgluckyphase(mut lgl: *mut LGL) -> libc::c_int {
    let mut pos: libc::c_int = 0 as libc::c_int;
    let mut neg: libc::c_int = 0 as libc::c_int;
    let mut lit: libc::c_int = 0;
    let mut idx: libc::c_int = 0;
    let mut count: libc::c_int = 0 as libc::c_int;
    let mut res: libc::c_int = 0 as libc::c_int;
    let mut negrest: libc::c_int = 0;
    let mut posrest: libc::c_int = 0;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut c: *const libc::c_int = 0 as *const libc::c_int;
    c = (*lgl).irr.start;
    while c < (*lgl).irr.top as *const libc::c_int {
        let mut foundpos: libc::c_int = 0 as libc::c_int;
        let mut foundneg: libc::c_int = 0 as libc::c_int;
        p = c;
        if !(*p >= 2147483647 as libc::c_int >> RMSHFT as libc::c_int) {
            loop {
                lit = *p;
                if !(lit != 0) {
                    break;
                }
                if lit > 0 as libc::c_int {
                    foundpos = 1 as libc::c_int;
                }
                if lit < 0 as libc::c_int {
                    foundneg = 1 as libc::c_int;
                }
                p = p.offset(1);
                p;
            }
            if foundpos != 0 {
                pos += 1;
                pos;
            }
            if foundneg != 0 {
                neg += 1;
                neg;
            }
            count += 1;
            count;
        }
        c = p.offset(1 as libc::c_int as isize);
    }
    idx = 2 as libc::c_int;
    while idx < (*lgl).nvars {
        let mut hts: *mut HTS = lglhts(lgl, idx);
        let mut p_0: *const libc::c_int = 0 as *const libc::c_int;
        let mut w: *const libc::c_int = 0 as *const libc::c_int;
        let mut eow: *const libc::c_int = 0 as *const libc::c_int;
        w = lglhts2wchs(lgl, hts);
        eow = w.offset((*hts).count as isize);
        let mut current_block_27: u64;
        p_0 = w;
        while p_0 < eow {
            let mut blit: libc::c_int = *p_0;
            let mut red: libc::c_int = 0;
            let mut other: libc::c_int = 0;
            let mut tag: libc::c_int = blit & MASKCS as libc::c_int;
            if tag == TRNCS as libc::c_int || tag == LRGCS as libc::c_int {
                p_0 = p_0.offset(1);
                p_0;
            }
            if !(tag == LRGCS as libc::c_int) {
                red = blit & REDCS as libc::c_int;
                if !(red != 0) {
                    other = blit >> RMSHFT as libc::c_int;
                    if !(abs(other) < idx) {
                        if tag == TRNCS as libc::c_int {
                            let mut other2: libc::c_int = *p_0;
                            if abs(other2) < idx {
                                current_block_27 = 7175849428784450219;
                            } else {
                                if other < 0 as libc::c_int || other2 < 0 as libc::c_int {
                                    neg += 1;
                                    neg;
                                }
                                current_block_27 = 17500079516916021833;
                            }
                        } else {
                            if other < 0 as libc::c_int {
                                neg += 1;
                                neg;
                            }
                            current_block_27 = 17500079516916021833;
                        }
                        match current_block_27 {
                            7175849428784450219 => {}
                            _ => {
                                count += 1;
                                count;
                                pos += 1;
                                pos;
                            }
                        }
                    }
                }
            }
            p_0 = p_0.offset(1);
            p_0;
        }
        hts = lglhts(lgl, -idx);
        w = lglhts2wchs(lgl, hts);
        eow = w.offset((*hts).count as isize);
        let mut current_block_42: u64;
        p_0 = w;
        while p_0 < eow {
            let mut blit_0: libc::c_int = *p_0;
            let mut red_0: libc::c_int = 0;
            let mut other_0: libc::c_int = 0;
            let mut tag_0: libc::c_int = blit_0 & MASKCS as libc::c_int;
            if tag_0 == TRNCS as libc::c_int || tag_0 == LRGCS as libc::c_int {
                p_0 = p_0.offset(1);
                p_0;
            }
            if !(tag_0 == LRGCS as libc::c_int) {
                red_0 = blit_0 & REDCS as libc::c_int;
                if !(red_0 != 0) {
                    other_0 = blit_0 >> RMSHFT as libc::c_int;
                    if !(abs(other_0) < idx) {
                        if tag_0 == TRNCS as libc::c_int {
                            let mut other2_0: libc::c_int = *p_0;
                            if abs(other2_0) < idx {
                                current_block_42 = 4090602189656566074;
                            } else {
                                if other_0 > 0 as libc::c_int || other2_0 > 0 as libc::c_int
                                {
                                    pos += 1;
                                    pos;
                                }
                                current_block_42 = 11777552016271000781;
                            }
                        } else {
                            if other_0 > 0 as libc::c_int {
                                pos += 1;
                                pos;
                            }
                            current_block_42 = 11777552016271000781;
                        }
                        match current_block_42 {
                            4090602189656566074 => {}
                            _ => {
                                count += 1;
                                count;
                                neg += 1;
                                neg;
                            }
                        }
                    }
                }
            }
            p_0 = p_0.offset(1);
            p_0;
        }
        idx += 1;
        idx;
    }
    negrest = count - neg;
    posrest = count - pos;
    lglprt(
        lgl,
        1 as libc::c_int,
        b"[phase-count-%d] %d negative %.1f%% of %d except %d %.1f%%\0" as *const u8
            as *const libc::c_char,
        (*(*lgl).stats).phase.count,
        neg,
        lglpcnt(neg as libc::c_double, count as libc::c_double),
        count,
        negrest,
        lglpcnt(negrest as libc::c_double, count as libc::c_double),
    );
    lglprt(
        lgl,
        1 as libc::c_int,
        b"[phase-count-%d] %d positive %.1f%% of %d except %d %.1f%%\0" as *const u8
            as *const libc::c_char,
        (*(*lgl).stats).phase.count,
        pos,
        lglpcnt(pos as libc::c_double, count as libc::c_double),
        count,
        posrest,
        lglpcnt(posrest as libc::c_double, count as libc::c_double),
    );
    if neg >= count {
        res = -(1 as libc::c_int);
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[phase-count-%d] all clauses contain a negative literal\0" as *const u8
                as *const libc::c_char,
            (*(*lgl).stats).phase.count,
        );
    } else if pos >= count {
        res = 1 as libc::c_int;
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[phase-count-%d] all clauses contain a positive literal\0" as *const u8
                as *const libc::c_char,
            (*(*lgl).stats).phase.count,
        );
    } else if (*(*lgl).stats).phase.count <= (*(*lgl).opts).phaseluckmaxround.val {
        let mut lim: libc::c_int = (*(*lgl).opts).phaselucklim.val
            * (count / 1000 as libc::c_int);
        let mut fac: libc::c_int = (*(*lgl).opts).phaseluckfactor.val;
        if negrest <= lim && negrest <= posrest
            && posrest / fac >= negrest / 100 as libc::c_int
        {
            res = -(1 as libc::c_int);
            lglprt(
                lgl,
                1 as libc::c_int,
                b"[phase-count-%d] less non-negative clauses %d than limit %d (%.1f%%)\0"
                    as *const u8 as *const libc::c_char,
                (*(*lgl).stats).phase.count,
                negrest,
                lim,
                (*(*lgl).opts).phaselucklim.val as libc::c_double / 10.0f64,
            );
            lglprt(
                lgl,
                1 as libc::c_int,
                b"[phase-count-%d] non-pos/non-neg = %d/%d = %.2f >= %.2f = %d/100\0"
                    as *const u8 as *const libc::c_char,
                (*(*lgl).stats).phase.count,
                posrest,
                negrest,
                posrest as libc::c_double / negrest as libc::c_double,
                fac as libc::c_double / 100.0f64,
                fac,
            );
        } else if posrest <= lim && posrest <= negrest
            && negrest / fac >= posrest / 100 as libc::c_int
        {
            res = 1 as libc::c_int;
            lglprt(
                lgl,
                1 as libc::c_int,
                b"[phase-count-%d] less non-positive clauses %d than limit %d (%.1f%%)\0"
                    as *const u8 as *const libc::c_char,
                (*(*lgl).stats).phase.count,
                posrest,
                lim,
                (*(*lgl).opts).phaselucklim.val as libc::c_double / 1000.0f64,
            );
            lglprt(
                lgl,
                1 as libc::c_int,
                b"[phase-count-%d] non-neg/non-pos = %d/%d = %.2f >= %.2f = %d/100\0"
                    as *const u8 as *const libc::c_char,
                (*(*lgl).stats).phase.count,
                negrest,
                posrest,
                negrest as libc::c_double / posrest as libc::c_double,
                fac as libc::c_double / 100.0f64,
                fac,
            );
        }
    } else {
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[phase-count-%d] skipping relative phase luck test\0" as *const u8
                as *const libc::c_char,
            (*(*lgl).stats).phase.count,
        );
    }
    if res != 0 {
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[lucky-phase-%d] forcing lucky phase %d\0" as *const u8
                as *const libc::c_char,
            (*(*lgl).stats).phase.count,
            res,
        );
    }
    return res;
}
unsafe extern "C" fn lglphase(mut lgl: *mut LGL) {
    let mut set: int64_t = (*(*lgl).stats).phase.set;
    let mut pos: int64_t = (*(*lgl).stats).phase.pos;
    let mut neg: int64_t = (*(*lgl).stats).phase.neg;
    let mut idx: libc::c_int = 0;
    let mut lucky: libc::c_int = 0;
    lglstart(lgl, &mut (*(*lgl).times).phase);
    if (*lgl).flushphases != 0 {
        lglflushphases(lgl);
    }
    if !((*(*lgl).opts).phase.val != 0) {
        lglsetallphases(lgl);
        if !((*lgl).allphaseset != 0) {
            (*(*lgl).stats).phase.count += 1;
            (*(*lgl).stats).phase.count;
            lgljwh(lgl);
            lucky = lgluckyphase(lgl);
            if lucky != 0 {
                idx = 2 as libc::c_int;
                while idx < (*lgl).nvars {
                    lglsetbias(lgl, idx, lucky);
                    idx += 1;
                    idx;
                }
            } else {
                idx = 2 as libc::c_int;
                while idx < (*lgl).nvars {
                    lglsetjwhbias(lgl, idx);
                    idx += 1;
                    idx;
                }
            }
            set = (*(*lgl).stats).phase.set - set;
            pos = (*(*lgl).stats).phase.pos - pos;
            neg = (*(*lgl).stats).phase.neg - neg;
            lglprt(
                lgl,
                1 as libc::c_int,
                b"[phase-%d] phase bias: %lld positive %.0f%%, %lld negative %.0f%%\0"
                    as *const u8 as *const libc::c_char,
                (*(*lgl).stats).phase.count,
                pos as libc::c_longlong,
                lglpcnt(pos as libc::c_double, set as libc::c_double),
                neg as libc::c_longlong,
                lglpcnt(neg as libc::c_double, set as libc::c_double),
            );
        }
    }
    lglstop(lgl);
}
unsafe extern "C" fn lglmaplit(
    mut map: *mut libc::c_int,
    mut lit: libc::c_int,
) -> libc::c_int {
    return *map.offset(abs(lit) as isize) * lglsgn(lit);
}
unsafe extern "C" fn lglmapstk(
    mut lgl: *mut LGL,
    mut map: *mut libc::c_int,
    mut lits: *mut Stk,
) {
    let mut p: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut eol: *mut libc::c_int = 0 as *mut libc::c_int;
    eol = (*lits).top;
    p = (*lits).start;
    while p < eol {
        *p = lglmaplit(map, *p);
        p = p.offset(1);
        p;
    }
}
unsafe extern "C" fn lglmapqueue(mut lgl: *mut LGL, mut map: *mut libc::c_int) {
    let mut idx: libc::c_int = 0;
    let mut found: libc::c_int = 0;
    let mut q: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut src: libc::c_int = 0;
    let mut dst: libc::c_int = 0;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut start: *const libc::c_int = 0 as *const libc::c_int;
    let mut qv: *mut QVar = 0 as *mut QVar;
    idx = 2 as libc::c_int;
    while idx < (*lgl).nvars {
        qv = lglqvar(lgl, idx);
        if !((*qv).enqueued() == 0) {
            (*qv).pos = -(1 as libc::c_int);
        }
        idx += 1;
        idx;
    }
    found = 0 as libc::c_int;
    q = (*lgl).queue.stk.start;
    start = q;
    p = q;
    while p < (*lgl).queue.stk.top as *const libc::c_int {
        src = *p;
        if !(src == 0) {
            dst = lglmaplit(map, src);
            if dst < 0 as libc::c_int {
                dst = -dst;
            }
            if !(dst <= 1 as libc::c_int) {
                qv = lglqvar(lgl, dst);
                if !((*qv).enqueued() == 0) {
                    if !((*qv).pos >= 0 as libc::c_int) {
                        (*qv).pos = q.offset_from(start) as libc::c_long as libc::c_int;
                        if found == 0
                            && (*lgl).queue.next as libc::c_long
                                >= p.offset_from(start) as libc::c_long
                        {
                            found = 1 as libc::c_int;
                            (*lgl).queue.next = (*qv).pos;
                        }
                        let fresh125 = q;
                        q = q.offset(1);
                        *fresh125 = dst;
                    }
                }
            }
        }
        p = p.offset(1);
        p;
    }
    idx = 2 as libc::c_int;
    while idx < (*lgl).nvars {
        qv = lglqvar(lgl, idx);
        if !((*qv).enqueued() == 0) {
            if !((*qv).pos >= 0 as libc::c_int) {
                (*qv).pos = q.offset_from(start) as libc::c_long as libc::c_int;
                let fresh126 = q;
                q = q.offset(1);
                *fresh126 = idx;
            }
        }
        idx += 1;
        idx;
    }
    (*lgl).queue.stk.top = q;
    lglfitstk(lgl, &mut (*lgl).queue.stk);
    if found == 0 {
        (*lgl)
            .queue
            .next = (lglcntstk(&mut (*lgl).queue.stk))
            .wrapping_sub(1 as libc::c_int as size_t) as libc::c_int;
    }
    (*lgl).queue.mt = 0 as libc::c_int;
}
unsafe extern "C" fn lglmapglue(
    mut lgl: *mut LGL,
    mut map: *mut libc::c_int,
    mut lits: *mut Stk,
) {
    let mut p: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut eol: *mut libc::c_int = 0 as *mut libc::c_int;
    eol = (*lits).top;
    p = (*lits).start;
    while p < eol {
        if lglisact(*p) == 0 {
            *p = lglmaplit(map, *p);
        }
        p = p.offset(1);
        p;
    }
}
unsafe extern "C" fn lglmaplits(mut lgl: *mut LGL, mut map: *mut libc::c_int) {
    let mut glue: libc::c_int = 0;
    lglmapstk(lgl, map, &mut (*lgl).irr);
    glue = 0 as libc::c_int;
    while glue < ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int {
        lglmapglue(lgl, map, &mut *((*lgl).red).offset(glue as isize));
        glue += 1;
        glue;
    }
}
unsafe extern "C" fn lglmapvars(
    mut lgl: *mut LGL,
    mut map: *mut libc::c_int,
    mut nvars: libc::c_int,
) {
    let mut i: libc::c_int = 0;
    let mut oldnvars: libc::c_int = (*lgl).nvars;
    let mut sign: libc::c_int = 0;
    let mut udst: libc::c_int = 0;
    let mut idst: libc::c_int = 0;
    let mut usrc: libc::c_int = 0;
    let mut isrc: libc::c_int = 0;
    let mut dvars: *mut DVar = 0 as *mut DVar;
    let mut qvars: *mut QVar = 0 as *mut QVar;
    let mut avars: *mut AVar = 0 as *mut AVar;
    let mut vals: *mut Val = 0 as *mut Val;
    let mut i2e: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut jwh: *mut Flt = 0 as *mut Flt;
    if !(nvars > 2 as libc::c_int) {
        nvars = 0 as libc::c_int;
    }
    lgldel(
        lgl,
        (*lgl).doms as *mut libc::c_void,
        ((2 as libc::c_int * (*lgl).szvars) as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
    );
    (*lgl).doms = 0 as *mut libc::c_int;
    (*lgl)
        .doms = lglnew(
        lgl,
        ((2 as libc::c_int * nvars) as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
    ) as *mut libc::c_int;
    vals = lglnew(
        lgl,
        (nvars as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Val>() as libc::c_ulong),
    ) as *mut Val;
    i = 2 as libc::c_int;
    while i < oldnvars {
        if lglisfree(lgl, i) != 0 {
            *vals
                .offset(
                    *map.offset(i as isize) as isize,
                ) = *((*lgl).vals).offset(i as isize);
        }
        i += 1;
        i;
    }
    lgldel(
        lgl,
        (*lgl).vals as *mut libc::c_void,
        ((*lgl).szvars as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Val>() as libc::c_ulong),
    );
    (*lgl).vals = 0 as *mut Val;
    (*lgl).vals = vals;
    i2e = lglnew(
        lgl,
        (nvars as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
    ) as *mut libc::c_int;
    i = 2 as libc::c_int;
    while i < oldnvars {
        if lglisfree(lgl, i) != 0 {
            *i2e
                .offset(
                    *map.offset(i as isize) as isize,
                ) = *((*lgl).i2e).offset(i as isize);
        }
        i += 1;
        i;
    }
    lgldel(
        lgl,
        (*lgl).i2e as *mut libc::c_void,
        ((*lgl).szvars as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
    );
    (*lgl).i2e = 0 as *mut libc::c_int;
    (*lgl).i2e = i2e;
    dvars = lglnew(
        lgl,
        (nvars as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<DVar>() as libc::c_ulong),
    ) as *mut DVar;
    i = 2 as libc::c_int;
    while i < oldnvars {
        if lglisfree(lgl, i) != 0 {
            *dvars
                .offset(
                    *map.offset(i as isize) as isize,
                ) = *((*lgl).dvars).offset(i as isize);
        }
        i += 1;
        i;
    }
    lgldel(
        lgl,
        (*lgl).dvars as *mut libc::c_void,
        ((*lgl).szvars as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<DVar>() as libc::c_ulong),
    );
    (*lgl).dvars = 0 as *mut DVar;
    (*lgl).dvars = dvars;
    qvars = lglnew(
        lgl,
        (nvars as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<QVar>() as libc::c_ulong),
    ) as *mut QVar;
    i = 2 as libc::c_int;
    while i < oldnvars {
        if lglisfree(lgl, i) != 0 {
            *qvars
                .offset(
                    *map.offset(i as isize) as isize,
                ) = *((*lgl).qvars).offset(i as isize);
        }
        i += 1;
        i;
    }
    lgldel(
        lgl,
        (*lgl).qvars as *mut libc::c_void,
        ((*lgl).szvars as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<QVar>() as libc::c_ulong),
    );
    (*lgl).qvars = 0 as *mut QVar;
    (*lgl).qvars = qvars;
    jwh = lglnew(
        lgl,
        ((2 as libc::c_int * nvars) as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Flt>() as libc::c_ulong),
    ) as *mut Flt;
    i = 2 as libc::c_int;
    while i < oldnvars {
        if lglisfree(lgl, i) != 0 {
            sign = -(1 as libc::c_int);
            while sign <= 1 as libc::c_int {
                isrc = sign * i;
                idst = sign * *map.offset(i as isize);
                usrc = lglulit(isrc);
                udst = lglulit(idst);
                *jwh
                    .offset(
                        udst as isize,
                    ) = lgladdflt(
                    *jwh.offset(udst as isize),
                    *((*lgl).jwh).offset(usrc as isize),
                );
                sign += 2 as libc::c_int;
            }
        }
        i += 1;
        i;
    }
    lgldel(
        lgl,
        (*lgl).jwh as *mut libc::c_void,
        ((2 as libc::c_int * (*lgl).szvars) as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Flt>() as libc::c_ulong),
    );
    (*lgl).jwh = 0 as *mut Flt;
    (*lgl).jwh = jwh;
    avars = lglnew(
        lgl,
        (nvars as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<AVar>() as libc::c_ulong),
    ) as *mut AVar;
    i = 2 as libc::c_int;
    while i < oldnvars {
        if lglisfree(lgl, i) != 0 {
            *avars
                .offset(
                    *map.offset(i as isize) as isize,
                ) = *((*lgl).avars).offset(i as isize);
        }
        i += 1;
        i;
    }
    lgldel(
        lgl,
        (*lgl).avars as *mut libc::c_void,
        ((*lgl).szvars as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<AVar>() as libc::c_ulong),
    );
    (*lgl).avars = 0 as *mut AVar;
    (*lgl).avars = avars;
    (*lgl).szvars = nvars;
    (*lgl).nvars = (*lgl).szvars;
    (*(*lgl).stats).fixed.current = 0 as libc::c_int;
}
unsafe extern "C" fn lglmaphts(mut lgl: *mut LGL, mut map: *mut libc::c_int) {
    let mut idx: libc::c_int = 0;
    let mut sign: libc::c_int = 0;
    let mut lit: libc::c_int = 0;
    let mut w: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut eow: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut p: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut other: libc::c_int = 0;
    let mut other2: libc::c_int = 0;
    let mut blit: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut red: libc::c_int = 0;
    let mut newblit: libc::c_int = 0;
    let mut newother: libc::c_int = 0;
    let mut newother2: libc::c_int = 0;
    let mut hts: *mut HTS = 0 as *mut HTS;
    idx = 2 as libc::c_int;
    while idx < (*lgl).nvars {
        sign = -(1 as libc::c_int);
        while sign <= 1 as libc::c_int {
            lit = sign * idx;
            hts = lglhts(lgl, lit);
            if !((*hts).count == 0) {
                w = lglhts2wchs(lgl, hts);
                eow = w.offset((*hts).count as isize);
                p = w;
                while p < eow {
                    blit = *p;
                    tag = blit & MASKCS as libc::c_int;
                    red = blit & REDCS as libc::c_int;
                    other = blit >> RMSHFT as libc::c_int;
                    newother = lglmaplit(map, other);
                    newblit = ((newother as libc::c_uint) << RMSHFT as libc::c_int)
                        as libc::c_int | tag | red;
                    *p = newblit;
                    if !(tag == BINCS as libc::c_int) {
                        p = p.offset(1);
                        other2 = *p;
                        if !(tag == LRGCS as libc::c_int) {
                            newother2 = lglmaplit(map, other2);
                            *p = newother2;
                        }
                    }
                    p = p.offset(1);
                    p;
                }
            }
            sign += 2 as libc::c_int;
        }
        idx += 1;
        idx;
    }
}
unsafe extern "C" fn lglmaptrail(mut lgl: *mut LGL, mut map: *mut libc::c_int) {
    let mut p: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut q: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut src: libc::c_int = 0;
    let mut dst: libc::c_int = 0;
    p = (*lgl).trail.start;
    while p < (*lgl).trail.top {
        if lglevel(lgl, *p) > 0 as libc::c_int {
            break;
        }
        p = p.offset(1);
        p;
    }
    q = (*lgl).trail.start;
    while p < (*lgl).trail.top {
        src = *p;
        dst = lglmaplit(map, src);
        let fresh127 = q;
        q = q.offset(1);
        *fresh127 = dst;
        p = p.offset(1);
        p;
    }
    (*lgl).trail.top = q;
    (*lgl).next = lglcntstk(&mut (*lgl).trail) as libc::c_int;
    (*lgl).next2 = (*lgl).next;
    (*lgl).flushed = (*lgl).next2;
}
unsafe extern "C" fn lglptrjmp(
    mut repr: *mut libc::c_int,
    mut max: libc::c_int,
    mut start: libc::c_int,
) -> libc::c_int {
    let mut next: libc::c_int = 0;
    let mut idx: libc::c_int = 0;
    let mut res: libc::c_int = 0;
    let mut sgn: libc::c_int = 0;
    let mut tmp: libc::c_int = 0;
    next = start;
    loop {
        res = next;
        idx = abs(res);
        sgn = lglsgn(res);
        next = *repr.offset(idx as isize);
        next *= sgn;
        if !(next != 0) {
            break;
        }
    }
    tmp = start;
    while tmp != res {
        idx = abs(tmp);
        sgn = lglsgn(tmp);
        next = *repr.offset(idx as isize) * sgn;
        *repr.offset(idx as isize) = sgn * res;
        tmp = next;
    }
    return res;
}
unsafe extern "C" fn lglirepr(mut lgl: *mut LGL, mut lit: libc::c_int) -> libc::c_int {
    return lglptrjmp((*lgl).repr, (*lgl).nvars - 1 as libc::c_int, lit);
}
unsafe extern "C" fn lglmapext(mut lgl: *mut LGL, mut map: *mut libc::c_int) {
    let mut eidx: libc::c_int = 0;
    let mut ilit: libc::c_int = 0;
    let mut mlit: libc::c_int = 0;
    let mut ext: *mut Ext = 0 as *mut Ext;
    eidx = 1 as libc::c_int;
    while eidx <= (*lgl).maxext {
        lglerepr(lgl, eidx);
        eidx += 1;
        eidx;
    }
    eidx = 1 as libc::c_int;
    while eidx <= (*lgl).maxext {
        ext = ((*lgl).ext).offset(eidx as isize);
        if !((*ext).imported() == 0) {
            if !((*ext).equiv() != 0) {
                ilit = (*ext).repr;
                mlit = lglmaplit(map, ilit);
                (*ext).repr = mlit;
            }
        }
        eidx += 1;
        eidx;
    }
}
unsafe extern "C" fn lglsignedmark(mut lgl: *mut LGL, mut lit: libc::c_int) {
    let mut av: *mut AVar = lglavar(lgl, lit);
    let mut bit: libc::c_int = (1 as libc::c_int)
        << (lit < 0 as libc::c_int) as libc::c_int;
    if (*av).mark & bit != 0 {
        return;
    }
    (*av).mark |= bit;
}
unsafe extern "C" fn lglsignedunmark(mut lgl: *mut LGL, mut lit: libc::c_int) {
    let mut av: *mut AVar = lglavar(lgl, lit);
    let mut bit: libc::c_int = (1 as libc::c_int)
        << (lit < 0 as libc::c_int) as libc::c_int;
    if (*av).mark & bit == 0 {
        return;
    }
    (*av).mark &= !bit;
}
unsafe extern "C" fn lglsignedmarked(
    mut lgl: *mut LGL,
    mut lit: libc::c_int,
) -> libc::c_int {
    let mut av: *mut AVar = lglavar(lgl, lit);
    let mut bit: libc::c_int = (1 as libc::c_int)
        << (lit < 0 as libc::c_int) as libc::c_int;
    return (*av).mark & bit;
}
unsafe extern "C" fn lglmapass(mut lgl: *mut LGL, mut map: *mut libc::c_int) {
    let mut p: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut q: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut iass: libc::c_int = 0;
    let mut mass: libc::c_int = 0;
    let mut flushed: libc::c_int = 0;
    let mut bit: libc::c_uint = 0;
    let mut av: *mut AVar = 0 as *mut AVar;
    if abs((*lgl).failed) != 1 as libc::c_int {
        (*lgl).failed = lglmaplit(map, (*lgl).failed);
    }
    q = (*lgl).assume.start;
    p = q;
    while p < (*lgl).assume.top {
        iass = *p;
        mass = lglmaplit(map, iass);
        if !(mass == 1 as libc::c_int) {
            if mass == -(1 as libc::c_int) {
                if (*lgl).failed != -(1 as libc::c_int) {
                    (*lgl).failed = -(1 as libc::c_int);
                }
            } else {
                av = lglavar(lgl, mass);
                bit = (1 as libc::c_uint) << (mass < 0 as libc::c_int) as libc::c_int;
                if (*av).assumed() & bit == 0 {
                    (*av).set_assumed((*av).assumed() | bit);
                }
                let fresh128 = q;
                q = q.offset(1);
                *fresh128 = mass;
            }
        }
        p = p.offset(1);
        p;
    }
    (*lgl).assume.top = q;
    flushed = 0 as libc::c_int;
    q = (*lgl).assume.start;
    p = q;
    while p < (*lgl).assume.top {
        iass = *p;
        if lglsignedmarked(lgl, iass) != 0 {
            flushed += 1;
            flushed;
        } else {
            lglsignedmark(lgl, iass);
            let fresh129 = q;
            q = q.offset(1);
            *fresh129 = iass;
        }
        p = p.offset(1);
        p;
    }
    (*lgl).assume.top = q;
    p = (*lgl).assume.start;
    while p < (*lgl).assume.top {
        iass = *p;
        lglsignedunmark(lgl, iass);
        p = p.offset(1);
        p;
    }
    flushed != 0;
}
unsafe extern "C" fn lglmaplkhdscore(
    mut lgl: *mut LGL,
    mut map: *mut libc::c_int,
    mut oldnvars: libc::c_int,
) {
    let mut oldlkhdscore: *mut LKHD = (*(*lgl).c2rust_unnamed.tlk).lkhd;
    let mut score: LKHD = 0;
    let mut idx: libc::c_int = 0;
    let mut src: libc::c_int = 0;
    let mut sign: libc::c_int = 0;
    let mut dst: libc::c_int = 0;
    (*(*lgl).c2rust_unnamed.tlk)
        .lkhd = lglnew(
        lgl,
        ((2 as libc::c_int * (*lgl).nvars) as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<LKHD>() as libc::c_ulong),
    ) as *mut LKHD;
    (*(*lgl).c2rust_unnamed.tlk)
        .lkhd = ((*(*lgl).c2rust_unnamed.tlk).lkhd).offset((*lgl).nvars as isize);
    idx = oldnvars - 1 as libc::c_int;
    while idx >= 2 as libc::c_int {
        sign = -(1 as libc::c_int);
        while sign <= 1 as libc::c_int {
            src = sign * idx;
            dst = lglmaplit(map, src);
            if !(abs(dst) <= 1 as libc::c_int) {
                score = *oldlkhdscore.offset(src as isize);
                *((*(*lgl).c2rust_unnamed.tlk).lkhd).offset(dst as isize) = score;
            }
            sign += 2 as libc::c_int;
        }
        idx -= 1;
        idx;
    }
    oldlkhdscore = oldlkhdscore.offset(-(oldnvars as isize));
    lgldel(
        lgl,
        oldlkhdscore as *mut libc::c_void,
        ((2 as libc::c_int * oldnvars) as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<LKHD>() as libc::c_ulong),
    );
    oldlkhdscore = 0 as *mut LKHD;
}
unsafe extern "C" fn lglmapsize(mut lgl: *mut LGL) -> libc::c_int {
    let mut size: libc::c_int = 0 as libc::c_int;
    let mut idx: libc::c_int = 0;
    idx = 2 as libc::c_int;
    while idx < (*lgl).nvars {
        if lglisfree(lgl, idx) != 0 {
            size += 1;
            size;
        }
        idx += 1;
        idx;
    }
    return size;
}
unsafe extern "C" fn lglmapnonequiv(
    mut lgl: *mut LGL,
    mut map: *mut libc::c_int,
    mut size: libc::c_int,
) {
    let mut count: libc::c_int = 0 as libc::c_int;
    let mut idx: libc::c_int = 0;
    let mut av: *mut AVar = 0 as *mut AVar;
    let mut val: Val = 0;
    *map.offset(0 as libc::c_int as isize) = 0 as libc::c_int;
    *map.offset(1 as libc::c_int as isize) = 1 as libc::c_int;
    idx = 2 as libc::c_int;
    while idx < (*lgl).nvars {
        if !(*map.offset(idx as isize) != 0) {
            av = lglavar(lgl, idx);
            if (*av).type_0() as libc::c_int == FREEVAR as libc::c_int {
                if !(*map.offset(idx as isize) != 0) {
                    *map.offset(idx as isize) = count + 2 as libc::c_int;
                    count += 1;
                    count;
                }
            } else if !((*av).type_0() as libc::c_int == EQUIVAR as libc::c_int) {
                if (*av).type_0() as libc::c_int == FIXEDVAR as libc::c_int {
                    val = *((*lgl).vals).offset(idx as isize);
                    *map.offset(idx as isize) = val as libc::c_int;
                } else {
                    *map.offset(idx as isize) = 0 as libc::c_int;
                }
            }
        }
        idx += 1;
        idx;
    }
}
unsafe extern "C" fn lglmapequiv(mut lgl: *mut LGL, mut map: *mut libc::c_int) {
    let mut idx: libc::c_int = 0;
    let mut repr: libc::c_int = 0;
    let mut dst: libc::c_int = 0;
    let mut av: *mut AVar = 0 as *mut AVar;
    idx = 2 as libc::c_int;
    while idx < (*lgl).nvars {
        if !(*map.offset(idx as isize) != 0) {
            av = lglavar(lgl, idx);
            if !((*av).type_0() as libc::c_int == ELIMVAR as libc::c_int) {
                repr = lglirepr(lgl, idx);
                dst = lglmaplit(map, repr);
                *map.offset(idx as isize) = dst;
            }
        }
        idx += 1;
        idx;
    }
}
unsafe extern "C" fn lglsteps(mut lgl: *mut LGL) -> int64_t {
    let mut res: int64_t = (*(*lgl).stats).steps;
    return res;
}
unsafe extern "C" fn lgltrep(mut lgl: *mut LGL) {
    let mut steps: int64_t = 0;
    let mut i: int64_t = 0;
    let mut t: libc::c_double = 0.;
    if (*(*lgl).opts).trep.val == 0 {
        return;
    }
    if (*(*lgl).opts).verbose.val != 0 {
        return;
    }
    steps = lglsteps(lgl);
    if steps < (*(*lgl).limits).trep.steps {
        return;
    }
    (*(*lgl).limits).trep.steps += (*(*lgl).opts).trepint.val as int64_t;
    t = if (*(*lgl).opts).abstime.val != 0 { lglgetime(lgl) } else { lglsec(lgl) };
    if t < (*(*lgl).limits).trep.time as libc::c_double {
        return;
    }
    lglrep(
        lgl,
        0 as libc::c_int,
        (if (*lgl).simp as libc::c_int != 0 { 'P' as i32 } else { 'S' as i32 })
            as libc::c_char,
    );
    i = (*(*lgl).limits).trep.time;
    loop {
        if i == 0 {
            i = 1 as libc::c_int as int64_t;
        } else if i == 1 as libc::c_int as int64_t {
            i = 2 as libc::c_int as int64_t;
        } else if i == 2 as libc::c_int as int64_t {
            i = 5 as libc::c_int as int64_t;
        } else if i < 10 as libc::c_int as int64_t {
            i = 10 as libc::c_int as int64_t;
        } else if i < 60 as libc::c_int as int64_t {
            i += 10 as libc::c_int as int64_t;
        } else if i < 300 as libc::c_int as int64_t {
            i += 60 as libc::c_int as int64_t;
        } else if i < 900 as libc::c_int as int64_t {
            i += 300 as libc::c_int as int64_t;
        } else if i < 7200 as libc::c_int as int64_t {
            i += 900 as libc::c_int as int64_t;
        } else {
            i += 3600 as libc::c_int as int64_t;
        }
        if !((i as libc::c_double) < t) {
            break;
        }
    }
    (*(*lgl).limits).trep.time = i;
}
unsafe extern "C" fn lglterminate(mut lgl: *mut LGL) -> libc::c_int {
    let mut steps: int64_t = 0;
    let mut res: libc::c_int = 0;
    lgltrep(lgl);
    if ((*lgl).cbs).is_null() {
        return 0 as libc::c_int;
    }
    if ((*(*lgl).cbs).term.fun).is_none() {
        return 0 as libc::c_int;
    }
    if (*(*lgl).cbs).term.done != 0 {
        return 1 as libc::c_int;
    }
    steps = lglsteps(lgl);
    if steps < (*(*lgl).limits).term.steps {
        return 0 as libc::c_int;
    }
    res = ((*(*lgl).cbs).term.fun)
        .expect("non-null function pointer")((*(*lgl).cbs).term.state);
    if res != 0 {
        (*(*lgl).cbs).term.done = res;
    } else {
        (*(*lgl).limits).term.steps = steps + (*(*lgl).opts).termint.val as int64_t;
    }
    return res;
}
unsafe extern "C" fn lglmap(mut lgl: *mut LGL) {
    let mut size: libc::c_int = 0;
    let mut map: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut oldnvars: libc::c_int = 0;
    let mut mapsize: libc::c_int = 0;
    lglrelstk(lgl, &mut (*lgl).promote);
    lgldreschedule(lgl);
    size = lglmapsize(lgl);
    oldnvars = (*lgl).nvars;
    mapsize = lglmax(oldnvars, 2 as libc::c_int);
    map = lglnew(
        lgl,
        (mapsize as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
    ) as *mut libc::c_int;
    lglmapnonequiv(lgl, map, size);
    lglmapequiv(lgl, map);
    lglmaptrail(lgl, map);
    lglmapvars(lgl, map, size + 2 as libc::c_int);
    lglmaplits(lgl, map);
    lglmapstk(lgl, map, &mut (*lgl).dsched);
    lglmapqueue(lgl, map);
    lglmapext(lgl, map);
    lglmapass(lgl, map);
    if (*lgl).treelooking as libc::c_int != 0 && !((*lgl).c2rust_unnamed.tlk).is_null()
        && !((*(*lgl).c2rust_unnamed.tlk).lkhd).is_null()
    {
        lglmaplkhdscore(lgl, map, oldnvars);
    }
    lglmaphts(lgl, map);
    lgldel(
        lgl,
        map as *mut libc::c_void,
        (mapsize as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
    );
    map = 0 as *mut libc::c_int;
    if !((*lgl).repr).is_null() {
        lgldel(
            lgl,
            (*lgl).repr as *mut libc::c_void,
            (oldnvars as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
        );
        (*lgl).repr = 0 as *mut libc::c_int;
    }
    (*lgl).unassigned = size;
    lgldreschedule(lgl);
}
unsafe extern "C" fn lglgcnotnecessary(mut lgl: *mut LGL) -> libc::c_int {
    if (*lgl).forcegc != 0 {
        return 0 as libc::c_int;
    }
    if (*lgl).notfullyconnected != 0 {
        return 0 as libc::c_int;
    }
    return ((*(*lgl).stats).fixed.sum as int64_t <= (*(*lgl).limits).gc.fixed)
        as libc::c_int;
}
unsafe extern "C" fn lglcompact(mut lgl: *mut LGL) {
    let mut glue: libc::c_int = 0;
    lglfitstk(lgl, &mut (*lgl).assume);
    lglfitstk(lgl, &mut (*lgl).clause);
    lglfitstk(lgl, &mut (*lgl).eclause);
    lglfitstk(lgl, &mut (*lgl).dsched);
    lglfitstk(lgl, &mut (*lgl).queue.stk);
    lglfitstk(lgl, &mut (*lgl).eassume);
    lglfitstk(lgl, &mut (*lgl).extend);
    lglfitstk(lgl, &mut (*lgl).learned);
    lglfitstk(lgl, &mut (*lgl).frames);
    lglfitstk(lgl, &mut (*lgl).promote);
    lglfitstk(lgl, &mut (*lgl).trail);
    lgldefrag(lgl);
    lglfitstk(lgl, &mut (*(*lgl).wchs).stk);
    lglfitstk(lgl, &mut (*lgl).irr);
    glue = 0 as libc::c_int;
    while glue <= ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int {
        lglfitlir(lgl, ((*lgl).red).offset(glue as isize));
        glue += 1;
        glue;
    }
    lglrelstk(lgl, &mut (*lgl).c2rust_unnamed_0.lcaseen);
    lglrelstk(lgl, &mut (*lgl).resolvent);
    lglrelstk(lgl, &mut (*lgl).minstk);
    lglrelstk(lgl, &mut (*lgl).poisoned);
    lglrelstk(lgl, &mut (*lgl).seen);
    lglrelstk(lgl, &mut (*lgl).esched);
    lglrelstk(lgl, &mut (*lgl).saved.bin);
    lglrelstk(lgl, &mut (*lgl).saved.trn);
}
unsafe extern "C" fn lglgc(mut lgl: *mut LGL) {
    if (*lgl).mt != 0 {
        return;
    }
    lglchkred(lgl);
    if lglgcnotnecessary(lgl) != 0 {
        return;
    }
    lglstart(lgl, &mut (*(*lgl).times).gc);
    lglchkbcpclean(lgl, b"gc\0" as *const u8 as *const libc::c_char);
    lglrep(lgl, 2 as libc::c_int, 'g' as i32 as libc::c_char);
    (*(*lgl).stats).gcs += 1;
    (*(*lgl).stats).gcs;
    if (*lgl).level > 0 as libc::c_int {
        lglbacktrack(lgl, 0 as libc::c_int);
    }
    lglconsaved(lgl);
    loop {
        lgldis(lgl);
        lglcon(lgl);
        if (*lgl).mt != 0 {
            break;
        }
        if lglbcpcomplete(lgl) != 0 {
            break;
        }
        if !(lglbcp(lgl) != 0) {
            lglmt(lgl);
        }
        if !((*lgl).mt == 0) {
            break;
        }
    }
    lglcount(lgl);
    lglmap(lgl);
    lglcompact(lgl);
    (*(*lgl).limits).gc.fixed = (*(*lgl).stats).fixed.sum as int64_t;
    lglchkred(lgl);
    lglrep(lgl, 2 as libc::c_int, 'c' as i32 as libc::c_char);
    lglstop(lgl);
}
unsafe extern "C" fn lgltopgc(mut lgl: *mut LGL) -> libc::c_int {
    if (*lgl).mt != 0 {
        return 0 as libc::c_int;
    }
    (*lgl).allowforce = 1 as libc::c_int as libc::c_char;
    (*lgl).forcegc = (*lgl).allowforce;
    lglgc(lgl);
    (*lgl).allowforce = 0 as libc::c_int as libc::c_char;
    (*lgl).forcegc = (*lgl).allowforce;
    return ((*lgl).mt == 0) as libc::c_int;
}
unsafe extern "C" fn lglrandec(mut lgl: *mut LGL) -> libc::c_int {
    let mut size: libc::c_uint = 0;
    let mut pos: libc::c_uint = 0;
    let mut start: libc::c_uint = 0;
    let mut delta: libc::c_uint = 0;
    let mut lit: libc::c_int = 0;
    (*(*lgl).limits).randec = (*(*lgl).stats).decisions;
    (*(*lgl).limits).randec
        += ((*(*lgl).opts).randecint.val / 2 as libc::c_int) as int64_t;
    (*(*lgl).limits).randec
        += (lglrand(lgl)).wrapping_rem((*(*lgl).opts).randecint.val as libc::c_uint)
            as int64_t;
    size = ((*lgl).nvars - 2 as libc::c_int) as libc::c_uint;
    if size == 0 {
        return 0 as libc::c_int;
    }
    start = (lglrand(lgl)).wrapping_rem(size);
    pos = start;
    lit = (2 as libc::c_int as libc::c_uint).wrapping_add(pos) as libc::c_int;
    if lglval(lgl, lit) != 0 {
        delta = (lglrand(lgl)).wrapping_rem(size);
        if size == 1 as libc::c_int as libc::c_uint {
            return 0 as libc::c_int;
        }
        if delta == 0 {
            delta = delta.wrapping_add(1);
            delta;
        }
        while lglgcd(delta, size) != 1 as libc::c_int as libc::c_uint {
            delta = delta.wrapping_add(1);
            if delta == size {
                delta = 1 as libc::c_int as libc::c_uint;
            }
        }
        loop {
            pos = pos.wrapping_add(delta);
            if pos >= size {
                pos = pos.wrapping_sub(size);
            }
            if pos == start {
                return 0 as libc::c_int;
            }
            lit = pos.wrapping_add(2 as libc::c_int as libc::c_uint) as libc::c_int;
            if !(lglval(lgl, lit) != 0) {
                break;
            }
        }
    }
    (*(*lgl).stats).randecs += 1;
    (*(*lgl).stats).randecs;
    return lit;
}
unsafe extern "C" fn lgladecide(mut lgl: *mut LGL) -> libc::c_int {
    let mut res: libc::c_int = 0;
    let mut val: libc::c_int = 0;
    while (*lgl).assumed < lglcntstk(&mut (*lgl).assume) as libc::c_int {
        res = lglpeek(&mut (*lgl).assume, (*lgl).assumed);
        val = lglcval(lgl, res);
        val > 0 as libc::c_int;
        (*lgl).assumed += 1;
        (*lgl).assumed;
        if val == 0 {
            return res;
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn lgldefphase(
    mut lgl: *mut LGL,
    mut idx: libc::c_int,
) -> libc::c_int {
    let mut bias: libc::c_int = 0;
    let mut res: libc::c_int = 0;
    let mut av: *mut AVar = 0 as *mut AVar;
    av = lglavar(lgl, idx);
    bias = (*(*lgl).opts).phase.val;
    if bias == 0 {
        bias = (*av).bias();
    }
    if bias == 0 {
        bias = lglsetjwhbias(lgl, idx);
    }
    if (*(*lgl).opts).phasesave.val != 0 {
        res = (*av).phase();
        if res == 0 {
            (*av).set_phase(bias);
            res = (*av).phase();
        } else if (*(*lgl).opts).phasesave.val < 0 as libc::c_int {
            res = -res;
        }
    } else {
        res = bias;
    }
    return res;
}
unsafe extern "C" fn lgldecidephase(
    mut lgl: *mut LGL,
    mut lit: libc::c_int,
) -> libc::c_int {
    let mut res: libc::c_int = abs(lit);
    let mut av: *mut AVar = lglavar(lgl, lit);
    if (*av).fase() != 0 {
        return (*av).fase() * res;
    }
    if lgldefphase(lgl, res) <= 0 as libc::c_int {
        res = -res;
    }
    if (*(*lgl).opts).randphase.val != 0
        && (*(*lgl).limits).randphase <= (*(*lgl).stats).decisions
    {
        (*(*lgl).limits).randphase = (*(*lgl).stats).decisions;
        (*(*lgl).limits).randphase
            += ((*(*lgl).opts).randphaseint.val / 2 as libc::c_int) as int64_t;
        (*(*lgl).limits).randphase
            += (lglrand(lgl))
                .wrapping_rem((*(*lgl).opts).randphaseint.val as libc::c_uint)
                as int64_t;
        (*(*lgl).stats).randphases += 1;
        (*(*lgl).stats).randphases;
        res = -res;
    }
    return res;
}
unsafe extern "C" fn lglhasbins(mut lgl: *mut LGL, mut lit: libc::c_int) -> libc::c_int {
    let mut blit: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut other2: libc::c_int = 0;
    let mut val: libc::c_int = 0;
    let mut val2: libc::c_int = 0;
    let mut implied: libc::c_int = 0;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut w: *const libc::c_int = 0 as *const libc::c_int;
    let mut eos: *const libc::c_int = 0 as *const libc::c_int;
    let mut q: *const libc::c_int = 0 as *const libc::c_int;
    let mut hts: *mut HTS = 0 as *mut HTS;
    hts = lglhts(lgl, lit);
    w = lglhts2wchs(lgl, hts);
    eos = w.offset((*hts).count as isize);
    p = w;
    while p < eos {
        if (*lgl).treelooking != 0 {
            (*(*lgl).stats).steps += 1;
            (*(*lgl).stats).steps;
            (*(*lgl).stats).prb.treelook.steps += 1;
            (*(*lgl).stats).prb.treelook.steps;
        }
        blit = *p;
        tag = blit & MASKCS as libc::c_int;
        if tag == BINCS as libc::c_int {
            other = blit >> RMSHFT as libc::c_int;
            val = lglval(lgl, other) as libc::c_int;
            if val == 0 {
                return 1 as libc::c_int;
            }
        } else if tag == TRNCS as libc::c_int {
            other = blit >> RMSHFT as libc::c_int;
            p = p.offset(1);
            other2 = *p;
            val = lglval(lgl, other) as libc::c_int;
            val2 = lglval(lgl, other2) as libc::c_int;
            if !(val > 0 as libc::c_int || val2 > 0 as libc::c_int) {
                if val == 0 && val2 < 0 as libc::c_int {
                    return 1 as libc::c_int;
                }
                if val < 0 as libc::c_int && val2 == 0 {
                    return 1 as libc::c_int;
                }
            }
        } else {
            p = p.offset(1);
            q = lglidx2lits(lgl, blit & REDCS as libc::c_int, *p);
            implied = 0 as libc::c_int;
            loop {
                let fresh130 = q;
                q = q.offset(1);
                other = *fresh130;
                if !(other != 0) {
                    break;
                }
                if other == lit {
                    continue;
                }
                val = lglval(lgl, other) as libc::c_int;
                if val > 0 as libc::c_int {
                    break;
                }
                if val < 0 as libc::c_int {
                    continue;
                }
                if implied != 0 {
                    break;
                }
                implied = other;
            }
            if !(other != 0) {
                if implied != 0 {
                    return 1 as libc::c_int;
                }
            }
        }
        p = p.offset(1);
        p;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn lgldecide(mut lgl: *mut LGL) -> libc::c_int {
    let mut lit: libc::c_int = 0;
    lglchkbcpclean(lgl, b"decide\0" as *const u8 as *const libc::c_char);
    if (*lgl).unassigned == 0 {
        return 0 as libc::c_int;
    }
    lit = lgladecide(lgl);
    if lit != 0 {
        (*lgl).alevel = (*lgl).level + 1 as libc::c_int;
    } else {
        lit = lglprunedecide(lgl);
        if lit == 0 {
            if (*(*lgl).stats).stability.level > 0 as libc::c_int
                && (*(*lgl).stats).stability.level <= (*lgl).level
            {
                lglupdstab(lgl);
            }
            if (*(*lgl).opts).randec.val != 0
                && (*(*lgl).limits).randec <= (*(*lgl).stats).decisions
            {
                lit = lglrandec(lgl);
                lit = lgldecidephase(lgl, lit);
            } else {
                lit = lglnextdecision(lgl, 1 as libc::c_int);
                lit = lgldecidephase(lgl, lit);
            }
        }
    }
    if lit != 0 && lit != -(2147483647 as libc::c_int) - 1 as libc::c_int {
        lgldassume(lgl, lit);
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn lgldcpdis(mut lgl: *mut LGL) {
    let mut idx: libc::c_int = 0;
    let mut sign: libc::c_int = 0;
    let mut lit: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut blit: libc::c_int = 0;
    let mut red: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut other2: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut w: *const libc::c_int = 0 as *const libc::c_int;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut eow: *const libc::c_int = 0 as *const libc::c_int;
    let mut val: Val = 0;
    let mut hts: *mut HTS = 0 as *mut HTS;
    let mut s: *mut Stk = 0 as *mut Stk;
    (*lgl)
        .dis = lglnew(
        lgl,
        (1 as libc::c_int as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Dis>() as libc::c_ulong),
    ) as *mut Dis;
    idx = 2 as libc::c_int;
    while idx < (*lgl).nvars {
        sign = -(1 as libc::c_int);
        while sign <= 1 as libc::c_int {
            lit = sign * idx;
            hts = lglhts(lgl, lit);
            if !((*hts).offset == 0) {
                w = lglhts2wchs(lgl, hts);
                eow = w.offset((*hts).count as isize);
                (*hts).offset = 0 as libc::c_int as libc::c_uint;
                (*hts).count = (*hts).offset;
                val = lglval(lgl, lit);
                if !(val as libc::c_int > 0 as libc::c_int) {
                    let mut current_block_29: u64;
                    p = w;
                    while p < eow {
                        blit = *p;
                        tag = blit & MASKCS as libc::c_int;
                        if tag == TRNCS as libc::c_int || tag == LRGCS as libc::c_int {
                            p = p.offset(1);
                            p;
                        }
                        if !(tag == LRGCS as libc::c_int) {
                            other = blit >> RMSHFT as libc::c_int;
                            if !(abs(other) < idx) {
                                val = lglval(lgl, other);
                                if !(val as libc::c_int > 0 as libc::c_int) {
                                    red = blit & REDCS as libc::c_int;
                                    if !(red != 0 && lglisfree(lgl, other) == 0) {
                                        if tag == BINCS as libc::c_int {
                                            s = if red != 0 {
                                                &mut (*(*lgl).dis).red.bin
                                            } else {
                                                &mut (*(*lgl).dis).irr.bin
                                            };
                                            current_block_29 = 8704759739624374314;
                                        } else {
                                            other2 = *p;
                                            if abs(other2) < idx {
                                                current_block_29 = 8236137900636309791;
                                            } else {
                                                val = lglval(lgl, other2);
                                                if val as libc::c_int > 0 as libc::c_int {
                                                    current_block_29 = 8236137900636309791;
                                                } else if red != 0 && lglisfree(lgl, other2) == 0 {
                                                    current_block_29 = 8236137900636309791;
                                                } else {
                                                    s = if red != 0 {
                                                        &mut (*(*lgl).dis).red.trn
                                                    } else {
                                                        &mut (*(*lgl).dis).irr.trn
                                                    };
                                                    lglpushstk(lgl, s, other2);
                                                    current_block_29 = 8704759739624374314;
                                                }
                                            }
                                        }
                                        match current_block_29 {
                                            8236137900636309791 => {}
                                            _ => {
                                                lglpushstk(lgl, s, other);
                                                lglpushstk(lgl, s, lit);
                                                lglpushstk(lgl, s, 0 as libc::c_int);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        p = p.offset(1);
                        p;
                    }
                }
            }
            sign += 2 as libc::c_int;
        }
        idx += 1;
        idx;
    }
    lglrststk(&mut (*(*lgl).wchs).stk, 2 as libc::c_int);
    *((*(*lgl).wchs).stk.top)
        .offset(
            -(1 as libc::c_int) as isize,
        ) = (2147483647 as libc::c_int as libc::c_uint)
        .wrapping_mul(2 as libc::c_uint)
        .wrapping_add(1 as libc::c_uint) as libc::c_int;
    i = 0 as libc::c_int;
    while i < 31 as libc::c_int {
        (*(*lgl).wchs)
            .start[i
            as usize] = (2147483647 as libc::c_int as libc::c_uint)
            .wrapping_mul(2 as libc::c_uint)
            .wrapping_add(1 as libc::c_uint);
        i += 1;
        i;
    }
    (*(*lgl).wchs).free = 0 as libc::c_int;
    lglrelstk(lgl, &mut (*lgl).learned);
}
unsafe extern "C" fn lgldcpclnstk(
    mut lgl: *mut LGL,
    mut red: libc::c_int,
    mut s: *mut Stk,
) {
    let mut oldsz: libc::c_int = 0;
    let mut newsz: libc::c_int = 0;
    let mut lit: libc::c_int = 0;
    let mut mark: libc::c_int = 0;
    let mut satisfied: libc::c_int = 0;
    let mut repr: libc::c_int = 0;
    let mut act: libc::c_int = 0;
    let mut changed: libc::c_int = 0;
    let druplig: libc::c_int = (*(*lgl).opts).druplig.val;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut c: *const libc::c_int = 0 as *const libc::c_int;
    let mut eos: *const libc::c_int = (*s).top;
    let mut start: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut q: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut r: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut d: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut t: *mut Stk = 0 as *mut Stk;
    let mut saved: Stk = Stk {
        start: 0 as *mut libc::c_int,
        top: 0 as *mut libc::c_int,
        end: 0 as *mut libc::c_int,
    };
    let mut val: Val = 0;
    memset(
        &mut saved as *mut Stk as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<Stk>() as libc::c_ulong,
    );
    start = (*s).start;
    q = start;
    c = q;
    while c < eos {
        act = *c;
        if act == 2147483647 as libc::c_int {
            p = c.offset(1 as libc::c_int as isize);
            while p < eos && *p == 2147483647 as libc::c_int {
                p = p.offset(1);
                p;
            }
            p = p.offset(-1);
            p;
        } else {
            if lglisact(act) != 0 {
                let fresh131 = c;
                c = c.offset(1);
                let fresh132 = q;
                q = q.offset(1);
                *fresh132 = *fresh131;
            } else {
                act = -(1 as libc::c_int);
            }
            d = q;
            changed = 0 as libc::c_int;
            satisfied = changed;
            lglclnstk(&mut saved);
            p = c;
            loop {
                lit = *p;
                if !(lit != 0) {
                    break;
                }
                if druplig != 0 {
                    lglpushstk(lgl, &mut saved, lit);
                }
                if !(satisfied != 0) {
                    repr = lglirepr(lgl, lit);
                    val = lglcval(lgl, repr) as Val;
                    if val as libc::c_int > 0 as libc::c_int {
                        satisfied = 1 as libc::c_int;
                    } else if (val as libc::c_int) < 0 as libc::c_int {
                        changed = 1 as libc::c_int;
                    } else {
                        mark = lglmarked(lgl, repr);
                        if mark < 0 as libc::c_int {
                            satisfied = 1 as libc::c_int;
                        } else if mark > 0 as libc::c_int {
                            changed = 1 as libc::c_int;
                        } else {
                            if lit != repr {
                                changed = 1 as libc::c_int;
                            }
                            lglmark(lgl, repr);
                            let fresh133 = q;
                            q = q.offset(1);
                            *fresh133 = repr;
                        }
                    }
                }
                p = p.offset(1);
                p;
            }
            oldsz = p.offset_from(c) as libc::c_long as libc::c_int;
            r = d;
            while r < q {
                lglunmark(lgl, *r);
                r = r.offset(1);
                r;
            }
            newsz = q.offset_from(d) as libc::c_long as libc::c_int;
            if druplig != 0 && satisfied == 0 && newsz > 1 as libc::c_int && changed != 0
            {
                *q = 0 as libc::c_int;
                lgldrupligaddclsaux(lgl, REDCS as libc::c_int, d);
            }
            if satisfied != 0 || oldsz == 0 {
                q = d.offset(-((act >= 0 as libc::c_int) as libc::c_int as isize));
            } else {
                if newsz >= 4 as libc::c_int {
                    let fresh134 = q;
                    q = q.offset(1);
                    *fresh134 = 0 as libc::c_int;
                } else if newsz == 0 {
                    lglmt(lgl);
                    q = d.offset(-((act >= 0 as libc::c_int) as libc::c_int as isize));
                } else if newsz == 1 as libc::c_int {
                    lglunit(lgl, *d.offset(0 as libc::c_int as isize));
                    q = d.offset(-((act >= 0 as libc::c_int) as libc::c_int as isize));
                } else if newsz == 2 as libc::c_int {
                    t = if red != 0 {
                        &mut (*(*lgl).dis).red.bin
                    } else {
                        &mut (*(*lgl).dis).irr.bin
                    };
                    if s != t {
                        lglpushstk(lgl, t, *d.offset(0 as libc::c_int as isize));
                        lglpushstk(lgl, t, *d.offset(1 as libc::c_int as isize));
                        lglpushstk(lgl, t, 0 as libc::c_int);
                        q = d
                            .offset(
                                -((act >= 0 as libc::c_int) as libc::c_int as isize),
                            );
                    } else {
                        let fresh135 = q;
                        q = q.offset(1);
                        *fresh135 = 0 as libc::c_int;
                    }
                } else {
                    t = if red != 0 {
                        &mut (*(*lgl).dis).red.trn
                    } else {
                        &mut (*(*lgl).dis).irr.trn
                    };
                    if s != t {
                        lglpushstk(lgl, t, *d.offset(0 as libc::c_int as isize));
                        lglpushstk(lgl, t, *d.offset(1 as libc::c_int as isize));
                        lglpushstk(lgl, t, *d.offset(2 as libc::c_int as isize));
                        lglpushstk(lgl, t, 0 as libc::c_int);
                        q = d
                            .offset(
                                -((act >= 0 as libc::c_int) as libc::c_int as isize),
                            );
                    } else {
                        let fresh136 = q;
                        q = q.offset(1);
                        *fresh136 = 0 as libc::c_int;
                    }
                }
                if druplig != 0 && (satisfied != 0 || changed != 0) {
                    lglpushstk(lgl, &mut saved, 0 as libc::c_int);
                    lgldrupligdelclsaux(lgl, saved.start);
                }
            }
        }
        c = p.offset(1 as libc::c_int as isize);
    }
    (*s).top = q;
    lglrelstk(lgl, &mut saved);
}
unsafe extern "C" fn lgldcpconnaux(
    mut lgl: *mut LGL,
    mut red: libc::c_int,
    mut glue: libc::c_int,
    mut s: *mut Stk,
) {
    let mut start: *mut libc::c_int = (*s).start;
    let mut q: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut d: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut lit: libc::c_int = 0;
    let mut size: libc::c_int = 0;
    let mut lidx: libc::c_int = 0;
    let mut act: libc::c_int = 0;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut c: *const libc::c_int = 0 as *const libc::c_int;
    let mut eos: *const libc::c_int = (*s).top;
    q = start;
    c = q;
    while c < eos {
        act = *c;
        if lglisact(act) != 0 {
            let fresh137 = c;
            c = c.offset(1);
            let fresh138 = q;
            q = q.offset(1);
            *fresh138 = *fresh137;
        } else {
            act = -(1 as libc::c_int);
        }
        d = q;
        p = c;
        loop {
            lit = *p;
            if !(lit != 0) {
                break;
            }
            let fresh139 = q;
            q = q.offset(1);
            *fresh139 = lit;
            p = p.offset(1);
            p;
        }
        size = q.offset_from(d) as libc::c_long as libc::c_int;
        if size == 2 as libc::c_int {
            q = d.offset(-((act >= 0 as libc::c_int) as libc::c_int as isize));
            lglwchbin(
                lgl,
                *d.offset(0 as libc::c_int as isize),
                *d.offset(1 as libc::c_int as isize),
                red,
            );
            lglwchbin(
                lgl,
                *d.offset(1 as libc::c_int as isize),
                *d.offset(0 as libc::c_int as isize),
                red,
            );
        } else if size == 3 as libc::c_int {
            q = d.offset(-((act >= 0 as libc::c_int) as libc::c_int as isize));
            lglwchtrn(
                lgl,
                *d.offset(0 as libc::c_int as isize),
                *d.offset(1 as libc::c_int as isize),
                *d.offset(2 as libc::c_int as isize),
                red,
            );
            lglwchtrn(
                lgl,
                *d.offset(1 as libc::c_int as isize),
                *d.offset(0 as libc::c_int as isize),
                *d.offset(2 as libc::c_int as isize),
                red,
            );
            lglwchtrn(
                lgl,
                *d.offset(2 as libc::c_int as isize),
                *d.offset(0 as libc::c_int as isize),
                *d.offset(1 as libc::c_int as isize),
                red,
            );
        } else {
            let fresh140 = q;
            q = q.offset(1);
            *fresh140 = 0 as libc::c_int;
            lidx = d.offset_from(start) as libc::c_long as libc::c_int;
            if red != 0 {
                lidx <<= 4 as libc::c_int;
                lidx |= glue;
            }
            lglwchlrg(
                lgl,
                *d.offset(0 as libc::c_int as isize),
                *d.offset(1 as libc::c_int as isize),
                red,
                lidx,
            );
            lglwchlrg(
                lgl,
                *d.offset(1 as libc::c_int as isize),
                *d.offset(0 as libc::c_int as isize),
                red,
                lidx,
            );
        }
        c = p.offset(1 as libc::c_int as isize);
    }
    (*s).top = q;
}
unsafe extern "C" fn lgldcpcon(mut lgl: *mut LGL) {
    let mut lir: *mut Stk = 0 as *mut Stk;
    let mut glue: libc::c_int = 0;
    lgldcpconnaux(lgl, 0 as libc::c_int, 0 as libc::c_int, &mut (*(*lgl).dis).irr.bin);
    lgldcpconnaux(
        lgl,
        REDCS as libc::c_int,
        0 as libc::c_int,
        &mut (*(*lgl).dis).red.bin,
    );
    lgldcpconnaux(lgl, 0 as libc::c_int, 0 as libc::c_int, &mut (*(*lgl).dis).irr.trn);
    lgldcpconnaux(
        lgl,
        REDCS as libc::c_int,
        0 as libc::c_int,
        &mut (*(*lgl).dis).red.trn,
    );
    lglrelstk(lgl, &mut (*(*lgl).dis).irr.bin);
    lglrelstk(lgl, &mut (*(*lgl).dis).irr.trn);
    lglrelstk(lgl, &mut (*(*lgl).dis).red.bin);
    lglrelstk(lgl, &mut (*(*lgl).dis).red.trn);
    lgldel(
        lgl,
        (*lgl).dis as *mut libc::c_void,
        (1 as libc::c_int as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Dis>() as libc::c_ulong),
    );
    (*lgl).dis = 0 as *mut Dis;
    lgldcpconnaux(lgl, 0 as libc::c_int, 0 as libc::c_int, &mut (*lgl).irr);
    glue = 0 as libc::c_int;
    while glue < ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int {
        lir = ((*lgl).red).offset(glue as isize);
        lgldcpconnaux(lgl, REDCS as libc::c_int, glue, lir);
        glue += 1;
        glue;
    }
    lglfullyconnected(lgl);
}
unsafe extern "C" fn lgldcpcln(mut lgl: *mut LGL) {
    let mut glue: libc::c_int = 0;
    let mut old: libc::c_int = 0;
    let mut rounds: libc::c_int = 0 as libc::c_int;
    let mut lir: *mut Stk = 0 as *mut Stk;
    loop {
        rounds += 1;
        rounds;
        old = (*(*lgl).stats).fixed.current;
        lgldcpclnstk(lgl, 0 as libc::c_int, &mut (*lgl).irr);
        lgldcpclnstk(lgl, 0 as libc::c_int, &mut (*(*lgl).dis).irr.bin);
        lgldcpclnstk(lgl, 0 as libc::c_int, &mut (*(*lgl).dis).irr.trn);
        lgldcpclnstk(lgl, REDCS as libc::c_int, &mut (*(*lgl).dis).red.bin);
        lgldcpclnstk(lgl, REDCS as libc::c_int, &mut (*(*lgl).dis).red.trn);
        glue = 0 as libc::c_int;
        while glue < ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int {
            lir = ((*lgl).red).offset(glue as isize);
            lgldcpclnstk(lgl, REDCS as libc::c_int, lir);
            glue += 1;
            glue;
        }
        if !(old < (*(*lgl).stats).fixed.current) {
            break;
        }
    };
}
unsafe extern "C" fn lglepush(mut lgl: *mut LGL, mut ilit: libc::c_int) {
    let mut elit: libc::c_int = if ilit != 0 {
        lglexport(lgl, ilit)
    } else {
        0 as libc::c_int
    };
    lglpushstk(lgl, &mut (*lgl).extend, elit);
}
unsafe extern "C" fn lglemerge(
    mut lgl: *mut LGL,
    mut ilit0: libc::c_int,
    mut ilit1: libc::c_int,
) {
    let mut elit0: libc::c_int = lglexport(lgl, ilit0);
    let mut elit1: libc::c_int = lglexport(lgl, ilit1);
    let mut repr0: libc::c_int = lglerepr(lgl, elit0);
    let mut repr1: libc::c_int = lglerepr(lgl, elit1);
    let mut ext0: *mut Ext = lglelit2ext(lgl, repr0);
    let mut ext1: *mut Ext = lglelit2ext(lgl, repr1);
    if repr0 < 0 as libc::c_int {
        repr1 *= -(1 as libc::c_int);
    }
    (*ext0).set_equiv(1 as libc::c_int as libc::c_uint);
    (*ext0).repr = repr1;
    if (*ext1).aliased() != 0 {
        (*ext0).set_aliased(1 as libc::c_int as libc::c_uint);
    }
    lglepush(lgl, -ilit0);
    lglepush(lgl, ilit1);
    lglepush(lgl, 0 as libc::c_int);
    lglepush(lgl, ilit0);
    lglepush(lgl, -ilit1);
    lglepush(lgl, 0 as libc::c_int);
    lgldrupligaddclsarg(lgl, REDCS as libc::c_int, -ilit0, ilit1, 0 as libc::c_int);
    lgldrupligaddclsarg(lgl, REDCS as libc::c_int, ilit0, -ilit1, 0 as libc::c_int);
}
unsafe extern "C" fn lglimerge(
    mut lgl: *mut LGL,
    mut lit: libc::c_int,
    mut repr: libc::c_int,
) {
    let mut idx: libc::c_int = abs(lit);
    let mut av: *mut AVar = lglavar(lgl, idx);
    if lit < 0 as libc::c_int {
        repr = -repr;
    }
    (*av).set_type_0(EQUIVAR as libc::c_int as libc::c_uint);
    *((*lgl).repr).offset(idx as isize) = repr;
    (*(*lgl).stats).prgss += 1;
    (*(*lgl).stats).prgss;
    (*(*lgl).stats).irrprgss += 1;
    (*(*lgl).stats).irrprgss;
    (*(*lgl).stats).equiv.sum += 1;
    (*(*lgl).stats).equiv.sum;
    (*(*lgl).stats).equiv.current += 1;
    (*(*lgl).stats).equiv.current;
    lglemerge(lgl, idx, repr);
}
unsafe extern "C" fn lglfreezer(mut lgl: *mut LGL) {
    let mut frozen: libc::c_int = 0;
    let mut melted: libc::c_int = 0;
    let mut tmpfrozen: libc::c_int = 0;
    let mut elit: libc::c_int = 0;
    let mut erepr: libc::c_int = 0;
    let mut ilit: libc::c_int = 0;
    let mut ext: *mut Ext = 0 as *mut Ext;
    let mut rext: *mut Ext = 0 as *mut Ext;
    let mut p: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut eass: libc::c_int = 0;
    if (*lgl).frozen != 0 {
        return;
    }
    elit = 1 as libc::c_int;
    while elit <= (*lgl).maxext {
        let ref mut fresh141 = *((*lgl).ext).offset(elit as isize);
        (*fresh141).set_tmpfrozen(0 as libc::c_int as libc::c_uint);
        elit += 1;
        elit;
    }
    frozen = 0 as libc::c_int;
    tmpfrozen = frozen;
    if lglmtstk(&mut (*lgl).eassume) == 0 {
        p = (*lgl).eassume.start;
        while p < (*lgl).eassume.top {
            eass = *p;
            ext = lglelit2ext(lgl, eass);
            if (*ext).frozen == 0 && (*ext).tmpfrozen() == 0 {
                (*ext).set_tmpfrozen(1 as libc::c_int as libc::c_uint);
                tmpfrozen += 1;
                tmpfrozen;
                erepr = lglerepr(lgl, eass);
                rext = lglelit2ext(lgl, erepr);
                if ext != rext && (*rext).frozen == 0 && (*rext).tmpfrozen() == 0 {
                    (*rext).set_tmpfrozen(1 as libc::c_int as libc::c_uint);
                    tmpfrozen += 1;
                    tmpfrozen;
                }
            }
            p = p.offset(1);
            p;
        }
    }
    elit = 1 as libc::c_int;
    while elit <= (*lgl).maxext {
        ext = lglelit2ext(lgl, elit);
        if !((*ext).frozen == 0) {
            frozen += 1;
            frozen;
            erepr = lglerepr(lgl, elit);
            rext = lglelit2ext(lgl, erepr);
            if !(ext == rext) {
                if !((*rext).frozen != 0) {
                    if !((*rext).tmpfrozen() != 0) {
                        (*rext).set_tmpfrozen(1 as libc::c_int as libc::c_uint);
                        tmpfrozen += 1;
                        tmpfrozen;
                    }
                }
            }
        }
        elit += 1;
        elit;
    }
    melted = 0 as libc::c_int;
    elit = 1 as libc::c_int;
    while elit <= (*lgl).maxext {
        ext = lglelit2ext(lgl, elit);
        if !((*ext).frozen != 0) {
            if !((*ext).melted() != 0) {
                if !((*ext).tmpfrozen() != 0) {
                    if !((*ext).imported() == 0) {
                        (*ext).set_melted(1 as libc::c_int as libc::c_uint);
                        melted += 1;
                        melted;
                    }
                }
            }
        }
        elit += 1;
        elit;
    }
    (*lgl).frozen = 1 as libc::c_int as libc::c_char;
    frozen = 0 as libc::c_int;
    melted = frozen;
    ilit = 2 as libc::c_int;
    while ilit < (*lgl).nvars {
        if !(lglisfree(lgl, ilit) == 0) {
            if lglifrozen(lgl, ilit) != 0 {
                frozen += 1;
                frozen;
            } else {
                melted += 1;
                melted;
            }
        }
        ilit += 1;
        ilit;
    }
    (*lgl).allfrozen = (melted == 0) as libc::c_int as libc::c_char;
    if (*lgl).allfrozen != 0 {
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[freezer] all %d free variables frozen\0" as *const u8
                as *const libc::c_char,
            frozen,
        );
    } else {
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[freezer] frozen %d variables out of %d free variables %.0f%%\0"
                as *const u8 as *const libc::c_char,
            frozen,
            frozen + melted,
            lglpcnt(frozen as libc::c_double, (frozen + melted) as libc::c_double),
        );
    };
}
unsafe extern "C" fn lglcmprepr(
    mut lgl: *mut LGL,
    mut a: libc::c_int,
    mut b: libc::c_int,
) -> libc::c_int {
    let mut f: libc::c_int = lglifrozen(lgl, a);
    let mut g: libc::c_int = lglifrozen(lgl, b);
    let mut res: libc::c_int = 0;
    res = g - f;
    if res != 0 {
        return res;
    }
    res = abs(a) - abs(b);
    if res != 0 {
        return res;
    }
    return a - b;
}
unsafe extern "C" fn lgltarjan(mut lgl: *mut LGL) -> libc::c_int {
    let mut dfsimap: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut mindfsimap: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut idx: libc::c_int = 0;
    let mut oidx: libc::c_int = 0;
    let mut sign: libc::c_int = 0;
    let mut lit: libc::c_int = 0;
    let mut blit: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut dfsi: libc::c_int = 0;
    let mut mindfsi: libc::c_int = 0;
    let mut ulit: libc::c_int = 0;
    let mut uother: libc::c_int = 0;
    let mut tmp: libc::c_int = 0;
    let mut repr: libc::c_int = 0;
    let mut res: libc::c_int = 0;
    let mut sgn: libc::c_int = 0;
    let mut frozen: libc::c_int = 0;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut w: *const libc::c_int = 0 as *const libc::c_int;
    let mut eow: *const libc::c_int = 0 as *const libc::c_int;
    let mut stk: Stk = Stk {
        start: 0 as *mut libc::c_int,
        top: 0 as *mut libc::c_int,
        end: 0 as *mut libc::c_int,
    };
    let mut component: Stk = Stk {
        start: 0 as *mut libc::c_int,
        top: 0 as *mut libc::c_int,
        end: 0 as *mut libc::c_int,
    };
    let mut av: *mut AVar = 0 as *mut AVar;
    let mut hts: *mut HTS = 0 as *mut HTS;
    if (*lgl).mt != 0 {
        return 0 as libc::c_int;
    }
    if (*lgl).nvars == 0 {
        return 1 as libc::c_int;
    }
    dfsi = 0 as libc::c_int;
    dfsimap = lglnew(
        lgl,
        ((2 as libc::c_int * (*lgl).nvars) as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
    ) as *mut libc::c_int;
    mindfsimap = lglnew(
        lgl,
        ((2 as libc::c_int * (*lgl).nvars) as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
    ) as *mut libc::c_int;
    (*lgl)
        .repr = lglnew(
        lgl,
        ((*lgl).nvars as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
    ) as *mut libc::c_int;
    memset(
        &mut stk as *mut Stk as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<Stk>() as libc::c_ulong,
    );
    memset(
        &mut component as *mut Stk as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<Stk>() as libc::c_ulong,
    );
    res = 1 as libc::c_int;
    idx = 2 as libc::c_int;
    's_102: while idx < (*lgl).nvars {
        sign = -(1 as libc::c_int);
        while sign <= 1 as libc::c_int {
            lit = sign * idx;
            ulit = lglulit(lit);
            tmp = *dfsimap.offset(ulit as isize);
            if !(tmp != 0) {
                lglpushstk(lgl, &mut stk, lit);
                while lglmtstk(&mut stk) == 0 {
                    lit = lglpopstk(&mut stk);
                    if lit != 0 {
                        ulit = lglulit(lit);
                        if *dfsimap.offset(ulit as isize) != 0 {
                            continue;
                        }
                        dfsi += 1;
                        let ref mut fresh142 = *mindfsimap.offset(ulit as isize);
                        *fresh142 = dfsi;
                        *dfsimap.offset(ulit as isize) = *fresh142;
                        lglpushstk(lgl, &mut component, lit);
                        lglpushstk(lgl, &mut stk, lit);
                        lglpushstk(lgl, &mut stk, 0 as libc::c_int);
                        hts = lglhts(lgl, -lit);
                        if (*hts).offset == 0 {
                            continue;
                        }
                        w = lglhts2wchs(lgl, hts);
                        eow = w.offset((*hts).count as isize);
                        p = w;
                        while p < eow {
                            blit = *p;
                            tag = blit & MASKCS as libc::c_int;
                            if tag != BINCS as libc::c_int {
                                p = p.offset(1);
                                p;
                            } else {
                                other = blit >> RMSHFT as libc::c_int;
                                uother = lglulit(other);
                                tmp = *dfsimap.offset(uother as isize);
                                if !(tmp != 0) {
                                    lglpushstk(lgl, &mut stk, other);
                                }
                            }
                            p = p.offset(1);
                            p;
                        }
                    } else {
                        lit = lglpopstk(&mut stk);
                        ulit = lglulit(lit);
                        mindfsi = *dfsimap.offset(ulit as isize);
                        hts = lglhts(lgl, -lit);
                        w = lglhts2wchs(lgl, hts);
                        eow = w.offset((*hts).count as isize);
                        p = w;
                        while p < eow {
                            blit = *p;
                            tag = blit & MASKCS as libc::c_int;
                            if tag != BINCS as libc::c_int {
                                p = p.offset(1);
                                p;
                            } else {
                                other = blit >> RMSHFT as libc::c_int;
                                uother = lglulit(other);
                                tmp = *mindfsimap.offset(uother as isize);
                                if !(tmp >= mindfsi) {
                                    mindfsi = tmp;
                                }
                            }
                            p = p.offset(1);
                            p;
                        }
                        if mindfsi == *dfsimap.offset(ulit as isize) {
                            repr = lit;
                            frozen = lglifrozen(lgl, repr);
                            p = (component.top).offset(-(1 as libc::c_int as isize));
                            loop {
                                other = *p;
                                if !(other != lit) {
                                    break;
                                }
                                if lglcmprepr(lgl, other, repr) < 0 as libc::c_int {
                                    repr = other;
                                }
                                if frozen == 0 && lglifrozen(lgl, other) != 0 {
                                    frozen = 1 as libc::c_int;
                                }
                                p = p.offset(-1);
                                p;
                            }
                            loop {
                                other = lglpopstk(&mut component);
                                if !(other != lit) {
                                    break;
                                }
                                *mindfsimap
                                    .offset(
                                        lglulit(other) as isize,
                                    ) = 2147483647 as libc::c_int;
                                if other == repr {
                                    continue;
                                }
                                if other == -repr {
                                    lgldrupligaddclsarg(
                                        lgl,
                                        REDCS as libc::c_int,
                                        repr,
                                        0 as libc::c_int,
                                    );
                                    lglmt(lgl);
                                    res = 0 as libc::c_int;
                                    break 's_102;
                                } else {
                                    sgn = lglsgn(other);
                                    oidx = abs(other);
                                    tmp = *((*lgl).repr).offset(oidx as isize);
                                    if tmp == sgn * repr {
                                        continue;
                                    }
                                    if tmp != 0 {
                                        lgldrupligaddclsarg(
                                            lgl,
                                            REDCS as libc::c_int,
                                            repr,
                                            0 as libc::c_int,
                                        );
                                        lglmt(lgl);
                                        res = 0 as libc::c_int;
                                        break 's_102;
                                    } else {
                                        av = lglavar(lgl, oidx);
                                        if (*av).type_0() as libc::c_int == FREEVAR as libc::c_int {
                                            lglimerge(lgl, other, repr);
                                        }
                                    }
                                }
                            }
                            *mindfsimap
                                .offset(lglulit(lit) as isize) = 2147483647 as libc::c_int;
                            frozen != 0;
                        } else {
                            *mindfsimap.offset(ulit as isize) = mindfsi;
                        }
                    }
                }
            }
            sign += 2 as libc::c_int;
        }
        idx += 1;
        idx;
    }
    lglrelstk(lgl, &mut stk);
    lglrelstk(lgl, &mut component);
    lgldel(
        lgl,
        mindfsimap as *mut libc::c_void,
        ((2 as libc::c_int * (*lgl).nvars) as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
    );
    mindfsimap = 0 as *mut libc::c_int;
    lgldel(
        lgl,
        dfsimap as *mut libc::c_void,
        ((2 as libc::c_int * (*lgl).nvars) as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
    );
    dfsimap = 0 as *mut libc::c_int;
    if res == 0 {
        lgldel(
            lgl,
            (*lgl).repr as *mut libc::c_void,
            ((*lgl).nvars as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
        );
        (*lgl).repr = 0 as *mut libc::c_int;
    }
    if (*lgl).mt != 0 {
        lgldrupligaddclsarg(lgl, REDCS as libc::c_int, 0 as libc::c_int);
    }
    return res;
}
unsafe extern "C" fn lglsyncunits(mut lgl: *mut LGL) -> libc::c_int {
    let mut units: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut eou: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut p: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut elit: libc::c_int = 0;
    let mut erepr: libc::c_int = 0;
    let mut ilit: libc::c_int = 0;
    let mut res: libc::c_int = 0;
    let mut count: libc::c_int = 0 as libc::c_int;
    let mut produce: Option::<
        unsafe extern "C" fn(*mut libc::c_void, libc::c_int) -> (),
    > = None;
    let mut steps: int64_t = 0;
    let mut ext: *mut Ext = 0 as *mut Ext;
    let mut val: Val = 0;
    if (*lgl).mt != 0 {
        return 0 as libc::c_int;
    }
    if ((*lgl).cbs).is_null() {
        return 1 as libc::c_int;
    }
    if ((*(*lgl).cbs).units.consume.fun).is_none() {
        return 1 as libc::c_int;
    }
    steps = lglsteps(lgl);
    if steps < (*(*lgl).limits).sync.steps {
        return 1 as libc::c_int;
    }
    (*(*lgl).limits).sync.steps = steps + (*(*lgl).opts).syncunint.val as int64_t;
    (*(*lgl).stats).sync.units.consumed.calls += 1;
    (*(*lgl).stats).sync.units.consumed.calls;
    ((*(*lgl).cbs).units.consume.fun)
        .expect(
            "non-null function pointer",
        )((*(*lgl).cbs).units.consume.state, &mut units, &mut eou);
    if units == eou {
        return 1 as libc::c_int;
    }
    (*(*lgl).stats).sync.units.consumed.tried += 1;
    (*(*lgl).stats).sync.units.consumed.tried;
    produce = (*(*lgl).cbs).units.produce.fun;
    (*(*lgl).cbs).units.produce.fun = None;
    p = units;
    while (*lgl).mt == 0 && p < eou {
        elit = *p;
        erepr = lglerepr(lgl, elit);
        ext = lglelit2ext(lgl, erepr);
        ilit = (*ext).repr;
        if !(ilit == 0) {
            if erepr < 0 as libc::c_int {
                ilit = -ilit;
            }
            if !(ilit == 1 as libc::c_int) {
                if ilit == -(1 as libc::c_int) {
                    val = -(1 as libc::c_int) as Val;
                } else {
                    val = lglval(lgl, ilit);
                    if val as libc::c_int != 0 && lglevel(lgl, ilit) != 0 {
                        val = 0 as libc::c_int as Val;
                    }
                }
                if !(val as libc::c_int == 1 as libc::c_int) {
                    if val as libc::c_int == -(1 as libc::c_int) {
                        if (*lgl).level > 0 as libc::c_int {
                            lglbacktrack(lgl, 0 as libc::c_int);
                        }
                        lglmt(lgl);
                    } else if !(lglisfree(lgl, ilit) == 0) {
                        if (*lgl).level > 0 as libc::c_int {
                            lglbacktrack(lgl, 0 as libc::c_int);
                        }
                        lglunit(lgl, ilit);
                        count += 1;
                        count;
                    }
                }
            }
        }
        p = p.offset(1);
        p;
    }
    (*(*lgl).cbs).units.produce.fun = produce;
    if ((*(*lgl).cbs).units.consumed.fun).is_some() {
        ((*(*lgl).cbs).units.consumed.fun)
            .expect(
                "non-null function pointer",
            )((*(*lgl).cbs).units.consumed.state, count);
    }
    if count != 0 {
        (*(*lgl).stats).sync.units.consumed.actual += 1;
        (*(*lgl).stats).sync.units.consumed.actual;
    }
    if (*lgl).mt != 0 {
        return 0 as libc::c_int;
    }
    count != 0;
    if count == 0 {
        return 1 as libc::c_int;
    }
    res = lglbcp(lgl);
    if res == 0 && (*lgl).mt == 0 {
        lglmt(lgl);
    }
    return res;
}
unsafe extern "C" fn lglelitblockingoreliminated(
    mut lgl: *mut LGL,
    mut elit: libc::c_int,
) -> libc::c_int {
    let mut ext: *mut Ext = lglelit2ext(lgl, elit);
    return ((*ext).blocking() as libc::c_int != 0
        || (*ext).eliminated() as libc::c_int != 0) as libc::c_int;
}
unsafe extern "C" fn lglsynclsexist(mut lgl: *mut LGL) -> libc::c_int {
    let mut len: libc::c_int = 0;
    let mut lit: libc::c_int = 0;
    let mut blit: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut other2: libc::c_int = 0;
    let mut s: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut p: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut w: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut eow: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut hts: *mut HTS = 0 as *mut HTS;
    len = lglcntstk(&mut (*lgl).clause) as libc::c_int;
    if len <= 1 as libc::c_int {
        return 0 as libc::c_int;
    }
    s = (*lgl).clause.start;
    p = s.offset(1 as libc::c_int as isize);
    while p.offset(1 as libc::c_int as isize) < (*lgl).clause.top {
        if (*lglhts(lgl, *s)).count > (*lglhts(lgl, *p)).count {
            let mut TMP: libc::c_int = *s;
            *s = *p;
            *p = TMP;
        }
        p = p.offset(1);
        p;
    }
    lit = *s;
    hts = lglhts(lgl, lit);
    w = lglhts2wchs(lgl, hts);
    eow = w.offset((*hts).count as isize);
    p = w;
    while p < eow {
        blit = *p;
        tag = blit & MASKCS as libc::c_int;
        if tag == TRNCS as libc::c_int || tag == LRGCS as libc::c_int {
            p = p.offset(1);
            p;
        }
        if !(tag == LRGCS as libc::c_int) {
            if tag == BINCS as libc::c_int {
                other = blit >> RMSHFT as libc::c_int;
                if lglmarked(lgl, other) > 0 as libc::c_int {
                    return 1 as libc::c_int;
                }
            } else if !(len <= 2 as libc::c_int) {
                other = blit >> RMSHFT as libc::c_int;
                if lglmarked(lgl, other) > 0 as libc::c_int {
                    return 1 as libc::c_int;
                }
                other2 = *p;
                if lglmarked(lgl, other2) > 0 as libc::c_int {
                    return 1 as libc::c_int;
                }
            }
        }
        p = p.offset(1);
        p;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn lglsyncls(mut lgl: *mut LGL) -> libc::c_int {
    let mut maxlevel: libc::c_int = 0;
    let mut level: libc::c_int = 0;
    let mut nonfalse: libc::c_int = 0;
    let mut numtrue: libc::c_int = 0;
    let mut res: libc::c_int = 0;
    let mut delta: libc::c_int = 0;
    let mut glue: libc::c_int = 0;
    let mut consumed: libc::c_int = 0;
    let mut cls: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut elit: libc::c_int = 0;
    let mut erepr: libc::c_int = 0;
    let mut tmp: libc::c_int = 0;
    let mut ilit: libc::c_int = 0;
    let mut len: libc::c_int = 0;
    let mut newglue: libc::c_int = 0;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut rate: int64_t = 0;
    if (*lgl).mt != 0 {
        return 0 as libc::c_int;
    }
    if ((*lgl).cbs).is_null() {
        return 1 as libc::c_int;
    }
    if ((*(*lgl).cbs).cls.consume.fun).is_none() {
        return 1 as libc::c_int;
    }
    if (*(*lgl).stats).confs < (*(*lgl).limits).sync.confs {
        return 1 as libc::c_int;
    }
    delta = (*(*lgl).opts).synclsint.val;
    if (*(*lgl).stats).sync.cls.consumed.calls != 0 {
        rate = 100 as libc::c_int as int64_t * (*(*lgl).stats).sync.cls.consumed.tried;
        rate /= (*(*lgl).stats).sync.cls.consumed.calls;
        if rate != 0 {
            delta = (delta as int64_t / rate) as libc::c_int;
        }
    }
    (*(*lgl).limits).sync.confs = (*(*lgl).stats).confs + delta as int64_t;
    (*(*lgl).stats).sync.cls.consumed.calls += 1;
    (*(*lgl).stats).sync.cls.consumed.calls;
    consumed = 0 as libc::c_int;
    loop {
        ((*(*lgl).cbs).cls.consume.fun)
            .expect(
                "non-null function pointer",
            )((*(*lgl).cbs).cls.consume.state, &mut cls, &mut glue);
        if cls.is_null() {
            return 1 as libc::c_int;
        }
        (*(*lgl).stats).sync.cls.consumed.tried += 1;
        (*(*lgl).stats).sync.cls.consumed.tried;
        numtrue = 0 as libc::c_int;
        nonfalse = numtrue;
        maxlevel = nonfalse;
        p = cls;
        loop {
            elit = *p;
            if !(elit != 0) {
                break;
            }
            erepr = lglerepr(lgl, elit);
            if lglelitblockingoreliminated(lgl, erepr) != 0 {
                break;
            }
            ilit = lglimport(lgl, erepr);
            if ilit == 0 {
                break;
            }
            if ilit == 1 as libc::c_int {
                break;
            }
            if !(ilit == -(1 as libc::c_int)) {
                tmp = lglifixed(lgl, ilit) as libc::c_int;
                if tmp > 0 as libc::c_int {
                    break;
                }
                if !(tmp < 0 as libc::c_int) {
                    tmp = lglmarked(lgl, ilit);
                    if !(tmp > 0 as libc::c_int) {
                        if tmp < 0 as libc::c_int {
                            break;
                        }
                        lglpushstk(lgl, &mut (*lgl).clause, ilit);
                        lglmark(lgl, ilit);
                        tmp = lglval(lgl, ilit) as libc::c_int;
                        if tmp > 0 as libc::c_int {
                            numtrue += 1;
                            numtrue;
                        } else if tmp == 0 {
                            nonfalse += 1;
                            nonfalse;
                        } else {
                            level = lglevel(lgl, ilit);
                            if level > maxlevel {
                                maxlevel = level;
                            }
                        }
                    }
                }
            }
            p = p.offset(1);
            p;
        }
        res = 1 as libc::c_int;
        if elit == 0 && lglsynclsexist(lgl) != 0 {
            elit = 2147483647 as libc::c_int;
        }
        p = (*lgl).clause.start;
        while p < (*lgl).clause.top as *const libc::c_int {
            lglunmark(lgl, *p);
            p = p.offset(1);
            p;
        }
        if !(elit != 0) {
            len = lglcntstk(&mut (*lgl).clause) as libc::c_int;
            if numtrue == 0 && nonfalse <= 1 as libc::c_int {
                if len <= 1 as libc::c_int || maxlevel <= 1 as libc::c_int {
                    level = 0 as libc::c_int;
                } else {
                    level = 0 as libc::c_int;
                    p = (*lgl).clause.start;
                    while p < (*lgl).clause.top as *const libc::c_int {
                        ilit = *p;
                        tmp = lglval(lgl, ilit) as libc::c_int;
                        if !(tmp == 0) {
                            tmp = lglevel(lgl, ilit);
                            if tmp < maxlevel && tmp > level {
                                level = tmp;
                            }
                        }
                        p = p.offset(1);
                        p;
                    }
                }
                if level < (*lgl).level {
                    lglbacktrack(lgl, level);
                }
            }
            lglpushstk(lgl, &mut (*lgl).clause, 0 as libc::c_int);
            newglue = glue;
            (*(*lgl).stats).sync.cls.consumed.actual += 1;
            (*(*lgl).stats).sync.cls.consumed.actual;
            lgldrupligaddcls(lgl, 0 as libc::c_int);
            lgladdcls(lgl, REDCS as libc::c_int, newglue, (numtrue == 0) as libc::c_int);
            consumed += 1;
            consumed;
            if (*lgl).mt != 0 {
                res = 0 as libc::c_int;
            } else {
                res = lglbcpsearch(lgl);
            }
        }
        lglclnstk(&mut (*lgl).clause);
        if !(res != 0 && (*(*lgl).opts).synclsall.val != 0) {
            break;
        }
    }
    if ((*(*lgl).cbs).cls.consumed.fun).is_some() {
        ((*(*lgl).cbs).cls.consumed.fun)
            .expect(
                "non-null function pointer",
            )((*(*lgl).cbs).cls.consumed.state, consumed);
    }
    return res;
}
unsafe extern "C" fn lglprbpull(
    mut lgl: *mut LGL,
    mut lit: libc::c_int,
    mut probe: libc::c_int,
) -> libc::c_int {
    let mut av: *mut AVar = 0 as *mut AVar;
    av = lglavar(lgl, lit);
    if (*av).mark != 0 {
        return 0 as libc::c_int;
    }
    if lglevel(lgl, lit) == 0 {
        return 0 as libc::c_int;
    }
    (*av).mark = 1 as libc::c_int;
    lglpushstk(lgl, &mut (*lgl).seen, -lit);
    return 1 as libc::c_int;
}
unsafe extern "C" fn lglprbana(
    mut lgl: *mut LGL,
    mut probe: libc::c_int,
) -> libc::c_int {
    let mut open: libc::c_int = 0;
    let mut lit: libc::c_int = 0;
    let mut r0: libc::c_int = 0;
    let mut r1: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut red: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut res: libc::c_int = 0;
    let mut p: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut rsn: *mut libc::c_int = 0 as *mut libc::c_int;
    lit = (*lgl).conf.lit;
    r0 = (*lgl).conf.rsn[0 as libc::c_int as usize];
    r1 = (*lgl).conf.rsn[1 as libc::c_int as usize];
    open = lglprbpull(lgl, lit, probe);
    loop {
        tag = r0 & MASKCS as libc::c_int;
        if tag == BINCS as libc::c_int || tag == TRNCS as libc::c_int {
            other = r0 >> RMSHFT as libc::c_int;
            if lglprbpull(lgl, other, probe) != 0 {
                open += 1;
                open;
            }
            if tag == TRNCS as libc::c_int && lglprbpull(lgl, r1, probe) != 0 {
                open += 1;
                open;
            }
        } else {
            red = r0 & REDCS as libc::c_int;
            p = lglidx2lits(lgl, red, r1);
            loop {
                let fresh143 = p;
                p = p.offset(1);
                other = *fresh143;
                if !(other != 0) {
                    break;
                }
                open += lglprbpull(lgl, other, probe);
            }
        }
        loop {
            lit = lglpopstk(&mut (*lgl).trail);
            if !(lglmarked(lgl, lit) == 0) {
                break;
            }
            lglunassign(lgl, lit);
        }
        lglunassign(lgl, lit);
        open -= 1;
        if open == 0 {
            res = lit;
            break;
        } else {
            rsn = lglrsn(lgl, lit);
            r0 = *rsn.offset(0 as libc::c_int as isize);
            r1 = *rsn.offset(1 as libc::c_int as isize);
        }
    }
    res == probe;
    lglpopnunmarkstk(lgl, &mut (*lgl).seen);
    return res;
}
unsafe extern "C" fn lglederef(mut lgl: *mut LGL, mut elit: libc::c_int) -> libc::c_int {
    let mut ilit: libc::c_int = 0;
    let mut res: libc::c_int = 0;
    let mut ext: *mut Ext = 0 as *mut Ext;
    if abs(elit) > (*lgl).maxext {
        return -(1 as libc::c_int);
    }
    ext = lglelit2ext(lgl, elit);
    res = (*ext).val();
    if res == 0 {
        ilit = (*ext).repr;
        res = if ilit != 0 { lglcval(lgl, ilit) } else { -(1 as libc::c_int) };
    }
    if elit < 0 as libc::c_int {
        res = -res;
    }
    return res;
}
unsafe extern "C" fn lglhasbin(
    mut lgl: *mut LGL,
    mut a: libc::c_int,
    mut b: libc::c_int,
) -> libc::c_int {
    let mut blit: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut res: libc::c_int = 0 as libc::c_int;
    let mut w: *const libc::c_int = 0 as *const libc::c_int;
    let mut eow: *const libc::c_int = 0 as *const libc::c_int;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut inc: int64_t = 0;
    let mut ha: *mut HTS = 0 as *mut HTS;
    let mut hb: *mut HTS = 0 as *mut HTS;
    ha = lglhts(lgl, a);
    hb = lglhts(lgl, b);
    if (*hb).count < (*ha).count {
        let mut TMP: libc::c_int = a;
        a = b;
        b = TMP;
        let mut TMP_0: *mut HTS = ha;
        ha = hb;
        hb = TMP_0;
    }
    w = lglhts2wchs(lgl, ha);
    eow = w.offset((*ha).count as isize);
    p = w;
    while res == 0 && p < eow {
        blit = *p;
        tag = blit & MASKCS as libc::c_int;
        if !(tag == OCCS as libc::c_int) {
            if tag == TRNCS as libc::c_int || tag == LRGCS as libc::c_int {
                p = p.offset(1);
                p;
            } else {
                other = blit >> RMSHFT as libc::c_int;
                if other == b {
                    res = 1 as libc::c_int;
                }
            }
        }
        p = p.offset(1);
        p;
    }
    inc = (2 as libc::c_int + p.offset_from(w) as libc::c_long as libc::c_int)
        as int64_t;
    if !((*lgl).c2rust_unnamed.card).is_null() {
        (*(*lgl).stats).steps += inc;
        (*(*lgl).stats).card.steps += inc;
    }
    if (*lgl).simpleprobing != 0 {
        (*(*lgl).stats).steps += inc;
        (*(*lgl).stats).prb.simple.steps += inc;
    }
    return res;
}
unsafe extern "C" fn lglwrkinit(
    mut lgl: *mut LGL,
    mut posonly: libc::c_int,
    mut fifo: libc::c_int,
) {
    let mut size: libc::c_int = 0;
    let mut lit: libc::c_int = 0;
    (*lgl)
        .wrk = lglnew(
        lgl,
        (1 as libc::c_int as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Wrk>() as libc::c_ulong),
    ) as *mut Wrk;
    (*(*lgl).wrk).fifo = fifo;
    (*(*lgl).wrk).size = (*lgl).nvars;
    size = (*(*lgl).wrk).size;
    if posonly != 0 {
        (*(*lgl).wrk)
            .pos = lglnew(
            lgl,
            (size as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
        ) as *mut libc::c_int;
        (*(*lgl).wrk).posonly = 1 as libc::c_int;
    } else {
        (*(*lgl).wrk)
            .pos = lglnew(
            lgl,
            ((2 as libc::c_int * size) as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
        ) as *mut libc::c_int;
        (*(*lgl).wrk).pos = ((*(*lgl).wrk).pos).offset(size as isize);
        lit = -size + 1 as libc::c_int;
        while lit < -(1 as libc::c_int) {
            *((*(*lgl).wrk).pos).offset(lit as isize) = -(1 as libc::c_int);
            lit += 1;
            lit;
        }
    }
    lit = 2 as libc::c_int;
    while lit < size {
        *((*(*lgl).wrk).pos).offset(lit as isize) = -(1 as libc::c_int);
        lit += 1;
        lit;
    }
}
unsafe extern "C" fn lglwrkreset(mut lgl: *mut LGL) {
    lglrelstk(lgl, &mut (*(*lgl).wrk).queue);
    if (*(*lgl).wrk).posonly != 0 {
        lgldel(
            lgl,
            (*(*lgl).wrk).pos as *mut libc::c_void,
            ((*(*lgl).wrk).size as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
        );
        (*(*lgl).wrk).pos = 0 as *mut libc::c_int;
    } else {
        (*(*lgl).wrk).pos = ((*(*lgl).wrk).pos).offset(-((*(*lgl).wrk).size as isize));
        lgldel(
            lgl,
            (*(*lgl).wrk).pos as *mut libc::c_void,
            ((2 as libc::c_int * (*(*lgl).wrk).size) as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
        );
        (*(*lgl).wrk).pos = 0 as *mut libc::c_int;
    }
    lgldel(
        lgl,
        (*lgl).wrk as *mut libc::c_void,
        (1 as libc::c_int as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Wrk>() as libc::c_ulong),
    );
    (*lgl).wrk = 0 as *mut Wrk;
}
unsafe extern "C" fn lglwrkcompact(mut lgl: *mut LGL) {
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0 as libc::c_int;
    let mut lit: libc::c_int = 0;
    let mut tail: libc::c_int = lglcntstk(&mut (*(*lgl).wrk).queue) as libc::c_int;
    i = (*(*lgl).wrk).head;
    while i < tail {
        lit = *((*(*lgl).wrk).queue.start).offset(i as isize);
        if !(lit == 0) {
            if lglisfree(lgl, lit) == 0 {
                *((*(*lgl).wrk).pos).offset(lit as isize) = -(1 as libc::c_int);
                (*(*lgl).wrk).count -= 1;
                (*(*lgl).wrk).count;
            } else {
                *((*(*lgl).wrk).queue.start).offset(j as isize) = lit;
                let fresh144 = j;
                j = j + 1;
                *((*(*lgl).wrk).pos).offset(lit as isize) = fresh144;
            }
        }
        i += 1;
        i;
    }
    lglrststk(&mut (*(*lgl).wrk).queue, j);
    (*(*lgl).wrk).head = 0 as libc::c_int;
}
unsafe extern "C" fn lglwrktouched(
    mut lgl: *mut LGL,
    mut lit: libc::c_int,
) -> libc::c_int {
    if (*(*lgl).wrk).posonly != 0 {
        lit = abs(lit);
    }
    return (*((*(*lgl).wrk).pos).offset(lit as isize) >= 0 as libc::c_int)
        as libc::c_int;
}
unsafe extern "C" fn lglwrktouch(
    mut lgl: *mut LGL,
    mut lit: libc::c_int,
) -> libc::c_int {
    let mut tail: libc::c_int = 0;
    let mut pos: libc::c_int = 0;
    if lglisfree(lgl, lit) == 0 {
        return 1 as libc::c_int;
    }
    if (*lgl).donotsched != 0 {
        if (*lgl).ternresing as libc::c_int != 0
            && (*lglavar(lgl, lit)).donoternres() as libc::c_int != 0
        {
            return 1 as libc::c_int;
        }
        if (*lgl).simpleprobing as libc::c_int != 0
            && (*lglavar(lgl, lit)).donotsimpleprobe() as libc::c_int != 0
        {
            return 1 as libc::c_int;
        }
    }
    if (*(*lgl).wrk).posonly != 0 {
        lit = abs(lit);
    }
    tail = lglcntstk(&mut (*(*lgl).wrk).queue) as libc::c_int;
    pos = *((*(*lgl).wrk).pos).offset(lit as isize);
    if pos >= 0 as libc::c_int {
        *((*(*lgl).wrk).queue.start).offset(pos as isize) = 0 as libc::c_int;
    }
    (*(*lgl).wrk).count += 1;
    (*(*lgl).wrk).count;
    *((*(*lgl).wrk).pos).offset(lit as isize) = tail;
    lglpushstk(lgl, &mut (*(*lgl).wrk).queue, lit);
    if tail / 2 as libc::c_int > (*(*lgl).wrk).count {
        lglwrkcompact(lgl);
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn lglwrkdeq(mut lgl: *mut LGL) -> libc::c_int {
    let mut res: libc::c_int = 0;
    let mut pos: libc::c_int = 0;
    loop {
        pos = (*(*lgl).wrk).head;
        if !(pos < lglcntstk(&mut (*(*lgl).wrk).queue) as libc::c_int) {
            break;
        }
        (*(*lgl).wrk).head += 1;
        (*(*lgl).wrk).head;
        res = *((*(*lgl).wrk).queue.start).offset(pos as isize);
        if res == 0 {
            continue;
        }
        *((*(*lgl).wrk).queue.start).offset(pos as isize) = 0 as libc::c_int;
        (*(*lgl).wrk).count -= 1;
        (*(*lgl).wrk).count;
        *((*(*lgl).wrk).pos).offset(res as isize) = -(1 as libc::c_int);
        if lglisfree(lgl, res) != 0 {
            return res;
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn lglwrkpop(mut lgl: *mut LGL) -> libc::c_int {
    let mut res: libc::c_int = 0;
    while lglcntstk(&mut (*(*lgl).wrk).queue) as libc::c_int > (*(*lgl).wrk).head {
        res = lglpopstk(&mut (*(*lgl).wrk).queue);
        if res == 0 {
            continue;
        }
        *((*(*lgl).wrk).pos).offset(res as isize) = -(1 as libc::c_int);
        if lglisfree(lgl, res) != 0 {
            return res;
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn lglwrknext(mut lgl: *mut LGL) -> libc::c_int {
    return if (*(*lgl).wrk).fifo != 0 { lglwrkdeq(lgl) } else { lglwrkpop(lgl) };
}
unsafe extern "C" fn lglrandlitrav(
    mut lgl: *mut LGL,
    mut fun: Option::<unsafe extern "C" fn(*mut LGL, libc::c_int) -> libc::c_int>,
) -> libc::c_int {
    let mut delta: libc::c_int = 0;
    let mut mod_0: libc::c_int = 0;
    let mut prev: libc::c_int = 0;
    let mut first: libc::c_int = 0;
    let mut ulit: libc::c_int = 0;
    let mut count: libc::c_int = 0;
    if (*lgl).nvars < 2 as libc::c_int {
        return 0 as libc::c_int;
    }
    mod_0 = 2 as libc::c_int * (*lgl).nvars;
    first = mod_0;
    ulit = (lglrand(lgl)).wrapping_rem(mod_0 as libc::c_uint) as libc::c_int;
    delta = (lglrand(lgl)).wrapping_rem(mod_0 as libc::c_uint) as libc::c_int;
    if delta == 0 {
        delta += 1;
        delta;
    }
    while lglgcd(delta as libc::c_uint, mod_0 as libc::c_uint)
        > 1 as libc::c_int as libc::c_uint
    {
        delta += 1;
        if delta == mod_0 {
            delta = 1 as libc::c_int;
        }
    }
    count = mod_0;
    loop {
        count -= 1;
        count;
        if ulit >= 4 as libc::c_int
            && fun.expect("non-null function pointer")(lgl, lglilit(ulit)) == 0
        {
            return 0 as libc::c_int;
        }
        prev = ulit;
        ulit += delta;
        if ulit >= mod_0 {
            ulit -= mod_0;
        }
        if ulit == first {
            break;
        }
        if first == mod_0 {
            first = prev;
        }
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn lglsimpleprobeinit(mut lgl: *mut LGL) {
    let mut idx: libc::c_int = 0;
    let mut rem: libc::c_int = 0 as libc::c_int;
    let mut ret: libc::c_int = 0 as libc::c_int;
    idx = 2 as libc::c_int;
    while idx < (*lgl).nvars {
        let ref mut fresh145 = *((*lgl).avars).offset(idx as isize);
        (*fresh145).set_equiv(0 as libc::c_int as libc::c_uint);
        idx += 1;
        idx;
    }
    idx = 2 as libc::c_int;
    while idx < (*lgl).nvars {
        if !(lglisfree(lgl, idx) == 0) {
            if (*lglavar(lgl, idx)).donotsimpleprobe() != 0 {
                ret += 1;
                ret;
            } else {
                rem += 1;
                rem;
            }
        }
        idx += 1;
        idx;
    }
    if rem == 0 {
        ret = 0 as libc::c_int;
        idx = 2 as libc::c_int;
        while idx < (*lgl).nvars {
            if !(lglisfree(lgl, idx) == 0) {
                let ref mut fresh146 = *lglavar(lgl, idx);
                (*fresh146).set_donotsimpleprobe(0 as libc::c_int as libc::c_uint);
                rem += 1;
                rem;
            }
            idx += 1;
            idx;
        }
    }
    if ret == 0 {
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[simpleprobe-%d] all %d free variables schedulable\0" as *const u8
                as *const libc::c_char,
            (*(*lgl).stats).prb.simple.count,
            rem,
        );
    } else {
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[simpleprobe-%d] %d schedulable variables %.0f%%\0" as *const u8
                as *const libc::c_char,
            (*(*lgl).stats).prb.simple.count,
            rem,
            lglpcnt(rem as libc::c_double, lglrem(lgl) as libc::c_double),
        );
    }
    lglwrkinit(lgl, 0 as libc::c_int, 1 as libc::c_int);
    (*lgl).donotsched = 1 as libc::c_int as libc::c_char;
    lglrandlitrav(
        lgl,
        Some(lglwrktouch as unsafe extern "C" fn(*mut LGL, libc::c_int) -> libc::c_int),
    );
    (*lgl).donotsched = 0 as libc::c_int as libc::c_char;
    lglchkirrstats(lgl);
}
unsafe extern "C" fn lglsimpleprobereset(mut lgl: *mut LGL, mut nvars: libc::c_int) {
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut idx: libc::c_int = 0;
    lglrelstk(lgl, &mut (*(*lgl).c2rust_unnamed.sprb).units);
    lglrelstk(lgl, &mut (*(*lgl).c2rust_unnamed.sprb).impls);
    lglrelstk(lgl, &mut (*(*lgl).c2rust_unnamed.sprb).eqs);
    idx = 2 as libc::c_int;
    while idx < (*lgl).nvars {
        let ref mut fresh147 = *((*lgl).avars).offset(idx as isize);
        (*fresh147).set_donotsimpleprobe(1 as libc::c_int as libc::c_uint);
        idx += 1;
        idx;
    }
    p = (*(*lgl).wrk).queue.start;
    while p < (*(*lgl).wrk).queue.top as *const libc::c_int {
        let ref mut fresh148 = *((*lgl).avars).offset(abs(*p) as isize);
        (*fresh148).set_donotsimpleprobe(0 as libc::c_int as libc::c_uint);
        p = p.offset(1);
        p;
    }
    lglwrkreset(lgl);
    lglrelstk(lgl, &mut (*(*lgl).c2rust_unnamed.sprb).counted);
    lglrelstk(lgl, &mut (*(*lgl).c2rust_unnamed.sprb).marked);
    (*(*lgl).c2rust_unnamed.sprb)
        .spes = ((*(*lgl).c2rust_unnamed.sprb).spes).offset(-(nvars as isize));
    lgldel(
        lgl,
        (*(*lgl).c2rust_unnamed.sprb).spes as *mut libc::c_void,
        ((2 as libc::c_int * nvars) as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<SPE>() as libc::c_ulong),
    );
    (*(*lgl).c2rust_unnamed.sprb).spes = 0 as *mut SPE;
}
unsafe extern "C" fn lglsimpleprobeunits(mut lgl: *mut LGL) -> libc::c_int {
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut lit: libc::c_int = 0;
    let mut res: libc::c_int = 0;
    let mut val: Val = 0;
    res = 0 as libc::c_int;
    lglchkirrstats(lgl);
    p = (*(*lgl).c2rust_unnamed.sprb).units.start;
    while (*lgl).mt == 0
        && p < (*(*lgl).c2rust_unnamed.sprb).units.top as *const libc::c_int
    {
        lit = *p;
        val = lglval(lgl, lit);
        if !(val as libc::c_int > 0 as libc::c_int) {
            (*(*lgl).stats).prb.simple.failed += 1;
            (*(*lgl).stats).prb.simple.failed;
            if (val as libc::c_int) < 0 as libc::c_int {
                lgldrupligaddclsarg(lgl, REDCS as libc::c_int, lit, 0 as libc::c_int);
                lglmt(lgl);
            } else {
                lglunit(lgl, lit);
                res += 1;
                res;
                if lglflush(lgl) == 0 {
                    lglmt(lgl);
                }
            }
        }
        p = p.offset(1);
        p;
    }
    return res;
}
unsafe extern "C" fn lglsimpleprobeimpls(mut lgl: *mut LGL) -> libc::c_int {
    let mut a: libc::c_int = 0;
    let mut b: libc::c_int = 0;
    let mut res: libc::c_int = 0;
    res = 0 as libc::c_int;
    while lglmtstk(&mut (*(*lgl).c2rust_unnamed.sprb).impls) == 0 {
        b = lglpopstk(&mut (*(*lgl).c2rust_unnamed.sprb).impls);
        a = lglpopstk(&mut (*(*lgl).c2rust_unnamed.sprb).impls);
        if lglval(lgl, a) as libc::c_int != 0 || lglval(lgl, b) as libc::c_int != 0 {
            continue;
        }
        if lglhasbin(lgl, a, b) != 0 {
            continue;
        }
        lgldrupligaddclsarg(lgl, REDCS as libc::c_int, a, b, 0 as libc::c_int);
        res += 1;
        res;
        (*(*lgl).stats).hbr.cnt += 1;
        (*(*lgl).stats).hbr.cnt;
        (*(*lgl).stats).hbr.simple += 1;
        (*(*lgl).stats).hbr.simple;
        lglwchbin(lgl, a, b, REDCS as libc::c_int);
        lglwchbin(lgl, b, a, REDCS as libc::c_int);
        (*(*lgl).stats).red.bin += 1;
        (*(*lgl).stats).red.bin;
        lglwrktouch(lgl, -a);
        lglwrktouch(lgl, -b);
        if lglhasbin(lgl, -a, -b) == 0 {
            continue;
        }
        lglpushstk(lgl, &mut (*(*lgl).c2rust_unnamed.sprb).eqs, -a);
        lglpushstk(lgl, &mut (*(*lgl).c2rust_unnamed.sprb).eqs, b);
    }
    return res;
}
unsafe extern "C" fn lglhasonlybin(
    mut lgl: *mut LGL,
    mut lit: libc::c_int,
    mut other: libc::c_int,
) -> libc::c_int {
    let mut hts: *mut HTS = lglhts(lgl, lit);
    let mut w: *const libc::c_int = 0 as *const libc::c_int;
    let mut blit: libc::c_int = 0;
    if (*hts).count != 1 as libc::c_int as libc::c_uint {
        return 0 as libc::c_int;
    }
    w = lglhts2wchs(lgl, hts);
    blit = *w;
    if blit & MASKCS as libc::c_int != BINCS as libc::c_int {
        return 0 as libc::c_int;
    }
    return (blit >> RMSHFT as libc::c_int == other) as libc::c_int;
}
unsafe extern "C" fn lglsimpleprobemerged(
    mut lgl: *mut LGL,
    mut a: libc::c_int,
    mut b: libc::c_int,
) -> libc::c_int {
    return (lglhasonlybin(lgl, -a, b) != 0 && lglhasonlybin(lgl, -b, a) != 0)
        as libc::c_int;
}
unsafe extern "C" fn lglsimpleprobeclscp(
    mut lgl: *mut LGL,
    mut nonrepr: libc::c_int,
    mut repr: libc::c_int,
    mut stk: *mut Stk,
) {
    let mut blit: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut red: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut other2: libc::c_int = 0;
    let mut lidx: libc::c_int = 0;
    let mut count: libc::c_int = 0;
    let mut found: libc::c_int = 0;
    let mut start: libc::c_int = 0;
    let mut trivial: libc::c_int = 0;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut w: *const libc::c_int = 0 as *const libc::c_int;
    let mut eow: *const libc::c_int = 0 as *const libc::c_int;
    let mut c: *const libc::c_int = 0 as *const libc::c_int;
    let mut q: *const libc::c_int = 0 as *const libc::c_int;
    let mut hts: *mut HTS = lglhts(lgl, nonrepr);
    w = lglhts2wchs(lgl, hts);
    eow = w.offset((*hts).count as isize);
    count = 0 as libc::c_int;
    p = w;
    while p < eow {
        (*(*lgl).stats).steps += 1;
        (*(*lgl).stats).steps;
        (*(*lgl).stats).prb.simple.steps += 1;
        (*(*lgl).stats).prb.simple.steps;
        blit = *p;
        tag = blit & MASKCS as libc::c_int;
        if tag == TRNCS as libc::c_int || tag == LRGCS as libc::c_int {
            p = p.offset(1);
            p;
        }
        if !(tag == LRGCS as libc::c_int) {
            start = lglcntstk(stk) as libc::c_int;
            trivial = 0 as libc::c_int;
            red = blit & REDCS as libc::c_int;
            lglpushstk(lgl, stk, red);
            lglpushstk(lgl, stk, repr);
            if tag == BINCS as libc::c_int || tag == TRNCS as libc::c_int {
                other = blit >> RMSHFT as libc::c_int;
                if other == -repr {
                    trivial = 1 as libc::c_int;
                } else if other != repr {
                    lglpushstk(lgl, stk, other);
                }
                if tag == TRNCS as libc::c_int {
                    other2 = *p;
                    if other2 == -repr {
                        trivial = 1 as libc::c_int;
                    } else if other2 != repr {
                        lglpushstk(lgl, stk, other2);
                    }
                }
            } else {
                lidx = blit >> RMSHFT as libc::c_int;
                c = lglidx2lits(lgl, red, lidx);
                found = 0 as libc::c_int;
                q = c;
                while trivial == 0
                    && {
                        other = *q;
                        other != 0
                    }
                {
                    if other >= 2147483647 as libc::c_int >> RMSHFT as libc::c_int {
                        trivial = 1 as libc::c_int;
                    } else if other == nonrepr {
                        found += 1;
                        found;
                    } else if other == -repr {
                        trivial = 1 as libc::c_int;
                    } else if other != repr {
                        lglpushstk(lgl, stk, other);
                    }
                    q = q.offset(1);
                    q;
                }
            }
            if trivial != 0 {
                lglrststk(stk, start);
            } else {
                lglpushstk(lgl, stk, 0 as libc::c_int);
                count += 1;
                count;
            }
        }
        p = p.offset(1);
        p;
    }
}
unsafe extern "C" fn lglsimpleprobebinexists(
    mut lgl: *mut LGL,
    mut a: libc::c_int,
    mut b: libc::c_int,
) -> libc::c_int {
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut w: *const libc::c_int = 0 as *const libc::c_int;
    let mut eow: *const libc::c_int = 0 as *const libc::c_int;
    let mut blit: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut red: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut hts: *mut HTS = 0 as *mut HTS;
    hts = lglhts(lgl, a);
    w = lglhts2wchs(lgl, hts);
    eow = w.offset((*hts).count as isize);
    p = w;
    while p < eow {
        blit = *p;
        tag = blit & MASKCS as libc::c_int;
        if tag == TRNCS as libc::c_int || tag == LRGCS as libc::c_int {
            p = p.offset(1);
            p;
        }
        if !(tag != BINCS as libc::c_int) {
            red = blit & REDCS as libc::c_int;
            if !(red != 0) {
                other = blit >> RMSHFT as libc::c_int;
                if other == b {
                    return 1 as libc::c_int;
                }
            }
        }
        p = p.offset(1);
        p;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn lglsimpleprobetrnexists(
    mut lgl: *mut LGL,
    mut a: libc::c_int,
    mut b: libc::c_int,
    mut c: libc::c_int,
) -> libc::c_int {
    let mut blit: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut red: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut other2: libc::c_int = 0;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut w: *const libc::c_int = 0 as *const libc::c_int;
    let mut eow: *const libc::c_int = 0 as *const libc::c_int;
    let mut hts: *mut HTS = 0 as *mut HTS;
    hts = lglhts(lgl, a);
    w = lglhts2wchs(lgl, hts);
    eow = w.offset((*hts).count as isize);
    p = w;
    while p < eow {
        blit = *p;
        tag = blit & MASKCS as libc::c_int;
        if tag == TRNCS as libc::c_int || tag == LRGCS as libc::c_int {
            p = p.offset(1);
            p;
        }
        red = blit & REDCS as libc::c_int;
        if !(red != 0) {
            other = blit >> RMSHFT as libc::c_int;
            if tag == BINCS as libc::c_int {
                if other == b {
                    return 1 as libc::c_int;
                }
                if other == c {
                    return 1 as libc::c_int;
                }
            } else if tag == TRNCS as libc::c_int {
                other2 = *p;
                if other == b && other2 == c {
                    return 1 as libc::c_int;
                }
                if other == c && other2 == b {
                    return 1 as libc::c_int;
                }
            }
        }
        p = p.offset(1);
        p;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn lglsimpleprobelrgexists(
    mut lgl: *mut LGL,
    mut a: libc::c_int,
) -> libc::c_int {
    let mut blit: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut red: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut other2: libc::c_int = 0;
    let mut lidx: libc::c_int = 0;
    let mut res: libc::c_int = 0;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut w: *const libc::c_int = 0 as *const libc::c_int;
    let mut eow: *const libc::c_int = 0 as *const libc::c_int;
    let mut c: *const libc::c_int = 0 as *const libc::c_int;
    let mut q: *const libc::c_int = 0 as *const libc::c_int;
    let mut hts: *mut HTS = 0 as *mut HTS;
    p = (*lgl).clause.start;
    while p.offset(1 as libc::c_int as isize) < (*lgl).clause.top as *const libc::c_int {
        other = *p;
        lglsignedmark(lgl, other);
        p = p.offset(1);
        p;
    }
    hts = lglhts(lgl, a);
    w = lglhts2wchs(lgl, hts);
    eow = w.offset((*hts).count as isize);
    res = 0 as libc::c_int;
    p = w;
    while res == 0 && p < eow {
        blit = *p;
        tag = blit & MASKCS as libc::c_int;
        if tag == TRNCS as libc::c_int || tag == LRGCS as libc::c_int {
            p = p.offset(1);
            p;
        }
        red = blit & REDCS as libc::c_int;
        if !(red != 0 || tag == LRGCS as libc::c_int) {
            other = blit >> RMSHFT as libc::c_int;
            if tag == BINCS as libc::c_int {
                res = lglsignedmarked(lgl, other);
            } else if tag == TRNCS as libc::c_int {
                other2 = *p;
                res = (lglsignedmarked(lgl, other) != 0
                    && lglsignedmarked(lgl, other2) != 0) as libc::c_int;
            } else {
                lidx = other;
                c = lglidx2lits(lgl, 0 as libc::c_int, lidx);
                q = c;
                loop {
                    other = *q;
                    if !(other != 0) {
                        break;
                    }
                    if lglsignedmarked(lgl, other) == 0 {
                        break;
                    }
                    q = q.offset(1);
                    q;
                }
                res = (other == 0) as libc::c_int;
            }
        }
        p = p.offset(1);
        p;
    }
    p = (*lgl).clause.start;
    while p.offset(1 as libc::c_int as isize) < (*lgl).clause.top as *const libc::c_int {
        lglunmark(lgl, *p);
        p = p.offset(1);
        p;
    }
    return res;
}
unsafe extern "C" fn lglsimpleprobeclausexists(mut lgl: *mut LGL) -> libc::c_int {
    let mut len: libc::c_int = (lglcntstk(&mut (*lgl).clause))
        .wrapping_sub(1 as libc::c_int as size_t) as libc::c_int;
    let mut a: libc::c_int = 0;
    let mut b: libc::c_int = 0;
    let mut c: libc::c_int = 0;
    let mut p: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut s: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut res: libc::c_int = 0;
    s = (*lgl).clause.start;
    p = s.offset(1 as libc::c_int as isize);
    while p.offset(1 as libc::c_int as isize) < (*lgl).clause.top {
        if (*lglhts(lgl, *s)).count > (*lglhts(lgl, *p)).count {
            let mut TMP: libc::c_int = *s;
            *s = *p;
            *p = TMP;
        }
        p = p.offset(1);
        p;
    }
    a = *((*lgl).clause.start).offset(0 as libc::c_int as isize);
    if len == 2 as libc::c_int {
        b = *((*lgl).clause.start).offset(1 as libc::c_int as isize);
        res = lglsimpleprobebinexists(lgl, a, b);
    } else if len == 3 as libc::c_int {
        b = *((*lgl).clause.start).offset(1 as libc::c_int as isize);
        c = *((*lgl).clause.start).offset(2 as libc::c_int as isize);
        res = lglsimpleprobetrnexists(lgl, a, b, c);
    } else if len > 3 as libc::c_int {
        res = lglsimpleprobelrgexists(lgl, a);
    } else {
        res = 0 as libc::c_int;
    }
    res != 0;
    return res;
}
unsafe extern "C" fn lglsimpleprobeaddclausesonstack(
    mut lgl: *mut LGL,
    mut stk: *mut Stk,
) {
    let mut count: libc::c_int = 0;
    let mut red: libc::c_int = 0;
    let mut lit: libc::c_int = 0;
    let mut size: libc::c_int = 0;
    let mut c: *const libc::c_int = 0 as *const libc::c_int;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut q: *const libc::c_int = 0 as *const libc::c_int;
    count = 0 as libc::c_int;
    c = (*stk).start;
    while c < (*stk).top as *const libc::c_int {
        p = c;
        red = *p;
        if *p.offset(1 as libc::c_int as isize) == 2147483647 as libc::c_int {
            p = p.offset(1);
            p;
            while p.offset(1 as libc::c_int as isize) < (*stk).top as *const libc::c_int
                && *p.offset(1 as libc::c_int as isize) == 2147483647 as libc::c_int
            {
                p = p.offset(1);
                p;
            }
        } else {
            loop {
                p = p.offset(1);
                lit = *p;
                lglpushstk(lgl, &mut (*lgl).clause, lit);
                if !(lit != 0) {
                    break;
                }
            }
            if lglisimpcls(lgl) == 0 && lglsimpleprobeclausexists(lgl) == 0 {
                lgldrupligaddcls(lgl, REDCS as libc::c_int);
                q = (*lgl).clause.start;
                size = lglcntstk(&mut (*lgl).clause) as libc::c_int;
                size -= 1;
                size;
                if size > 2 as libc::c_int
                    && (*(*lgl).opts).prbsimple.val >= 3 as libc::c_int
                {
                    loop {
                        let fresh149 = q;
                        q = q.offset(1);
                        lit = *fresh149;
                        if !(lit != 0) {
                            break;
                        }
                        lglwrktouch(lgl, lit);
                    }
                }
                if size == 2 as libc::c_int
                    && (*(*lgl).opts).prbsimple.val >= 2 as libc::c_int
                {
                    lglwrktouch(lgl, -*q.offset(0 as libc::c_int as isize));
                    lglwrktouch(lgl, -*q.offset(1 as libc::c_int as isize));
                }
                lgladdcls(lgl, red, 0 as libc::c_int, 1 as libc::c_int);
                count += 1;
                count;
            }
            lglclnstk(&mut (*lgl).clause);
            if lglflush(lgl) == 0 {
                break;
            }
        }
        c = p.offset(1 as libc::c_int as isize);
    }
}
unsafe extern "C" fn lglsimpleprobeaddprbincls(
    mut lgl: *mut LGL,
    mut a: libc::c_int,
    mut b: libc::c_int,
) {
    lglpushstk(lgl, &mut (*lgl).clause, a);
    lglpushstk(lgl, &mut (*lgl).clause, b);
    lglpushstk(lgl, &mut (*lgl).clause, 0 as libc::c_int);
    if lglsimpleprobeclausexists(lgl) == 0 {
        lgldrupligaddcls(lgl, REDCS as libc::c_int);
        lgladdcls(lgl, 0 as libc::c_int, 0 as libc::c_int, 1 as libc::c_int);
    }
    lglclnstk(&mut (*lgl).clause);
}
unsafe extern "C" fn lglcmpilit(
    mut a: *mut libc::c_int,
    mut b: *mut libc::c_int,
) -> libc::c_int {
    let mut res: libc::c_int = 0;
    let mut l: libc::c_int = *a;
    let mut k: libc::c_int = *b;
    res = abs(l) - abs(k);
    if res != 0 {
        return res;
    }
    return l - k;
}
unsafe extern "C" fn lglcmpcls(
    mut lgl: *mut LGL,
    mut c: *const libc::c_int,
    mut d: *const libc::c_int,
) -> libc::c_int {
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut q: *const libc::c_int = 0 as *const libc::c_int;
    if *c >= 2147483647 as libc::c_int && *d >= 2147483647 as libc::c_int {
        return c.offset_from(d) as libc::c_long as libc::c_int;
    }
    if *c >= 2147483647 as libc::c_int {
        return 1 as libc::c_int;
    }
    if *d >= 2147483647 as libc::c_int {
        return -(1 as libc::c_int);
    }
    p = c;
    q = d;
    while *p != 0 && *q == *p {
        p = p.offset(1);
        p;
        q = q.offset(1);
        q;
    }
    return *p - *q;
}
unsafe extern "C" fn lglcmpsz(
    mut lgl: *mut LGL,
    mut start: *const libc::c_int,
    mut p: *mut PSz,
    mut q: *mut PSz,
) -> libc::c_int {
    let mut c: *const libc::c_int = 0 as *const libc::c_int;
    let mut d: *const libc::c_int = 0 as *const libc::c_int;
    let mut res: libc::c_int = 0;
    res = (*p).size - (*q).size;
    if res != 0 {
        return res;
    }
    c = start.offset((*p).pos as isize);
    d = start.offset((*q).pos as isize);
    res = lglcmpcls(lgl, c, d);
    if res != 0 {
        return res;
    }
    res = *c.offset(-(1 as libc::c_int) as isize)
        - *d.offset(-(1 as libc::c_int) as isize);
    if res != 0 {
        return res;
    }
    return (*p).pos - (*q).pos;
}
unsafe extern "C" fn lglrmdupclsonstack(
    mut lgl: *mut LGL,
    mut stk: *mut Stk,
    mut sort: *mut Stk,
) {
    let mut start: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut c: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut p: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut d: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut pos: libc::c_int = 0;
    let mut size: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut ps: *mut PSz = 0 as *mut PSz;
    lglclnstk(sort);
    start = (*stk).start;
    c = start;
    while c < (*stk).top {
        c = c.offset(1);
        c;
        pos = c.offset_from(start) as libc::c_long as libc::c_int;
        size = 0 as libc::c_int;
        p = c;
        while *p != 0 {
            size += 1;
            size;
            p = p.offset(1);
            p;
        }
        let mut AA: *mut libc::c_int = c;
        let NN: libc::c_int = size;
        let mut L: libc::c_int = 0 as libc::c_int;
        let mut R: libc::c_int = NN - 1 as libc::c_int;
        let mut M: libc::c_int = 0;
        let mut LL: libc::c_int = 0;
        let mut RR: libc::c_int = 0;
        let mut I: libc::c_int = 0;
        if !(R - L <= 10 as libc::c_int) {
            loop {
                M = (L + R) / 2 as libc::c_int;
                let mut TMP: libc::c_int = *AA.offset(M as isize);
                *AA.offset(M as isize) = *AA.offset((R - 1 as libc::c_int) as isize);
                *AA.offset((R - 1 as libc::c_int) as isize) = TMP;
                if lglcmpilit(
                    &mut *AA.offset(L as isize),
                    &mut *AA.offset((R - 1 as libc::c_int) as isize),
                ) > 0 as libc::c_int
                {
                    let mut TMP_0: libc::c_int = *AA.offset(L as isize);
                    *AA.offset(L as isize) = *AA.offset((R - 1 as libc::c_int) as isize);
                    *AA.offset((R - 1 as libc::c_int) as isize) = TMP_0;
                }
                if lglcmpilit(&mut *AA.offset(L as isize), &mut *AA.offset(R as isize))
                    > 0 as libc::c_int
                {
                    let mut TMP_1: libc::c_int = *AA.offset(L as isize);
                    *AA.offset(L as isize) = *AA.offset(R as isize);
                    *AA.offset(R as isize) = TMP_1;
                }
                if lglcmpilit(
                    &mut *AA.offset((R - 1 as libc::c_int) as isize),
                    &mut *AA.offset(R as isize),
                ) > 0 as libc::c_int
                {
                    let mut TMP_2: libc::c_int = *AA
                        .offset((R - 1 as libc::c_int) as isize);
                    *AA.offset((R - 1 as libc::c_int) as isize) = *AA.offset(R as isize);
                    *AA.offset(R as isize) = TMP_2;
                }
                let mut PIVOT: libc::c_int = 0;
                let mut J: libc::c_int = R - 1 as libc::c_int;
                I = L + 1 as libc::c_int - 1 as libc::c_int;
                PIVOT = *AA.offset(J as isize);
                loop {
                    loop {
                        I += 1;
                        if !(lglcmpilit(&mut *AA.offset(I as isize), &mut PIVOT)
                            < 0 as libc::c_int)
                        {
                            break;
                        }
                    }
                    loop {
                        J -= 1;
                        if !(lglcmpilit(&mut PIVOT, &mut *AA.offset(J as isize))
                            < 0 as libc::c_int)
                        {
                            break;
                        }
                        if J == L + 1 as libc::c_int {
                            break;
                        }
                    }
                    if I >= J {
                        break;
                    }
                    let mut TMP_3: libc::c_int = *AA.offset(I as isize);
                    *AA.offset(I as isize) = *AA.offset(J as isize);
                    *AA.offset(J as isize) = TMP_3;
                }
                let mut TMP_4: libc::c_int = *AA.offset(I as isize);
                *AA.offset(I as isize) = *AA.offset((R - 1 as libc::c_int) as isize);
                *AA.offset((R - 1 as libc::c_int) as isize) = TMP_4;
                if I - L < R - I {
                    LL = I + 1 as libc::c_int;
                    RR = R;
                    R = I - 1 as libc::c_int;
                } else {
                    LL = L;
                    RR = I - 1 as libc::c_int;
                    L = I + 1 as libc::c_int;
                }
                if R - L > 10 as libc::c_int {
                    lglpushstk(lgl, &mut (*lgl).c2rust_unnamed_0.sortstk, LL);
                    lglpushstk(lgl, &mut (*lgl).c2rust_unnamed_0.sortstk, RR);
                } else if RR - LL > 10 as libc::c_int {
                    L = LL;
                    R = RR;
                } else {
                    if !(lglmtstk(&mut (*lgl).c2rust_unnamed_0.sortstk) == 0) {
                        break;
                    }
                    R = lglpopstk(&mut (*lgl).c2rust_unnamed_0.sortstk);
                    L = lglpopstk(&mut (*lgl).c2rust_unnamed_0.sortstk);
                }
            }
        }
        let mut PIVOT_0: libc::c_int = 0;
        let mut L_0: libc::c_int = 0 as libc::c_int;
        let mut R_0: libc::c_int = NN - 1 as libc::c_int;
        let mut I_0: libc::c_int = 0;
        let mut J_0: libc::c_int = 0;
        I_0 = R_0;
        while I_0 > L_0 {
            if lglcmpilit(
                &mut *AA.offset((I_0 - 1 as libc::c_int) as isize),
                &mut *AA.offset(I_0 as isize),
            ) > 0 as libc::c_int
            {
                let mut TMP_5: libc::c_int = *AA
                    .offset((I_0 - 1 as libc::c_int) as isize);
                *AA.offset((I_0 - 1 as libc::c_int) as isize) = *AA.offset(I_0 as isize);
                *AA.offset(I_0 as isize) = TMP_5;
            }
            I_0 -= 1;
            I_0;
        }
        I_0 = L_0 + 2 as libc::c_int;
        while I_0 <= R_0 {
            J_0 = I_0;
            PIVOT_0 = *AA.offset(I_0 as isize);
            while lglcmpilit(
                &mut PIVOT_0,
                &mut *AA.offset((J_0 - 1 as libc::c_int) as isize),
            ) < 0 as libc::c_int
            {
                *AA.offset(J_0 as isize) = *AA.offset((J_0 - 1 as libc::c_int) as isize);
                J_0 -= 1;
                J_0;
            }
            *AA.offset(J_0 as isize) = PIVOT_0;
            I_0 += 1;
            I_0;
        }
        lglpushstk(lgl, sort, pos);
        lglpushstk(lgl, sort, size);
        c = p.offset(1 as libc::c_int as isize);
    }
    size = (lglcntstk(sort) / 2 as libc::c_int as size_t) as libc::c_int;
    if size <= 1 as libc::c_int {
        return;
    }
    ps = (*sort).start as *mut PSz;
    let mut AA_0: *mut PSz = ps;
    let NN_0: libc::c_int = size;
    let mut L_1: libc::c_int = 0 as libc::c_int;
    let mut R_1: libc::c_int = NN_0 - 1 as libc::c_int;
    let mut M_0: libc::c_int = 0;
    let mut LL_0: libc::c_int = 0;
    let mut RR_0: libc::c_int = 0;
    let mut I_1: libc::c_int = 0;
    if !(R_1 - L_1 <= 10 as libc::c_int) {
        loop {
            M_0 = (L_1 + R_1) / 2 as libc::c_int;
            let mut TMP_6: PSz = *AA_0.offset(M_0 as isize);
            *AA_0.offset(M_0 as isize) = *AA_0.offset((R_1 - 1 as libc::c_int) as isize);
            *AA_0.offset((R_1 - 1 as libc::c_int) as isize) = TMP_6;
            if lglcmpsz(
                lgl,
                start,
                &mut *AA_0.offset(L_1 as isize),
                &mut *AA_0.offset((R_1 - 1 as libc::c_int) as isize),
            ) > 0 as libc::c_int
            {
                let mut TMP_7: PSz = *AA_0.offset(L_1 as isize);
                *AA_0
                    .offset(
                        L_1 as isize,
                    ) = *AA_0.offset((R_1 - 1 as libc::c_int) as isize);
                *AA_0.offset((R_1 - 1 as libc::c_int) as isize) = TMP_7;
            }
            if lglcmpsz(
                lgl,
                start,
                &mut *AA_0.offset(L_1 as isize),
                &mut *AA_0.offset(R_1 as isize),
            ) > 0 as libc::c_int
            {
                let mut TMP_8: PSz = *AA_0.offset(L_1 as isize);
                *AA_0.offset(L_1 as isize) = *AA_0.offset(R_1 as isize);
                *AA_0.offset(R_1 as isize) = TMP_8;
            }
            if lglcmpsz(
                lgl,
                start,
                &mut *AA_0.offset((R_1 - 1 as libc::c_int) as isize),
                &mut *AA_0.offset(R_1 as isize),
            ) > 0 as libc::c_int
            {
                let mut TMP_9: PSz = *AA_0.offset((R_1 - 1 as libc::c_int) as isize);
                *AA_0
                    .offset(
                        (R_1 - 1 as libc::c_int) as isize,
                    ) = *AA_0.offset(R_1 as isize);
                *AA_0.offset(R_1 as isize) = TMP_9;
            }
            let mut PIVOT_1: PSz = PSz { pos: 0, size: 0 };
            let mut J_1: libc::c_int = R_1 - 1 as libc::c_int;
            I_1 = L_1 + 1 as libc::c_int - 1 as libc::c_int;
            PIVOT_1 = *AA_0.offset(J_1 as isize);
            loop {
                loop {
                    I_1 += 1;
                    if !(lglcmpsz(
                        lgl,
                        start,
                        &mut *AA_0.offset(I_1 as isize),
                        &mut PIVOT_1,
                    ) < 0 as libc::c_int)
                    {
                        break;
                    }
                }
                loop {
                    J_1 -= 1;
                    if !(lglcmpsz(
                        lgl,
                        start,
                        &mut PIVOT_1,
                        &mut *AA_0.offset(J_1 as isize),
                    ) < 0 as libc::c_int)
                    {
                        break;
                    }
                    if J_1 == L_1 + 1 as libc::c_int {
                        break;
                    }
                }
                if I_1 >= J_1 {
                    break;
                }
                let mut TMP_10: PSz = *AA_0.offset(I_1 as isize);
                *AA_0.offset(I_1 as isize) = *AA_0.offset(J_1 as isize);
                *AA_0.offset(J_1 as isize) = TMP_10;
            }
            let mut TMP_11: PSz = *AA_0.offset(I_1 as isize);
            *AA_0.offset(I_1 as isize) = *AA_0.offset((R_1 - 1 as libc::c_int) as isize);
            *AA_0.offset((R_1 - 1 as libc::c_int) as isize) = TMP_11;
            if I_1 - L_1 < R_1 - I_1 {
                LL_0 = I_1 + 1 as libc::c_int;
                RR_0 = R_1;
                R_1 = I_1 - 1 as libc::c_int;
            } else {
                LL_0 = L_1;
                RR_0 = I_1 - 1 as libc::c_int;
                L_1 = I_1 + 1 as libc::c_int;
            }
            if R_1 - L_1 > 10 as libc::c_int {
                lglpushstk(lgl, &mut (*lgl).c2rust_unnamed_0.sortstk, LL_0);
                lglpushstk(lgl, &mut (*lgl).c2rust_unnamed_0.sortstk, RR_0);
            } else if RR_0 - LL_0 > 10 as libc::c_int {
                L_1 = LL_0;
                R_1 = RR_0;
            } else {
                if !(lglmtstk(&mut (*lgl).c2rust_unnamed_0.sortstk) == 0) {
                    break;
                }
                R_1 = lglpopstk(&mut (*lgl).c2rust_unnamed_0.sortstk);
                L_1 = lglpopstk(&mut (*lgl).c2rust_unnamed_0.sortstk);
            }
        }
    }
    let mut PIVOT_2: PSz = PSz { pos: 0, size: 0 };
    let mut L_2: libc::c_int = 0 as libc::c_int;
    let mut R_2: libc::c_int = NN_0 - 1 as libc::c_int;
    let mut I_2: libc::c_int = 0;
    let mut J_2: libc::c_int = 0;
    I_2 = R_2;
    while I_2 > L_2 {
        if lglcmpsz(
            lgl,
            start,
            &mut *AA_0.offset((I_2 - 1 as libc::c_int) as isize),
            &mut *AA_0.offset(I_2 as isize),
        ) > 0 as libc::c_int
        {
            let mut TMP_12: PSz = *AA_0.offset((I_2 - 1 as libc::c_int) as isize);
            *AA_0.offset((I_2 - 1 as libc::c_int) as isize) = *AA_0.offset(I_2 as isize);
            *AA_0.offset(I_2 as isize) = TMP_12;
        }
        I_2 -= 1;
        I_2;
    }
    I_2 = L_2 + 2 as libc::c_int;
    while I_2 <= R_2 {
        J_2 = I_2;
        PIVOT_2 = *AA_0.offset(I_2 as isize);
        while lglcmpsz(
            lgl,
            start,
            &mut PIVOT_2,
            &mut *AA_0.offset((J_2 - 1 as libc::c_int) as isize),
        ) < 0 as libc::c_int
        {
            *AA_0.offset(J_2 as isize) = *AA_0.offset((J_2 - 1 as libc::c_int) as isize);
            J_2 -= 1;
            J_2;
        }
        *AA_0.offset(J_2 as isize) = PIVOT_2;
        I_2 += 1;
        I_2;
    }
    i = 1 as libc::c_int;
    while i < size {
        if !((*ps.offset((i - 1 as libc::c_int) as isize)).size
            != (*ps.offset(i as isize)).size)
        {
            c = ((*stk).start)
                .offset((*ps.offset((i - 1 as libc::c_int) as isize)).pos as isize);
            d = ((*stk).start).offset((*ps.offset(i as isize)).pos as isize);
            if !(lglcmpcls(lgl, c, d) != 0) {
                while *d != 0 {
                    let fresh150 = d;
                    d = d.offset(1);
                    *fresh150 = 2147483647 as libc::c_int;
                }
                *d = 2147483647 as libc::c_int;
            }
        }
        i += 1;
        i;
    }
}
unsafe extern "C" fn lglsimpleprobemerge(
    mut lgl: *mut LGL,
    mut repr: libc::c_int,
    mut nonrepr: libc::c_int,
) {
    let druplig: libc::c_int = (*(*lgl).opts).druplig.val;
    let mut valrepr: Val = 0;
    let mut valnonrepr: Val = 0;
    let mut stk: Stk = Stk {
        start: 0 as *mut libc::c_int,
        top: 0 as *mut libc::c_int,
        end: 0 as *mut libc::c_int,
    };
    let mut sort: Stk = Stk {
        start: 0 as *mut libc::c_int,
        top: 0 as *mut libc::c_int,
        end: 0 as *mut libc::c_int,
    };
    let mut unit: libc::c_int = 0;
    lglchkirrstats(lgl);
    (*(*lgl).stats).prb.simple.eqs += 1;
    (*(*lgl).stats).prb.simple.eqs;
    let ref mut fresh151 = *lglavar(lgl, nonrepr);
    (*fresh151).set_equiv(1 as libc::c_int as libc::c_uint);
    memset(
        &mut stk as *mut Stk as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<Stk>() as libc::c_ulong,
    );
    memset(
        &mut sort as *mut Stk as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<Stk>() as libc::c_ulong,
    );
    if druplig != 0 {
        lgldrupligaddclsarg(lgl, REDCS as libc::c_int, repr, -nonrepr, 0 as libc::c_int);
        lgldrupligaddclsarg(lgl, REDCS as libc::c_int, -repr, nonrepr, 0 as libc::c_int);
    }
    lglsimpleprobeclscp(lgl, nonrepr, repr, &mut stk);
    lglsimpleprobeclscp(lgl, -nonrepr, -repr, &mut stk);
    lglrmdupclsonstack(lgl, &mut stk, &mut sort);
    lglsimpleprobeaddclausesonstack(lgl, &mut stk);
    lglrelstk(lgl, &mut sort);
    lglrelstk(lgl, &mut stk);
    lglflushclauses(lgl, nonrepr);
    lglflushclauses(lgl, -nonrepr);
    if !((*lgl).mt != 0) {
        valrepr = lglval(lgl, repr);
        valnonrepr = lglval(lgl, nonrepr);
        if !(valrepr as libc::c_int != 0
            && valnonrepr as libc::c_int == valrepr as libc::c_int)
        {
            if valrepr as libc::c_int != 0
                && valrepr as libc::c_int == -(valrepr as libc::c_int)
            {
                lglmt(lgl);
            } else {
                if valrepr as libc::c_int != 0 && valnonrepr == 0 {
                    unit = if (valrepr as libc::c_int) < 0 as libc::c_int {
                        -nonrepr
                    } else {
                        nonrepr
                    };
                } else if valrepr == 0 && valnonrepr as libc::c_int != 0 {
                    unit = if (valnonrepr as libc::c_int) < 0 as libc::c_int {
                        -repr
                    } else {
                        repr
                    };
                } else {
                    unit = 0 as libc::c_int;
                }
                if unit != 0 {
                    lglunit(lgl, unit);
                    lglflush(lgl);
                } else {
                    lglsimpleprobeaddprbincls(lgl, repr, -nonrepr);
                    lglsimpleprobeaddprbincls(lgl, -repr, nonrepr);
                }
                lglchkirrstats(lgl);
            }
        }
    }
    if druplig != 0 {
        lgldrupligdelclsarg(lgl, repr, -nonrepr, 0 as libc::c_int);
        lgldrupligdelclsarg(lgl, -repr, nonrepr, 0 as libc::c_int);
    }
}
unsafe extern "C" fn lglsimpleprobeqs(mut lgl: *mut LGL) -> libc::c_int {
    let mut a: libc::c_int = 0;
    let mut b: libc::c_int = 0;
    let mut res: libc::c_int = 0;
    res = 0 as libc::c_int;
    while (*lgl).mt == 0 && lglmtstk(&mut (*(*lgl).c2rust_unnamed.sprb).eqs) == 0 {
        a = lglpopstk(&mut (*(*lgl).c2rust_unnamed.sprb).eqs);
        b = lglpopstk(&mut (*(*lgl).c2rust_unnamed.sprb).eqs);
        if lglval(lgl, a) != 0 {
            continue;
        }
        if lglsimpleprobemerged(lgl, a, b) != 0 {
            continue;
        }
        if abs(b) < abs(a) {
            let mut TMP: libc::c_int = a;
            a = b;
            b = TMP;
        }
        lglsimpleprobemerge(lgl, a, b);
        res += 1;
        res;
    }
    return res;
}
unsafe extern "C" fn lglspe(mut lgl: *mut LGL, mut lit: libc::c_int) -> *mut SPE {
    return ((*(*lgl).c2rust_unnamed.sprb).spes).offset(lit as isize);
}
unsafe extern "C" fn lglsimpleprobehbr(
    mut lgl: *mut LGL,
    mut touched: libc::c_int,
    mut c: *const libc::c_int,
) {
    let mut current_block: u64;
    let mut blit: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut lit: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut count: libc::c_int = 0;
    let mut val: libc::c_int = 0;
    let mut maxcount: libc::c_int = 0;
    let mut rem: libc::c_int = 0;
    let mut first: libc::c_int = 0;
    let mut second: libc::c_int = 0;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut q: *const libc::c_int = 0 as *const libc::c_int;
    let mut w: *const libc::c_int = 0 as *const libc::c_int;
    let mut eow: *const libc::c_int = 0 as *const libc::c_int;
    let mut sum: libc::c_uint = 0;
    let mut tmp: libc::c_uint = 0;
    let mut spe: *mut SPE = 0 as *mut SPE;
    let mut hts: *mut HTS = 0 as *mut HTS;
    sum = 0 as libc::c_int as libc::c_uint;
    count = sum as libc::c_int;
    second = count;
    first = second;
    p = c;
    loop {
        lit = *p;
        if !(lit != 0) {
            break;
        }
        if lglwrktouched(lgl, lit) != 0 {
            return;
        }
        val = lglval(lgl, lit) as libc::c_int;
        if val > 0 as libc::c_int {
            return;
        }
        if !(val < 0 as libc::c_int) {
            if first == 0 {
                first = lit;
            } else if second == 0 {
                second = lit;
            }
            sum = sum.wrapping_add(lit as libc::c_uint);
            count += 1;
            count;
        }
        p = p.offset(1);
        p;
    }
    if count == 2 as libc::c_int {
        if lglhasbin(lgl, -first, -second) != 0 {
            lglpushstk(lgl, &mut (*(*lgl).c2rust_unnamed.sprb).eqs, -first);
            lglpushstk(lgl, &mut (*(*lgl).c2rust_unnamed.sprb).eqs, second);
            current_block = 2957701765105505278;
        } else {
            current_block = 4808432441040389987;
        }
    } else {
        current_block = 4808432441040389987;
    }
    match current_block {
        4808432441040389987 => {
            rem = count;
            maxcount = 0 as libc::c_int;
            p = c;
            's_113: loop {
                lit = *p;
                if !(lit != 0) {
                    current_block = 2520131295878969859;
                    break;
                }
                (*(*lgl).stats).steps += 1;
                (*(*lgl).stats).steps;
                let fresh152 = (*(*lgl).stats).prb.simple.steps;
                (*(*lgl).stats).prb.simple.steps = (*(*lgl).stats).prb.simple.steps + 1;
                if fresh152 >= (*(*lgl).limits).prb.steps {
                    current_block = 2957701765105505278;
                    break;
                }
                val = lglval(lgl, lit) as libc::c_int;
                if !(val != 0) {
                    hts = lglhts(lgl, -lit);
                    w = lglhts2wchs(lgl, hts);
                    eow = w.offset((*hts).count as isize);
                    q = w;
                    while q < eow {
                        (*(*lgl).stats).steps += 1;
                        (*(*lgl).stats).steps;
                        let fresh153 = (*(*lgl).stats).prb.simple.steps;
                        (*(*lgl).stats)
                            .prb
                            .simple
                            .steps = (*(*lgl).stats).prb.simple.steps + 1;
                        if fresh153 >= (*(*lgl).limits).prb.steps {
                            current_block = 2957701765105505278;
                            break 's_113;
                        }
                        blit = *q;
                        tag = blit & MASKCS as libc::c_int;
                        if tag == TRNCS as libc::c_int || tag == LRGCS as libc::c_int {
                            q = q.offset(1);
                            q;
                        }
                        if !(tag != BINCS as libc::c_int) {
                            other = blit >> RMSHFT as libc::c_int;
                            val = lglval(lgl, other) as libc::c_int;
                            if !(val != 0) {
                                spe = lglspe(lgl, other);
                                if !((*spe).mark() != 0) {
                                    if (*lglspe(lgl, -other)).mark() != 0 {
                                        lglpushstk(
                                            lgl,
                                            &mut (*(*lgl).c2rust_unnamed.sprb).units,
                                            -lit,
                                        );
                                        current_block = 2957701765105505278;
                                        break 's_113;
                                    } else {
                                        if (*spe).count() == 0 {
                                            lglpushstk(
                                                lgl,
                                                &mut (*(*lgl).c2rust_unnamed.sprb).counted,
                                                other,
                                            );
                                        }
                                        (*spe).sum = ((*spe).sum).wrapping_add(lit as libc::c_uint);
                                        (*spe).set_count((*spe).count() + 1);
                                        (*spe).count();
                                        (*spe).set_mark(1 as libc::c_int as libc::c_uint);
                                        lglpushstk(
                                            lgl,
                                            &mut (*(*lgl).c2rust_unnamed.sprb).marked,
                                            other,
                                        );
                                        if (*spe).count() > maxcount {
                                            maxcount = (*spe).count();
                                        }
                                    }
                                }
                            }
                        }
                        q = q.offset(1);
                        q;
                    }
                    while lglmtstk(&mut (*(*lgl).c2rust_unnamed.sprb).marked) == 0 {
                        other = lglpopstk(&mut (*(*lgl).c2rust_unnamed.sprb).marked);
                        spe = lglspe(lgl, other);
                        (*spe).set_mark(0 as libc::c_int as libc::c_uint);
                    }
                    rem -= 1;
                    rem;
                    if (maxcount + rem + 1 as libc::c_int) < count {
                        current_block = 2957701765105505278;
                        break;
                    }
                }
                p = p.offset(1);
                p;
            }
            match current_block {
                2957701765105505278 => {}
                _ => {
                    if !(count <= 2 as libc::c_int) {
                        q = (*(*lgl).c2rust_unnamed.sprb).counted.start;
                        while q
                            < (*(*lgl).c2rust_unnamed.sprb).counted.top
                                as *const libc::c_int
                        {
                            other = *q;
                            spe = lglspe(lgl, other);
                            if (*spe).count() == count {
                                lglpushstk(
                                    lgl,
                                    &mut (*(*lgl).c2rust_unnamed.sprb).units,
                                    other,
                                );
                            } else if (*spe).count() + 1 as libc::c_int == count {
                                tmp = sum.wrapping_sub((*spe).sum);
                                lit = tmp as libc::c_int;
                                if abs(lit) != abs(other) && lglhasbin(lgl, other, lit) == 0
                                {
                                    lglpushstk(
                                        lgl,
                                        &mut (*(*lgl).c2rust_unnamed.sprb).impls,
                                        other,
                                    );
                                    lglpushstk(
                                        lgl,
                                        &mut (*(*lgl).c2rust_unnamed.sprb).impls,
                                        lit,
                                    );
                                }
                            }
                            q = q.offset(1);
                            q;
                        }
                        p = c;
                        loop {
                            lit = *p;
                            if !(lit != 0) {
                                break;
                            }
                            if !(lglval(lgl, lit) != 0) {
                                spe = lglspe(lgl, lit);
                                if !((*spe).count() + 2 as libc::c_int != count) {
                                    tmp = sum.wrapping_sub((*spe).sum);
                                    tmp = tmp.wrapping_sub(lit as libc::c_uint);
                                    other = tmp as libc::c_int;
                                    if abs(lit) != abs(other) && lglhasbin(lgl, other, lit) == 0
                                    {
                                        lglpushstk(
                                            lgl,
                                            &mut (*(*lgl).c2rust_unnamed.sprb).impls,
                                            other,
                                        );
                                        lglpushstk(
                                            lgl,
                                            &mut (*(*lgl).c2rust_unnamed.sprb).impls,
                                            lit,
                                        );
                                    }
                                }
                            }
                            p = p.offset(1);
                            p;
                        }
                    }
                }
            }
        }
        _ => {}
    }
    while lglmtstk(&mut (*(*lgl).c2rust_unnamed.sprb).counted) == 0 {
        lit = lglpopstk(&mut (*(*lgl).c2rust_unnamed.sprb).counted);
        spe = lglspe(lgl, lit);
        memset(
            spe as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<SPE>() as libc::c_ulong,
        );
    }
    lglclnstk(&mut (*(*lgl).c2rust_unnamed.sprb).marked);
}
unsafe extern "C" fn lglpushnmarkseen(mut lgl: *mut LGL, mut lit: libc::c_int) {
    lglpushstk(lgl, &mut (*lgl).seen, lit);
    lglmarkunmarked(lgl, lit);
}
unsafe extern "C" fn lglsignedmarknpushseen(mut lgl: *mut LGL, mut lit: libc::c_int) {
    lglsignedmark(lgl, lit);
    lglpushstk(lgl, &mut (*lgl).seen, lit);
}
unsafe extern "C" fn lglsimpleliftmark(
    mut lgl: *mut LGL,
    mut root: libc::c_int,
    mut level: libc::c_int,
) {
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut w: *const libc::c_int = 0 as *const libc::c_int;
    let mut eow: *const libc::c_int = 0 as *const libc::c_int;
    let mut blit: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut hts: *mut HTS = 0 as *mut HTS;
    (*(*lgl).stats).steps += 1;
    (*(*lgl).stats).steps;
    (*(*lgl).stats).prb.simple.steps += 1;
    (*(*lgl).stats).prb.simple.steps;
    hts = lglhts(lgl, root);
    w = lglhts2wchs(lgl, hts);
    eow = w.offset((*hts).count as isize);
    p = w;
    while p < eow {
        blit = *p;
        tag = blit & MASKCS as libc::c_int;
        if tag == TRNCS as libc::c_int || tag == LRGCS as libc::c_int {
            p = p.offset(1);
            p;
        }
        if !(tag != BINCS as libc::c_int) {
            other = blit >> RMSHFT as libc::c_int;
            if !(lglsignedmarked(lgl, other) != 0) {
                lglsignedmarknpushseen(lgl, other);
                if level > 1 as libc::c_int {
                    lglsimpleliftmark(lgl, -other, level - 1 as libc::c_int);
                }
            }
        }
        p = p.offset(1);
        p;
    }
}
unsafe extern "C" fn lglsimpleliftcollect(
    mut lgl: *mut LGL,
    mut root: libc::c_int,
    mut start: libc::c_int,
    mut level: libc::c_int,
) {
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut w: *const libc::c_int = 0 as *const libc::c_int;
    let mut eow: *const libc::c_int = 0 as *const libc::c_int;
    let mut blit: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut hts: *mut HTS = 0 as *mut HTS;
    (*(*lgl).stats).steps += 1;
    (*(*lgl).stats).steps;
    (*(*lgl).stats).prb.simple.steps += 1;
    (*(*lgl).stats).prb.simple.steps;
    hts = lglhts(lgl, start);
    w = lglhts2wchs(lgl, hts);
    eow = w.offset((*hts).count as isize);
    p = w;
    while p < eow {
        blit = *p;
        tag = blit & MASKCS as libc::c_int;
        if tag == TRNCS as libc::c_int || tag == LRGCS as libc::c_int {
            p = p.offset(1);
            p;
        }
        if !(tag != BINCS as libc::c_int) {
            other = blit >> RMSHFT as libc::c_int;
            if !(other == -root) {
                if lglsignedmarked(lgl, other) != 0 {
                    lglpushstk(lgl, &mut (*(*lgl).c2rust_unnamed.sprb).units, other);
                } else if other != root && lglsignedmarked(lgl, -other) != 0 {
                    lglpushstk(lgl, &mut (*(*lgl).c2rust_unnamed.sprb).eqs, root);
                    lglpushstk(lgl, &mut (*(*lgl).c2rust_unnamed.sprb).eqs, other);
                }
                if level > 1 as libc::c_int {
                    lglsimpleliftcollect(lgl, root, -other, level - 1 as libc::c_int);
                }
            }
        }
        p = p.offset(1);
        p;
    }
}
unsafe extern "C" fn lglsimplelift(mut lgl: *mut LGL, mut root: libc::c_int) {
    let mut count: libc::c_int = 0;
    let mut pos: libc::c_int = 0;
    let mut neg: libc::c_int = 0;
    pos = (*lglhts(lgl, root)).count as libc::c_int;
    neg = (*lglhts(lgl, -root)).count as libc::c_int;
    if neg < pos {
        root = -root;
    }
    lglsignedmarknpushseen(lgl, -root);
    lglsimpleliftmark(lgl, root, (*(*lgl).opts).prbsimpleliftdepth.val);
    count = lglcntstk(&mut (*lgl).seen) as libc::c_int;
    if count == 0 {
        return;
    }
    lglsimpleliftcollect(lgl, root, -root, (*(*lgl).opts).prbsimpleliftdepth.val);
    lglpopnunmarkstk(lgl, &mut (*lgl).seen);
}
unsafe extern "C" fn lglsimpleprobelit(mut lgl: *mut LGL, mut lit: libc::c_int) {
    let mut blit: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut other2: libc::c_int = 0;
    let mut red: libc::c_int = 0;
    let mut lidx: libc::c_int = 0;
    let mut cls: [libc::c_int; 4] = [0; 4];
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut w: *const libc::c_int = 0 as *const libc::c_int;
    let mut eow: *const libc::c_int = 0 as *const libc::c_int;
    let mut c: *const libc::c_int = 0 as *const libc::c_int;
    let mut hts: *mut HTS = 0 as *mut HTS;
    (*(*lgl).stats).prb.simple.probed += 1;
    (*(*lgl).stats).prb.simple.probed;
    lglclnstk(&mut (*(*lgl).c2rust_unnamed.sprb).units);
    lglclnstk(&mut (*(*lgl).c2rust_unnamed.sprb).impls);
    if lglwrktouched(lgl, -lit) == 0 {
        lglsimplelift(lgl, lit);
    }
    hts = lglhts(lgl, lit);
    if (*hts).count == 0 {
        return;
    }
    w = lglhts2wchs(lgl, hts);
    eow = w.offset((*hts).count as isize);
    p = w;
    while p < eow {
        (*(*lgl).stats).steps += 1;
        (*(*lgl).stats).steps;
        let fresh154 = (*(*lgl).stats).prb.simple.steps;
        (*(*lgl).stats).prb.simple.steps = (*(*lgl).stats).prb.simple.steps + 1;
        if fresh154 >= (*(*lgl).limits).prb.steps {
            break;
        }
        blit = *p;
        tag = blit & MASKCS as libc::c_int;
        if tag == TRNCS as libc::c_int || tag == LRGCS as libc::c_int {
            p = p.offset(1);
            p;
        }
        if !(tag == BINCS as libc::c_int || tag == LRGCS as libc::c_int) {
            if tag == TRNCS as libc::c_int {
                other = blit >> RMSHFT as libc::c_int;
                if !(lglval(lgl, other) != 0) {
                    other2 = *p;
                    if !(lglval(lgl, other2) != 0) {
                        cls[0 as libc::c_int as usize] = lit;
                        cls[1 as libc::c_int as usize] = other;
                        cls[2 as libc::c_int as usize] = other2;
                        cls[3 as libc::c_int as usize] = 0 as libc::c_int;
                        lglsimpleprobehbr(lgl, lit, cls.as_mut_ptr());
                    }
                }
            } else {
                red = blit & REDCS as libc::c_int;
                lidx = blit >> RMSHFT as libc::c_int;
                c = lglidx2lits(lgl, red, lidx);
                lglsimpleprobehbr(lgl, lit, c);
            }
        }
        p = p.offset(1);
        p;
    }
    lglpopnunmarkstk(lgl, &mut (*lgl).seen);
}
unsafe extern "C" fn lglprtsimpleproberem(mut lgl: *mut LGL) {
    let mut idx: libc::c_int = 0;
    let mut ret: libc::c_int = 0 as libc::c_int;
    let mut rem: libc::c_int = 0 as libc::c_int;
    let mut sum: libc::c_int = 0;
    idx = 2 as libc::c_int;
    while idx < (*lgl).nvars {
        if !(lglisfree(lgl, idx) == 0) {
            if (*lglavar(lgl, idx)).donotsimpleprobe() != 0 {
                ret += 1;
                ret;
            } else {
                rem += 1;
                rem;
            }
        }
        idx += 1;
        idx;
    }
    if rem != 0 {
        sum = rem + ret;
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[simpleprobe-%d] %d variables remain %.0f%% (%d retained %.0f%%)\0"
                as *const u8 as *const libc::c_char,
            (*(*lgl).stats).prb.simple.count,
            rem,
            lglpcnt(rem as libc::c_double, sum as libc::c_double),
            ret,
            lglpcnt(ret as libc::c_double, sum as libc::c_double),
        );
    } else {
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[simpleprobe-%d] fully completed simple probing\0" as *const u8
                as *const libc::c_char,
            (*(*lgl).stats).prb.simple.count,
        );
        idx = 2 as libc::c_int;
        while idx < (*lgl).nvars {
            let ref mut fresh155 = *lglavar(lgl, idx);
            (*fresh155).set_donotsimpleprobe(0 as libc::c_int as libc::c_uint);
            idx += 1;
            idx;
        }
    };
}
unsafe extern "C" fn lglirrlits(mut lgl: *mut LGL) -> int64_t {
    return (*(*lgl).stats).irr.lits.cur as int64_t;
}
unsafe extern "C" fn lglredlits(mut lgl: *mut LGL) -> int64_t {
    let mut res: int64_t = (2 as libc::c_int * (*(*lgl).stats).red.bin
        + 3 as libc::c_int * (*(*lgl).stats).red.trn) as int64_t;
    let mut glue: libc::c_int = 0;
    glue = 0 as libc::c_int;
    while glue <= ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int {
        res = (res as size_t).wrapping_add(lglcntstk(((*lgl).red).offset(glue as isize)))
            as int64_t as int64_t;
        res
            -= (2 as libc::c_int * (*(*lgl).stats).lir[glue as usize].clauses)
                as int64_t;
        glue += 1;
        glue;
    }
    return res;
}
unsafe extern "C" fn lglszpenaux(
    mut lgl: *mut LGL,
    mut litstoo: libc::c_int,
    mut redtoo: libc::c_int,
) -> libc::c_int {
    let mut size64: int64_t = 0;
    let mut res: libc::c_int = 0;
    size64 = (*(*lgl).stats).irr.clauses.cur as int64_t;
    if litstoo != 0 {
        size64 += lglirrlits(lgl) / 4 as libc::c_int as int64_t;
    }
    if redtoo != 0 {
        size64 += (*(*lgl).stats).irr.clauses.cur as int64_t;
        if litstoo != 0 {
            size64 += lglredlits(lgl) / 4 as libc::c_int as int64_t;
        }
    }
    size64 /= (*(*lgl).opts).sizepen.val as int64_t;
    if size64 >= 2147483647 as libc::c_int as int64_t {
        res = 32 as libc::c_int;
    } else {
        res = lglceild(size64 as libc::c_int);
    }
    if res < 0 as libc::c_int {
        res = 0 as libc::c_int;
    }
    if res > (*(*lgl).opts).sizemaxpen.val {
        res = (*(*lgl).opts).sizemaxpen.val;
    }
    return res;
}
unsafe extern "C" fn lglszpen(mut lgl: *mut LGL) -> libc::c_int {
    return lglszpenaux(lgl, 0 as libc::c_int, 0 as libc::c_int);
}
unsafe extern "C" fn lglvisearch(mut lgl: *mut LGL) -> int64_t {
    let mut res: int64_t = (*(*lgl).stats).visits.search;
    res -= (*(*lgl).limits).inc.visits;
    return res;
}
unsafe extern "C" fn lglsetprbsimplelim(mut lgl: *mut LGL) {
    let mut limit: int64_t = 0;
    let mut irrlim: int64_t = 0;
    let mut pen: libc::c_int = 0;
    let mut szpen: libc::c_int = 0;
    if (*(*lgl).opts).prbsimplertc.val != 0 || (*(*lgl).opts).prbrtc.val != 0 {
        (*(*lgl).limits).prb.steps = 0x7fffffffffffffff as libc::c_longlong as int64_t;
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[simpleprobe-%d] really no limit (run to completion)\0" as *const u8
                as *const libc::c_char,
            (*(*lgl).stats).prb.simple.count,
        );
    } else {
        limit = (*(*lgl).opts).prbsimplereleff.val as int64_t * lglvisearch(lgl)
            / 1000 as libc::c_int as int64_t;
        if limit < (*(*lgl).opts).prbsimplemineff.val as int64_t {
            limit = (*(*lgl).opts).prbsimplemineff.val as int64_t;
        }
        if (*(*lgl).opts).prbsimplemaxeff.val >= 0 as libc::c_int
            && limit > (*(*lgl).opts).prbsimplemaxeff.val as int64_t
        {
            limit = (*(*lgl).opts).prbsimplemaxeff.val as int64_t;
        }
        if (*(*lgl).stats).prb.simple.count <= 1 as libc::c_int
            && (*(*lgl).opts).boost.val != 0
            && (*(*lgl).opts).prbsimpleboost.val > 1 as libc::c_int
        {
            lglprt(
                lgl,
                1 as libc::c_int,
                b"[simpleprobe-%d] boosting simple probing limit by %d\0" as *const u8
                    as *const libc::c_char,
                (*(*lgl).stats).prb.simple.count,
                (*(*lgl).opts).prbsimpleboost.val,
            );
            limit *= (*(*lgl).opts).prbsimpleboost.val as int64_t;
        }
        szpen = lglszpen(lgl);
        pen = (*(*lgl).limits).prb.simple.pen + szpen;
        limit >>= pen;
        irrlim = (2 as libc::c_int * (*(*lgl).stats).irr.clauses.cur >> szpen)
            as int64_t;
        if (*(*lgl).opts).irrlim.val != 0 && limit < irrlim {
            limit = irrlim;
            lglprt(
                lgl,
                1 as libc::c_int,
                b"[simpleprobe-%d] limit %lld based on %d irredundant clauses penalty %d\0"
                    as *const u8 as *const libc::c_char,
                (*(*lgl).stats).prb.simple.count,
                limit as libc::c_longlong,
                (*(*lgl).stats).irr.clauses.cur,
                szpen,
            );
        } else {
            lglprt(
                lgl,
                1 as libc::c_int,
                b"[simpleprobe-%d] limit %lld penalty %d = %d + %d\0" as *const u8
                    as *const libc::c_char,
                (*(*lgl).stats).prb.simple.count,
                limit as libc::c_longlong,
                pen,
                (*(*lgl).limits).prb.simple.pen,
                szpen,
            );
        }
        (*(*lgl).limits).prb.steps = (*(*lgl).stats).prb.simple.steps + limit;
    };
}
unsafe extern "C" fn lgldelaying(
    mut lgl: *mut LGL,
    mut name: *const libc::c_char,
    mut delptr: *mut libc::c_int,
) -> libc::c_int {
    if *delptr == 0 {
        return 0 as libc::c_int;
    }
    *delptr -= 1 as libc::c_int;
    lglprt(
        lgl,
        2 as libc::c_int,
        b"[%s-delayed] skipping this scheduled invocation and %d more\0" as *const u8
            as *const libc::c_char,
        name,
        *delptr,
    );
    return 1 as libc::c_int;
}
unsafe extern "C" fn lglsimpleprobe(mut lgl: *mut LGL) -> libc::c_int {
    let mut deltarem: libc::c_int = 0;
    let mut nunits: libc::c_int = 0;
    let mut hbrs: libc::c_int = 0;
    let mut neqs: libc::c_int = 0;
    let mut oldrem: libc::c_int = lglrem(lgl);
    let mut lit: libc::c_int = 0;
    let mut success: libc::c_int = 0;
    let mut nvars: libc::c_int = 0;
    if lgldelaying(
        lgl,
        b"simpleprobe\0" as *const u8 as *const libc::c_char,
        &mut (*(*lgl).limits).prb.simple.del.rem,
    ) != 0
    {
        return 1 as libc::c_int;
    }
    lglstart(lgl, &mut (*(*lgl).times).prb.simple);
    (*(*lgl).stats).prb.simple.count += 1;
    (*(*lgl).stats).prb.simple.count;
    (*lgl).simpleprobing = 1 as libc::c_int as libc::c_char;
    (*lgl).probing = (*lgl).simpleprobing as libc::c_int;
    (*lgl).simp = (*lgl).probing as libc::c_char;
    (*lgl)
        .c2rust_unnamed
        .sprb = lglnew(
        lgl,
        (1 as libc::c_int as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<SPrb>() as libc::c_ulong),
    ) as *mut SPrb;
    if (*lgl).level > 0 as libc::c_int {
        lglbacktrack(lgl, 0 as libc::c_int);
    }
    lglgc(lgl);
    lgldense(lgl, 0 as libc::c_int);
    lglsimpleprobeinit(lgl);
    lglsetprbsimplelim(lgl);
    nunits = 0 as libc::c_int;
    hbrs = nunits;
    neqs = hbrs;
    nvars = (*lgl).nvars;
    (*(*lgl).c2rust_unnamed.sprb)
        .spes = lglnew(
        lgl,
        ((2 as libc::c_int * nvars) as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<SPE>() as libc::c_ulong),
    ) as *mut SPE;
    (*(*lgl).c2rust_unnamed.sprb)
        .spes = ((*(*lgl).c2rust_unnamed.sprb).spes).offset(nvars as isize);
    while (*lgl).mt == 0
        && {
            lit = lglwrknext(lgl);
            lit != 0
        }
    {
        (*(*lgl).stats).steps += 1;
        (*(*lgl).stats).steps;
        let fresh156 = (*(*lgl).stats).prb.simple.steps;
        (*(*lgl).stats).prb.simple.steps = (*(*lgl).stats).prb.simple.steps + 1;
        if fresh156 >= (*(*lgl).limits).prb.steps {
            break;
        }
        if lglisfree(lgl, lit) == 0 {
            continue;
        }
        if (*lglavar(lgl, lit)).equiv() != 0 {
            continue;
        }
        lglsimpleprobelit(lgl, lit);
        if (*lgl).mt != 0 {
            break;
        }
        lglchkirrstats(lgl);
        nunits += lglsimpleprobeunits(lgl);
        if (*lgl).mt != 0 {
            break;
        }
        hbrs += lglsimpleprobeimpls(lgl);
        if (*lgl).mt != 0 {
            break;
        }
        neqs += lglsimpleprobeqs(lgl);
        if lglflush(lgl) == 0 {
            break;
        }
        if lglterminate(lgl) != 0 {
            break;
        }
        if lglsyncunits(lgl) == 0 {
            break;
        }
    }
    lglsimpleprobereset(lgl, nvars);
    lglsparse(lgl);
    if (*lgl).mt == 0 {
        lgldecomp(lgl);
    }
    lgldel(
        lgl,
        (*lgl).c2rust_unnamed.sprb as *mut libc::c_void,
        (1 as libc::c_int as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<SPrb>() as libc::c_ulong),
    );
    (*lgl).c2rust_unnamed.sprb = 0 as *mut SPrb;
    deltarem = oldrem - lglrem(lgl);
    success = (deltarem != 0 || hbrs != 0 || nunits != 0) as libc::c_int;
    if deltarem != 0 && (*(*lgl).limits).prb.simple.pen != 0 {
        (*(*lgl).limits).prb.simple.pen -= 1;
        (*(*lgl).limits).prb.simple.pen;
    }
    if deltarem == 0 && (*(*lgl).limits).prb.simple.pen < (*(*lgl).opts).penmax.val {
        (*(*lgl).limits).prb.simple.pen += 1;
        (*(*lgl).limits).prb.simple.pen;
    }
    if deltarem != 0 && (*(*lgl).limits).prb.simple.del.cur != 0 {
        (*(*lgl).limits).prb.simple.del.cur /= 2 as libc::c_int;
    }
    if deltarem == 0 && (*(*lgl).limits).prb.simple.del.cur < (*(*lgl).opts).delmax.val {
        (*(*lgl).limits).prb.simple.del.cur += 1;
        (*(*lgl).limits).prb.simple.del.cur;
    }
    (*(*lgl).limits).prb.simple.del.rem = (*(*lgl).limits).prb.simple.del.cur;
    lglprtsimpleproberem(lgl);
    lglprt(
        lgl,
        1 as libc::c_int + (success == 0) as libc::c_int,
        b"[simpleprobe-%d] removed %d variables, found %d hbrs, %d units\0" as *const u8
            as *const libc::c_char,
        (*(*lgl).stats).prb.simple.count,
        deltarem,
        hbrs,
        nunits,
    );
    (*lgl).simpleprobing = 0 as libc::c_int as libc::c_char;
    (*lgl).probing = (*lgl).simpleprobing as libc::c_int;
    (*lgl).simp = (*lgl).probing as libc::c_char;
    lglrep(lgl, 2 as libc::c_int, 'p' as i32 as libc::c_char);
    lglstop(lgl);
    return ((*lgl).mt == 0) as libc::c_int;
}
unsafe extern "C" fn lglmvbcls(
    mut lgl: *mut LGL,
    mut a: libc::c_int,
    mut b: libc::c_int,
) -> libc::c_int {
    let mut res: libc::c_int = 0 as libc::c_int;
    lglpushstk(lgl, &mut (*lgl).clause, a);
    lglpushstk(lgl, &mut (*lgl).clause, b);
    lglpushstk(lgl, &mut (*lgl).clause, 0 as libc::c_int);
    if lglsimpleprobeclausexists(lgl) == 0 {
        lgldrupligaddcls(lgl, REDCS as libc::c_int);
        lgladdcls(lgl, REDCS as libc::c_int, 0 as libc::c_int, 1 as libc::c_int);
        res = 1 as libc::c_int;
    }
    lglclnstk(&mut (*lgl).clause);
    (*(*lgl).stats).moved.bin += 1;
    (*(*lgl).stats).moved.bin;
    return res;
}
unsafe extern "C" fn lglrmvbcls(
    mut lgl: *mut LGL,
    mut a: libc::c_int,
    mut b: libc::c_int,
) -> libc::c_int {
    lglrmbcls(lgl, a, b, 0 as libc::c_int);
    if (*(*lgl).opts).move_0.val != 0 {
        return lglmvbcls(lgl, a, b);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn lglmvtcls(
    mut lgl: *mut LGL,
    mut a: libc::c_int,
    mut b: libc::c_int,
    mut c: libc::c_int,
) -> libc::c_int {
    let mut res: libc::c_int = 0 as libc::c_int;
    lglpushstk(lgl, &mut (*lgl).clause, a);
    lglpushstk(lgl, &mut (*lgl).clause, b);
    lglpushstk(lgl, &mut (*lgl).clause, c);
    lglpushstk(lgl, &mut (*lgl).clause, 0 as libc::c_int);
    if lglsimpleprobeclausexists(lgl) == 0 {
        lgldrupligaddcls(lgl, REDCS as libc::c_int);
        lgladdcls(lgl, REDCS as libc::c_int, 0 as libc::c_int, 1 as libc::c_int);
        res = 1 as libc::c_int;
    }
    lglclnstk(&mut (*lgl).clause);
    (*(*lgl).stats).moved.trn += 1;
    (*(*lgl).stats).moved.trn;
    return res;
}
unsafe extern "C" fn lglrmvtcls(
    mut lgl: *mut LGL,
    mut a: libc::c_int,
    mut b: libc::c_int,
    mut c: libc::c_int,
) -> libc::c_int {
    lglrmtcls(lgl, a, b, c, 0 as libc::c_int);
    if (*(*lgl).opts).move_0.val >= 2 as libc::c_int {
        return lglmvtcls(lgl, a, b, c);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn lglwaiting(
    mut lgl: *mut LGL,
    mut str: *const libc::c_char,
    mut wait: libc::c_int,
) -> libc::c_int {
    if wait == 0 {
        return 0 as libc::c_int;
    }
    if (*lgl).wait == 0 {
        return 0 as libc::c_int;
    }
    if wait >= 2 as libc::c_int && (*(*lgl).opts).elim.val != 0 && (*lgl).elmrtc == 0 {
        if !str.is_null() {
            lglprt(
                lgl,
                2 as libc::c_int,
                b"[%s-waiting] on variable elimination to be completed\0" as *const u8
                    as *const libc::c_char,
                str,
            );
        }
        return 1 as libc::c_int;
    }
    if wait >= 1 as libc::c_int && (*(*lgl).opts).block.val != 0 && (*lgl).blkrtc == 0 {
        if !str.is_null() {
            lglprt(
                lgl,
                2 as libc::c_int,
                b"[%s-waiting] on blocked clause elimination to be completed\0"
                    as *const u8 as *const libc::c_char,
                str,
            );
        }
        return 1 as libc::c_int;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn lglbasicate(mut lgl: *mut LGL, mut lit: libc::c_int) {
    let mut current_block: u64;
    let druplig: libc::c_int = (*(*lgl).opts).druplig.val;
    let mut blit: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut red: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut other2: libc::c_int = 0;
    let mut lidx: libc::c_int = 0;
    let mut w: *const libc::c_int = 0 as *const libc::c_int;
    let mut eow: *const libc::c_int = 0 as *const libc::c_int;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut c: *const libc::c_int = 0 as *const libc::c_int;
    let mut l: *const libc::c_int = 0 as *const libc::c_int;
    let mut nonfalse: libc::c_int = 0;
    let mut numtrue: libc::c_int = 0;
    let mut val: libc::c_int = 0;
    let mut hts: *mut HTS = 0 as *mut HTS;
    if (*(*lgl).opts).bate.val == 0 {
        return;
    }
    if lglwaiting(lgl, 0 as *const libc::c_char, (*(*lgl).opts).batewait.val) != 0 {
        return;
    }
    '_RESTART: loop {
        hts = lglhts(lgl, -lit);
        w = lglhts2wchs(lgl, hts);
        eow = w.offset((*hts).count as isize);
        p = w;
        loop {
            if !(p < eow) {
                break '_RESTART;
            }
            blit = *p;
            tag = blit & MASKCS as libc::c_int;
            if tag == TRNCS as libc::c_int || tag == LRGCS as libc::c_int {
                p = p.offset(1);
                p;
            }
            red = blit & REDCS as libc::c_int;
            if !(red != 0) {
                if !(tag == BINCS as libc::c_int) {
                    if tag == TRNCS as libc::c_int {
                        other = blit >> RMSHFT as libc::c_int;
                        numtrue = 0 as libc::c_int;
                        val = lglval(lgl, other) as libc::c_int;
                        if !(val < 0 as libc::c_int) {
                            if val > 0 as libc::c_int {
                                if lglevel(lgl, other) == 0 {
                                    current_block = 7815301370352969686;
                                } else {
                                    if (*lgltd(lgl, other)).irr() != 0 {
                                        numtrue += 1;
                                        numtrue;
                                    }
                                    current_block = 224731115979188411;
                                }
                            } else {
                                current_block = 224731115979188411;
                            }
                            match current_block {
                                7815301370352969686 => {}
                                _ => {
                                    other2 = *p;
                                    val = lglval(lgl, other2) as libc::c_int;
                                    if !(val < 0 as libc::c_int) {
                                        if val > 0 as libc::c_int {
                                            if lglevel(lgl, other2) == 0 {
                                                current_block = 7815301370352969686;
                                            } else {
                                                if (*lgltd(lgl, other2)).irr() != 0 {
                                                    numtrue += 1;
                                                    numtrue;
                                                }
                                                current_block = 7056779235015430508;
                                            }
                                        } else {
                                            current_block = 7056779235015430508;
                                        }
                                        match current_block {
                                            7815301370352969686 => {}
                                            _ => {
                                                if !(numtrue == 0) {
                                                    (*(*lgl).stats).prb.basic.ate.trnr += 1;
                                                    (*(*lgl).stats).prb.basic.ate.trnr;
                                                    if lglrmvtcls(lgl, -lit, other, other2) == 0 {
                                                        lgldrupligdelclsarg(
                                                            lgl,
                                                            -lit,
                                                            other,
                                                            other2,
                                                            0 as libc::c_int,
                                                        );
                                                    }
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else if !(tag == LRGCS as libc::c_int
                        && (*lgl).dense as libc::c_int != 0)
                    {
                        lidx = if tag == LRGCS as libc::c_int {
                            *p
                        } else {
                            blit >> RMSHFT as libc::c_int
                        };
                        c = lglidx2lits(lgl, 0 as libc::c_int, lidx);
                        nonfalse = 0 as libc::c_int;
                        numtrue = nonfalse;
                        l = c;
                        while (nonfalse < 2 as libc::c_int || numtrue == 0)
                            && {
                                other = *l;
                                other != 0
                            }
                        {
                            if !(other == -lit) {
                                val = lglval(lgl, other) as libc::c_int;
                                if val >= 0 as libc::c_int {
                                    nonfalse += 1;
                                    nonfalse;
                                }
                                if val > 0 as libc::c_int {
                                    if lglevel(lgl, other) == 0 {
                                        numtrue = -(1 as libc::c_int);
                                        break;
                                    } else if (*lgltd(lgl, other)).irr() != 0 {
                                        numtrue += 1;
                                        numtrue;
                                    }
                                }
                            }
                            l = l.offset(1);
                            l;
                        }
                        if numtrue > 0 as libc::c_int && nonfalse >= 2 as libc::c_int {
                            (*(*lgl).stats).prb.basic.ate.lrg += 1;
                            (*(*lgl).stats).prb.basic.ate.lrg;
                            if druplig != 0 {
                                lgldrupligdelclsaux(lgl, c);
                            }
                            lglrmlcls(lgl, lidx, 0 as libc::c_int);
                            break;
                        }
                    }
                }
            }
            p = p.offset(1);
            p;
        }
    };
}
unsafe extern "C" fn lglbasicatestats(mut lgl: *mut LGL) {
    let mut n: libc::c_int = (*(*lgl).stats).prb.basic.ate.lrg
        + (*(*lgl).stats).prb.basic.ate.trnr;
    let mut d: libc::c_int = (n as int64_t - (*(*lgl).stats).prb.basic.lastate)
        as libc::c_int;
    if d <= 0 as libc::c_int {
        return;
    }
    (*(*lgl).stats).prb.basic.ate.count += 1;
    (*(*lgl).stats).prb.basic.ate.count;
    lglprt(
        lgl,
        1 as libc::c_int,
        b"[bate-%d] eliminated %d asymmetric tautologies during probing\0" as *const u8
            as *const libc::c_char,
        (*(*lgl).stats).prb.basic.ate.count,
        d,
    );
    (*(*lgl).stats).prb.basic.lastate = n as int64_t;
}
unsafe extern "C" fn lglbasicprobelit(mut lgl: *mut LGL, mut root: libc::c_int) {
    let mut old: libc::c_int = 0;
    let mut ok: libc::c_int = 0;
    let mut dom: libc::c_int = 0;
    let mut lit: libc::c_int = 0;
    let mut val: libc::c_int = 0;
    let mut lift: Stk = Stk {
        start: 0 as *mut libc::c_int,
        top: 0 as *mut libc::c_int,
        end: 0 as *mut libc::c_int,
    };
    let mut saved: Stk = Stk {
        start: 0 as *mut libc::c_int,
        top: 0 as *mut libc::c_int,
        end: 0 as *mut libc::c_int,
    };
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    memset(
        &mut lift as *mut Stk as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<Stk>() as libc::c_ulong,
    );
    memset(
        &mut saved as *mut Stk as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<Stk>() as libc::c_ulong,
    );
    if (*lgl).treelooking != 0 {
        (*(*lgl).stats).prb.treelook.probed += 1;
        (*(*lgl).stats).prb.treelook.probed;
    } else if (*lgl).cceing != 0 {
        (*(*lgl).stats).cce.probed += 1;
        (*(*lgl).stats).cce.probed;
    } else {
        (*(*lgl).stats).prb.basic.probed += 1;
        (*(*lgl).stats).prb.basic.probed;
    }
    if lglrand(lgl) & ((1 as libc::c_int) << 12 as libc::c_int) as libc::c_uint != 0 {
        root = -root;
    }
    lgliassume(lgl, root);
    old = (*lgl).next;
    ok = lglbcp(lgl);
    dom = 0 as libc::c_int;
    if ok != 0 {
        lglclnstk(&mut saved);
        lglbasicate(lgl, root);
        p = ((*lgl).trail.start).offset(old as isize);
        while p < (*lgl).trail.top as *const libc::c_int {
            lit = *p;
            if !(lit == root) {
                lglpushstk(lgl, &mut saved, lit);
            }
            p = p.offset(1);
            p;
        }
    } else {
        dom = lglprbana(lgl, root);
    }
    lglbacktrack(lgl, 0 as libc::c_int);
    if ok == 0 {
        lglpushstk(lgl, &mut lift, -dom);
    } else {
        if (*lgl).treelooking != 0 {
            (*(*lgl).stats).prb.treelook.probed += 1;
            (*(*lgl).stats).prb.treelook.probed;
        } else if (*lgl).cceing != 0 {
            (*(*lgl).stats).cce.probed += 1;
            (*(*lgl).stats).cce.probed;
        } else {
            (*(*lgl).stats).prb.basic.probed += 1;
            (*(*lgl).stats).prb.basic.probed;
        }
        lgliassume(lgl, -root);
        ok = lglbcp(lgl);
        if ok != 0 {
            lglbasicate(lgl, -root);
            p = saved.start;
            while p < saved.top as *const libc::c_int {
                lit = *p;
                val = lglval(lgl, lit) as libc::c_int;
                if !(val <= 0 as libc::c_int) {
                    if (*lgl).treelooking != 0 {
                        (*(*lgl).stats).prb.treelook.lifted += 1;
                        (*(*lgl).stats).prb.treelook.lifted;
                    } else if (*lgl).cceing != 0 {
                        (*(*lgl).stats).cce.lifted += 1;
                        (*(*lgl).stats).cce.lifted;
                    } else {
                        (*(*lgl).stats).prb.basic.lifted += 1;
                        (*(*lgl).stats).prb.basic.lifted;
                    }
                    lglpushstk(lgl, &mut lift, lit);
                }
                p = p.offset(1);
                p;
            }
        } else {
            dom = lglprbana(lgl, -root);
        }
        lglbacktrack(lgl, 0 as libc::c_int);
        if ok == 0 {
            lglpushstk(lgl, &mut lift, -dom);
        }
    }
    while lglmtstk(&mut lift) == 0 {
        lit = lglpopstk(&mut lift);
        val = lglval(lgl, lit) as libc::c_int;
        if val > 0 as libc::c_int {
            continue;
        }
        if !(val < 0 as libc::c_int) {
            if (*(*lgl).opts).druplig.val != 0 {
                lgldrupligaddclsarg(
                    lgl,
                    REDCS as libc::c_int,
                    -root,
                    lit,
                    0 as libc::c_int,
                );
                lgldrupligaddclsarg(
                    lgl,
                    REDCS as libc::c_int,
                    root,
                    lit,
                    0 as libc::c_int,
                );
            }
            lglunit(lgl, lit);
            if (*(*lgl).opts).druplig.val != 0 {
                lgldrupligdelclsarg(lgl, -root, lit, 0 as libc::c_int);
                lgldrupligdelclsarg(lgl, root, lit, 0 as libc::c_int);
            }
            if (*lgl).treelooking != 0 {
                (*(*lgl).stats).prb.treelook.failed += 1;
                (*(*lgl).stats).prb.treelook.failed;
            } else if (*lgl).cceing != 0 {
                (*(*lgl).stats).cce.failed += 1;
                (*(*lgl).stats).cce.failed;
            } else {
                (*(*lgl).stats).prb.basic.failed += 1;
                (*(*lgl).stats).prb.basic.failed;
            }
            if lglbcp(lgl) != 0 {
                continue;
            }
        }
        lglmt(lgl);
    }
    lglrelstk(lgl, &mut lift);
    lglrelstk(lgl, &mut saved);
}
unsafe extern "C" fn lgltvar(mut lgl: *mut LGL, mut lit: libc::c_int) -> *mut TVar {
    let mut idx: libc::c_int = abs(lit);
    return ((*(*lgl).c2rust_unnamed.tlk).tvars).offset(idx as isize);
}
unsafe extern "C" fn lglsignedtlmark(mut lgl: *mut LGL, mut lit: libc::c_int) {
    let mut tv: *mut TVar = lgltvar(lgl, lit);
    let mut bit: libc::c_uint = (1 as libc::c_uint)
        << (lit < 0 as libc::c_int) as libc::c_int;
    if (*tv).mark() & bit != 0 {
        return;
    }
    (*tv).set_mark((*tv).mark() | bit);
}
unsafe extern "C" fn lglsignedtlmarked(
    mut lgl: *mut LGL,
    mut lit: libc::c_int,
) -> libc::c_int {
    let mut tv: *mut TVar = lgltvar(lgl, lit);
    let mut bit: libc::c_uint = (1 as libc::c_uint)
        << (lit < 0 as libc::c_int) as libc::c_int;
    return ((*tv).mark() & bit) as libc::c_int;
}
unsafe extern "C" fn lgltlenq(mut lgl: *mut LGL, mut start: libc::c_int) {
    let mut lit: libc::c_int = 0;
    let mut blit: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut oldcount: libc::c_int = 0;
    let mut newcount: libc::c_int = 0;
    let mut stk: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut delta: libc::c_uint = 0;
    let mut i: libc::c_uint = 0;
    let mut j: libc::c_uint = 0;
    let mut mod_0: libc::c_uint = 0;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut w: *const libc::c_int = 0 as *const libc::c_int;
    let mut eos: *const libc::c_int = 0 as *const libc::c_int;
    let mut hts: *mut HTS = 0 as *mut HTS;
    lglsignedtlmark(lgl, start);
    lglpushstk(lgl, &mut (*(*lgl).c2rust_unnamed.tlk).stk, start);
    while lglmtstk(&mut (*(*lgl).c2rust_unnamed.tlk).stk) == 0 {
        lit = lglpopstk(&mut (*(*lgl).c2rust_unnamed.tlk).stk);
        if lit != 0 {
            lglpushstk(lgl, &mut (*(*lgl).c2rust_unnamed.tlk).seen, lit);
            lglpushstk(lgl, &mut (*(*lgl).c2rust_unnamed.tlk).stk, 0 as libc::c_int);
            hts = lglhts(lgl, lit);
            w = lglhts2wchs(lgl, hts);
            eos = w.offset((*hts).count as isize);
            oldcount = lglcntstk(&mut (*(*lgl).c2rust_unnamed.tlk).stk) as libc::c_int;
            p = w;
            while p < eos {
                (*(*lgl).stats).steps += 1;
                (*(*lgl).stats).steps;
                (*(*lgl).stats).prb.treelook.steps += 1;
                (*(*lgl).stats).prb.treelook.steps;
                blit = *p;
                tag = blit & MASKCS as libc::c_int;
                if !(tag == OCCS as libc::c_int) {
                    if tag == TRNCS as libc::c_int || tag == LRGCS as libc::c_int {
                        p = p.offset(1);
                        p;
                    } else {
                        other = -(blit >> RMSHFT as libc::c_int);
                        if !(lglval(lgl, other) != 0) {
                            if lglsignedtlmarked(lgl, other) == 0 {
                                lglsignedtlmark(lgl, other);
                                lglpushstk(
                                    lgl,
                                    &mut (*(*lgl).c2rust_unnamed.tlk).stk,
                                    other,
                                );
                            }
                        }
                    }
                }
                p = p.offset(1);
                p;
            }
            newcount = lglcntstk(&mut (*(*lgl).c2rust_unnamed.tlk).stk) as libc::c_int;
            delta = (newcount - oldcount) as libc::c_uint;
            mod_0 = delta;
            if mod_0 <= 1 as libc::c_int as libc::c_uint {
                continue;
            }
            stk = (*(*lgl).c2rust_unnamed.tlk).stk.start;
            i = 0 as libc::c_int as libc::c_uint;
            while i < delta.wrapping_sub(1 as libc::c_int as libc::c_uint) {
                j = i.wrapping_add((lglrand(lgl)).wrapping_rem(mod_0));
                if !(i == j) {
                    let mut TMP: libc::c_int = *stk
                        .offset(i.wrapping_add(oldcount as libc::c_uint) as isize);
                    *stk
                        .offset(
                            i.wrapping_add(oldcount as libc::c_uint) as isize,
                        ) = *stk
                        .offset(j.wrapping_add(oldcount as libc::c_uint) as isize);
                    *stk.offset(j.wrapping_add(oldcount as libc::c_uint) as isize) = TMP;
                }
                i = i.wrapping_add(1);
                i;
                mod_0 = mod_0.wrapping_sub(1);
                mod_0;
            }
        } else {
            lglpushstk(lgl, &mut (*(*lgl).c2rust_unnamed.tlk).seen, 0 as libc::c_int);
        }
    }
}
unsafe extern "C" fn lglisroot(mut lgl: *mut LGL, mut lit: libc::c_int) -> libc::c_int {
    return (lglhasbins(lgl, lit) == 0) as libc::c_int;
}
unsafe extern "C" fn lgltlunmarkall(mut lgl: *mut LGL) {
    let mut idx: libc::c_int = 0;
    idx = 2 as libc::c_int;
    while idx < (*lgl).nvars {
        let ref mut fresh157 = *((*(*lgl).c2rust_unnamed.tlk).tvars)
            .offset(idx as isize);
        (*fresh157).set_mark(0 as libc::c_int as libc::c_uint);
        idx += 1;
        idx;
    }
}
unsafe extern "C" fn lgltlschedlit(
    mut lgl: *mut LGL,
    mut lit: libc::c_int,
) -> libc::c_int {
    (*(*lgl).stats).steps += 1;
    (*(*lgl).stats).steps;
    let fresh158 = (*(*lgl).stats).prb.treelook.steps;
    (*(*lgl).stats).prb.treelook.steps = (*(*lgl).stats).prb.treelook.steps + 1;
    if fresh158 > (*(*lgl).limits).prb.steps {
        return 0 as libc::c_int;
    }
    if lglisfree(lgl, lit) == 0 {
        return 1 as libc::c_int;
    }
    if lglsignedtlmarked(lgl, lit) != 0 {
        return 1 as libc::c_int;
    }
    if lglisroot(lgl, -lit) == 0 {
        return 1 as libc::c_int;
    }
    if ((*(*lgl).c2rust_unnamed.tlk).lkhd).is_null()
        && (*lglavar(lgl, lit)).donotreelook() as libc::c_int != 0
    {
        return 1 as libc::c_int;
    }
    if (*(*lgl).opts).treelook.val >= 2 as libc::c_int {
        lglbasicprobelit(lgl, -lit);
        if (*lgl).mt != 0 {
            return 0 as libc::c_int;
        }
        if lglterminate(lgl) != 0 {
            return 0 as libc::c_int;
        }
        if lglisfree(lgl, lit) == 0 {
            return 1 as libc::c_int;
        }
        if lglisroot(lgl, -lit) == 0 {
            return 1 as libc::c_int;
        }
        if lglhasbins(lgl, lit) == 0 {
            return 1 as libc::c_int;
        }
    }
    lgltlenq(lgl, lit);
    return 1 as libc::c_int;
}
unsafe extern "C" fn lgltlschedanylit(
    mut lgl: *mut LGL,
    mut lit: libc::c_int,
) -> libc::c_int {
    (*(*lgl).stats).steps += 1;
    (*(*lgl).stats).steps;
    let fresh159 = (*(*lgl).stats).prb.treelook.steps;
    (*(*lgl).stats).prb.treelook.steps = (*(*lgl).stats).prb.treelook.steps + 1;
    if fresh159 > (*(*lgl).limits).prb.steps {
        return 0 as libc::c_int;
    }
    if lglisfree(lgl, lit) == 0 {
        return 1 as libc::c_int;
    }
    if lglsignedtlmarked(lgl, lit) != 0 {
        return 1 as libc::c_int;
    }
    if ((*(*lgl).c2rust_unnamed.tlk).lkhd).is_null()
        && (*lglavar(lgl, lit)).donotreelook() as libc::c_int != 0
    {
        return 1 as libc::c_int;
    }
    if (*(*lgl).opts).treelook.val >= 2 as libc::c_int {
        lglbasicprobelit(lgl, -lit);
        if (*lgl).mt != 0 {
            return 0 as libc::c_int;
        }
        if lglterminate(lgl) != 0 {
            return 0 as libc::c_int;
        }
        if lglisfree(lgl, lit) == 0 {
            return 1 as libc::c_int;
        }
    }
    lgltlenq(lgl, lit);
    return 1 as libc::c_int;
}
unsafe extern "C" fn lgltlsched(mut lgl: *mut LGL) {
    let mut idx: libc::c_int = 0;
    let mut round: libc::c_int = 0;
    let mut count: libc::c_int = 0;
    let mut p: *mut libc::c_int = 0 as *mut libc::c_int;
    round = 0 as libc::c_int;
    while (*lgl).mt == 0 && round < 2 as libc::c_int {
        if lglrandlitrav(
            lgl,
            Some(
                lgltlschedlit
                    as unsafe extern "C" fn(*mut LGL, libc::c_int) -> libc::c_int,
            ),
        ) != 0
        {
            lglrandlitrav(
                lgl,
                Some(
                    lgltlschedanylit
                        as unsafe extern "C" fn(*mut LGL, libc::c_int) -> libc::c_int,
                ),
            );
        }
        lgltlunmarkall(lgl);
        lglrelstk(lgl, &mut (*(*lgl).c2rust_unnamed.tlk).stk);
        if lglmtstk(&mut (*(*lgl).c2rust_unnamed.tlk).seen) == 0 {
            break;
        }
        idx = 2 as libc::c_int;
        while idx < (*lgl).nvars {
            let ref mut fresh160 = *lglavar(lgl, idx);
            (*fresh160).set_donotreelook(0 as libc::c_int as libc::c_uint);
            idx += 1;
            idx;
        }
        round += 1;
        round;
    }
    lglfitstk(lgl, &mut (*(*lgl).c2rust_unnamed.tlk).seen);
    count = 0 as libc::c_int;
    p = (*(*lgl).c2rust_unnamed.tlk).seen.start;
    while p < (*(*lgl).c2rust_unnamed.tlk).seen.top {
        if *p != 0 {
            count += 1;
            count;
        }
        p = p.offset(1);
        p;
    }
    lglprt(
        lgl,
        1 as libc::c_int,
        b"[treelook-%d] scheduled %d literals %.0f%%\0" as *const u8
            as *const libc::c_char,
        (*(*lgl).stats).prb.treelook.count,
        count,
        lglpcnt(
            count as libc::c_double,
            (2 as libc::c_int * lglrem(lgl)) as libc::c_double,
        ),
    );
    if count == 0 {
        idx = 2 as libc::c_int;
        while idx < (*lgl).nvars {
            let ref mut fresh161 = *lglavar(lgl, idx);
            (*fresh161).set_donotreelook(0 as libc::c_int as libc::c_uint);
            idx += 1;
            idx;
        }
    }
}
unsafe extern "C" fn lgltlassign(
    mut lgl: *mut LGL,
    mut assignment: *mut Stk,
    mut lit: libc::c_int,
) {
    let mut tv: *mut TVar = 0 as *mut TVar;
    tv = lgltvar(lgl, lit);
    (*tv)
        .set_val(
            (lglsgn(lit) as size_t
                * (1 as libc::c_int as size_t).wrapping_add(lglcntstk(assignment)))
                as libc::c_int,
        );
    lglpushstk(lgl, assignment, lit);
}
unsafe extern "C" fn lgltlunassign(mut lgl: *mut LGL, mut lit: libc::c_int) {
    let mut tv: *mut TVar = 0 as *mut TVar;
    tv = lgltvar(lgl, lit);
    (*tv).set_val(0 as libc::c_int);
}
unsafe extern "C" fn lgltlval(mut lgl: *mut LGL, mut lit: libc::c_int) -> libc::c_int {
    let mut tv: *mut TVar = lgltvar(lgl, lit);
    let mut res: libc::c_int = 0;
    if (*tv).val() == 0 {
        return 0 as libc::c_int;
    }
    res = lglsgn((*tv).val());
    if lit < 0 as libc::c_int {
        res = -res;
    }
    return res;
}
unsafe extern "C" fn lglincreducedptr(
    mut lgl: *mut LGL,
    mut reducedptr: *mut Flt,
    mut size: libc::c_int,
) {
    let mut reduced: Flt = *reducedptr;
    let mut inc: Flt = lglflt(-size, 1 as libc::c_int as Mnt);
    reduced = lgladdflt(reduced, inc);
    *reducedptr = reduced;
}
unsafe extern "C" fn lgltlbcp(
    mut lgl: *mut LGL,
    mut assignment: *mut Stk,
    mut reducedptr: *mut Flt,
    mut dom: libc::c_int,
) -> libc::c_int {
    let mut next: libc::c_int = lglcntstk(assignment) as libc::c_int;
    let mut next2: libc::c_int = next;
    let mut lit: libc::c_int = 0;
    let mut size: libc::c_int = 0;
    let mut implied: libc::c_int = 0;
    let mut blit: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut other2: libc::c_int = 0;
    let mut val: libc::c_int = 0;
    let mut lidx: libc::c_int = 0;
    let mut red: libc::c_int = 0;
    let mut found: libc::c_int = 0;
    let mut trivial: libc::c_int = 0;
    let mut numnonfalse: libc::c_int = 0;
    let mut numfalse: libc::c_int = 0;
    let mut firstfalse: libc::c_int = 0;
    let mut litval: libc::c_int = 0;
    let mut skip: libc::c_int = 0;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut w: *const libc::c_int = 0 as *const libc::c_int;
    let mut eos: *const libc::c_int = 0 as *const libc::c_int;
    let mut c: *const libc::c_int = 0 as *const libc::c_int;
    let mut q: *const libc::c_int = 0 as *const libc::c_int;
    let mut hts: *mut HTS = 0 as *mut HTS;
    if lglval(lgl, dom) != 0 {
        return 1 as libc::c_int;
    }
    lgltlassign(lgl, assignment, dom);
    (*(*lgl).stats).prb.treelook.probed += 1;
    (*(*lgl).stats).prb.treelook.probed;
    loop {
        if next2 < lglcntstk(assignment) as libc::c_int {
            (*(*lgl).stats).steps += 1;
            (*(*lgl).stats).steps;
            (*(*lgl).stats).props.simp += 1;
            (*(*lgl).stats).props.simp;
            if (*lgl).lkhd != 0 {
                (*(*lgl).stats).steps += 1;
                (*(*lgl).stats).steps;
                (*(*lgl).stats).props.lkhd += 1;
                (*(*lgl).stats).props.lkhd;
            }
            let fresh162 = next2;
            next2 = next2 + 1;
            lit = lglpeek(assignment, fresh162);
            hts = lglhts(lgl, -lit);
            w = lglhts2wchs(lgl, hts);
            eos = w.offset((*hts).count as isize);
            p = w;
            while p < eos {
                (*(*lgl).stats).visits.simp += 1;
                (*(*lgl).stats).visits.simp;
                if (*lgl).lkhd != 0 {
                    (*(*lgl).stats).visits.lkhd += 1;
                    (*(*lgl).stats).visits.lkhd;
                }
                (*(*lgl).stats).steps += 1;
                (*(*lgl).stats).steps;
                (*(*lgl).stats).prb.treelook.steps += 1;
                (*(*lgl).stats).prb.treelook.steps;
                blit = *p;
                tag = blit & MASKCS as libc::c_int;
                if !(tag == OCCS as libc::c_int) {
                    if tag == TRNCS as libc::c_int || tag == LRGCS as libc::c_int {
                        p = p.offset(1);
                        p;
                    } else {
                        other = blit >> RMSHFT as libc::c_int;
                        val = lglval(lgl, other) as libc::c_int;
                        if val < 0 as libc::c_int {
                            return 0 as libc::c_int;
                        }
                        if !(val > 0 as libc::c_int) {
                            val = lgltlval(lgl, other);
                            if val < 0 as libc::c_int {
                                return 0 as libc::c_int;
                            }
                            if !reducedptr.is_null() {
                                lglincreducedptr(lgl, reducedptr, 2 as libc::c_int);
                            }
                            if !(val > 0 as libc::c_int) {
                                lgltlassign(lgl, assignment, other);
                            }
                        }
                    }
                }
                p = p.offset(1);
                p;
            }
        } else {
            if !(next < lglcntstk(assignment) as libc::c_int) {
                break;
            }
            let fresh163 = next;
            next = next + 1;
            lit = lglpeek(assignment, fresh163);
            litval = lgltlval(lgl, lit);
            hts = lglhts(lgl, -lit);
            w = lglhts2wchs(lgl, hts);
            eos = w.offset((*hts).count as isize);
            p = w;
            while p < eos {
                blit = *p;
                tag = blit & MASKCS as libc::c_int;
                if tag == LRGCS as libc::c_int || tag == TRNCS as libc::c_int {
                    p = p.offset(1);
                    p;
                }
                if !(tag == BINCS as libc::c_int || tag == LRGCS as libc::c_int) {
                    (*(*lgl).stats).steps += 1;
                    (*(*lgl).stats).steps;
                    (*(*lgl).stats).prb.treelook.steps += 1;
                    (*(*lgl).stats).prb.treelook.steps;
                    trivial = 0 as libc::c_int;
                    skip = trivial;
                    if tag == TRNCS as libc::c_int {
                        other = blit >> RMSHFT as libc::c_int;
                        other2 = *p;
                        if lglval(lgl, other) as libc::c_int > 0 as libc::c_int
                            || lglval(lgl, other2) as libc::c_int > 0 as libc::c_int
                        {
                            skip = 1 as libc::c_int;
                        } else {
                            if lgltlval(lgl, other) > 0 as libc::c_int
                                || lgltlval(lgl, other2) > 0 as libc::c_int
                            {
                                trivial = 1 as libc::c_int;
                            }
                            lglpushstk(lgl, &mut (*lgl).clause, -lit);
                            lglpushstk(lgl, &mut (*lgl).clause, other);
                            lglpushstk(lgl, &mut (*lgl).clause, other2);
                        }
                    } else {
                        red = blit & REDCS as libc::c_int;
                        lidx = blit >> RMSHFT as libc::c_int;
                        trivial = 0 as libc::c_int;
                        found = trivial;
                        c = lglidx2lits(lgl, red, lidx);
                        (*(*lgl).stats).steps += 1;
                        (*(*lgl).stats).steps;
                        (*(*lgl).stats).prb.treelook.steps += 1;
                        (*(*lgl).stats).prb.treelook.steps;
                        q = c;
                        while skip == 0
                            && {
                                other = *q;
                                other != 0
                            }
                        {
                            if other
                                >= 2147483647 as libc::c_int >> RMSHFT as libc::c_int
                            {
                                skip = 1 as libc::c_int;
                            } else if lglval(lgl, other) as libc::c_int
                                > 0 as libc::c_int
                            {
                                skip = 1 as libc::c_int;
                            } else {
                                if other == -lit {
                                    found += 1;
                                    found;
                                }
                                if lgltlval(lgl, other) > 0 as libc::c_int {
                                    trivial = 1 as libc::c_int;
                                }
                                lglpushstk(lgl, &mut (*lgl).clause, other);
                            }
                            q = q.offset(1);
                            q;
                        }
                    }
                    implied = 0 as libc::c_int;
                    size = implied;
                    numfalse = size;
                    numnonfalse = numfalse;
                    firstfalse = 1 as libc::c_int;
                    if skip == 0 {
                        (*(*lgl).stats).steps += 1;
                        (*(*lgl).stats).steps;
                        (*(*lgl).stats).prb.treelook.steps += 1;
                        (*(*lgl).stats).prb.treelook.steps;
                        q = (*lgl).clause.start;
                        while q < (*lgl).clause.top as *const libc::c_int {
                            other = *q;
                            if !((lglval(lgl, other) as libc::c_int) < 0 as libc::c_int)
                            {
                                size += 1;
                                size;
                                val = lgltlval(lgl, other);
                                if val < 0 as libc::c_int {
                                    if !reducedptr.is_null() && -val < litval {
                                        firstfalse = 0 as libc::c_int;
                                    }
                                    numfalse += 1;
                                    numfalse;
                                } else {
                                    numnonfalse += 1;
                                    numnonfalse;
                                    if !(implied
                                        == 2147483647 as libc::c_int >> RMSHFT as libc::c_int)
                                    {
                                        if implied != 0 {
                                            implied = 2147483647 as libc::c_int
                                                >> RMSHFT as libc::c_int;
                                        } else {
                                            implied = other;
                                        }
                                    }
                                }
                            }
                            q = q.offset(1);
                            q;
                        }
                    }
                    lglclnstk(&mut (*lgl).clause);
                    if !(skip != 0) {
                        if !reducedptr.is_null() && firstfalse != 0 {
                            lglincreducedptr(lgl, reducedptr, size);
                        }
                        if !(trivial != 0) {
                            if numnonfalse == 0 {
                                return 0 as libc::c_int;
                            }
                            if !(implied
                                == 2147483647 as libc::c_int >> RMSHFT as libc::c_int)
                            {
                                if !(numfalse == 0) {
                                    (*(*lgl).stats).steps += 1;
                                    (*(*lgl).stats).steps;
                                    (*(*lgl).stats).prb.treelook.steps += 1;
                                    (*(*lgl).stats).prb.treelook.steps;
                                    if tag == TRNCS as libc::c_int {
                                        (*(*lgl).stats).hbr.trn += 1;
                                        (*(*lgl).stats).hbr.trn;
                                    } else {
                                        (*(*lgl).stats).hbr.lrg += 1;
                                        (*(*lgl).stats).hbr.lrg;
                                    }
                                    lgldrupligaddclsarg(
                                        lgl,
                                        REDCS as libc::c_int,
                                        -dom,
                                        implied,
                                        0 as libc::c_int,
                                    );
                                    lglwchbin(lgl, -dom, implied, REDCS as libc::c_int);
                                    lglwchbin(lgl, implied, -dom, REDCS as libc::c_int);
                                    (*(*lgl).stats).red.bin += 1;
                                    (*(*lgl).stats).red.bin;
                                    (*(*lgl).stats).hbr.cnt += 1;
                                    (*(*lgl).stats).hbr.cnt;
                                    (*(*lgl).stats).prgss += 1;
                                    (*(*lgl).stats).prgss;
                                    lgltlassign(lgl, assignment, implied);
                                    next -= 1;
                                    next;
                                    break;
                                }
                            }
                        }
                    }
                }
                p = p.offset(1);
                p;
            }
        }
    }
    if !reducedptr.is_null() {
        *((*(*lgl).c2rust_unnamed.tlk).lkhd).offset(dom as isize) = *reducedptr;
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn lgltreelooklit(
    mut lgl: *mut LGL,
    mut a: *mut Stk,
    mut r: *mut Ftk,
    mut lit: libc::c_int,
) {
    let mut reduced: Flt = 0;
    if lit != 0 {
        if (*(*lgl).opts).treelook.val >= 2 as libc::c_int && lglmtstk(a) != 0
            && lglisfree(lgl, lit) != 0
        {
            lglbasicprobelit(lgl, -lit);
        }
        if !r.is_null() {
            reduced = (if lglmtftk(r) != 0 {
                0 as libc::c_longlong
            } else {
                lgltopftk(r) as libc::c_longlong
            }) as Flt;
            lglpushftk(lgl, r, reduced);
        }
        lglpushstk(lgl, a, 0 as libc::c_int);
        if (*lgl).mt != 0 || lglisfree(lgl, lit) == 0 {
            return;
        }
        if lgltlval(lgl, -lit) > 0 as libc::c_int
            || lgltlval(lgl, lit) == 0
                && lgltlbcp(
                    lgl,
                    a,
                    (if !r.is_null() { &mut reduced } else { 0 as *mut Flt }),
                    lit,
                ) == 0
        {
            let mut tmp: libc::c_int = 0;
            tmp = lglval(lgl, lit) as libc::c_int;
            if tmp == 0 {
                (*(*lgl).stats).prb.treelook.failed += 1;
                (*(*lgl).stats).prb.treelook.failed;
                lglunit(lgl, -lit);
                if lglbcp(lgl) == 0 {
                    if (*lgl).mt == 0 {
                        lglmt(lgl);
                    }
                }
            } else if tmp > 0 as libc::c_int {
                (*(*lgl).stats).prb.treelook.failed += 1;
                (*(*lgl).stats).prb.treelook.failed;
                if (*lgl).mt == 0 {
                    lglmt(lgl);
                }
            }
        }
        if !r.is_null() {
            *((*r).top).offset(-(1 as libc::c_int) as isize) = reduced;
        }
    } else {
        if !r.is_null() {
            lglpopftk(r);
        }
        loop {
            lit = lglpopstk(a);
            if !(lit != 0) {
                break;
            }
            lgltlunassign(lgl, lit);
        }
    };
}
unsafe extern "C" fn lglsetprbtreelooklim(
    mut lgl: *mut LGL,
    mut lkhdresptr: *mut libc::c_int,
) -> int64_t {
    let mut szpen: libc::c_int = 0;
    let mut lastpen: libc::c_int = 0;
    let mut pen: libc::c_int = 0;
    let mut boost: libc::c_int = 0;
    let mut limit: int64_t = 0;
    let mut irrlim: int64_t = 0;
    if (*(*lgl).opts).treelookrtc.val != 0 || (*(*lgl).opts).prbrtc.val != 0 {
        (*(*lgl).limits).prb.steps = 0x7fffffffffffffff as libc::c_longlong as int64_t;
        limit = (*(*lgl).limits).prb.steps;
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[treelook-%d] really no limit (run to completion)\0" as *const u8
                as *const libc::c_char,
            (*(*lgl).stats).prb.treelook.count,
        );
    } else if !lkhdresptr.is_null() && (*(*lgl).opts).treelookfull.val != 0 {
        (*(*lgl).limits).prb.steps = 0x7fffffffffffffff as libc::c_longlong as int64_t;
        limit = (*(*lgl).limits).prb.steps;
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[treelook-%d] unlimited look-ahead requested\0" as *const u8
                as *const libc::c_char,
            (*(*lgl).stats).prb.treelook.count,
        );
    } else {
        limit = (*(*lgl).opts).treelookreleff.val as int64_t * lglvisearch(lgl)
            / 2000 as libc::c_int as int64_t;
        if limit < (*(*lgl).opts).treelookmineff.val as int64_t {
            limit = (*(*lgl).opts).treelookmineff.val as int64_t;
        }
        if (*(*lgl).opts).treelookmaxeff.val >= 0 as libc::c_int
            && limit > (*(*lgl).opts).treelookmaxeff.val as int64_t
        {
            limit = (*(*lgl).opts).treelookmaxeff.val as int64_t;
        }
        szpen = lglszpen(lgl);
        lastpen = if !((*(*lgl).c2rust_unnamed.tlk).lkhd).is_null() {
            (*(*lgl).limits).lkhdpen
        } else {
            (*(*lgl).limits).prb.treelook.pen
        };
        pen = szpen + lastpen;
        limit >>= pen;
        irrlim = ((*(*lgl).stats).irr.clauses.cur / 4 as libc::c_int >> szpen)
            as int64_t;
        if (*(*lgl).opts).boost.val != 0
            && !((*(*lgl).c2rust_unnamed.tlk).lkhd).is_null()
        {
            boost = (*(*lgl).opts).treelookboost.val;
        } else {
            boost = 1 as libc::c_int;
        }
        limit *= boost as int64_t;
        if (*(*lgl).opts).irrlim.val != 0 && limit < irrlim {
            limit = irrlim;
            lglprt(
                lgl,
                1 as libc::c_int,
                b"[treelook-%d] limit %lld based on %d irredundant clauses penalty %d\0"
                    as *const u8 as *const libc::c_char,
                (*(*lgl).stats).prb.treelook.count,
                limit as libc::c_longlong,
                (*(*lgl).stats).irr.clauses.cur,
                szpen,
            );
        } else {
            lglprt(
                lgl,
                1 as libc::c_int,
                b"[treelook-%d] limit %lld penalty %d = %d + %d boost %d\0" as *const u8
                    as *const libc::c_char,
                (*(*lgl).stats).prb.treelook.count,
                limit as libc::c_longlong,
                pen,
                lastpen,
                szpen,
                boost,
            );
        }
        if !lkhdresptr.is_null() {
            lglprt(
                lgl,
                1 as libc::c_int,
                b"[treelook-%d] limited look-ahead requested\0" as *const u8
                    as *const libc::c_char,
                (*(*lgl).stats).prb.treelook.count,
            );
        }
        (*(*lgl).limits).prb.steps = (*(*lgl).stats).prb.treelook.steps + limit;
    }
    return limit;
}
unsafe extern "C" fn lglclntlvals(mut lgl: *mut LGL) {
    let mut idx: libc::c_int = 0;
    idx = 2 as libc::c_int;
    while idx < (*lgl).nvars {
        let ref mut fresh164 = *((*(*lgl).c2rust_unnamed.tlk).tvars)
            .offset(idx as isize);
        (*fresh164).set_val(0 as libc::c_int);
        idx += 1;
        idx;
    }
}
unsafe extern "C" fn lgliblocking(
    mut lgl: *mut LGL,
    mut ilit: libc::c_int,
) -> libc::c_int {
    return (*lglelit2ext(lgl, lglexport(lgl, ilit))).blocking() as libc::c_int;
}
unsafe extern "C" fn lgltlsetlkhd(
    mut lgl: *mut LGL,
    mut lkhdresptr: *mut libc::c_int,
    mut remlits: libc::c_int,
) {
    let mut lkhdrescore: LKHD = 0;
    let mut lkhdscore: LKHD = 0;
    let mut lkhdpos: LKHD = 0;
    let mut lkhdneg: LKHD = 0;
    let mut jwhrescore: Flt = 0;
    let mut jwhscore: Flt = 0;
    let mut jwhpos: Flt = 0;
    let mut jwhneg: Flt = 0;
    let mut idx: libc::c_int = 0;
    let mut lkhdres: libc::c_int = 0;
    let mut phase: libc::c_int = 0;
    let mut elit: libc::c_int = 0;
    let mut ext: *mut Ext = 0 as *mut Ext;
    lkhdres = 0 as libc::c_int;
    lkhdrescore = 0 as libc::c_longlong as LKHD;
    jwhrescore = 0 as libc::c_longlong as Flt;
    lgljwh(lgl);
    let mut current_block_33: u64;
    idx = 2 as libc::c_int;
    while idx < (*lgl).nvars {
        if !(lglisfree(lgl, idx) == 0) {
            if !(!lkhdresptr.is_null() && lgliblocking(lgl, idx) != 0) {
                if remlits == 0 {
                    lkhdpos = *((*(*lgl).c2rust_unnamed.tlk).lkhd).offset(idx as isize);
                    lkhdneg = *((*(*lgl).c2rust_unnamed.tlk).lkhd).offset(-idx as isize);
                    lkhdscore = lglmulflt(lkhdneg, lkhdpos);
                    if lkhdscore as libc::c_longlong > 0 as libc::c_longlong {
                        lkhdscore = lgladdflt(lkhdscore, lgladdflt(lkhdneg, lkhdpos));
                    }
                } else {
                    lkhdneg = 0 as libc::c_longlong as LKHD;
                    lkhdpos = lkhdneg;
                    lkhdscore = lkhdpos;
                }
                jwhpos = *((*lgl).jwh).offset(lglulit(idx) as isize);
                jwhneg = *((*lgl).jwh).offset(lglulit(-idx) as isize);
                jwhscore = lglmulflt(jwhpos, jwhneg);
                jwhscore = lgladdflt(jwhscore, lgladdflt(jwhpos, jwhneg));
                if lkhdpos > lkhdneg {
                    phase = -(1 as libc::c_int);
                } else if lkhdpos < lkhdneg {
                    phase = 1 as libc::c_int;
                } else if jwhpos > jwhneg {
                    phase = 1 as libc::c_int;
                } else if jwhpos < jwhneg {
                    phase = -(1 as libc::c_int);
                } else {
                    phase = -(1 as libc::c_int);
                }
                if lkhdres != 0 {
                    if lkhdscore < lkhdrescore {
                        current_block_33 = 6873731126896040597;
                    } else if lkhdscore == lkhdrescore && jwhscore <= jwhrescore {
                        current_block_33 = 6873731126896040597;
                    } else {
                        current_block_33 = 11636175345244025579;
                    }
                } else {
                    current_block_33 = 11636175345244025579;
                }
                match current_block_33 {
                    6873731126896040597 => {}
                    _ => {
                        lkhdrescore = lkhdscore;
                        jwhrescore = jwhscore;
                        lkhdres = phase * idx;
                    }
                }
            }
        }
        idx += 1;
        idx;
    }
    if lkhdres != 0 {
        elit = lglexport(lgl, lkhdres);
        ext = lglelit2ext(lgl, elit);
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[treelook-%d] best look-ahead %d score [%s,%s]\0" as *const u8
                as *const libc::c_char,
            (*(*lgl).stats).prb.treelook.count,
            lkhdres,
            lglflt2str(lgl, lkhdrescore),
            lglflt2str(lgl, jwhrescore),
        );
        if (*ext).melted() != 0 {
            (*ext).set_melted(0 as libc::c_int as libc::c_uint);
        }
    }
    if !lkhdresptr.is_null() {
        *lkhdresptr = lkhdres;
    }
}
unsafe extern "C" fn lglgenericreport(
    mut lgl: *mut LGL,
    mut name: *const libc::c_char,
    mut count: libc::c_int,
    mut probed: libc::c_int,
    mut nprobes: libc::c_int,
    mut start: libc::c_double,
) {
    let mut div: libc::c_int = 0;
    let mut mod_0: libc::c_int = 0;
    if nprobes == 0 || (*(*lgl).opts).verbose.val < 2 as libc::c_int {
        return;
    }
    if (*(*lgl).opts).verbose.val == 2 as libc::c_int {
        div = 10 as libc::c_int;
    } else if (*(*lgl).opts).verbose.val == 3 as libc::c_int {
        div = 100 as libc::c_int;
    } else {
        div = 0 as libc::c_int;
    }
    mod_0 = if div != 0 {
        (nprobes + div - 1 as libc::c_int) / div
    } else {
        1 as libc::c_int
    };
    if probed % mod_0 != 0 {
        return;
    }
    lglprt(
        lgl,
        1 as libc::c_int,
        b"[%s-%d] probed %d/%d (%.0f%%) %.1f sec %d vars %.0f MB\0" as *const u8
            as *const libc::c_char,
        name,
        count,
        probed,
        nprobes,
        lglpcnt(probed as libc::c_double, nprobes as libc::c_double),
        lglgetime(lgl) - start,
        lglrem(lgl),
        lglmb(lgl),
    );
}
unsafe extern "C" fn lgltreelookreport(
    mut lgl: *mut LGL,
    mut probed: libc::c_int,
    mut nprobes: libc::c_int,
    mut start: libc::c_double,
) {
    lglgenericreport(
        lgl,
        b"treelook\0" as *const u8 as *const libc::c_char,
        (*(*lgl).stats).prb.treelook.count,
        probed,
        nprobes,
        start,
    );
}
unsafe extern "C" fn lgltreelookaux(
    mut lgl: *mut LGL,
    mut lkhdresptr: *mut libc::c_int,
) -> libc::c_int {
    let mut oldhbrs: libc::c_int = 0;
    let mut oldrem: libc::c_int = 0;
    let mut remvarsall: libc::c_int = 0;
    let mut remvarslkhd: libc::c_int = 0;
    let mut remlits: libc::c_int = 0;
    let mut notfullyscheduled: libc::c_int = 0;
    let mut deltavars: libc::c_int = 0;
    let mut newhbrs: libc::c_int = 0;
    let mut success: libc::c_int = 0;
    let mut idx: libc::c_int = 0;
    let mut next: libc::c_int = 0;
    let mut lit: libc::c_int = 0;
    let mut nseen: libc::c_int = 0;
    let mut oldsteps: int64_t = 0;
    let mut steps: int64_t = 0;
    let mut limit: int64_t = 0;
    let mut assignment: Stk = Stk {
        start: 0 as *mut libc::c_int,
        top: 0 as *mut libc::c_int,
        end: 0 as *mut libc::c_int,
    };
    let mut start: libc::c_double = 0.;
    let mut reduced: Ftk = Ftk {
        start: 0 as *mut Flt,
        top: 0 as *mut Flt,
        end: 0 as *mut Flt,
    };
    let mut tv: *mut TVar = 0 as *mut TVar;
    let mut av: *mut AVar = 0 as *mut AVar;
    if (*lgl).mt != 0 {
        return 0 as libc::c_int;
    }
    if !lkhdresptr.is_null() {
        *lkhdresptr = 0 as libc::c_int;
    }
    if (*lgl).nvars == 0 {
        return 1 as libc::c_int;
    }
    lglstart(lgl, &mut (*(*lgl).times).prb.treelook);
    (*(*lgl).stats).prb.treelook.count += 1;
    (*(*lgl).stats).prb.treelook.count;
    (*lgl)
        .c2rust_unnamed
        .tlk = lglnew(
        lgl,
        (1 as libc::c_int as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Tlk>() as libc::c_ulong),
    ) as *mut Tlk;
    (*(*lgl).c2rust_unnamed.tlk)
        .tvars = lglnew(
        lgl,
        ((*lgl).nvars as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<TVar>() as libc::c_ulong),
    ) as *mut TVar;
    (*lgl).treelooking = 1 as libc::c_int as libc::c_char;
    (*lgl).probing = (*lgl).treelooking as libc::c_int;
    (*lgl).simp = (*lgl).probing as libc::c_char;
    if (*lgl).level > 0 as libc::c_int {
        lglbacktrack(lgl, 0 as libc::c_int);
    }
    oldhbrs = (*(*lgl).stats).hbr.cnt;
    oldrem = lglrem(lgl);
    if !lkhdresptr.is_null() {
        (*(*lgl).c2rust_unnamed.tlk)
            .lkhd = lglnew(
            lgl,
            ((2 as libc::c_int * (*lgl).nvars) as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<LKHD>() as libc::c_ulong),
        ) as *mut LKHD;
        (*(*lgl).c2rust_unnamed.tlk)
            .lkhd = ((*(*lgl).c2rust_unnamed.tlk).lkhd).offset((*lgl).nvars as isize);
    }
    limit = lglsetprbtreelooklim(lgl, lkhdresptr);
    oldsteps = (*(*lgl).stats).prb.treelook.steps;
    lgltlsched(lgl);
    steps = (*(*lgl).stats).prb.treelook.steps - oldsteps;
    lglprt(
        lgl,
        1 as libc::c_int,
        b"[treelook-%d] scheduling used %lld steps\0" as *const u8
            as *const libc::c_char,
        (*(*lgl).stats).prb.treelook.count,
        steps as libc::c_longlong,
    );
    if limit as libc::c_longlong != 0x7fffffffffffffff as libc::c_longlong {
        notfullyscheduled = ((*(*lgl).stats).prb.treelook.steps
            >= (*(*lgl).limits).prb.steps) as libc::c_int;
        (*(*lgl).limits).prb.steps = (*(*lgl).stats).prb.treelook.steps + limit;
        if notfullyscheduled != 0 {
            lglprt(
                lgl,
                1 as libc::c_int,
                b"[treelook-%d] not fully scheduled\0" as *const u8
                    as *const libc::c_char,
                (*(*lgl).stats).prb.treelook.count,
            );
        } else {
            lglprt(
                lgl,
                1 as libc::c_int,
                b"[treelook-%d] scheduled completely\0" as *const u8
                    as *const libc::c_char,
                (*(*lgl).stats).prb.treelook.count,
            );
        }
    } else {
        notfullyscheduled = 0 as libc::c_int;
    }
    memset(
        &mut assignment as *mut Stk as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<Stk>() as libc::c_ulong,
    );
    memset(
        &mut reduced as *mut Ftk as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<Ftk>() as libc::c_ulong,
    );
    remvarslkhd = 0 as libc::c_int;
    remvarsall = remvarslkhd;
    remlits = remvarsall;
    nseen = lglcntstk(&mut (*(*lgl).c2rust_unnamed.tlk).seen) as libc::c_int;
    if (*lgl).mt == 0 && nseen != 0 {
        lglsetprbtreelooklim(lgl, lkhdresptr);
        oldsteps = (*(*lgl).stats).prb.treelook.steps;
        lgldense(lgl, 0 as libc::c_int);
        next = 0 as libc::c_int;
        start = lglgetime(lgl);
        lgltreelookreport(lgl, next, nseen, start);
        while (*lgl).mt == 0 && lglterminate(lgl) == 0 && lglsyncunits(lgl) != 0
            && next < nseen
            && (*(*lgl).stats).prb.treelook.steps < (*(*lgl).limits).prb.steps
        {
            let fresh165 = next;
            next = next + 1;
            lit = lglpeek(&mut (*(*lgl).c2rust_unnamed.tlk).seen, fresh165);
            lgltreelooklit(
                lgl,
                &mut assignment,
                if !lkhdresptr.is_null() { &mut reduced } else { 0 as *mut Ftk },
                lit,
            );
            lgltreelookreport(lgl, next, nseen, start);
        }
        lgltreelookreport(lgl, next, nseen, start);
        lglclntlvals(lgl);
        steps = (*(*lgl).stats).prb.treelook.steps - oldsteps;
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[treelook-%d] used %lld steps\0" as *const u8 as *const libc::c_char,
            (*(*lgl).stats).prb.treelook.count,
            steps as libc::c_longlong,
        );
        while next < lglcntstk(&mut (*(*lgl).c2rust_unnamed.tlk).seen) as libc::c_int {
            let fresh166 = next;
            next = next + 1;
            lit = lglpeek(&mut (*(*lgl).c2rust_unnamed.tlk).seen, fresh166);
            if lit == 0 {
                continue;
            }
            if lglisfree(lgl, lit) == 0 {
                continue;
            }
            remlits += 1;
            remlits;
            tv = lgltvar(lgl, lit);
            (*tv).set_val(1 as libc::c_int);
        }
        idx = 2 as libc::c_int;
        while idx < (*lgl).nvars {
            if lglisfree(lgl, idx) != 0 {
                tv = lgltvar(lgl, idx);
                av = lglavar(lgl, idx);
                if (*tv).val() != 0 {
                    (*tv).set_val(0 as libc::c_int);
                    if (*av).donotreelook() == 0 {
                        remvarsall += 1;
                        remvarsall;
                    }
                    remvarslkhd += 1;
                    remvarslkhd;
                } else if (*av).donotreelook() == 0 {
                    (*av).set_donotreelook(1 as libc::c_int as libc::c_uint);
                }
            }
            idx += 1;
            idx;
        }
        if remvarsall != 0 || notfullyscheduled != 0 {
            lglprt(
                lgl,
                1 as libc::c_int,
                b"[treelook-%d] %d literals remain %.0f%%%s\0" as *const u8
                    as *const libc::c_char,
                (*(*lgl).stats).prb.treelook.count,
                remlits,
                lglpcnt(
                    remlits as libc::c_double,
                    (2 as libc::c_int * lglrem(lgl)) as libc::c_double,
                ),
                if !lkhdresptr.is_null() {
                    b" in look-ahead\0" as *const u8 as *const libc::c_char
                } else {
                    b"\0" as *const u8 as *const libc::c_char
                },
            );
            if !lkhdresptr.is_null() {
                lglprt(
                    lgl,
                    1 as libc::c_int,
                    b"[treelook-%d] %d look-ahead variables remain %.0f%%\0" as *const u8
                        as *const libc::c_char,
                    (*(*lgl).stats).prb.treelook.count,
                    remvarslkhd,
                    lglpcnt(remvarslkhd as libc::c_double, lglrem(lgl) as libc::c_double),
                );
            }
            lglprt(
                lgl,
                1 as libc::c_int,
                b"[treelook-%d] %d variables remain to probed next time %.0f%%\0"
                    as *const u8 as *const libc::c_char,
                (*(*lgl).stats).prb.treelook.count,
                remvarsall,
                lglpcnt(remvarsall as libc::c_double, lglrem(lgl) as libc::c_double),
            );
        } else {
            lglprt(
                lgl,
                1 as libc::c_int,
                b"[treelook-%d] fully completed tree based probing%s\0" as *const u8
                    as *const libc::c_char,
                (*(*lgl).stats).prb.treelook.count,
                if !lkhdresptr.is_null() {
                    b" in look-ahead\0" as *const u8 as *const libc::c_char
                } else {
                    b"\0" as *const u8 as *const libc::c_char
                },
            );
            idx = 2 as libc::c_int;
            while idx < (*lgl).nvars {
                let ref mut fresh167 = *lglavar(lgl, idx);
                (*fresh167).set_donotreelook(0 as libc::c_int as libc::c_uint);
                idx += 1;
                idx;
            }
        }
        lglsparse(lgl);
    }
    lgldel(
        lgl,
        (*(*lgl).c2rust_unnamed.tlk).tvars as *mut libc::c_void,
        ((*lgl).nvars as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<TVar>() as libc::c_ulong),
    );
    (*(*lgl).c2rust_unnamed.tlk).tvars = 0 as *mut TVar;
    lglgc(lgl);
    lglrelftk(lgl, &mut reduced);
    lglrelstk(lgl, &mut assignment);
    lglrelstk(lgl, &mut (*(*lgl).c2rust_unnamed.tlk).seen);
    if (*lgl).mt == 0 && !lkhdresptr.is_null() {
        lgltlsetlkhd(
            lgl,
            lkhdresptr,
            (remlits != 0 || notfullyscheduled != 0) as libc::c_int,
        );
    }
    if !((*(*lgl).c2rust_unnamed.tlk).lkhd).is_null() {
        (*(*lgl).c2rust_unnamed.tlk)
            .lkhd = ((*(*lgl).c2rust_unnamed.tlk).lkhd).offset(-((*lgl).nvars as isize));
        lgldel(
            lgl,
            (*(*lgl).c2rust_unnamed.tlk).lkhd as *mut libc::c_void,
            ((2 as libc::c_int * (*lgl).nvars) as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<LKHD>() as libc::c_ulong),
        );
        (*(*lgl).c2rust_unnamed.tlk).lkhd = 0 as *mut LKHD;
    }
    lgldel(
        lgl,
        (*lgl).c2rust_unnamed.tlk as *mut libc::c_void,
        (1 as libc::c_int as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Tlk>() as libc::c_ulong),
    );
    (*lgl).c2rust_unnamed.tlk = 0 as *mut Tlk;
    newhbrs = (*(*lgl).stats).hbr.cnt - oldhbrs;
    if newhbrs != 0 && (*lgl).mt == 0 && lkhdresptr.is_null() {
        lgldecomp(lgl);
    }
    (*lgl).treelooking = 0 as libc::c_int as libc::c_char;
    (*lgl).probing = (*lgl).treelooking as libc::c_int;
    (*lgl).simp = (*lgl).probing as libc::c_char;
    deltavars = oldrem - lglrem(lgl);
    success = (deltavars != 0 || newhbrs != 0) as libc::c_int;
    if lkhdresptr.is_null() {
        if deltavars != 0 && (*(*lgl).limits).prb.treelook.pen != 0 {
            (*(*lgl).limits).prb.treelook.pen -= 1;
            (*(*lgl).limits).prb.treelook.pen;
        }
        if deltavars == 0
            && (*(*lgl).limits).prb.treelook.pen < (*(*lgl).opts).penmax.val
        {
            (*(*lgl).limits).prb.treelook.pen += 1;
            (*(*lgl).limits).prb.treelook.pen;
        }
        if deltavars != 0 && (*(*lgl).limits).prb.treelook.del.cur != 0 {
            (*(*lgl).limits).prb.treelook.del.cur /= 2 as libc::c_int;
        }
        if deltavars == 0
            && (*(*lgl).limits).prb.treelook.del.cur < (*(*lgl).opts).delmax.val
        {
            (*(*lgl).limits).prb.treelook.del.cur += 1;
            (*(*lgl).limits).prb.treelook.del.cur;
        }
        (*(*lgl).limits).prb.treelook.del.rem = (*(*lgl).limits).prb.treelook.del.cur;
    } else if remlits != 0 && (*(*lgl).limits).lkhdpen < (*(*lgl).opts).penmax.val {
        (*(*lgl).limits).lkhdpen += 1;
        (*(*lgl).limits).lkhdpen;
    } else if remlits == 0 && (*(*lgl).limits).lkhdpen != 0 {
        (*(*lgl).limits).lkhdpen -= 1;
        (*(*lgl).limits).lkhdpen;
    }
    lglprt(
        lgl,
        1 as libc::c_int + (success == 0) as libc::c_int,
        b"[treelook-%d] removed %d variables, found %d hbrs\0" as *const u8
            as *const libc::c_char,
        (*(*lgl).stats).prb.treelook.count,
        deltavars,
        newhbrs,
    );
    lglrep(lgl, 2 as libc::c_int, 'p' as i32 as libc::c_char);
    lglstop(lgl);
    lglbasicatestats(lgl);
    return ((*lgl).mt == 0) as libc::c_int;
}
unsafe extern "C" fn lgltreelook(mut lgl: *mut LGL) -> libc::c_int {
    if lgldelaying(
        lgl,
        b"treelook\0" as *const u8 as *const libc::c_char,
        &mut (*(*lgl).limits).prb.treelook.del.rem,
    ) != 0
    {
        return 1 as libc::c_int;
    }
    return lgltreelookaux(lgl, 0 as *mut libc::c_int);
}
unsafe extern "C" fn lgljwhlook(mut lgl: *mut LGL) -> libc::c_int {
    let mut best: Flt = 0;
    let mut pos: Flt = 0;
    let mut neg: Flt = 0;
    let mut score: Flt = 0;
    let mut res: libc::c_int = 0;
    let mut idx: libc::c_int = 0;
    let mut elit: libc::c_int = 0;
    let mut ext: *mut Ext = 0 as *mut Ext;
    lgljwh(lgl);
    best = 0 as libc::c_longlong as Flt;
    res = 0 as libc::c_int;
    idx = 2 as libc::c_int;
    while idx < (*lgl).nvars {
        if !(lglisfree(lgl, idx) == 0) {
            if !(lgliblocking(lgl, idx) != 0) {
                pos = *((*lgl).jwh).offset(lglulit(idx) as isize);
                neg = *((*lgl).jwh).offset(lglulit(-idx) as isize);
                score = lglmulflt(pos, neg);
                score = lgladdflt(score, lgladdflt(pos, neg));
                if !(res != 0 && score <= best) {
                    res = if pos > neg { idx } else { -idx };
                    best = score;
                }
            }
        }
        idx += 1;
        idx;
    }
    if res != 0 {
        elit = lglexport(lgl, res);
        ext = lglelit2ext(lgl, elit);
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[jwhlook] best look-ahead %d score %s\0" as *const u8
                as *const libc::c_char,
            res,
            lglflt2str(lgl, best),
        );
        if (*ext).melted() != 0 {
            (*ext).set_melted(0 as libc::c_int as libc::c_uint);
        }
    }
    return res;
}
unsafe extern "C" fn lglislook(mut lgl: *mut LGL) -> libc::c_int {
    let mut best: int64_t = 0;
    let mut pos: int64_t = 0;
    let mut neg: int64_t = 0;
    let mut score: int64_t = 0;
    let mut res: libc::c_int = 0;
    let mut idx: libc::c_int = 0;
    let mut elit: libc::c_int = 0;
    let mut scores: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut ext: *mut Ext = 0 as *mut Ext;
    scores = lglis(lgl);
    res = 0 as libc::c_int;
    best = res as int64_t;
    idx = 2 as libc::c_int;
    while idx < (*lgl).nvars {
        if !(lglisfree(lgl, idx) == 0) {
            if !(lgliblocking(lgl, idx) != 0) {
                pos = *scores.offset(idx as isize) as int64_t;
                neg = *scores.offset(-idx as isize) as int64_t;
                score = pos * neg + pos + neg;
                if !(res != 0 && score <= best) {
                    res = if pos > neg { idx } else { -idx };
                    best = score;
                }
            }
        }
        idx += 1;
        idx;
    }
    scores = scores.offset(-((*lgl).nvars as isize));
    lgldel(
        lgl,
        scores as *mut libc::c_void,
        ((2 as libc::c_int * (*lgl).nvars) as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
    );
    scores = 0 as *mut libc::c_int;
    if res != 0 {
        elit = lglexport(lgl, res);
        ext = lglelit2ext(lgl, elit);
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[lislook] best LIS look-ahead %d score %lld\0" as *const u8
                as *const libc::c_char,
            res,
            best as libc::c_longlong,
        );
        if (*ext).melted() != 0 {
            (*ext).set_melted(0 as libc::c_int as libc::c_uint);
        }
    }
    return res;
}
unsafe extern "C" fn lglrelevancelook(mut lgl: *mut LGL) -> libc::c_int {
    let mut res: libc::c_int = 0;
    let mut elit: libc::c_int = 0;
    let mut ext: *mut Ext = 0 as *mut Ext;
    if (*lgl).unassigned == 0 {
        return 0 as libc::c_int;
    }
    res = lglnextdecision(lgl, 1 as libc::c_int);
    if res != 0 {
        elit = lglexport(lgl, res);
        ext = lglelit2ext(lgl, elit);
        if (*ext).eliminated() as libc::c_int != 0
            || (*ext).blocking() as libc::c_int != 0
        {
            res = 0 as libc::c_int;
        } else {
            res = lgldecidephase(lgl, res);
            lglprt(
                lgl,
                1 as libc::c_int,
                b"[lislook] best relevance look-ahead %d\0" as *const u8
                    as *const libc::c_char,
                res,
            );
            if (*ext).melted() != 0 {
                (*ext).set_melted(0 as libc::c_int as libc::c_uint);
            }
        }
    }
    return res;
}
unsafe extern "C" fn lglsatmul64(mut a: int64_t, mut b: int64_t) -> int64_t {
    return (if b != 0
        && (0x7fffffffffffffff as libc::c_longlong / b as libc::c_longlong)
            < a as libc::c_longlong
    {
        0x7fffffffffffffff as libc::c_longlong
    } else {
        (a * b) as libc::c_longlong
    }) as int64_t;
}
unsafe extern "C" fn lglsatadd64(mut a: int64_t, mut b: int64_t) -> int64_t {
    return (if (0x7fffffffffffffff as libc::c_longlong - b as libc::c_longlong)
        < a as libc::c_longlong
    {
        0x7fffffffffffffff as libc::c_longlong
    } else {
        (a + b) as libc::c_longlong
    }) as int64_t;
}
unsafe extern "C" fn lglsumlenscores(mut lgl: *mut LGL) -> *mut int64_t {
    let mut idx: libc::c_int = 0;
    let mut sign: libc::c_int = 0;
    let mut lit: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut blit: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut other2: libc::c_int = 0;
    let mut red: libc::c_int = 0;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut w: *const libc::c_int = 0 as *const libc::c_int;
    let mut eow: *const libc::c_int = 0 as *const libc::c_int;
    let mut c: *const libc::c_int = 0 as *const libc::c_int;
    let mut res: *mut int64_t = 0 as *mut int64_t;
    let mut len: int64_t = 0;
    let mut val: Val = 0;
    let mut tmp: Val = 0;
    let mut tmp2: Val = 0;
    let mut hts: *mut HTS = 0 as *mut HTS;
    let mut s: *mut Stk = 0 as *mut Stk;
    res = lglnew(
        lgl,
        ((2 as libc::c_int * (*lgl).nvars) as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<int64_t>() as libc::c_ulong),
    ) as *mut int64_t;
    res = res.offset((*lgl).nvars as isize);
    idx = 2 as libc::c_int;
    while idx < (*lgl).nvars {
        sign = -(1 as libc::c_int);
        while sign <= 1 as libc::c_int {
            lit = sign * idx;
            val = lglval(lgl, lit);
            if !(val as libc::c_int > 0 as libc::c_int) {
                hts = lglhts(lgl, lit);
                if !((*hts).offset == 0) {
                    w = lglhts2wchs(lgl, hts);
                    eow = w.offset((*hts).count as isize);
                    p = w;
                    while p < eow {
                        blit = *p;
                        tag = blit & MASKCS as libc::c_int;
                        if tag == TRNCS as libc::c_int || tag == LRGCS as libc::c_int {
                            p = p.offset(1);
                            p;
                        }
                        if !(tag == LRGCS as libc::c_int) {
                            red = blit & REDCS as libc::c_int;
                            if !(red != 0) {
                                other = blit >> RMSHFT as libc::c_int;
                                if !(abs(other) < abs(lit)) {
                                    tmp = lglval(lgl, other);
                                    if !(tmp as libc::c_int > 0 as libc::c_int) {
                                        if tag == BINCS as libc::c_int {
                                            *res.offset(lit as isize) += 2 as libc::c_int as int64_t;
                                            *res.offset(other as isize) += 2 as libc::c_int as int64_t;
                                        } else {
                                            other2 = *p;
                                            if !(abs(other2) < abs(lit)) {
                                                tmp2 = lglval(lgl, other2);
                                                if !(tmp2 as libc::c_int > 0 as libc::c_int) {
                                                    len = ((val == 0) as libc::c_int + (tmp == 0) as libc::c_int
                                                        + (tmp2 == 0) as libc::c_int) as int64_t;
                                                    if val == 0 {
                                                        *res.offset(lit as isize) += len;
                                                    }
                                                    if tmp == 0 {
                                                        *res.offset(other as isize) += len;
                                                    }
                                                    if tmp2 == 0 {
                                                        *res.offset(other2 as isize) += len;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        p = p.offset(1);
                        p;
                    }
                }
            }
            sign += 2 as libc::c_int;
        }
        idx += 1;
        idx;
    }
    s = &mut (*lgl).irr;
    c = (*s).start;
    while c < (*s).top as *const libc::c_int {
        p = c;
        if !(*p >= 2147483647 as libc::c_int >> RMSHFT as libc::c_int) {
            val = -(1 as libc::c_int) as Val;
            len = 0 as libc::c_int as int64_t;
            loop {
                other = *p;
                if !(other != 0) {
                    break;
                }
                tmp = lglval(lgl, other);
                if tmp as libc::c_int > val as libc::c_int {
                    val = tmp;
                }
                if tmp == 0 {
                    len += 1;
                    len;
                }
                p = p.offset(1);
                p;
            }
            if !(val as libc::c_int > 0 as libc::c_int) {
                p = c;
                loop {
                    other = *p;
                    if !(other != 0) {
                        break;
                    }
                    if lglval(lgl, other) == 0 {
                        *res.offset(other as isize) += len;
                    }
                    p = p.offset(1);
                    p;
                }
            }
        }
        c = p.offset(1 as libc::c_int as isize);
    }
    return res;
}
unsafe extern "C" fn lglsumlenlook(mut lgl: *mut LGL) -> libc::c_int {
    let mut best: int64_t = 0;
    let mut pos: int64_t = 0;
    let mut neg: int64_t = 0;
    let mut score: int64_t = 0;
    let mut scores: *mut int64_t = 0 as *mut int64_t;
    let mut res: libc::c_int = 0;
    let mut idx: libc::c_int = 0;
    let mut elit: libc::c_int = 0;
    let mut ext: *mut Ext = 0 as *mut Ext;
    scores = lglsumlenscores(lgl);
    res = 0 as libc::c_int;
    best = res as int64_t;
    idx = 2 as libc::c_int;
    while idx < (*lgl).nvars {
        if !(lglisfree(lgl, idx) == 0) {
            if !(lgliblocking(lgl, idx) != 0) {
                pos = *scores.offset(idx as isize);
                neg = *scores.offset(-idx as isize);
                score = lglsatadd64(lglsatmul64(pos, neg), lglsatadd64(pos, neg));
                if !(res != 0 && score <= best) {
                    res = if pos > neg { idx } else { -idx };
                    best = score;
                }
            }
        }
        idx += 1;
        idx;
    }
    scores = scores.offset(-((*lgl).nvars as isize));
    lgldel(
        lgl,
        scores as *mut libc::c_void,
        ((2 as libc::c_int * (*lgl).nvars) as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<int64_t>() as libc::c_ulong),
    );
    scores = 0 as *mut int64_t;
    if res != 0 {
        elit = lglexport(lgl, res);
        ext = lglelit2ext(lgl, elit);
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[sumlook] best look-ahead %d score %lld\0" as *const u8
                as *const libc::c_char,
            res,
            best as libc::c_longlong,
        );
        if (*ext).melted() != 0 {
            (*ext).set_melted(0 as libc::c_int as libc::c_uint);
        }
    }
    return res;
}
unsafe extern "C" fn lglschedbasicprobe(
    mut lgl: *mut LGL,
    mut probes: *mut Stk,
    mut round: libc::c_int,
) -> libc::c_int {
    let mut idx: libc::c_int = 0;
    let mut res: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut donotbasicprobes: libc::c_int = 0;
    let mut keepscheduled: libc::c_int = 0;
    idx = 2 as libc::c_int;
    while idx < (*lgl).nvars {
        if !(lglisfree(lgl, idx) == 0) {
            if !((*(*lgl).opts).prbasic.val <= 1 as libc::c_int
                && lglhasbins(lgl, idx) == lglhasbins(lgl, -idx))
            {
                lglpushstk(lgl, probes, idx);
            }
        }
        idx += 1;
        idx;
    }
    res = lglcntstk(probes) as libc::c_int;
    keepscheduled = 0 as libc::c_int;
    donotbasicprobes = keepscheduled;
    i = 0 as libc::c_int;
    while i < res {
        idx = lglpeek(probes, i);
        if !(idx == 0) {
            if (*lglavar(lgl, idx)).donotbasicprobe() != 0 {
                donotbasicprobes += 1;
                donotbasicprobes;
            } else {
                keepscheduled += 1;
                keepscheduled;
            }
        }
        i += 1;
        i;
    }
    if keepscheduled == 0 {
        i = 0 as libc::c_int;
        while i < res {
            idx = lglpeek(probes, i);
            if !(idx == 0) {
                let ref mut fresh168 = *lglavar(lgl, idx);
                (*fresh168).set_donotbasicprobe(0 as libc::c_int as libc::c_uint);
                keepscheduled += 1;
                keepscheduled;
            }
            i += 1;
            i;
        }
        donotbasicprobes = 0 as libc::c_int;
    }
    i = 0 as libc::c_int;
    while i < res {
        idx = lglpeek(probes, i);
        if !(idx == 0) {
            if (*lglavar(lgl, idx)).donotbasicprobe() != 0 {
                donotbasicprobes += 1;
                donotbasicprobes;
            } else {
                keepscheduled += 1;
                keepscheduled;
            }
        }
        i += 1;
        i;
    }
    j = 0 as libc::c_int;
    i = 0 as libc::c_int;
    while i < res {
        idx = lglpeek(probes, i);
        if !(idx == 0) {
            if (*lglavar(lgl, idx)).donotbasicprobe() == 0 {
                let fresh169 = j;
                j = j + 1;
                lglpoke(probes, fresh169, idx);
            }
        }
        i += 1;
        i;
    }
    res = j;
    lglrststk(probes, res);
    if res == 0 {
        lglprt(
            lgl,
            2 as libc::c_int,
            b"[basicprobe-%d-%d] no potential probes found\0" as *const u8
                as *const libc::c_char,
            (*(*lgl).stats).prb.basic.count,
            round,
        );
    } else if donotbasicprobes == 0 {
        lglprt(
            lgl,
            2 as libc::c_int,
            b"[basicprobe-%d-%d] scheduled all %d potential probes\0" as *const u8
                as *const libc::c_char,
            (*(*lgl).stats).prb.basic.count,
            round,
            res,
        );
    } else {
        lglprt(
            lgl,
            2 as libc::c_int,
            b"[basicprobe-%d-%d] scheduled %d probes %.0f%%\0" as *const u8
                as *const libc::c_char,
            (*(*lgl).stats).prb.basic.count,
            round,
            res,
            lglpcnt(res as libc::c_double, lglrem(lgl) as libc::c_double),
        );
    }
    return res;
}
unsafe extern "C" fn lglsetprbasiclim(mut lgl: *mut LGL) {
    let mut limit: int64_t = 0;
    let mut irrlim: int64_t = 0;
    let mut pen: libc::c_int = 0;
    let mut szpen: libc::c_int = 0;
    if (*(*lgl).opts).prbasicrtc.val != 0 || (*(*lgl).opts).prbrtc.val != 0 {
        (*(*lgl).limits).prb.steps = 0x7fffffffffffffff as libc::c_longlong as int64_t;
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[basicprobe-%d] really no limit (run to completion)\0" as *const u8
                as *const libc::c_char,
            (*(*lgl).stats).prb.basic.count,
        );
    } else {
        limit = (*(*lgl).opts).prbasicreleff.val as int64_t * lglvisearch(lgl)
            / 1000 as libc::c_int as int64_t;
        if limit < (*(*lgl).opts).prbasicmineff.val as int64_t {
            limit = (*(*lgl).opts).prbasicmineff.val as int64_t;
        }
        if (*(*lgl).opts).prbasicmaxeff.val >= 0 as libc::c_int
            && limit > (*(*lgl).opts).prbasicmaxeff.val as int64_t
        {
            limit = (*(*lgl).opts).prbasicmaxeff.val as int64_t;
        }
        szpen = lglszpen(lgl);
        pen = (*(*lgl).limits).prb.basic.pen + szpen;
        limit >>= pen;
        irrlim = (8 as libc::c_int * (*(*lgl).stats).irr.clauses.cur >> szpen)
            as int64_t;
        if (*(*lgl).opts).irrlim.val != 0 && limit < irrlim {
            limit = irrlim;
            lglprt(
                lgl,
                1 as libc::c_int,
                b"[basicprobe-%d] limit %lld based on %d irredundant clauses penalty %d\0"
                    as *const u8 as *const libc::c_char,
                (*(*lgl).stats).prb.basic.count,
                limit as libc::c_longlong,
                (*(*lgl).stats).irr.clauses.cur,
                szpen,
            );
        } else {
            lglprt(
                lgl,
                1 as libc::c_int,
                b"[basicprobe-%d] limit %lld penalty %d = %d + %d\0" as *const u8
                    as *const libc::c_char,
                (*(*lgl).stats).prb.basic.count,
                limit as libc::c_longlong,
                pen,
                (*(*lgl).limits).prb.basic.pen,
                szpen,
            );
        }
        (*(*lgl).limits).prb.steps = (*(*lgl).stats).prb.basic.steps + limit;
    };
}
unsafe extern "C" fn lglbasicprobereport(
    mut lgl: *mut LGL,
    mut probed: libc::c_int,
    mut nprobes: libc::c_int,
    mut start: libc::c_double,
) {
    lglgenericreport(
        lgl,
        b"basicprobe\0" as *const u8 as *const libc::c_char,
        (*(*lgl).stats).prb.basic.count,
        probed,
        nprobes,
        start,
    );
}
unsafe extern "C" fn lglbasicprobe(mut lgl: *mut LGL) -> libc::c_int {
    let mut origfailed: libc::c_int = (*(*lgl).stats).prb.basic.failed;
    let mut origlifted: libc::c_int = (*(*lgl).stats).prb.basic.lifted;
    let mut orighbr: libc::c_int = (*(*lgl).stats).hbr.cnt;
    let mut root: libc::c_int = 0;
    let mut failed: libc::c_int = 0;
    let mut lifted: libc::c_int = 0;
    let mut units: libc::c_int = 0;
    let mut first: libc::c_int = 0;
    let mut idx: libc::c_int = 0;
    let mut oldrem: libc::c_int = 0;
    let mut deltarem: libc::c_int = 0;
    let mut deltahbr: libc::c_int = 0;
    let mut remprobes: libc::c_int = 0;
    let mut nprobes: libc::c_int = 0;
    let mut success: libc::c_int = 0;
    let mut round: libc::c_int = 0;
    let mut probed: libc::c_int = 0;
    let mut oldhbr: libc::c_int = 0;
    let mut oldfailed: libc::c_int = 0;
    let mut oldlifted: libc::c_int = 0;
    let mut probes: Stk = Stk {
        start: 0 as *mut libc::c_int,
        top: 0 as *mut libc::c_int,
        end: 0 as *mut libc::c_int,
    };
    let mut lift: Stk = Stk {
        start: 0 as *mut libc::c_int,
        top: 0 as *mut libc::c_int,
        end: 0 as *mut libc::c_int,
    };
    let mut saved: Stk = Stk {
        start: 0 as *mut libc::c_int,
        top: 0 as *mut libc::c_int,
        end: 0 as *mut libc::c_int,
    };
    let mut pos: libc::c_uint = 0;
    let mut delta: libc::c_uint = 0;
    let mut start: libc::c_double = 0.;
    if (*lgl).nvars == 0 {
        return 1 as libc::c_int;
    }
    if (*(*lgl).opts).probe.val == 0 {
        return 1 as libc::c_int;
    }
    if lgldelaying(
        lgl,
        b"basicprobe\0" as *const u8 as *const libc::c_char,
        &mut (*(*lgl).limits).prb.basic.del.rem,
    ) != 0
    {
        return 1 as libc::c_int;
    }
    lglstart(lgl, &mut (*(*lgl).times).prb.basic);
    (*(*lgl).stats).prb.basic.count += 1;
    (*(*lgl).stats).prb.basic.count;
    if (*lgl).level > 0 as libc::c_int {
        lglbacktrack(lgl, 0 as libc::c_int);
    }
    (*lgl).basicprobing = 1 as libc::c_int as libc::c_char;
    (*lgl).probing = (*lgl).basicprobing as libc::c_int;
    (*lgl).simp = (*lgl).probing as libc::c_char;
    memset(
        &mut lift as *mut Stk as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<Stk>() as libc::c_ulong,
    );
    memset(
        &mut probes as *mut Stk as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<Stk>() as libc::c_ulong,
    );
    memset(
        &mut saved as *mut Stk as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<Stk>() as libc::c_ulong,
    );
    lglsetprbasiclim(lgl);
    oldfailed = origfailed;
    oldlifted = origlifted;
    oldhbr = (*(*lgl).stats).hbr.cnt;
    oldrem = lglrem(lgl);
    round = 0 as libc::c_int;
    loop {
        nprobes = lglschedbasicprobe(lgl, &mut probes, round);
        remprobes = 0 as libc::c_int;
        if nprobes == 0 {
            break;
        }
        pos = (lglrand(lgl)).wrapping_rem(nprobes as libc::c_uint);
        delta = (lglrand(lgl)).wrapping_rem(nprobes as libc::c_uint);
        if delta == 0 {
            delta = delta.wrapping_add(1);
            delta;
        }
        probed = 0 as libc::c_int;
        start = lglgetime(lgl);
        lglbasicprobereport(lgl, probed, nprobes, start);
        while lglgcd(delta, nprobes as libc::c_uint) > 1 as libc::c_int as libc::c_uint {
            delta = delta.wrapping_add(1);
            if delta as libc::c_int == nprobes {
                delta = 1 as libc::c_int as libc::c_uint;
            }
        }
        first = 0 as libc::c_int;
        while (*lgl).mt == 0 {
            if (*(*lgl).stats).prb.basic.steps >= (*(*lgl).limits).prb.steps {
                break;
            }
            if lglterminate(lgl) != 0 {
                break;
            }
            if lglsyncunits(lgl) == 0 {
                break;
            }
            root = *(probes.start).offset(pos as isize);
            *(probes.start).offset(pos as isize) = 0 as libc::c_int;
            if root == 0 || root == first {
                lglprt(
                    lgl,
                    1 as libc::c_int,
                    b"[basicprobe-%d-%d] %d sched %.0f%%, %d failed, %d lifted, %d hbrs\0"
                        as *const u8 as *const libc::c_char,
                    (*(*lgl).stats).prb.basic.count,
                    round,
                    nprobes,
                    lglpcnt(nprobes as libc::c_double, lglrem(lgl) as libc::c_double),
                    (*(*lgl).stats).prb.basic.failed - oldfailed,
                    (*(*lgl).stats).prb.basic.lifted - oldlifted,
                    (*(*lgl).stats).hbr.cnt - oldhbr,
                );
                idx = 2 as libc::c_int;
                while idx < (*lgl).nvars {
                    let ref mut fresh170 = *lglavar(lgl, idx);
                    (*fresh170).set_donotbasicprobe(0 as libc::c_int as libc::c_uint);
                    idx += 1;
                    idx;
                }
                break;
            } else {
                let ref mut fresh171 = *lglavar(lgl, root);
                (*fresh171).set_donotbasicprobe(1 as libc::c_int as libc::c_uint);
                if first == 0 {
                    first = root;
                }
                pos = pos.wrapping_add(delta);
                if pos as libc::c_int >= nprobes {
                    pos = pos.wrapping_sub(nprobes as libc::c_uint);
                }
                if lglisfree(lgl, root) == 0 {
                    continue;
                }
                probed += 1;
                lglbasicprobereport(lgl, probed, nprobes, start);
                lglbasicprobelit(lgl, root);
            }
        }
        lglbasicprobereport(lgl, probed, nprobes, start);
        if !((*lgl).mt == 0) {
            break;
        }
        if (*(*lgl).stats).prb.basic.steps >= (*(*lgl).limits).prb.steps {
            while lglmtstk(&mut probes) == 0 {
                idx = lglpopstk(&mut probes);
                if idx != 0 && lglisfree(lgl, idx) != 0 {
                    remprobes += 1;
                    remprobes;
                }
            }
            lglprt(
                lgl,
                1 as libc::c_int,
                b"[basicprobe-%d-%d] %d probes remain %.0f%% after last round\0"
                    as *const u8 as *const libc::c_char,
                (*(*lgl).stats).prb.basic.count,
                round,
                remprobes,
                lglpcnt(remprobes as libc::c_double, lglrem(lgl) as libc::c_double),
            );
            break;
        } else if round >= (*(*lgl).opts).prbasicroundlim.val {
            lglprt(
                lgl,
                1 as libc::c_int,
                b"[basicprobe-%d-%d] round limit %d hit\0" as *const u8
                    as *const libc::c_char,
                (*(*lgl).stats).prb.basic.count,
                round,
                (*(*lgl).opts).prbasicroundlim.val,
            );
            break;
        } else if (*(*lgl).stats).prb.basic.failed > oldfailed
            || (*(*lgl).stats).prb.basic.lifted > oldlifted
            || (*(*lgl).stats).hbr.cnt > oldhbr
        {
            oldfailed = (*(*lgl).stats).prb.basic.failed;
            oldlifted = (*(*lgl).stats).prb.basic.lifted;
            lglclnstk(&mut probes);
            if oldhbr < (*(*lgl).stats).hbr.cnt && (*(*lgl).opts).decompose.val != 0 {
                if lgldecomp(lgl) == 0 {
                    break;
                }
            }
            oldhbr = (*(*lgl).stats).hbr.cnt;
            round += 1;
            round;
        } else {
            lglprt(
                lgl,
                1 as libc::c_int,
                b"[basicprobe-%d-%d] fully completed probing\0" as *const u8
                    as *const libc::c_char,
                (*(*lgl).stats).prb.basic.count,
                round,
            );
            idx = 2 as libc::c_int;
            while idx < (*lgl).nvars {
                let ref mut fresh172 = *lglavar(lgl, idx);
                (*fresh172).set_donotbasicprobe(0 as libc::c_int as libc::c_uint);
                idx += 1;
                idx;
            }
            break;
        }
    }
    lglrelstk(lgl, &mut lift);
    lglrelstk(lgl, &mut probes);
    lglrelstk(lgl, &mut saved);
    deltarem = oldrem - lglrem(lgl);
    deltahbr = (*(*lgl).stats).hbr.cnt - orighbr;
    success = (deltarem != 0 || deltahbr != 0) as libc::c_int;
    if deltarem != 0 && (*(*lgl).limits).prb.basic.pen != 0 {
        (*(*lgl).limits).prb.basic.pen -= 1;
        (*(*lgl).limits).prb.basic.pen;
    }
    if deltarem == 0 && (*(*lgl).limits).prb.basic.pen < (*(*lgl).opts).penmax.val {
        (*(*lgl).limits).prb.basic.pen += 1;
        (*(*lgl).limits).prb.basic.pen;
    }
    if deltarem != 0 && (*(*lgl).limits).prb.basic.del.cur != 0 {
        (*(*lgl).limits).prb.basic.del.cur /= 2 as libc::c_int;
    }
    if deltarem == 0 && (*(*lgl).limits).prb.basic.del.cur < (*(*lgl).opts).delmax.val {
        (*(*lgl).limits).prb.basic.del.cur += 1;
        (*(*lgl).limits).prb.basic.del.cur;
    }
    (*(*lgl).limits).prb.basic.del.rem = (*(*lgl).limits).prb.basic.del.cur;
    failed = (*(*lgl).stats).prb.basic.failed - origfailed;
    lifted = (*(*lgl).stats).prb.basic.lifted - origlifted;
    (*lgl).basicprobing = 0 as libc::c_int as libc::c_char;
    (*lgl).probing = (*lgl).basicprobing as libc::c_int;
    (*lgl).simp = (*lgl).probing as libc::c_char;
    units = failed + lifted;
    lglprt(
        lgl,
        1 as libc::c_int + (units == 0) as libc::c_int,
        b"[basicprobe-%d-%d] %d units = %d failed (%.0f%%) + %d lifted (%.0f%%)\0"
            as *const u8 as *const libc::c_char,
        (*(*lgl).stats).prb.basic.count,
        round,
        units,
        failed,
        lglpcnt(failed as libc::c_double, units as libc::c_double),
        lifted,
        lglpcnt(lifted as libc::c_double, units as libc::c_double),
    );
    lglprt(
        lgl,
        1 as libc::c_int + (success == 0) as libc::c_int,
        b"[basicprobe-%d-%d] removed %d variables, found %d hbrs\0" as *const u8
            as *const libc::c_char,
        (*(*lgl).stats).prb.basic.count,
        round,
        deltarem,
        deltahbr,
    );
    lglrep(lgl, 2 as libc::c_int, 'p' as i32 as libc::c_char);
    lglstop(lgl);
    lglbasicatestats(lgl);
    return ((*lgl).mt == 0) as libc::c_int;
}
unsafe extern "C" fn lglsmallirr(mut lgl: *mut LGL) -> libc::c_int {
    let mut maxirrlidx: libc::c_int = lglcntstk(&mut (*lgl).irr) as libc::c_int;
    let mut limit: libc::c_int = 0;
    let mut tmp: int64_t = (((1 as libc::c_int) << 31 as libc::c_int - 4 as libc::c_int)
        - 2 as libc::c_int) as int64_t;
    tmp *= (*(*lgl).opts).smallirr.val as int64_t;
    tmp /= 100 as libc::c_int as int64_t;
    limit = (if tmp < 2147483647 as libc::c_int as int64_t {
        tmp
    } else {
        2147483647 as libc::c_int as int64_t
    }) as libc::c_int;
    if maxirrlidx >= limit {
        return 0 as libc::c_int;
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn lglprobe(mut lgl: *mut LGL) -> libc::c_int {
    let mut res: libc::c_int = 1 as libc::c_int;
    let mut mod_0: libc::c_int = 0 as libc::c_int;
    let mut all: libc::c_int = 0;
    let mut small: libc::c_int = lglsmallirr(lgl);
    let mut prb: [Option::<unsafe extern "C" fn(*mut LGL) -> libc::c_int>; 3] = [None; 3];
    lglstart(lgl, &mut (*(*lgl).times).probe);
    if small != 0 && (*(*lgl).opts).prbsimple.val != 0 {
        let fresh173 = mod_0;
        mod_0 = mod_0 + 1;
        prb[fresh173
            as usize] = Some(
            lglsimpleprobe as unsafe extern "C" fn(*mut LGL) -> libc::c_int,
        );
    }
    if small != 0 && (*(*lgl).opts).treelook.val != 0 {
        let fresh174 = mod_0;
        mod_0 = mod_0 + 1;
        prb[fresh174
            as usize] = Some(
            lgltreelook as unsafe extern "C" fn(*mut LGL) -> libc::c_int,
        );
    }
    if (*(*lgl).opts).prbasic.val != 0 {
        let fresh175 = mod_0;
        mod_0 = mod_0 + 1;
        prb[fresh175
            as usize] = Some(
            lglbasicprobe as unsafe extern "C" fn(*mut LGL) -> libc::c_int,
        );
    }
    all = (*(*lgl).stats).prb.simple.count;
    all += (*(*lgl).stats).prb.basic.count;
    all += (*(*lgl).stats).prb.treelook.count;
    if (*(*lgl).stats).simp.count == 2 as libc::c_int {
        let mut i: libc::c_int = 0;
        res = 1 as libc::c_int;
        i = 0 as libc::c_int;
        while res != 0 && i < mod_0 {
            res = (prb[i as usize]).expect("non-null function pointer")(lgl);
            i += 1;
            i;
        }
    } else {
        res = if mod_0 != 0 {
            (prb[(all % mod_0) as usize]).expect("non-null function pointer")(lgl)
        } else {
            1 as libc::c_int
        };
    }
    lglstop(lgl);
    return res;
}
unsafe extern "C" fn lglinitevars(mut lgl: *mut LGL) {
    let mut ev: *mut EVar = 0 as *mut EVar;
    let mut idx: libc::c_int = 0;
    (*lgl)
        .evars = lglnew(
        lgl,
        ((*lgl).nvars as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<EVar>() as libc::c_ulong),
    ) as *mut EVar;
    idx = 2 as libc::c_int;
    while idx < (*lgl).nvars {
        ev = ((*lgl).evars).offset(idx as isize);
        (*ev).pos = -(1 as libc::c_int);
        idx += 1;
        idx;
    }
}
unsafe extern "C" fn lgldense(mut lgl: *mut LGL, mut rmredbintrn: libc::c_int) {
    let mut lit: libc::c_int = 0;
    let mut lidx: libc::c_int = 0;
    let mut count: libc::c_int = 0;
    let mut idx: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut other2: libc::c_int = 0;
    let mut blit: libc::c_int = 0;
    let mut sign: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut red: libc::c_int = 0;
    let mut start: *const libc::c_int = 0 as *const libc::c_int;
    let mut top: *const libc::c_int = 0 as *const libc::c_int;
    let mut c: *const libc::c_int = 0 as *const libc::c_int;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut eow: *const libc::c_int = 0 as *const libc::c_int;
    let mut q: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut w: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut ev: *mut EVar = 0 as *mut EVar;
    let mut hts: *mut HTS = 0 as *mut HTS;
    (*(*lgl).stats).dense += 1;
    (*(*lgl).stats).dense;
    if rmredbintrn != 0 {
        (*lgl).rmredbintrn = 1 as libc::c_int as libc::c_char;
    }
    count = 0 as libc::c_int;
    if (*lgl).occs != 0 {
        lglinitevars(lgl);
    }
    idx = 2 as libc::c_int;
    while idx < (*lgl).nvars {
        sign = -(1 as libc::c_int);
        while sign <= 1 as libc::c_int {
            lit = sign * idx;
            hts = lglhts(lgl, lit);
            if !((*hts).count == 0) {
                w = lglhts2wchs(lgl, hts);
                q = w;
                eow = w.offset((*hts).count as isize);
                let mut current_block_56: u64;
                p = w;
                while p < eow {
                    blit = *p;
                    tag = blit & MASKCS as libc::c_int;
                    if tag == TRNCS as libc::c_int || tag == LRGCS as libc::c_int {
                        p = p.offset(1);
                        p;
                    }
                    red = blit & REDCS as libc::c_int;
                    if red != 0 {
                        if !(tag == LRGCS as libc::c_int) {
                            if rmredbintrn != 0 {
                                other = blit >> RMSHFT as libc::c_int;
                                if !(abs(other) < idx) {
                                    if tag == TRNCS as libc::c_int {
                                        other2 = *p;
                                        if !(abs(other2) < idx) {
                                            lglpushstk(lgl, &mut (*lgl).saved.trn, lit);
                                            lglpushstk(lgl, &mut (*lgl).saved.trn, other);
                                            lglpushstk(lgl, &mut (*lgl).saved.trn, other2);
                                            (*(*lgl).stats).red.trn -= 1;
                                            (*(*lgl).stats).red.trn;
                                        }
                                    } else {
                                        lglpushstk(lgl, &mut (*lgl).saved.bin, lit);
                                        lglpushstk(lgl, &mut (*lgl).saved.bin, other);
                                        (*(*lgl).stats).red.bin -= 1;
                                        (*(*lgl).stats).red.bin;
                                    }
                                }
                            } else {
                                let fresh176 = q;
                                q = q.offset(1);
                                *fresh176 = blit;
                                if tag == TRNCS as libc::c_int {
                                    let fresh177 = q;
                                    q = q.offset(1);
                                    *fresh177 = *p;
                                }
                            }
                        }
                    } else {
                        let fresh178 = q;
                        q = q.offset(1);
                        *fresh178 = blit;
                        if tag == LRGCS as libc::c_int || tag == TRNCS as libc::c_int {
                            let fresh179 = q;
                            q = q.offset(1);
                            *fresh179 = *p;
                        }
                        if !(tag == LRGCS as libc::c_int) {
                            other = blit >> RMSHFT as libc::c_int;
                            if !(abs(other) < idx) {
                                if tag == TRNCS as libc::c_int {
                                    other2 = *p;
                                    if abs(other2) < idx {
                                        current_block_56 = 11307063007268554308;
                                    } else {
                                        lglincocc(lgl, other2);
                                        count += 1;
                                        count;
                                        current_block_56 = 2500484646272006982;
                                    }
                                } else {
                                    current_block_56 = 2500484646272006982;
                                }
                                match current_block_56 {
                                    11307063007268554308 => {}
                                    _ => {
                                        lglincocc(lgl, lit);
                                        count += 1;
                                        count;
                                        lglincocc(lgl, other);
                                        count += 1;
                                        count;
                                    }
                                }
                            }
                        }
                    }
                    p = p.offset(1);
                    p;
                }
                lglshrinkhts(lgl, hts, q.offset_from(w) as libc::c_long as libc::c_int);
            }
            sign += 2 as libc::c_int;
        }
        idx += 1;
        idx;
    }
    lglfitstk(lgl, &mut (*lgl).saved.bin);
    lglfitstk(lgl, &mut (*lgl).saved.trn);
    count != 0;
    count = 0 as libc::c_int;
    start = (*lgl).irr.start;
    top = (*lgl).irr.top;
    c = start;
    while c < top {
        p = c;
        if !(*c >= 2147483647 as libc::c_int >> RMSHFT as libc::c_int) {
            lidx = c.offset_from(start) as libc::c_long as libc::c_int;
            blit = lidx << RMSHFT as libc::c_int | OCCS as libc::c_int;
            loop {
                lit = *p;
                if !(lit != 0) {
                    break;
                }
                hts = lglhts(lgl, lit);
                lglpushwch(lgl, hts, blit);
                lglincocc(lgl, lit);
                count += 1;
                count;
                p = p.offset(1);
                p;
            }
        }
        c = p.offset(1 as libc::c_int as isize);
    }
    count != 0;
    count = 0 as libc::c_int;
    if (*lgl).occs != 0 {
        let mut current_block_89: u64;
        idx = 2 as libc::c_int;
        while idx < (*lgl).nvars {
            ev = lglevar(lgl, idx);
            if !((*ev).pos >= 0 as libc::c_int) {
                if !(lglifrozen(lgl, idx) != 0) {
                    if (*lgl).donotsched != 0 {
                        let mut av: *mut AVar = lglavar(lgl, idx);
                        if (*lgl).eliminating as libc::c_int != 0
                            && (*av).donotelm() as libc::c_int != 0
                        {
                            current_block_89 = 18383263831861166299;
                        } else if (*lgl).blocking as libc::c_int != 0
                            && (*av).donotblk() as libc::c_int != 0
                        {
                            current_block_89 = 18383263831861166299;
                        } else {
                            current_block_89 = 496303045384785551;
                        }
                    } else {
                        current_block_89 = 496303045384785551;
                    }
                    match current_block_89 {
                        18383263831861166299 => {}
                        _ => {
                            lglesched(lgl, idx);
                            count += 1;
                            count;
                        }
                    }
                }
            }
            idx += 1;
            idx;
        }
        count != 0;
    }
    (*lgl).dense = 1 as libc::c_int as libc::c_char;
    lglfullyconnected(lgl);
    if (*lgl).occs as libc::c_int != 0 && (*(*lgl).opts).verbose.val >= 1 as libc::c_int
    {
        let mut str: *const libc::c_char = 0 as *const libc::c_char;
        let mut inst: libc::c_int = 0;
        let mut vl: libc::c_int = 0;
        count = 0 as libc::c_int;
        if (*lgl).eliminating != 0 {
            str = b"elim\0" as *const u8 as *const libc::c_char;
            inst = (*(*lgl).stats).elm.count;
            vl = 1 as libc::c_int;
        } else if (*lgl).blocking != 0 {
            str = b"block\0" as *const u8 as *const libc::c_char;
            inst = (*(*lgl).stats).blk.count;
            vl = 1 as libc::c_int;
        } else {
            str = b"dense\0" as *const u8 as *const libc::c_char;
            inst = (*(*lgl).stats).dense as libc::c_int;
            vl = 2 as libc::c_int;
        }
        idx = 2 as libc::c_int;
        while idx < (*lgl).nvars {
            if (*lglevar(lgl, idx)).pos >= 0 as libc::c_int {
                count += 1;
                count;
            }
            idx += 1;
            idx;
        }
        lglprt(
            lgl,
            vl,
            b"[%s-%d] scheduled %d variables %.0f%%\0" as *const u8
                as *const libc::c_char,
            str,
            inst,
            count,
            lglpcnt(
                count as libc::c_double,
                ((*lgl).nvars - 2 as libc::c_int) as libc::c_double,
            ),
        );
    }
}
unsafe extern "C" fn lglsparse(mut lgl: *mut LGL) {
    let mut idx: libc::c_int = 0;
    let mut sign: libc::c_int = 0;
    let mut lit: libc::c_int = 0;
    let mut count: libc::c_int = 0;
    let mut blit: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut w: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut p: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut eow: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut q: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut hts: *mut HTS = 0 as *mut HTS;
    (*(*lgl).stats).sparse += 1;
    (*(*lgl).stats).sparse;
    count = 0 as libc::c_int;
    idx = 2 as libc::c_int;
    while idx < (*lgl).nvars {
        sign = -(1 as libc::c_int);
        while sign <= 1 as libc::c_int {
            lit = sign * idx;
            hts = lglhts(lgl, lit);
            if !((*hts).count == 0) {
                w = lglhts2wchs(lgl, hts);
                eow = w.offset((*hts).count as isize);
                q = w;
                p = q;
                while p < eow {
                    blit = *p;
                    tag = blit & MASKCS as libc::c_int;
                    if tag == OCCS as libc::c_int {
                        count += 1;
                        count;
                    } else {
                        let fresh180 = q;
                        q = q.offset(1);
                        *fresh180 = blit;
                        if !(tag == BINCS as libc::c_int) {
                            p = p.offset(1);
                            let fresh181 = q;
                            q = q.offset(1);
                            *fresh181 = *p;
                        }
                    }
                    p = p.offset(1);
                    p;
                }
                lglshrinkhts(lgl, hts, q.offset_from(w) as libc::c_long as libc::c_int);
            }
            sign += 2 as libc::c_int;
        }
        idx += 1;
        idx;
    }
    if (*lgl).occs != 0 {
        lgldel(
            lgl,
            (*lgl).evars as *mut libc::c_void,
            ((*lgl).nvars as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<EVar>() as libc::c_ulong),
        );
        (*lgl).evars = 0 as *mut EVar;
        lglrelstk(lgl, &mut (*lgl).esched);
    }
    (*lgl).dense = 0 as libc::c_int as libc::c_char;
    (*lgl).notfullyconnected = 1 as libc::c_int as libc::c_char;
}
unsafe extern "C" fn lglm2i(mut lgl: *mut LGL, mut mlit: libc::c_int) -> libc::c_int {
    let mut res: libc::c_int = 0;
    let mut midx: libc::c_int = abs(mlit);
    res = lglpeek(&mut (*(*lgl).c2rust_unnamed.elm).m2i, midx);
    if mlit < 0 as libc::c_int {
        res = -res;
    }
    return res;
}
unsafe extern "C" fn lgli2m(mut lgl: *mut LGL, mut ilit: libc::c_int) -> libc::c_int {
    let mut av: *mut AVar = lglavar(lgl, ilit);
    let mut res: libc::c_int = (*av).mark;
    if res == 0 {
        res = (lglcntstk(&mut (*lgl).seen)).wrapping_add(1 as libc::c_int as size_t)
            as libc::c_int;
        (*av).mark = res;
        lglpushstk(lgl, &mut (*lgl).seen, abs(ilit));
        lglpushstk(lgl, &mut (*(*lgl).c2rust_unnamed.elm).noccs, 0 as libc::c_int);
        lglpushstk(lgl, &mut (*(*lgl).c2rust_unnamed.elm).noccs, 0 as libc::c_int);
        lglpushstk(lgl, &mut (*(*lgl).c2rust_unnamed.elm).mark, 0 as libc::c_int);
        lglpushstk(lgl, &mut (*(*lgl).c2rust_unnamed.elm).mark, 0 as libc::c_int);
        lglpushstk(lgl, &mut (*(*lgl).c2rust_unnamed.elm).occs, 0 as libc::c_int);
        lglpushstk(lgl, &mut (*(*lgl).c2rust_unnamed.elm).occs, 0 as libc::c_int);
        lglpushstk(lgl, &mut (*(*lgl).c2rust_unnamed.elm).m2i, abs(ilit));
    }
    if ilit < 0 as libc::c_int {
        res = -res;
    }
    return res;
}
unsafe extern "C" fn lglsig(mut lit: libc::c_int) -> libc::c_uint {
    let mut ulit: libc::c_uint = lglulit(lit) as libc::c_uint;
    let mut res: libc::c_uint = 0;
    ulit = ulit.wrapping_sub(2 as libc::c_int as libc::c_uint);
    res = (1 as libc::c_uint) << (ulit & 31 as libc::c_int as libc::c_uint);
    return res;
}
unsafe extern "C" fn lgladdecl(mut lgl: *mut LGL, mut c: *const libc::c_int) {
    let mut ilit: libc::c_int = 0;
    let mut mlit: libc::c_int = 0;
    let mut umlit: libc::c_int = 0;
    let mut size: libc::c_int = 0 as libc::c_int;
    let mut next: libc::c_int = 0;
    let mut prev: libc::c_int = 0;
    let mut csig: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut val: Val = 0;
    (*(*lgl).stats).steps += 1;
    (*(*lgl).stats).steps;
    (*(*lgl).stats).elm.copies += 1;
    (*(*lgl).stats).elm.copies;
    size = 0 as libc::c_int;
    p = c;
    loop {
        ilit = *p;
        if !(ilit != 0) {
            break;
        }
        val = lglval(lgl, ilit);
        if !((val as libc::c_int) < 0 as libc::c_int) {
            size += 1;
            size;
            if !(abs(ilit) == (*(*lgl).c2rust_unnamed.elm).pivot) {
                mlit = lgli2m(lgl, ilit);
                csig |= lglsig(mlit);
            }
        }
        p = p.offset(1);
        p;
    }
    next = lglcntstk(&mut (*(*lgl).c2rust_unnamed.elm).lits) as libc::c_int;
    p = c;
    loop {
        ilit = *p;
        if !(ilit != 0) {
            break;
        }
        val = lglval(lgl, ilit);
        if !((val as libc::c_int) < 0 as libc::c_int) {
            mlit = lgli2m(lgl, ilit);
            lglpushstk(lgl, &mut (*(*lgl).c2rust_unnamed.elm).lits, mlit);
            umlit = lglulit(mlit);
            prev = lglpeek(&mut (*(*lgl).c2rust_unnamed.elm).occs, umlit);
            lglpushstk(lgl, &mut (*(*lgl).c2rust_unnamed.elm).next, prev);
            let fresh182 = next;
            next = next + 1;
            lglpoke(&mut (*(*lgl).c2rust_unnamed.elm).occs, umlit, fresh182);
            lglpushstk(
                lgl,
                &mut (*(*lgl).c2rust_unnamed.elm).csigs,
                csig as libc::c_int,
            );
            lglpushstk(lgl, &mut (*(*lgl).c2rust_unnamed.elm).sizes, size);
            let ref mut fresh183 = *((*(*lgl).c2rust_unnamed.elm).noccs.start)
                .offset(umlit as isize);
            *fresh183 += 1;
            *fresh183;
        }
        p = p.offset(1);
        p;
    }
    lglpushstk(lgl, &mut (*(*lgl).c2rust_unnamed.elm).lits, 0 as libc::c_int);
    lglpushstk(lgl, &mut (*(*lgl).c2rust_unnamed.elm).next, 0 as libc::c_int);
    lglpushstk(lgl, &mut (*(*lgl).c2rust_unnamed.elm).csigs, 0 as libc::c_int);
    lglpushstk(lgl, &mut (*(*lgl).c2rust_unnamed.elm).sizes, 0 as libc::c_int);
    (*(*lgl).c2rust_unnamed.elm).necls += 1;
    (*(*lgl).c2rust_unnamed.elm).necls;
}
unsafe extern "C" fn lglecls(mut lgl: *mut LGL, mut lit: libc::c_int) -> libc::c_int {
    let mut blit: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut red: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut lidx: libc::c_int = 0;
    let mut count: libc::c_int = 0;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut w: *const libc::c_int = 0 as *const libc::c_int;
    let mut eow: *const libc::c_int = 0 as *const libc::c_int;
    let mut c: *const libc::c_int = 0 as *const libc::c_int;
    let mut d: [libc::c_int; 4] = [0; 4];
    let mut hts: *mut HTS = 0 as *mut HTS;
    count = 0 as libc::c_int;
    hts = lglhts(lgl, lit);
    if (*hts).count == 0 {
        return 0 as libc::c_int;
    }
    w = lglhts2wchs(lgl, hts);
    eow = w.offset((*hts).count as isize);
    p = w;
    while p < eow {
        blit = *p;
        tag = blit & MASKCS as libc::c_int;
        if tag == TRNCS as libc::c_int || tag == LRGCS as libc::c_int {
            p = p.offset(1);
            p;
        }
        if !(tag == LRGCS as libc::c_int) {
            red = blit & REDCS as libc::c_int;
            if !(red != 0) {
                if tag == BINCS as libc::c_int || tag == TRNCS as libc::c_int {
                    d[0 as libc::c_int as usize] = lit;
                    other = blit >> RMSHFT as libc::c_int;
                    d[1 as libc::c_int as usize] = other;
                    if tag == TRNCS as libc::c_int {
                        d[2 as libc::c_int as usize] = *p;
                        d[3 as libc::c_int as usize] = 0 as libc::c_int;
                    } else {
                        d[2 as libc::c_int as usize] = 0 as libc::c_int;
                    }
                    c = d.as_mut_ptr();
                } else {
                    lidx = if tag == OCCS as libc::c_int {
                        blit >> RMSHFT as libc::c_int
                    } else {
                        *p
                    };
                    c = lglidx2lits(lgl, 0 as libc::c_int, lidx);
                }
                lgladdecl(lgl, c);
                count += 1;
                count;
            }
        }
        p = p.offset(1);
        p;
    }
    return count;
}
unsafe extern "C" fn lglrstecls(mut lgl: *mut LGL) {
    lglclnstk(&mut (*(*lgl).c2rust_unnamed.elm).lits);
    lglclnstk(&mut (*(*lgl).c2rust_unnamed.elm).next);
    lglclnstk(&mut (*(*lgl).c2rust_unnamed.elm).csigs);
    lglclnstk(&mut (*(*lgl).c2rust_unnamed.elm).sizes);
    lglclnstk(&mut (*(*lgl).c2rust_unnamed.elm).occs);
    lglclnstk(&mut (*(*lgl).c2rust_unnamed.elm).noccs);
    lglclnstk(&mut (*(*lgl).c2rust_unnamed.elm).mark);
    lglclnstk(&mut (*(*lgl).c2rust_unnamed.elm).m2i);
    lglpopnunmarkstk(lgl, &mut (*lgl).seen);
    (*(*lgl).c2rust_unnamed.elm).pivot = 0 as libc::c_int;
}
unsafe extern "C" fn lglrelecls(mut lgl: *mut LGL) {
    lglrelstk(lgl, &mut (*(*lgl).c2rust_unnamed.elm).lits);
    lglrelstk(lgl, &mut (*(*lgl).c2rust_unnamed.elm).next);
    lglrelstk(lgl, &mut (*(*lgl).c2rust_unnamed.elm).csigs);
    lglrelstk(lgl, &mut (*(*lgl).c2rust_unnamed.elm).sizes);
    lglrelstk(lgl, &mut (*(*lgl).c2rust_unnamed.elm).occs);
    lglrelstk(lgl, &mut (*(*lgl).c2rust_unnamed.elm).noccs);
    lglrelstk(lgl, &mut (*(*lgl).c2rust_unnamed.elm).mark);
    lglrelstk(lgl, &mut (*(*lgl).c2rust_unnamed.elm).m2i);
    lglrelstk(lgl, &mut (*(*lgl).c2rust_unnamed.elm).clv);
}
unsafe extern "C" fn lglinitecls(mut lgl: *mut LGL, mut idx: libc::c_int) {
    (*(*lgl).c2rust_unnamed.elm).pivot = idx;
    lglpushstk(lgl, &mut (*(*lgl).c2rust_unnamed.elm).mark, 0 as libc::c_int);
    lglpushstk(lgl, &mut (*(*lgl).c2rust_unnamed.elm).mark, 0 as libc::c_int);
    lglpushstk(lgl, &mut (*(*lgl).c2rust_unnamed.elm).occs, 0 as libc::c_int);
    lglpushstk(lgl, &mut (*(*lgl).c2rust_unnamed.elm).occs, 0 as libc::c_int);
    lglpushstk(lgl, &mut (*(*lgl).c2rust_unnamed.elm).noccs, 0 as libc::c_int);
    lglpushstk(lgl, &mut (*(*lgl).c2rust_unnamed.elm).noccs, 0 as libc::c_int);
    lglpushstk(lgl, &mut (*(*lgl).c2rust_unnamed.elm).m2i, 0 as libc::c_int);
    lgli2m(lgl, idx);
    lglpushstk(lgl, &mut (*(*lgl).c2rust_unnamed.elm).lits, 0 as libc::c_int);
    lglpushstk(lgl, &mut (*(*lgl).c2rust_unnamed.elm).next, 0 as libc::c_int);
    lglpushstk(lgl, &mut (*(*lgl).c2rust_unnamed.elm).csigs, 0 as libc::c_int);
    lglpushstk(lgl, &mut (*(*lgl).c2rust_unnamed.elm).sizes, 0 as libc::c_int);
    (*(*lgl).c2rust_unnamed.elm).necls = 0 as libc::c_int;
    lglecls(lgl, idx);
    (*(*lgl).c2rust_unnamed.elm).negcls = (*(*lgl).c2rust_unnamed.elm).necls;
    (*(*lgl).c2rust_unnamed.elm)
        .neglidx = lglcntstk(&mut (*(*lgl).c2rust_unnamed.elm).lits) as libc::c_int;
    lglecls(lgl, -idx);
}
unsafe extern "C" fn lglelrmcls(
    mut lgl: *mut LGL,
    mut lit: libc::c_int,
    mut c: *mut libc::c_int,
    mut clidx: libc::c_int,
) {
    let mut lidx: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut ulit: libc::c_int = 0;
    let mut lits: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut csigs: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut blit: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut red: libc::c_int = 0;
    let mut other2: libc::c_int = 0;
    let mut p: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut eow: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut w: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut count: libc::c_int = 0;
    let mut hts: *mut HTS = 0 as *mut HTS;
    lits = (*(*lgl).c2rust_unnamed.elm).lits.start;
    csigs = (*(*lgl).c2rust_unnamed.elm).csigs.start;
    lidx = c.offset_from(lits) as libc::c_long as libc::c_int;
    i = lidx;
    loop {
        other = *lits.offset(i as isize);
        if !(other != 0) {
            break;
        }
        *lits.offset(i as isize) = 2147483647 as libc::c_int;
        *csigs.offset(i as isize) = 0 as libc::c_int;
        ulit = lglulit(other);
        *((*(*lgl).c2rust_unnamed.elm).noccs.start).offset(ulit as isize)
            -= 1 as libc::c_int;
        i += 1;
        i;
    }
    hts = lglhts(lgl, lit);
    w = lglhts2wchs(lgl, hts);
    eow = w.offset((*hts).count as isize);
    count = 0 as libc::c_int;
    tag = count;
    blit = tag;
    p = w;
    while p < eow {
        blit = *p;
        tag = blit & MASKCS as libc::c_int;
        if tag == TRNCS as libc::c_int || tag == LRGCS as libc::c_int {
            p = p.offset(1);
            p;
        }
        if !(tag == LRGCS as libc::c_int) {
            red = blit & REDCS as libc::c_int;
            if !(red != 0) {
                if count == clidx {
                    break;
                }
                count += 1;
                count;
            }
        }
        p = p.offset(1);
        p;
    }
    if tag == BINCS as libc::c_int {
        other = blit >> RMSHFT as libc::c_int;
        lglrmbcls(lgl, lit, other, 0 as libc::c_int);
        lgldrupligdelclsarg(lgl, lit, other, 0 as libc::c_int);
    } else if tag == TRNCS as libc::c_int {
        other = blit >> RMSHFT as libc::c_int;
        other2 = *p;
        lgldrupligdelclsarg(lgl, lit, other, other2, 0 as libc::c_int);
        lglrmtcls(lgl, lit, other, other2, 0 as libc::c_int);
    } else {
        lidx = if tag == OCCS as libc::c_int {
            blit >> RMSHFT as libc::c_int
        } else {
            *p
        };
        lgldrupligdelclsaux(lgl, lglidx2lits(lgl, 0 as libc::c_int, lidx));
        lglrmlcls(lgl, lidx, 0 as libc::c_int);
    };
}
unsafe extern "C" fn lglbacksub(
    mut lgl: *mut LGL,
    mut c: *mut libc::c_int,
    mut str: libc::c_int,
    mut dptr: *mut *mut libc::c_int,
    mut dlidxptr: *mut libc::c_int,
) -> libc::c_int {
    let mut start: *mut libc::c_int = (*(*lgl).c2rust_unnamed.elm).lits.start;
    let mut p: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut q: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut marked: libc::c_int = 0 as libc::c_int;
    let mut res: libc::c_int = 0;
    let mut d: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut lit: libc::c_int = 0;
    let mut ulit: libc::c_int = 0;
    let mut occ: libc::c_int = 0;
    let mut next: libc::c_int = 0;
    let mut osize: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut uolit: libc::c_int = 0;
    let mut size: libc::c_int = 0;
    let mut plit: libc::c_int = 0;
    let mut phase: libc::c_int = 0;
    let mut clidx: libc::c_int = 0;
    let mut ocsig: libc::c_uint = 0;
    let mut csig: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    let mut masksig: libc::c_uint = 0;
    phase = (c.offset_from(start) as libc::c_long
        >= (*(*lgl).c2rust_unnamed.elm).neglidx as libc::c_long) as libc::c_int;
    p = c;
    loop {
        lit = *p;
        if !(lit != 0) {
            break;
        }
        if abs(lit) != 1 as libc::c_int {
            csig |= lglsig(lit);
        }
        p = p.offset(1);
        p;
    }
    size = p.offset_from(c) as libc::c_long as libc::c_int;
    res = 0 as libc::c_int;
    if !dptr.is_null() {
        *dptr = 0 as *mut libc::c_int;
    }
    if !dlidxptr.is_null() {
        *dlidxptr = 0 as libc::c_int;
    }
    if str != 0 {
        phase = (phase == 0) as libc::c_int;
    }
    lit = if phase != 0 { -(1 as libc::c_int) } else { 1 as libc::c_int };
    masksig = !(lglsig(-lit) | lglsig(lit));
    ulit = lglulit(lit);
    occ = lglpeek(&mut (*(*lgl).c2rust_unnamed.elm).noccs, ulit);
    if str == 0 && occ <= 1 as libc::c_int {
        return 0 as libc::c_int;
    }
    if str != 0 && occ == 0 {
        return 0 as libc::c_int;
    }
    if occ > (*(*lgl).c2rust_unnamed.elm).bkwdocclim {
        return 0 as libc::c_int;
    }
    next = lglpeek(&mut (*(*lgl).c2rust_unnamed.elm).occs, ulit);
    while res == 0 && next != 0 && (*(*lgl).limits).elm.steps > (*(*lgl).stats).elm.steps
    {
        (*(*lgl).stats).steps += 1;
        (*(*lgl).stats).steps;
        (*(*lgl).stats).elm.steps += 1;
        (*(*lgl).stats).elm.steps;
        if !(next as libc::c_long == p.offset_from(start) as libc::c_long) {
            if !(phase != (next >= (*(*lgl).c2rust_unnamed.elm).neglidx) as libc::c_int)
            {
                plit = lglpeek(&mut (*(*lgl).c2rust_unnamed.elm).lits, next);
                if !(plit >= 2147483647 as libc::c_int >> RMSHFT as libc::c_int) {
                    osize = lglpeek(&mut (*(*lgl).c2rust_unnamed.elm).sizes, next);
                    (*(*lgl).stats).steps += 1;
                    (*(*lgl).stats).steps;
                    (*(*lgl).stats).elm.steps += 1;
                    (*(*lgl).stats).elm.steps;
                    if !(osize > size) {
                        ocsig = lglpeek(&mut (*(*lgl).c2rust_unnamed.elm).csigs, next)
                            as libc::c_uint;
                        (*(*lgl).stats).steps += 1;
                        (*(*lgl).stats).steps;
                        (*(*lgl).stats).elm.steps += 1;
                        (*(*lgl).stats).elm.steps;
                        ocsig &= masksig;
                        if !(ocsig & !csig != 0) {
                            if marked == 0 {
                                q = c;
                                loop {
                                    other = *q;
                                    if !(other != 0) {
                                        break;
                                    }
                                    if str != 0 && abs(other) == 1 as libc::c_int {
                                        other = -other;
                                    }
                                    uolit = lglulit(other);
                                    lglpoke(
                                        &mut (*(*lgl).c2rust_unnamed.elm).mark,
                                        uolit,
                                        1 as libc::c_int,
                                    );
                                    q = q.offset(1);
                                    q;
                                }
                                marked = 1 as libc::c_int;
                                (*(*lgl).stats).steps += q.offset_from(c) as libc::c_long;
                                (*(*lgl).stats).elm.steps
                                    += q.offset_from(c) as libc::c_long;
                            }
                            d = ((*(*lgl).c2rust_unnamed.elm).lits.start)
                                .offset(next as isize);
                            if !(c <= d && d < c.offset(size as isize)) {
                                if str != 0 {
                                    (*(*lgl).stats).elm.strchks += 1;
                                    (*(*lgl).stats).elm.strchks;
                                } else {
                                    (*(*lgl).stats).elm.subchks += 1;
                                    (*(*lgl).stats).elm.subchks;
                                }
                                while *d.offset(-(1 as libc::c_int) as isize) != 0 {
                                    d = d.offset(-1);
                                    d;
                                }
                                res = 1 as libc::c_int;
                                q = d;
                                while res != 0
                                    && {
                                        other = *q;
                                        other != 0
                                    }
                                {
                                    uolit = lglulit(other);
                                    res = lglpeek(
                                        &mut (*(*lgl).c2rust_unnamed.elm).mark,
                                        uolit,
                                    );
                                    q = q.offset(1);
                                    q;
                                }
                                (*(*lgl).stats).steps += q.offset_from(d) as libc::c_long;
                                (*(*lgl).stats).elm.steps
                                    += q.offset_from(d) as libc::c_long;
                                if !(res == 0 || str == 0 || osize < size) {
                                    (*(*lgl).stats).steps += q.offset_from(d) as libc::c_long;
                                    (*(*lgl).stats).elm.steps
                                        += q.offset_from(d) as libc::c_long;
                                    q = (*(*lgl).c2rust_unnamed.elm).lits.start;
                                    if phase != 0 {
                                        q = q.offset((*(*lgl).c2rust_unnamed.elm).neglidx as isize);
                                    } else {
                                        q = q.offset(1);
                                        q;
                                    }
                                    clidx = 0 as libc::c_int;
                                    while q < d {
                                        let fresh184 = q;
                                        q = q.offset(1);
                                        other = *fresh184;
                                        if other
                                            >= 2147483647 as libc::c_int >> RMSHFT as libc::c_int
                                        {
                                            loop {
                                                let fresh185 = q;
                                                q = q.offset(1);
                                                if !(*fresh185 != 0) {
                                                    break;
                                                }
                                            }
                                        } else if other == 0 {
                                            clidx += 1;
                                            clidx;
                                        }
                                    }
                                    *dptr = d;
                                    *dlidxptr = clidx;
                                }
                            }
                        }
                    }
                }
            }
        }
        next = lglpeek(&mut (*(*lgl).c2rust_unnamed.elm).next, next);
    }
    if marked != 0 {
        p = c;
        loop {
            lit = *p;
            if !(lit != 0) {
                break;
            }
            if str != 0 && abs(lit) == 1 as libc::c_int {
                lit = -lit;
            }
            ulit = lglulit(lit);
            lglpoke(&mut (*(*lgl).c2rust_unnamed.elm).mark, ulit, 0 as libc::c_int);
            p = p.offset(1);
            p;
        }
        (*(*lgl).stats).steps += p.offset_from(c) as libc::c_long;
        (*(*lgl).stats).elm.steps += p.offset_from(c) as libc::c_long;
    }
    return res;
}
unsafe extern "C" fn lglelmsub(mut lgl: *mut LGL) {
    let mut clidx: libc::c_int = 0;
    let mut count: libc::c_int = 0;
    let mut subsumed: libc::c_int = 0;
    let mut pivot: libc::c_int = 0;
    let mut c: *mut libc::c_int = 0 as *mut libc::c_int;
    if (*(*lgl).opts).elmotfsub.val == 0 {
        return;
    }
    subsumed = 0 as libc::c_int;
    clidx = subsumed;
    count = clidx;
    pivot = (*(*lgl).c2rust_unnamed.elm).pivot;
    c = ((*(*lgl).c2rust_unnamed.elm).lits.start).offset(1 as libc::c_int as isize);
    while c < (*(*lgl).c2rust_unnamed.elm).lits.top
        && (*(*lgl).limits).elm.steps > (*(*lgl).stats).elm.steps
    {
        (*(*lgl).stats).steps += 1;
        (*(*lgl).stats).steps;
        (*(*lgl).stats).elm.steps += 1;
        (*(*lgl).stats).elm.steps;
        let fresh186 = count;
        count = count + 1;
        if fresh186 == (*(*lgl).c2rust_unnamed.elm).negcls {
            clidx = 0 as libc::c_int;
            pivot = -pivot;
        }
        if lglbacksub(
            lgl,
            c,
            0 as libc::c_int,
            0 as *mut *mut libc::c_int,
            0 as *mut libc::c_int,
        ) != 0
        {
            subsumed += 1;
            subsumed;
            (*(*lgl).stats).elm.sub += 1;
            (*(*lgl).stats).elm.sub;
            lglelrmcls(lgl, pivot, c, clidx);
        } else {
            clidx += 1;
            clidx;
        }
        while *c != 0 {
            c = c.offset(1);
            c;
        }
        c = c.offset(1);
        c;
    }
}
unsafe extern "C" fn lglelmstr(mut lgl: *mut LGL) -> libc::c_int {
    let mut clidx: libc::c_int = 0;
    let mut count: libc::c_int = 0;
    let mut strengthened: libc::c_int = 0;
    let mut pivot: libc::c_int = 0;
    let mut c: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut p: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut mlit: libc::c_int = 0;
    let mut ilit: libc::c_int = 0;
    let mut res: libc::c_int = 0;
    let mut found: libc::c_int = 0;
    let mut d: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut dlidx: libc::c_int = 0;
    let mut size: libc::c_int = 0;
    if (*(*lgl).opts).elmotfstr.val == 0 {
        return 0 as libc::c_int;
    }
    strengthened = 0 as libc::c_int;
    clidx = strengthened;
    count = clidx;
    pivot = (*(*lgl).c2rust_unnamed.elm).pivot;
    res = 0 as libc::c_int;
    c = ((*(*lgl).c2rust_unnamed.elm).lits.start).offset(1 as libc::c_int as isize);
    while c < (*(*lgl).c2rust_unnamed.elm).lits.top
        && (*(*lgl).limits).elm.steps > (*(*lgl).stats).elm.steps
    {
        (*(*lgl).stats).steps += 1;
        (*(*lgl).stats).steps;
        (*(*lgl).stats).elm.steps += 1;
        (*(*lgl).stats).elm.steps;
        let fresh187 = count;
        count = count + 1;
        if fresh187 == (*(*lgl).c2rust_unnamed.elm).negcls {
            clidx = 0 as libc::c_int;
            pivot = -pivot;
        }
        if *c == 2147483647 as libc::c_int {
            while *c != 0 {
                c = c.offset(1);
                c;
            }
        } else {
            if lglbacksub(lgl, c, 1 as libc::c_int, &mut d, &mut dlidx) != 0 {
                strengthened += 1;
                strengthened;
                (*(*lgl).stats).elm.str_0 += 1;
                (*(*lgl).stats).elm.str_0;
                found = 0 as libc::c_int;
                size = 0 as libc::c_int;
                p = c;
                loop {
                    mlit = *p;
                    if !(mlit != 0) {
                        break;
                    }
                    ilit = lglm2i(lgl, *p);
                    if ilit == pivot {
                        found += 1;
                        found;
                    } else {
                        lglpushstk(lgl, &mut (*lgl).clause, ilit);
                        size += 1;
                        size;
                    }
                    p = p.offset(1);
                    p;
                }
                lglpushstk(lgl, &mut (*lgl).clause, 0 as libc::c_int);
                lgldrupligaddcls(lgl, REDCS as libc::c_int);
                if !d.is_null() {
                    lglelrmcls(lgl, -pivot, d, dlidx);
                }
                lglelrmcls(lgl, pivot, c, clidx);
                lgladdcls(lgl, 0 as libc::c_int, 0 as libc::c_int, 1 as libc::c_int);
                lglclnstk(&mut (*lgl).clause);
                if size == 1 as libc::c_int {
                    res = 1 as libc::c_int;
                    break;
                }
            } else {
                clidx += 1;
                clidx;
            }
            while *c != 0 {
                c = c.offset(1);
                c;
            }
        }
        c = c.offset(1);
        c;
    }
    return res;
}
unsafe extern "C" fn lglflushclauses(
    mut lgl: *mut LGL,
    mut lit: libc::c_int,
) -> libc::c_int {
    let mut blit: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut red: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut other2: libc::c_int = 0;
    let mut count: libc::c_int = 0;
    let mut glue: libc::c_int = 0;
    let mut res: libc::c_int = 0;
    let druplig: libc::c_int = (*(*lgl).opts).druplig.val;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut w: *const libc::c_int = 0 as *const libc::c_int;
    let mut eow: *const libc::c_int = 0 as *const libc::c_int;
    let mut lidx: libc::c_int = 0;
    let mut glidx: libc::c_int = 0;
    let mut slidx: libc::c_int = 0;
    let mut c: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut q: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut hts: *mut HTS = 0 as *mut HTS;
    let mut s: *mut Stk = 0 as *mut Stk;
    lglchkirrstats(lgl);
    hts = lglhts(lgl, lit);
    if (*hts).count == 0 {
        return 0 as libc::c_int;
    }
    res = 0 as libc::c_int;
    w = lglhts2wchs(lgl, hts);
    eow = w.offset((*hts).count as isize);
    count = 0 as libc::c_int;
    p = w;
    while p < eow {
        if (*lgl).blocking != 0 {
            (*(*lgl).stats).steps += 1;
            (*(*lgl).stats).steps;
            (*(*lgl).stats).blk.steps += 1;
            (*(*lgl).stats).blk.steps;
        }
        if (*lgl).eliminating != 0 {
            (*(*lgl).stats).steps += 1;
            (*(*lgl).stats).steps;
            (*(*lgl).stats).elm.steps += 1;
            (*(*lgl).stats).elm.steps;
        }
        if (*lgl).simpleprobing != 0 {
            (*(*lgl).stats).steps += 1;
            (*(*lgl).stats).steps;
            (*(*lgl).stats).prb.simple.steps += 1;
            (*(*lgl).stats).prb.simple.steps;
        }
        blit = *p;
        tag = blit & MASKCS as libc::c_int;
        red = blit & REDCS as libc::c_int;
        other = blit >> RMSHFT as libc::c_int;
        if tag == TRNCS as libc::c_int || tag == LRGCS as libc::c_int {
            p = p.offset(1);
            p;
        }
        if tag == BINCS as libc::c_int {
            lglrmbwch(lgl, other, lit, red);
            if druplig != 0 {
                lgldrupligdelclsarg(lgl, lit, other, 0 as libc::c_int);
            }
            lgldeclscnt(lgl, 2 as libc::c_int, red, 0 as libc::c_int);
            if red == 0 {
                lgldecocc(lgl, lit);
                lgldecocc(lgl, other);
                res += 1;
                res;
            }
            count += 1;
            count;
        } else if tag == TRNCS as libc::c_int {
            other2 = *p;
            lglrmtwch(lgl, other2, lit, other, red);
            lglrmtwch(lgl, other, lit, other2, red);
            if druplig != 0 {
                lgldrupligdelclsarg(lgl, lit, other, other2, 0 as libc::c_int);
            }
            lgldeclscnt(lgl, 3 as libc::c_int, red, 0 as libc::c_int);
            if red == 0 {
                lgldecocc(lgl, lit);
                lgldecocc(lgl, other);
                lgldecocc(lgl, other2);
                res += 1;
                res;
            }
            count += 1;
            count;
        } else {
            if tag == LRGCS as libc::c_int {
                lidx = *p;
                s = lglidx2stk(lgl, red, lidx);
                if red != 0 {
                    glue = lidx
                        & ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int;
                    c = ((*s).start).offset((lidx >> 4 as libc::c_int) as isize);
                } else {
                    glue = 0 as libc::c_int;
                    c = ((*s).start).offset(lidx as isize);
                }
            } else {
                lidx = blit >> RMSHFT as libc::c_int;
                s = &mut (*lgl).irr;
                c = ((*s).start).offset(lidx as isize);
                glue = 0 as libc::c_int;
            }
            if !(c >= (*s).top
                || {
                    other = *c.offset(0 as libc::c_int as isize);
                    other >= 2147483647 as libc::c_int >> RMSHFT as libc::c_int
                })
            {
                if druplig != 0 {
                    lgldrupligdelclsaux(lgl, c);
                }
                if tag == LRGCS as libc::c_int {
                    if other == lit {
                        other = *c.offset(1 as libc::c_int as isize);
                    }
                    lglrmlwch(lgl, other, red, lidx);
                } else {
                    glidx = lidx;
                    if red != 0 {
                        glidx <<= 4 as libc::c_int;
                    }
                    if *c.offset(1 as libc::c_int as isize) != lit {
                        lglrmlwch(lgl, *c.offset(1 as libc::c_int as isize), red, glidx);
                    }
                    if other != lit {
                        lglrmlwch(lgl, other, red, glidx);
                    }
                }
                if red != 0 {
                    *c.offset(-(1 as libc::c_int) as isize) = 2147483647 as libc::c_int;
                } else {
                    lgldecocc(lgl, lit);
                }
                q = c;
                loop {
                    other = *q;
                    if !(other != 0) {
                        break;
                    }
                    *q = 2147483647 as libc::c_int;
                    if !(other == lit) {
                        if !(red != 0 && glue != 0) {
                            slidx = lidx;
                            if red != 0 && tag == LRGCS as libc::c_int {
                                slidx >>= 4 as libc::c_int;
                            }
                            lglrmlocc(lgl, other, red, slidx);
                            if red == 0 {
                                lgldecocc(lgl, other);
                            }
                        }
                    }
                    q = q.offset(1);
                    q;
                }
                *q = 2147483647 as libc::c_int;
                lgldeclscnt(
                    lgl,
                    q.offset_from(c) as libc::c_long as libc::c_int,
                    red,
                    glue,
                );
                lgltrimlitstk(lgl, red, lidx);
                if red == 0 {
                    res += 1;
                    res;
                }
                count += 1;
                count;
            }
        }
        p = p.offset(1);
        p;
    }
    lglshrinkhts(lgl, hts, 0 as libc::c_int);
    lglchkirrstats(lgl);
    return res;
}
unsafe extern "C" fn lglflushlits(
    mut lgl: *mut LGL,
    mut lit: libc::c_int,
) -> libc::c_int {
    let mut blit: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut red: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut other2: libc::c_int = 0;
    let mut size: libc::c_int = 0;
    let mut satisfied: libc::c_int = 0;
    let mut d: [libc::c_int; 3] = [0; 3];
    let mut glue: libc::c_int = 0;
    let druplig: libc::c_int = (*(*lgl).opts).druplig.val;
    let mut p: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut w: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut eow: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut c: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut l: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut k: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut lidx: libc::c_int = 0;
    let mut slidx: libc::c_int = 0;
    let mut glidx: libc::c_int = 0;
    let mut count: libc::c_int = 0;
    let mut res: libc::c_int = 0;
    let mut val: Val = 0;
    let mut val2: Val = 0;
    let mut delta: ptrdiff_t = 0;
    let mut saved: Stk = Stk {
        start: 0 as *mut libc::c_int,
        top: 0 as *mut libc::c_int,
        end: 0 as *mut libc::c_int,
    };
    let mut s: *mut Stk = 0 as *mut Stk;
    let mut hts: *mut HTS = 0 as *mut HTS;
    lglchkirrstats(lgl);
    hts = lglhts(lgl, lit);
    w = lglhts2wchs(lgl, hts);
    eow = w.offset((*hts).count as isize);
    count = 0 as libc::c_int;
    res = count;
    memset(
        &mut saved as *mut Stk as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<Stk>() as libc::c_ulong,
    );
    p = w;
    while p < eow {
        if (*lgl).blocking != 0 {
            (*(*lgl).stats).steps += 1;
            (*(*lgl).stats).steps;
            (*(*lgl).stats).blk.steps += 1;
            (*(*lgl).stats).blk.steps;
        }
        if (*lgl).eliminating != 0 {
            (*(*lgl).stats).steps += 1;
            (*(*lgl).stats).steps;
            (*(*lgl).stats).elm.steps += 1;
            (*(*lgl).stats).elm.steps;
        }
        if (*lgl).simpleprobing != 0 {
            (*(*lgl).stats).steps += 1;
            (*(*lgl).stats).steps;
            (*(*lgl).stats).prb.simple.steps += 1;
            (*(*lgl).stats).prb.simple.steps;
        }
        count += 1;
        count;
        blit = *p;
        tag = blit & MASKCS as libc::c_int;
        red = blit & REDCS as libc::c_int;
        if tag == BINCS as libc::c_int {
            other = blit >> RMSHFT as libc::c_int;
            lglrmbwch(lgl, other, lit, red);
            if druplig != 0 {
                lgldrupligdelclsarg(lgl, lit, other, 0 as libc::c_int);
            }
            lgldeclscnt(lgl, 2 as libc::c_int, red, 0 as libc::c_int);
            if red == 0 {
                if (*lgl).dense != 0 {
                    lgldecocc(lgl, lit);
                    lgldecocc(lgl, other);
                }
                res += 1;
                res;
            }
        } else if tag == TRNCS as libc::c_int {
            other = blit >> RMSHFT as libc::c_int;
            p = p.offset(1);
            other2 = *p;
            lglrmtwch(lgl, other2, lit, other, red);
            lglrmtwch(lgl, other, lit, other2, red);
            lgldeclscnt(lgl, 3 as libc::c_int, red, 0 as libc::c_int);
            if red == 0 {
                if (*lgl).dense != 0 {
                    lgldecocc(lgl, lit);
                    lgldecocc(lgl, other);
                    lgldecocc(lgl, other2);
                }
                res += 1;
                res;
            }
            val = lglval(lgl, other);
            val2 = lglval(lgl, other2);
            if val == 0 && val2 == 0 {
                delta = lglwchbin(lgl, other, other2, red);
                delta += lglwchbin(lgl, other2, other, red);
                if (*lgl).simpleprobing as libc::c_int != 0
                    && (*(*lgl).opts).prbsimple.val >= 2 as libc::c_int
                {
                    lglwrktouch(lgl, -other);
                    lglwrktouch(lgl, -other2);
                }
                if delta != 0 {
                    p = p.offset(delta as isize);
                    w = w.offset(delta as isize);
                    eow = eow.offset(delta as isize);
                }
                if red != 0 {
                    (*(*lgl).stats).red.bin += 1;
                    (*(*lgl).stats).red.bin;
                } else {
                    lglincirr(lgl, 2 as libc::c_int);
                    if (*lgl).dense != 0 {
                        lglincocc(lgl, other);
                        lglincocc(lgl, other2);
                    }
                }
                if druplig != 0 {
                    lgldrupligaddclsarg(
                        lgl,
                        REDCS as libc::c_int,
                        other,
                        other2,
                        0 as libc::c_int,
                    );
                }
            }
            if druplig != 0 {
                lgldrupligdelclsarg(lgl, lit, other, other2, 0 as libc::c_int);
            }
        } else {
            lidx = if tag == LRGCS as libc::c_int {
                p = p.offset(1);
                *p
            } else {
                blit >> RMSHFT as libc::c_int
            };
            s = lglidx2stk(lgl, red, lidx);
            c = ((*s).start)
                .offset(
                    (if red != 0 { lidx >> 4 as libc::c_int } else { lidx }) as isize,
                );
            if !(c >= (*s).top
                || *c.offset(0 as libc::c_int as isize)
                    >= 2147483647 as libc::c_int >> RMSHFT as libc::c_int)
            {
                satisfied = 0 as libc::c_int;
                size = satisfied;
                l = c;
                loop {
                    other = *l;
                    if !(other != 0) {
                        break;
                    }
                    if druplig != 0 {
                        lglpushstk(lgl, &mut saved, other);
                    }
                    if !(satisfied != 0) {
                        if !(other == lit) {
                            val = lglval(lgl, other);
                            if !((val as libc::c_int) < 0 as libc::c_int) {
                                if val as libc::c_int > 0 as libc::c_int {
                                    satisfied = 1 as libc::c_int;
                                } else {
                                    if size < 3 as libc::c_int {
                                        d[size as usize] = other;
                                    }
                                    size += 1;
                                    size;
                                }
                            }
                        }
                    }
                    l = l.offset(1);
                    l;
                }
                if satisfied == 0 && size == 2 as libc::c_int {
                    delta = lglwchbin(
                        lgl,
                        d[0 as libc::c_int as usize],
                        d[1 as libc::c_int as usize],
                        red,
                    );
                    delta
                        += lglwchbin(
                            lgl,
                            d[1 as libc::c_int as usize],
                            d[0 as libc::c_int as usize],
                            red,
                        );
                    if delta != 0 {
                        p = p.offset(delta as isize);
                        w = w.offset(delta as isize);
                        eow = eow.offset(delta as isize);
                    }
                    if red != 0 {
                        (*(*lgl).stats).red.bin += 1;
                        (*(*lgl).stats).red.bin;
                    } else {
                        lglincirr(lgl, 2 as libc::c_int);
                        if (*lgl).dense != 0 {
                            lglincocc(lgl, d[0 as libc::c_int as usize]);
                            lglincocc(lgl, d[1 as libc::c_int as usize]);
                        }
                    }
                    if (*lgl).simpleprobing as libc::c_int != 0
                        && (*(*lgl).opts).prbsimple.val >= 2 as libc::c_int
                    {
                        lglwrktouch(lgl, -d[0 as libc::c_int as usize]);
                        lglwrktouch(lgl, -d[1 as libc::c_int as usize]);
                    }
                    if druplig != 0 {
                        lgldrupligaddclsarg(
                            lgl,
                            REDCS as libc::c_int,
                            d[0 as libc::c_int as usize],
                            d[1 as libc::c_int as usize],
                            0 as libc::c_int,
                        );
                    }
                }
                if satisfied == 0 && size == 3 as libc::c_int {
                    delta = lglwchtrn(
                        lgl,
                        d[0 as libc::c_int as usize],
                        d[1 as libc::c_int as usize],
                        d[2 as libc::c_int as usize],
                        red,
                    );
                    delta
                        += lglwchtrn(
                            lgl,
                            d[1 as libc::c_int as usize],
                            d[0 as libc::c_int as usize],
                            d[2 as libc::c_int as usize],
                            red,
                        );
                    delta
                        += lglwchtrn(
                            lgl,
                            d[2 as libc::c_int as usize],
                            d[0 as libc::c_int as usize],
                            d[1 as libc::c_int as usize],
                            red,
                        );
                    if delta != 0 {
                        p = p.offset(delta as isize);
                        w = w.offset(delta as isize);
                        eow = eow.offset(delta as isize);
                    }
                    if red != 0 {
                        (*(*lgl).stats).red.trn += 1;
                        (*(*lgl).stats).red.trn;
                    } else {
                        lglincirr(lgl, 3 as libc::c_int);
                        if (*lgl).dense != 0 {
                            lglincocc(lgl, d[0 as libc::c_int as usize]);
                            lglincocc(lgl, d[1 as libc::c_int as usize]);
                            lglincocc(lgl, d[2 as libc::c_int as usize]);
                        }
                    }
                    if (*lgl).simpleprobing as libc::c_int != 0
                        && (*(*lgl).opts).prbsimple.val >= 3 as libc::c_int
                    {
                        lglwrktouch(lgl, d[0 as libc::c_int as usize]);
                        lglwrktouch(lgl, d[1 as libc::c_int as usize]);
                        lglwrktouch(lgl, d[2 as libc::c_int as usize]);
                    }
                    if druplig != 0 {
                        lgldrupligaddclsarg(
                            lgl,
                            REDCS as libc::c_int,
                            d[0 as libc::c_int as usize],
                            d[1 as libc::c_int as usize],
                            d[2 as libc::c_int as usize],
                            0 as libc::c_int,
                        );
                    }
                }
                if (*lgl).dense as libc::c_int != 0 && red == 0 {
                    l = c;
                    loop {
                        other = *l;
                        if !(other != 0) {
                            break;
                        }
                        if satisfied != 0 || size <= 3 as libc::c_int
                            || (lglval(lgl, other) as libc::c_int) < 0 as libc::c_int
                        {
                            if red == 0 {
                                lgldecocc(lgl, other);
                            }
                            if other != lit {
                                slidx = lidx;
                                if red != 0 && tag == LRGCS as libc::c_int {
                                    slidx >>= 4 as libc::c_int;
                                }
                                lglrmlocc(lgl, other, red, slidx);
                            }
                        }
                        l = l.offset(1);
                        l;
                    }
                }
                glidx = lidx;
                if red != 0 && tag == OCCS as libc::c_int {
                    glidx <<= 4 as libc::c_int;
                }
                if *c.offset(0 as libc::c_int as isize) != lit {
                    lglrmlwch(lgl, *c.offset(0 as libc::c_int as isize), red, glidx);
                }
                if *c.offset(1 as libc::c_int as isize) != lit {
                    lglrmlwch(lgl, *c.offset(1 as libc::c_int as isize), red, glidx);
                }
                if satisfied != 0 || size <= 3 as libc::c_int {
                    if red != 0 {
                        *c
                            .offset(
                                -(1 as libc::c_int) as isize,
                            ) = 2147483647 as libc::c_int;
                    }
                    k = c;
                    loop {
                        other = *k;
                        if !(other != 0) {
                            break;
                        }
                        *k = 2147483647 as libc::c_int;
                        k = k.offset(1);
                        k;
                    }
                    *k = 2147483647 as libc::c_int;
                    if red != 0 {
                        glue = if tag == LRGCS as libc::c_int {
                            lidx
                                & ((1 as libc::c_int) << 4 as libc::c_int)
                                    - 1 as libc::c_int
                        } else {
                            0 as libc::c_int
                        };
                        (*(*lgl).stats).lir[glue as usize].clauses -= 1;
                        (*(*lgl).stats).lir[glue as usize].clauses;
                        (*(*lgl).stats).red.lrg -= 1;
                        (*(*lgl).stats).red.lrg;
                    } else {
                        lgldecirr(lgl, k.offset_from(c) as libc::c_long as libc::c_int);
                    }
                } else {
                    k = c;
                    l = k;
                    loop {
                        other = *l;
                        if !(other != 0) {
                            break;
                        }
                        val = lglval(lgl, other);
                        if !((val as libc::c_int) < 0 as libc::c_int) {
                            if (*lgl).simpleprobing as libc::c_int != 0
                                && (*(*lgl).opts).prbsimple.val >= 3 as libc::c_int
                            {
                                lglwrktouch(lgl, other);
                            }
                            let fresh188 = k;
                            k = k.offset(1);
                            *fresh188 = other;
                        }
                        l = l.offset(1);
                        l;
                    }
                    if red == 0 && k < l {
                        (*(*lgl).stats)
                            .irr
                            .lits
                            .cur = ((*(*lgl).stats).irr.lits.cur as libc::c_long
                            - l.offset_from(k) as libc::c_long) as libc::c_int;
                    }
                    let fresh189 = k;
                    k = k.offset(1);
                    *fresh189 = 0 as libc::c_int;
                    while k <= l {
                        let fresh190 = k;
                        k = k.offset(1);
                        *fresh190 = 2147483647 as libc::c_int;
                    }
                    delta = lglwchlrg(
                        lgl,
                        *c.offset(0 as libc::c_int as isize),
                        *c.offset(1 as libc::c_int as isize),
                        red,
                        glidx,
                    );
                    delta
                        += lglwchlrg(
                            lgl,
                            *c.offset(1 as libc::c_int as isize),
                            *c.offset(0 as libc::c_int as isize),
                            red,
                            glidx,
                        );
                    if delta != 0 {
                        p = p.offset(delta as isize);
                        w = w.offset(delta as isize);
                        eow = eow.offset(delta as isize);
                    }
                    if druplig != 0 {
                        lgldrupligaddclsaux(lgl, REDCS as libc::c_int, c);
                    }
                }
                lgltrimlitstk(lgl, red, lidx);
                if druplig != 0 {
                    lglpushstk(lgl, &mut saved, 0 as libc::c_int);
                    lgldrupligdelclsaux(lgl, saved.start);
                    lglclnstk(&mut saved);
                }
            }
        }
        p = p.offset(1);
        p;
    }
    lglrelstk(lgl, &mut saved);
    hts = lglhts(lgl, lit);
    lglshrinkhts(lgl, hts, 0 as libc::c_int);
    lglchkirrstats(lgl);
    return res;
}
unsafe extern "C" fn lglflushed(mut lgl: *mut LGL) -> libc::c_int {
    return ((*lgl).flushed == lglcntstk(&mut (*lgl).trail) as libc::c_int)
        as libc::c_int;
}
unsafe extern "C" fn lglflush(mut lgl: *mut LGL) -> libc::c_int {
    let mut lit: libc::c_int = 0;
    let mut count: libc::c_int = 0;
    if (*lgl).mt != 0 {
        return 0 as libc::c_int;
    }
    lglchkirrstats(lgl);
    if lglflushed(lgl) != 0 {
        return 1 as libc::c_int;
    }
    if lglbcp(lgl) == 0 {
        lglmt(lgl);
        return 0 as libc::c_int;
    }
    if lglsyncunits(lgl) == 0 {
        return 0 as libc::c_int;
    }
    count = 0 as libc::c_int;
    while (*lgl).flushed < lglcntstk(&mut (*lgl).trail) as libc::c_int {
        let fresh191 = (*lgl).flushed;
        (*lgl).flushed = (*lgl).flushed + 1;
        lit = lglpeek(&mut (*lgl).trail, fresh191);
        lglflushclauses(lgl, lit);
        lglflushlits(lgl, -lit);
        count += 1;
        count;
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn lglblockinglit(mut lgl: *mut LGL, mut ilit: libc::c_int) {
    let mut elit: libc::c_int = lglexport(lgl, ilit);
    let mut sgnbit: libc::c_int = (1 as libc::c_int)
        << (elit < 0 as libc::c_int) as libc::c_int;
    let mut ext: *mut Ext = lglelit2ext(lgl, elit);
    if (*ext).blocking() as libc::c_int & sgnbit != 0 {
        return;
    }
    (*ext).set_blocking((*ext).blocking() | sgnbit as libc::c_uint);
    (*(*lgl).stats).blk.lits += 1;
    (*(*lgl).stats).blk.lits;
}
unsafe extern "C" fn lglelmfrelit(
    mut lgl: *mut LGL,
    mut mpivot: libc::c_int,
    mut sop: *mut libc::c_int,
    mut eop: *mut libc::c_int,
    mut son: *mut libc::c_int,
    mut eon: *mut libc::c_int,
) {
    let mut ipivot: libc::c_int = mpivot * (*(*lgl).c2rust_unnamed.elm).pivot;
    let mut clidx: libc::c_int = 0;
    let mut ilit: libc::c_int = 0;
    let mut tmp: libc::c_int = 0;
    let mut cover: libc::c_int = 0;
    let mut maxcover: libc::c_int = 0;
    let mut c: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut d: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut p: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut q: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut lit: libc::c_int = 0;
    let mut nontrivial: libc::c_int = 0;
    let mut idx: libc::c_int = 0;
    let mut sgn: libc::c_int = 0;
    let mut clen: libc::c_int = 0;
    let mut reslen: libc::c_int = 0;
    clidx = 0 as libc::c_int;
    cover = lglpeek(&mut (*(*lgl).c2rust_unnamed.elm).noccs, lglulit(-mpivot));
    c = sop;
    while c < eop {
        if (*lgl).eliminating != 0 {
            (*(*lgl).stats).steps += 1;
            (*(*lgl).stats).steps;
            (*(*lgl).stats).elm.steps += 1;
            (*(*lgl).stats).elm.steps;
        }
        if *c == 2147483647 as libc::c_int {
            p = c.offset(1 as libc::c_int as isize);
            while *p != 0 {
                p = p.offset(1);
                p;
            }
        } else {
            maxcover = 0 as libc::c_int;
            p = c;
            loop {
                lit = *p;
                if !(lit != 0) {
                    break;
                }
                if !(lit == mpivot) {
                    maxcover
                        += lglpeek(
                            &mut (*(*lgl).c2rust_unnamed.elm).noccs,
                            lglulit(-lit),
                        );
                }
                p = p.offset(1);
                p;
            }
            if maxcover < cover - 1 as libc::c_int {
                clidx += 1;
                clidx;
            } else {
                p = c;
                loop {
                    lit = *p;
                    if !(lit != 0) {
                        break;
                    }
                    if !(lit == mpivot) {
                        idx = abs(lit);
                        sgn = lglsgn(lit);
                        lglpoke(&mut (*(*lgl).c2rust_unnamed.elm).mark, idx, sgn);
                    }
                    p = p.offset(1);
                    p;
                }
                nontrivial = 0 as libc::c_int;
                clen = p.offset_from(c) as libc::c_long as libc::c_int;
                d = son;
                while nontrivial == 0 && d < eon {
                    (*(*lgl).stats).steps += 1;
                    (*(*lgl).stats).steps;
                    (*(*lgl).stats).elm.steps += 1;
                    (*(*lgl).stats).elm.steps;
                    if *d == 2147483647 as libc::c_int {
                        q = d.offset(1 as libc::c_int as isize);
                        while *q != 0 {
                            q = q.offset(1);
                            q;
                        }
                    } else {
                        (*(*lgl).stats).steps += 1;
                        (*(*lgl).stats).steps;
                        (*(*lgl).stats).elm.resolutions += 1;
                        (*(*lgl).stats).elm.resolutions;
                        reslen = clen - 1 as libc::c_int;
                        q = d;
                        loop {
                            lit = *q;
                            if !(lit != 0) {
                                break;
                            }
                            if !(lit == -mpivot) {
                                idx = abs(lit);
                                sgn = lglsgn(lit);
                                tmp = lglpeek(&mut (*(*lgl).c2rust_unnamed.elm).mark, idx);
                                if tmp == -sgn {
                                    break;
                                }
                                if tmp != sgn {
                                    reslen += 1;
                                    reslen;
                                }
                            }
                            q = q.offset(1);
                            q;
                        }
                        if lit != 0 {
                            loop {
                                q = q.offset(1);
                                if !(*q != 0) {
                                    break;
                                }
                            }
                        } else {
                            nontrivial = 2147483647 as libc::c_int;
                        }
                    }
                    d = q.offset(1 as libc::c_int as isize);
                }
                p = c;
                loop {
                    lit = *p;
                    if !(lit != 0) {
                        break;
                    }
                    if !(lit == mpivot) {
                        idx = abs(lit);
                        lglpoke(
                            &mut (*(*lgl).c2rust_unnamed.elm).mark,
                            idx,
                            0 as libc::c_int,
                        );
                    }
                    p = p.offset(1);
                    p;
                }
                if nontrivial == 0 && (*(*lgl).opts).block.val != 0
                    && (*(*lgl).opts).elmblk.val != 0
                    && ((*(*lgl).opts).elmblkwait.val == 0
                        || (*(*lgl).opts).elim.val == 0
                        || (*lgl).elmrtc as libc::c_int != 0)
                {
                    (*(*lgl).stats).elm.blkd += 1;
                    (*(*lgl).stats).elm.blkd;
                    lglepush(lgl, ipivot);
                    p = c;
                    loop {
                        lit = *p;
                        if !(lit != 0) {
                            break;
                        }
                        if !(lit == mpivot) {
                            ilit = lglm2i(lgl, lit);
                            lglepush(lgl, ilit);
                        }
                        p = p.offset(1);
                        p;
                    }
                    lglepush(lgl, 0 as libc::c_int);
                    lglelrmcls(lgl, ipivot, c, clidx);
                    lglblockinglit(lgl, ipivot);
                } else {
                    clidx += 1;
                    clidx;
                    if (*(*lgl).limits).elm.steps <= (*(*lgl).stats).elm.steps {
                        return;
                    }
                }
            }
        }
        c = p.offset(1 as libc::c_int as isize);
    }
}
unsafe extern "C" fn lglelmfre(mut lgl: *mut LGL) {
    let mut sop: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut eop: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut son: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut eon: *mut libc::c_int = 0 as *mut libc::c_int;
    sop = ((*(*lgl).c2rust_unnamed.elm).lits.start).offset(1 as libc::c_int as isize);
    son = ((*(*lgl).c2rust_unnamed.elm).lits.start)
        .offset((*(*lgl).c2rust_unnamed.elm).neglidx as isize);
    eop = son;
    eon = (*(*lgl).c2rust_unnamed.elm).lits.top;
    lglelmfrelit(lgl, 1 as libc::c_int, sop, eop, son, eon);
    lglelmfrelit(lgl, -(1 as libc::c_int), son, eon, sop, eop);
}
unsafe extern "C" fn lgleliminated(mut lgl: *mut LGL, mut pivot: libc::c_int) {
    let mut av: *mut AVar = 0 as *mut AVar;
    let mut elit: libc::c_int = 0;
    let mut e: *mut Ext = 0 as *mut Ext;
    av = lglavar(lgl, pivot);
    (*av).set_type_0(ELIMVAR as libc::c_int as libc::c_uint);
    (*(*lgl).stats).elm.elmd += 1;
    (*(*lgl).stats).elm.elmd;
    lglflushclauses(lgl, pivot);
    lglflushclauses(lgl, -pivot);
    elit = lglexport(lgl, pivot);
    e = lglelit2ext(lgl, elit);
    (*e).set_eliminated(1 as libc::c_int as libc::c_uint);
}
unsafe extern "C" fn lglepusheliminated(mut lgl: *mut LGL, mut idx: libc::c_int) {
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut w: *const libc::c_int = 0 as *const libc::c_int;
    let mut eow: *const libc::c_int = 0 as *const libc::c_int;
    let mut c: *const libc::c_int = 0 as *const libc::c_int;
    let mut l: *const libc::c_int = 0 as *const libc::c_int;
    let mut lit: libc::c_int = 0;
    let mut blit: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut red: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut hts: *mut HTS = 0 as *mut HTS;
    lit = if lglocc(lgl, idx) < lglocc(lgl, -idx) { idx } else { -idx };
    hts = lglhts(lgl, lit);
    w = lglhts2wchs(lgl, hts);
    eow = w.offset((*hts).count as isize);
    p = w;
    while p < eow {
        blit = *p;
        tag = blit & MASKCS as libc::c_int;
        if tag == TRNCS as libc::c_int || tag == LRGCS as libc::c_int {
            p = p.offset(1);
            p;
        }
        if !(tag == LRGCS as libc::c_int) {
            red = blit & REDCS as libc::c_int;
            if !(red != 0) {
                lglepush(lgl, lit);
                if tag == BINCS as libc::c_int || tag == TRNCS as libc::c_int {
                    lglepush(lgl, blit >> RMSHFT as libc::c_int);
                    if tag == TRNCS as libc::c_int {
                        lglepush(lgl, *p);
                    }
                } else {
                    c = lglidx2lits(
                        lgl,
                        0 as libc::c_int,
                        blit >> RMSHFT as libc::c_int,
                    );
                    l = c;
                    loop {
                        other = *l;
                        if !(other != 0) {
                            break;
                        }
                        if other != lit {
                            lglepush(lgl, other);
                        }
                        l = l.offset(1);
                        l;
                    }
                }
                lglepush(lgl, 0 as libc::c_int);
            }
        }
        p = p.offset(1);
        p;
    }
    lglepush(lgl, -lit);
    lglepush(lgl, 0 as libc::c_int);
    lgleliminated(lgl, idx);
}
unsafe extern "C" fn lglunhimpl(
    mut dfpr: *const DFPR,
    mut a: libc::c_int,
    mut b: libc::c_int,
) -> libc::c_int {
    let mut u: libc::c_int = lglulit(a);
    let mut v: libc::c_int = lglulit(b);
    let mut c: libc::c_int = 0;
    let mut d: libc::c_int = 0;
    let mut f: libc::c_int = 0;
    let mut g: libc::c_int = 0;
    c = (*dfpr.offset(u as isize)).discovered;
    if c == 0 {
        return 0 as libc::c_int;
    }
    d = (*dfpr.offset(v as isize)).discovered;
    if d == 0 {
        return 0 as libc::c_int;
    }
    f = (*dfpr.offset(u as isize)).finished;
    g = (*dfpr.offset(v as isize)).finished;
    return (c < d && g < f) as libc::c_int;
}
unsafe extern "C" fn lglunhimplies2(
    mut dfpr: *const DFPR,
    mut a: libc::c_int,
    mut b: libc::c_int,
) -> libc::c_int {
    return (lglunhimpl(dfpr, a, b) != 0 || lglunhimpl(dfpr, -b, -a) != 0) as libc::c_int;
}
unsafe extern "C" fn lglunhimplincl(
    mut dfpr: *const DFPR,
    mut a: libc::c_int,
    mut b: libc::c_int,
) -> libc::c_int {
    let mut u: libc::c_int = lglulit(a);
    let mut v: libc::c_int = lglulit(b);
    let mut c: libc::c_int = 0;
    let mut d: libc::c_int = 0;
    let mut f: libc::c_int = 0;
    let mut g: libc::c_int = 0;
    c = (*dfpr.offset(u as isize)).discovered;
    if c == 0 {
        return 0 as libc::c_int;
    }
    d = (*dfpr.offset(v as isize)).discovered;
    if d == 0 {
        return 0 as libc::c_int;
    }
    f = (*dfpr.offset(u as isize)).finished;
    g = (*dfpr.offset(v as isize)).finished;
    return (c <= d && g <= f) as libc::c_int;
}
unsafe extern "C" fn lglunhimplies2incl(
    mut dfpr: *const DFPR,
    mut a: libc::c_int,
    mut b: libc::c_int,
) -> libc::c_int {
    return (lglunhimplincl(dfpr, a, b) != 0 || lglunhimplincl(dfpr, -b, -a) != 0)
        as libc::c_int;
}
unsafe extern "C" fn lglhastrn(
    mut lgl: *mut LGL,
    mut a: libc::c_int,
    mut b: libc::c_int,
    mut c: libc::c_int,
) -> libc::c_int {
    let mut blit: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut other2: libc::c_int = 0;
    let mut w: *const libc::c_int = 0 as *const libc::c_int;
    let mut eow: *const libc::c_int = 0 as *const libc::c_int;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut ha: *mut HTS = 0 as *mut HTS;
    let mut hb: *mut HTS = 0 as *mut HTS;
    let mut hc: *mut HTS = 0 as *mut HTS;
    ha = lglhts(lgl, a);
    hb = lglhts(lgl, b);
    if (*hb).count < (*ha).count {
        let mut TMP: libc::c_int = a;
        a = b;
        b = TMP;
        let mut TMP_0: *mut HTS = ha;
        ha = hb;
        hb = TMP_0;
    }
    hc = lglhts(lgl, c);
    if (*hc).count < (*ha).count {
        let mut TMP_1: libc::c_int = a;
        a = c;
        c = TMP_1;
        let mut TMP_2: *mut HTS = ha;
        ha = hc;
        hc = TMP_2;
    }
    w = lglhts2wchs(lgl, ha);
    eow = w.offset((*ha).count as isize);
    p = w;
    while p < eow {
        blit = *p;
        tag = blit & MASKCS as libc::c_int;
        if !(tag == OCCS as libc::c_int) {
            if tag == BINCS as libc::c_int {
                other = blit >> RMSHFT as libc::c_int;
                if other == b || other == c {
                    return 1 as libc::c_int;
                }
            } else {
                if tag == TRNCS as libc::c_int || tag == LRGCS as libc::c_int {
                    p = p.offset(1);
                    p;
                }
                if !(tag == LRGCS as libc::c_int) {
                    other = blit >> RMSHFT as libc::c_int;
                    if !(other != b && other != c) {
                        other2 = *p;
                        if other2 == b || other2 == c {
                            return 1 as libc::c_int;
                        }
                    }
                }
            }
        }
        p = p.offset(1);
        p;
    }
    if (*hc).count < (*hb).count {
        let mut TMP_3: libc::c_int = b;
        b = c;
        c = TMP_3;
        let mut TMP_4: *mut HTS = hb;
        hb = hc;
        hc = TMP_4;
    }
    w = lglhts2wchs(lgl, hb);
    eow = w.offset((*hb).count as isize);
    p = w;
    while p < eow {
        blit = *p;
        tag = blit & MASKCS as libc::c_int;
        if !(tag == OCCS as libc::c_int) {
            if tag == TRNCS as libc::c_int || tag == LRGCS as libc::c_int {
                p = p.offset(1);
                p;
            } else {
                other = blit >> RMSHFT as libc::c_int;
                if other == c {
                    return 1 as libc::c_int;
                }
            }
        }
        p = p.offset(1);
        p;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn lglfactor(
    mut lgl: *mut LGL,
    mut lim: libc::c_int,
    mut count: libc::c_int,
) -> int64_t {
    let mut factor: int64_t = 0;
    let mut res: int64_t = 0;
    if count == 0 {
        return lim as int64_t;
    }
    match (*(*lgl).opts).factor.val {
        1 => {
            factor = lglceild(count) as int64_t;
        }
        2 => {
            factor = count as int64_t;
        }
        3 => {
            factor = count as int64_t * count as int64_t;
        }
        _ => {
            factor = 1 as libc::c_int as int64_t;
        }
    }
    if factor == 0 {
        factor = 1 as libc::c_int as int64_t;
    }
    if factor > (*(*lgl).opts).factmax.val as int64_t {
        factor = (*(*lgl).opts).factmax.val as int64_t;
    }
    res = lim as int64_t * factor;
    return res;
}
unsafe extern "C" fn lglforcedve(
    mut lgl: *mut LGL,
    mut idx: libc::c_int,
) -> libc::c_int {
    let mut pocc: libc::c_int = lglocc(lgl, idx);
    let mut nocc: libc::c_int = lglocc(lgl, -idx);
    let mut count: libc::c_int = (*(*lgl).stats).elm.count;
    if pocc == 0 {
        return 1 as libc::c_int;
    }
    if nocc == 0 {
        return 1 as libc::c_int;
    }
    if pocc + nocc <= (*(*lgl).opts).elmoccsumforced.val {
        return 1 as libc::c_int;
    }
    if (*(*lgl).opts).elmfull.val != 0 {
        return 0 as libc::c_int;
    }
    if pocc as int64_t >= lglfactor(lgl, (*(*lgl).opts).elmocclim1.val, count) {
        return -(1 as libc::c_int);
    }
    if nocc as int64_t >= lglfactor(lgl, (*(*lgl).opts).elmocclim1.val, count) {
        return -(1 as libc::c_int);
    }
    if (pocc as int64_t) < lglfactor(lgl, (*(*lgl).opts).elmocclim2.val, count) {
        return 0 as libc::c_int;
    }
    if (nocc as int64_t) < lglfactor(lgl, (*(*lgl).opts).elmocclim2.val, count) {
        return 0 as libc::c_int;
    }
    return -(1 as libc::c_int);
}
unsafe extern "C" fn lgltrylargeve(mut lgl: *mut LGL) -> libc::c_int {
    let mut c: *const libc::c_int = 0 as *const libc::c_int;
    let mut d: *const libc::c_int = 0 as *const libc::c_int;
    let mut sop: *const libc::c_int = 0 as *const libc::c_int;
    let mut eop: *const libc::c_int = 0 as *const libc::c_int;
    let mut son: *const libc::c_int = 0 as *const libc::c_int;
    let mut eon: *const libc::c_int = 0 as *const libc::c_int;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut q: *const libc::c_int = 0 as *const libc::c_int;
    let mut start: *const libc::c_int = 0 as *const libc::c_int;
    let mut end: *const libc::c_int = 0 as *const libc::c_int;
    let mut lit: libc::c_int = 0;
    let mut idx: libc::c_int = 0;
    let mut sgn: libc::c_int = 0;
    let mut tmp: libc::c_int = 0;
    let mut ip: libc::c_int = 0;
    let mut ilit: libc::c_int = 0;
    let mut npocc: libc::c_int = 0;
    let mut nnocc: libc::c_int = 0;
    let mut limit: libc::c_int = 0;
    let mut count: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut res: libc::c_int = 0;
    let mut clen: libc::c_int = 0;
    let mut dlen: libc::c_int = 0;
    let mut reslen: libc::c_int = 0;
    let mut maxreslen: libc::c_int = 0;
    ip = (*(*lgl).c2rust_unnamed.elm).pivot;
    res = lglforcedve(lgl, ip);
    if res != 0 {
        return (res > 0 as libc::c_int) as libc::c_int;
    }
    sop = ((*(*lgl).c2rust_unnamed.elm).lits.start).offset(1 as libc::c_int as isize);
    son = ((*(*lgl).c2rust_unnamed.elm).lits.start)
        .offset((*(*lgl).c2rust_unnamed.elm).neglidx as isize);
    eop = son;
    eon = (*(*lgl).c2rust_unnamed.elm).lits.top;
    npocc = lglpeek(&mut (*(*lgl).c2rust_unnamed.elm).noccs, lglulit(1 as libc::c_int));
    nnocc = lglpeek(
        &mut (*(*lgl).c2rust_unnamed.elm).noccs,
        lglulit(-(1 as libc::c_int)),
    );
    limit = npocc + nnocc;
    count = 0 as libc::c_int;
    i = 0 as libc::c_int;
    while i <= 1 as libc::c_int {
        start = if i != 0 { son } else { sop };
        end = if i != 0 { eon } else { eop };
        c = start;
        while c < end {
            (*(*lgl).stats).steps += 1;
            (*(*lgl).stats).steps;
            (*(*lgl).stats).elm.steps += 1;
            (*(*lgl).stats).elm.steps;
            if *c == 2147483647 as libc::c_int {
                while *c != 0 {
                    c = c.offset(1);
                    c;
                }
            } else {
                loop {
                    lit = *c;
                    if !(lit != 0) {
                        break;
                    }
                    lglm2i(lgl, lit);
                    c = c.offset(1);
                    c;
                }
                count += 1;
                count;
            }
            c = c.offset(1);
            c;
        }
        i += 1;
        i;
    }
    maxreslen = 0 as libc::c_int;
    c = sop;
    while c < eop && limit >= 0 as libc::c_int {
        (*(*lgl).stats).steps += 1;
        (*(*lgl).stats).steps;
        (*(*lgl).stats).elm.steps += 1;
        (*(*lgl).stats).elm.steps;
        if *c == 2147483647 as libc::c_int {
            p = c.offset(1 as libc::c_int as isize);
            while *p != 0 {
                p = p.offset(1);
                p;
            }
        } else {
            clen = 0 as libc::c_int;
            p = c;
            loop {
                lit = *p;
                if !(lit != 0) {
                    break;
                }
                if !(lit == 1 as libc::c_int) {
                    idx = abs(lit);
                    sgn = lglsgn(lit);
                    lglpoke(&mut (*(*lgl).c2rust_unnamed.elm).mark, idx, sgn);
                    ilit = lglm2i(lgl, lit);
                    lglpushstk(lgl, &mut (*lgl).resolvent, ilit);
                    clen += 1;
                    clen;
                }
                p = p.offset(1);
                p;
            }
            d = son;
            while limit >= 0 as libc::c_int && d < eon {
                (*(*lgl).stats).steps += 1;
                (*(*lgl).stats).steps;
                (*(*lgl).stats).elm.steps += 1;
                (*(*lgl).stats).elm.steps;
                if *d == 2147483647 as libc::c_int {
                    q = d.offset(1 as libc::c_int as isize);
                    while *q != 0 {
                        q = q.offset(1);
                        q;
                    }
                } else {
                    (*(*lgl).stats).steps += 1;
                    (*(*lgl).stats).steps;
                    (*(*lgl).stats).elm.resolutions += 1;
                    (*(*lgl).stats).elm.resolutions;
                    dlen = 0 as libc::c_int;
                    reslen = clen;
                    q = d;
                    loop {
                        lit = *q;
                        if !(lit != 0) {
                            break;
                        }
                        if !(lit == -(1 as libc::c_int)) {
                            dlen += 1;
                            dlen;
                            idx = abs(lit);
                            sgn = lglsgn(lit);
                            tmp = lglpeek(&mut (*(*lgl).c2rust_unnamed.elm).mark, idx);
                            if tmp == -sgn {
                                break;
                            }
                            if !(tmp == sgn) {
                                ilit = lglm2i(lgl, lit);
                                lglpushstk(lgl, &mut (*lgl).resolvent, ilit);
                                reslen += 1;
                                reslen;
                            }
                        }
                        q = q.offset(1);
                        q;
                    }
                    if lit == 0 && reslen == 1 as libc::c_int {
                        lit = lglpeek(&mut (*lgl).resolvent, 0 as libc::c_int);
                        limit
                            += (*lglevar(lgl, lit))
                                .occ[(lit < 0 as libc::c_int) as libc::c_int as usize];
                    } else if lit != 0 {
                        loop {
                            q = q.offset(1);
                            if !(*q != 0) {
                                break;
                            }
                        }
                    } else {
                        limit -= 1;
                        limit;
                        if reslen > maxreslen {
                            maxreslen = reslen;
                        }
                    }
                    lglrststk(&mut (*lgl).resolvent, clen);
                }
                d = q.offset(1 as libc::c_int as isize);
            }
            lglclnstk(&mut (*lgl).resolvent);
            p = c;
            loop {
                lit = *p;
                if !(lit != 0) {
                    break;
                }
                if !(lit == 1 as libc::c_int) {
                    idx = abs(lit);
                    lglpoke(
                        &mut (*(*lgl).c2rust_unnamed.elm).mark,
                        idx,
                        0 as libc::c_int,
                    );
                }
                p = p.offset(1);
                p;
            }
            if (*(*lgl).limits).elm.steps <= (*(*lgl).stats).elm.steps {
                return 0 as libc::c_int;
            }
        }
        c = p.offset(1 as libc::c_int as isize);
    }
    if limit < 0 as libc::c_int {
        return 0 as libc::c_int;
    }
    limit != 0;
    return 1 as libc::c_int;
}
unsafe extern "C" fn lgldolargeve(mut lgl: *mut LGL) {
    let mut c: *const libc::c_int = 0 as *const libc::c_int;
    let mut d: *const libc::c_int = 0 as *const libc::c_int;
    let mut sop: *const libc::c_int = 0 as *const libc::c_int;
    let mut eop: *const libc::c_int = 0 as *const libc::c_int;
    let mut son: *const libc::c_int = 0 as *const libc::c_int;
    let mut eon: *const libc::c_int = 0 as *const libc::c_int;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut q: *const libc::c_int = 0 as *const libc::c_int;
    let mut start: *const libc::c_int = 0 as *const libc::c_int;
    let mut end: *const libc::c_int = 0 as *const libc::c_int;
    let mut lit: libc::c_int = 0;
    let mut idx: libc::c_int = 0;
    let mut sgn: libc::c_int = 0;
    let mut tmp: libc::c_int = 0;
    let mut ip: libc::c_int = 0;
    let mut ilit: libc::c_int = 0;
    let mut mp: libc::c_int = 0;
    let mut npocc: libc::c_int = 0;
    let mut nnocc: libc::c_int = 0;
    let mut clen: libc::c_int = 0;
    let mut dlen: libc::c_int = 0;
    let mut reslen: libc::c_int = 0;
    let mut val: Val = 0;
    ip = (*(*lgl).c2rust_unnamed.elm).pivot;
    sop = ((*(*lgl).c2rust_unnamed.elm).lits.start).offset(1 as libc::c_int as isize);
    son = ((*(*lgl).c2rust_unnamed.elm).lits.start)
        .offset((*(*lgl).c2rust_unnamed.elm).neglidx as isize);
    eop = son;
    eon = (*(*lgl).c2rust_unnamed.elm).lits.top;
    npocc = lglpeek(&mut (*(*lgl).c2rust_unnamed.elm).noccs, lglulit(1 as libc::c_int));
    nnocc = lglpeek(
        &mut (*(*lgl).c2rust_unnamed.elm).noccs,
        lglulit(-(1 as libc::c_int)),
    );
    if npocc < nnocc {
        start = sop;
        end = eop;
        mp = 1 as libc::c_int;
    } else {
        start = son;
        end = eon;
        ip = -ip;
        mp = -(1 as libc::c_int);
    }
    c = start;
    while c < end {
        (*(*lgl).stats).steps += 1;
        (*(*lgl).stats).steps;
        (*(*lgl).stats).elm.steps += 1;
        (*(*lgl).stats).elm.steps;
        if *c == 2147483647 as libc::c_int {
            p = c.offset(1 as libc::c_int as isize);
            while *p != 0 {
                p = p.offset(1);
                p;
            }
        } else {
            lglepush(lgl, ip);
            p = c;
            loop {
                lit = *p;
                if !(lit != 0) {
                    break;
                }
                if !(lit == mp) {
                    ilit = lglm2i(lgl, lit);
                    lglepush(lgl, ilit);
                }
                p = p.offset(1);
                p;
            }
            lglepush(lgl, 0 as libc::c_int);
        }
        c = p.offset(1 as libc::c_int as isize);
    }
    lglepush(lgl, -ip);
    lglepush(lgl, 0 as libc::c_int);
    c = sop;
    while c < eop {
        (*(*lgl).stats).steps += 1;
        (*(*lgl).stats).steps;
        (*(*lgl).stats).elm.steps += 1;
        (*(*lgl).stats).elm.steps;
        if *c == 2147483647 as libc::c_int {
            p = c.offset(1 as libc::c_int as isize);
            while *p != 0 {
                p = p.offset(1);
                p;
            }
        } else {
            clen = 0 as libc::c_int;
            p = c;
            loop {
                lit = *p;
                if !(lit != 0) {
                    break;
                }
                if !(lit == 1 as libc::c_int) {
                    idx = abs(lit);
                    sgn = lglsgn(lit);
                    lglpoke(&mut (*(*lgl).c2rust_unnamed.elm).mark, idx, sgn);
                    ilit = lglm2i(lgl, lit);
                    lglpushstk(lgl, &mut (*lgl).resolvent, ilit);
                    clen += 1;
                    clen;
                }
                p = p.offset(1);
                p;
            }
            let mut current_block_90: u64;
            d = son;
            while d < eon {
                (*(*lgl).stats).steps += 1;
                (*(*lgl).stats).steps;
                (*(*lgl).stats).elm.steps += 1;
                (*(*lgl).stats).elm.steps;
                if *d == 2147483647 as libc::c_int {
                    q = d.offset(1 as libc::c_int as isize);
                    while *q != 0 {
                        q = q.offset(1);
                        q;
                    }
                } else {
                    (*(*lgl).stats).steps += 1;
                    (*(*lgl).stats).steps;
                    (*(*lgl).stats).elm.resolutions += 1;
                    (*(*lgl).stats).elm.resolutions;
                    dlen = 0 as libc::c_int;
                    reslen = clen;
                    q = d;
                    loop {
                        lit = *q;
                        if !(lit != 0) {
                            break;
                        }
                        if !(lit == -(1 as libc::c_int)) {
                            dlen += 1;
                            dlen;
                            idx = abs(lit);
                            sgn = lglsgn(lit);
                            tmp = lglpeek(&mut (*(*lgl).c2rust_unnamed.elm).mark, idx);
                            if !(tmp == sgn) {
                                if tmp == -sgn {
                                    break;
                                }
                                ilit = lglm2i(lgl, lit);
                                val = lglval(lgl, ilit);
                                if !((val as libc::c_int) < 0 as libc::c_int) {
                                    if val as libc::c_int > 0 as libc::c_int {
                                        break;
                                    }
                                    lglpushstk(lgl, &mut (*lgl).clause, ilit);
                                    ilit = lglm2i(lgl, lit);
                                    lglpushstk(lgl, &mut (*lgl).resolvent, ilit);
                                    reslen += 1;
                                    reslen;
                                }
                            }
                        }
                        q = q.offset(1);
                        q;
                    }
                    if lit == 0 && reslen == 1 as libc::c_int {
                        current_block_90 = 10435735846551762309;
                    } else if lit != 0 {
                        loop {
                            q = q.offset(1);
                            if !(*q != 0) {
                                break;
                            }
                        }
                        current_block_90 = 6471821049853688503;
                    } else {
                        current_block_90 = 10435735846551762309;
                    }
                    match current_block_90 {
                        10435735846551762309 => {
                            p = c;
                            loop {
                                lit = *p;
                                if !(lit != 0) {
                                    break;
                                }
                                if !(lit == 1 as libc::c_int) {
                                    ilit = lglm2i(lgl, lit);
                                    val = lglval(lgl, ilit);
                                    if !((val as libc::c_int) < 0 as libc::c_int) {
                                        if val as libc::c_int > 0 as libc::c_int {
                                            break;
                                        }
                                        lglpushstk(lgl, &mut (*lgl).clause, ilit);
                                    }
                                }
                                p = p.offset(1);
                                p;
                            }
                            if lit == 0 {
                                lglpushstk(lgl, &mut (*lgl).clause, 0 as libc::c_int);
                                lgldrupligaddcls(lgl, REDCS as libc::c_int);
                                lgladdcls(
                                    lgl,
                                    0 as libc::c_int,
                                    0 as libc::c_int,
                                    1 as libc::c_int,
                                );
                            }
                        }
                        _ => {}
                    }
                    lglclnstk(&mut (*lgl).clause);
                    lglrststk(&mut (*lgl).resolvent, clen);
                }
                d = q.offset(1 as libc::c_int as isize);
            }
            lglclnstk(&mut (*lgl).resolvent);
            p = c;
            loop {
                lit = *p;
                if !(lit != 0) {
                    break;
                }
                if !(lit == 1 as libc::c_int) {
                    idx = abs(lit);
                    lglpoke(
                        &mut (*(*lgl).c2rust_unnamed.elm).mark,
                        idx,
                        0 as libc::c_int,
                    );
                }
                p = p.offset(1);
                p;
            }
        }
        c = p.offset(1 as libc::c_int as isize);
    }
    lgleliminated(lgl, (*(*lgl).c2rust_unnamed.elm).pivot);
    (*(*lgl).stats).elm.large += 1;
    (*(*lgl).stats).elm.large;
}
unsafe extern "C" fn lglelimlitaux(mut lgl: *mut LGL, mut idx: libc::c_int) {
    lglelmsub(lgl);
    if lglelmstr(lgl) != 0 {
        return;
    }
    lglelmfre(lgl);
    if lgltrylargeve(lgl) != 0 {
        lgldolargeve(lgl);
    }
}
unsafe extern "C" fn lgls2m(mut lgl: *mut LGL, mut ilit: libc::c_int) -> libc::c_int {
    let mut av: *mut AVar = lglavar(lgl, ilit);
    let mut res: libc::c_int = (*av).mark;
    if res == 0 {
        res = (lglcntstk(&mut (*lgl).seen)).wrapping_add(1 as libc::c_int as size_t)
            as libc::c_int;
        if res > (*(*lgl).opts).smallvevars.val + 1 as libc::c_int {
            return 0 as libc::c_int;
        }
        (*av).mark = res;
        lglpushstk(lgl, &mut (*lgl).seen, abs(ilit));
        lglpushstk(lgl, &mut (*(*lgl).c2rust_unnamed.elm).m2i, abs(ilit));
    }
    if ilit < 0 as libc::c_int {
        res = -res;
    }
    return res;
}
unsafe extern "C" fn lglvar2funaux(
    mut v: libc::c_int,
    mut res: *mut uint64_t,
    mut negate: libc::c_int,
) {
    let mut tmp: uint64_t = 0;
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut p: libc::c_int = 0;
    if v < 6 as libc::c_int {
        tmp = lglbasevar2funtab[v as usize];
        if negate != 0 {
            tmp = !tmp;
        }
        i = 0 as libc::c_int;
        while i < (1 as libc::c_int) << 12 as libc::c_int - 6 as libc::c_int {
            *res.offset(i as isize) = tmp;
            i += 1;
            i;
        }
    } else {
        tmp = (if negate != 0 {
            !(0 as libc::c_ulonglong)
        } else {
            0 as libc::c_ulonglong
        }) as uint64_t;
        p = (1 as libc::c_int) << v - 6 as libc::c_int;
        j = 0 as libc::c_int;
        i = 0 as libc::c_int;
        while i < (1 as libc::c_int) << 12 as libc::c_int - 6 as libc::c_int {
            *res.offset(i as isize) = tmp;
            j += 1;
            if !(j < p) {
                tmp = !tmp;
                j = 0 as libc::c_int;
            }
            i += 1;
            i;
        }
    };
}
unsafe extern "C" fn lglvar2fun(mut v: libc::c_int, mut res: *mut uint64_t) {
    lglvar2funaux(v, res, 0 as libc::c_int);
}
unsafe extern "C" fn lglnegvar2fun(mut v: libc::c_int, mut res: *mut uint64_t) {
    lglvar2funaux(v, res, 1 as libc::c_int);
}
unsafe extern "C" fn lglfuncpy(mut dst: *mut uint64_t, mut src: *const uint64_t) {
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < (1 as libc::c_int) << 12 as libc::c_int - 6 as libc::c_int {
        *dst.offset(i as isize) = *src.offset(i as isize);
        i += 1;
        i;
    }
}
unsafe extern "C" fn lglfalsefun(mut res: *mut uint64_t) {
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < (1 as libc::c_int) << 12 as libc::c_int - 6 as libc::c_int {
        *res.offset(i as isize) = 0 as libc::c_int as uint64_t;
        i += 1;
        i;
    }
}
unsafe extern "C" fn lgltruefun(mut res: *mut uint64_t) {
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < (1 as libc::c_int) << 12 as libc::c_int - 6 as libc::c_int {
        *res.offset(i as isize) = !(0 as libc::c_int as uint64_t);
        i += 1;
        i;
    }
}
unsafe extern "C" fn lglisfalsefun(mut f: *const uint64_t) -> libc::c_int {
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < (1 as libc::c_int) << 12 as libc::c_int - 6 as libc::c_int {
        if *f.offset(i as isize) != 0 as libc::c_int as uint64_t {
            return 0 as libc::c_int;
        }
        i += 1;
        i;
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn lglistruefun(mut f: *const uint64_t) -> libc::c_int {
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < (1 as libc::c_int) << 12 as libc::c_int - 6 as libc::c_int {
        if *f.offset(i as isize) != !(0 as libc::c_int as uint64_t) {
            return 0 as libc::c_int;
        }
        i += 1;
        i;
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn lglorfun(mut a: *mut uint64_t, mut b: *const uint64_t) {
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < (1 as libc::c_int) << 12 as libc::c_int - 6 as libc::c_int {
        *a.offset(i as isize) |= *b.offset(i as isize);
        i += 1;
        i;
    }
}
unsafe extern "C" fn lglornegfun(mut a: *mut uint64_t, mut b: *const uint64_t) {
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < (1 as libc::c_int) << 12 as libc::c_int - 6 as libc::c_int {
        *a.offset(i as isize) |= !*b.offset(i as isize);
        i += 1;
        i;
    }
}
unsafe extern "C" fn lglor3fun(
    mut a: *mut uint64_t,
    mut b: *const uint64_t,
    mut c: *const uint64_t,
) {
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < (1 as libc::c_int) << 12 as libc::c_int - 6 as libc::c_int {
        *a.offset(i as isize) = *b.offset(i as isize) | *c.offset(i as isize);
        i += 1;
        i;
    }
}
unsafe extern "C" fn lglor3negfun(
    mut a: *mut uint64_t,
    mut b: *const uint64_t,
    mut c: *const uint64_t,
) {
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < (1 as libc::c_int) << 12 as libc::c_int - 6 as libc::c_int {
        *a.offset(i as isize) = *b.offset(i as isize) | !*c.offset(i as isize);
        i += 1;
        i;
    }
}
unsafe extern "C" fn lglandornegfun(
    mut a: *mut uint64_t,
    mut b: *const uint64_t,
    mut c: *const uint64_t,
) {
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < (1 as libc::c_int) << 12 as libc::c_int - 6 as libc::c_int {
        *a.offset(i as isize) &= *b.offset(i as isize) | !*c.offset(i as isize);
        i += 1;
        i;
    }
}
unsafe extern "C" fn lglandfun(mut a: *mut uint64_t, mut b: *const uint64_t) {
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < (1 as libc::c_int) << 12 as libc::c_int - 6 as libc::c_int {
        *a.offset(i as isize) &= *b.offset(i as isize);
        i += 1;
        i;
    }
}
unsafe extern "C" fn lgland3fun(
    mut a: *mut uint64_t,
    mut b: *const uint64_t,
    mut c: *const uint64_t,
) {
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < (1 as libc::c_int) << 12 as libc::c_int - 6 as libc::c_int {
        *a.offset(i as isize) = *b.offset(i as isize) & *c.offset(i as isize);
        i += 1;
        i;
    }
}
unsafe extern "C" fn lgland3negfun(
    mut a: *mut uint64_t,
    mut b: *const uint64_t,
    mut c: *const uint64_t,
) {
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < (1 as libc::c_int) << 12 as libc::c_int - 6 as libc::c_int {
        *a.offset(i as isize) = *b.offset(i as isize) & !*c.offset(i as isize);
        i += 1;
        i;
    }
}
unsafe extern "C" fn lglsrfun(mut a: *mut uint64_t, mut shift: libc::c_int) {
    let mut rest: uint64_t = 0;
    let mut tmp: uint64_t = 0;
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut q: libc::c_int = 0;
    let mut b: libc::c_int = 0;
    let mut l: libc::c_int = 0;
    b = shift & 63 as libc::c_int;
    q = shift >> 6 as libc::c_int;
    j = 0 as libc::c_int;
    i = q;
    l = 64 as libc::c_int - b;
    while j < (1 as libc::c_int) << 12 as libc::c_int - 6 as libc::c_int {
        if i < (1 as libc::c_int) << 12 as libc::c_int - 6 as libc::c_int {
            tmp = *a.offset(i as isize) >> b;
            rest = (if b != 0
                && (i + 1 as libc::c_int)
                    < (1 as libc::c_int) << 12 as libc::c_int - 6 as libc::c_int
            {
                (*a.offset((i + 1 as libc::c_int) as isize) << l) as libc::c_ulonglong
            } else {
                0 as libc::c_ulonglong
            }) as uint64_t;
            *a.offset(j as isize) = rest | tmp;
        } else {
            *a.offset(j as isize) = 0 as libc::c_ulonglong as uint64_t;
        }
        i += 1;
        i;
        j += 1;
        j;
    }
}
unsafe extern "C" fn lglslfun(mut a: *mut uint64_t, mut shift: libc::c_int) {
    let mut rest: uint64_t = 0;
    let mut tmp: uint64_t = 0;
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut q: libc::c_int = 0;
    let mut b: libc::c_int = 0;
    let mut l: libc::c_int = 0;
    b = shift & 63 as libc::c_int;
    q = shift >> 6 as libc::c_int;
    j = ((1 as libc::c_int) << 12 as libc::c_int - 6 as libc::c_int) - 1 as libc::c_int;
    i = j - q;
    l = 64 as libc::c_int - b;
    while j >= 0 as libc::c_int {
        if i >= 0 as libc::c_int {
            tmp = *a.offset(i as isize) << b;
            rest = if b != 0 && i > 0 as libc::c_int {
                *a.offset((i - 1 as libc::c_int) as isize) >> l
            } else {
                0 as libc::c_int as uint64_t
            };
            *a.offset(j as isize) = rest | tmp;
        } else {
            *a.offset(j as isize) = 0 as libc::c_int as uint64_t;
        }
        i -= 1;
        i;
        j -= 1;
        j;
    }
}
unsafe extern "C" fn lgls2fun(mut mlit: libc::c_int, mut res: *mut uint64_t) {
    let mut midx: libc::c_int = abs(mlit);
    let mut sidx: libc::c_int = midx - 2 as libc::c_int;
    if mlit < 0 as libc::c_int {
        lglnegvar2fun(sidx, res);
    } else {
        lglvar2fun(sidx, res);
    };
}
unsafe extern "C" fn lglinitsmallve(
    mut lgl: *mut LGL,
    mut lit: libc::c_int,
    mut res: *mut uint64_t,
) -> libc::c_int {
    let mut blit: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut red: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut other2: libc::c_int = 0;
    let mut lidx: libc::c_int = 0;
    let mut mlit: libc::c_int = 0;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut w: *const libc::c_int = 0 as *const libc::c_int;
    let mut eow: *const libc::c_int = 0 as *const libc::c_int;
    let mut c: *const libc::c_int = 0 as *const libc::c_int;
    let mut q: *const libc::c_int = 0 as *const libc::c_int;
    let mut cls: Fun = [0; 64];
    let mut tmp: Fun = [0; 64];
    let mut hts: *mut HTS = 0 as *mut HTS;
    let mut val: Val = 0;
    lgls2m(lgl, lit);
    hts = lglhts(lgl, lit);
    lgltruefun(res);
    if !((*hts).count == 0) {
        w = lglhts2wchs(lgl, hts);
        eow = w.offset((*hts).count as isize);
        p = w;
        while p < eow {
            (*(*lgl).stats).steps += 1;
            (*(*lgl).stats).steps;
            (*(*lgl).stats).elm.steps += 1;
            (*(*lgl).stats).elm.steps;
            blit = *p;
            tag = blit & MASKCS as libc::c_int;
            if tag == TRNCS as libc::c_int || tag == LRGCS as libc::c_int {
                p = p.offset(1);
                p;
            }
            if !(tag == LRGCS as libc::c_int) {
                red = blit & REDCS as libc::c_int;
                if !(red != 0) {
                    lglfalsefun(cls.as_mut_ptr());
                    if tag == BINCS as libc::c_int || tag == TRNCS as libc::c_int {
                        other = blit >> RMSHFT as libc::c_int;
                        val = lglval(lgl, other);
                        if val == 0 {
                            mlit = lgls2m(lgl, other);
                            if mlit == 0 {
                                return 0 as libc::c_int;
                            }
                            lgls2fun(mlit, tmp.as_mut_ptr());
                            lglorfun(
                                cls.as_mut_ptr(),
                                tmp.as_mut_ptr() as *const uint64_t,
                            );
                        }
                        if tag == TRNCS as libc::c_int {
                            other2 = *p;
                            val = lglval(lgl, other2);
                            if val == 0 {
                                mlit = lgls2m(lgl, other2);
                                if mlit == 0 {
                                    return 0 as libc::c_int;
                                }
                                lgls2fun(mlit, tmp.as_mut_ptr());
                                lglorfun(
                                    cls.as_mut_ptr(),
                                    tmp.as_mut_ptr() as *const uint64_t,
                                );
                            }
                        }
                    } else {
                        lidx = blit >> RMSHFT as libc::c_int;
                        c = lglidx2lits(lgl, 0 as libc::c_int, lidx);
                        q = c;
                        loop {
                            other = *q;
                            if !(other != 0) {
                                break;
                            }
                            if !(other == lit) {
                                val = lglval(lgl, other);
                                if val == 0 {
                                    mlit = lgls2m(lgl, other);
                                    if mlit == 0 {
                                        return 0 as libc::c_int;
                                    }
                                    lgls2fun(mlit, tmp.as_mut_ptr());
                                    lglorfun(
                                        cls.as_mut_ptr(),
                                        tmp.as_mut_ptr() as *const uint64_t,
                                    );
                                }
                            }
                            q = q.offset(1);
                            q;
                        }
                    }
                    lglandfun(res, cls.as_mut_ptr() as *const uint64_t);
                    (*(*lgl).stats).steps += 1;
                    (*(*lgl).stats).steps;
                    (*(*lgl).stats).elm.copies += 1;
                    (*(*lgl).stats).elm.copies;
                }
            }
            p = p.offset(1);
            p;
        }
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn lglresetsmallve(mut lgl: *mut LGL) {
    lglclnstk(&mut (*(*lgl).c2rust_unnamed.elm).m2i);
    lglclnstk(&mut (*(*lgl).c2rust_unnamed.elm).clv);
    lglpopnunmarkstk(lgl, &mut (*lgl).seen);
}
unsafe extern "C" fn lglsmallevalcls(mut cls: libc::c_uint, mut res: *mut uint64_t) {
    let mut tmp: Fun = [0; 64];
    let mut v: libc::c_int = 0;
    lglfalsefun(res);
    v = 0 as libc::c_int;
    while v < 12 as libc::c_int {
        if cls
            & ((1 as libc::c_int) << 2 as libc::c_int * v + 1 as libc::c_int)
                as libc::c_uint != 0
        {
            lglvar2fun(v, tmp.as_mut_ptr());
            lglornegfun(res, tmp.as_mut_ptr() as *const uint64_t);
        } else if cls & ((1 as libc::c_int) << 2 as libc::c_int * v) as libc::c_uint != 0
        {
            lglvar2fun(v, tmp.as_mut_ptr());
            lglorfun(res, tmp.as_mut_ptr() as *const uint64_t);
        }
        v += 1;
        v;
    }
}
unsafe extern "C" fn lglpos2cnf(mut pos: libc::c_int) -> Cnf {
    return pos as Cnf;
}
unsafe extern "C" fn lglsize2cnf(mut s: libc::c_int) -> Cnf {
    return (s as Cnf) << 32 as libc::c_int;
}
unsafe extern "C" fn lglcnf2pos(mut cnf: Cnf) -> libc::c_int {
    return (cnf as libc::c_longlong & 0xfffff as libc::c_longlong) as libc::c_int;
}
unsafe extern "C" fn lglcnf2size(mut cnf: Cnf) -> libc::c_int {
    return (cnf >> 32 as libc::c_int) as libc::c_int;
}
unsafe extern "C" fn lglcnf(mut pos: libc::c_int, mut size: libc::c_int) -> Cnf {
    return lglpos2cnf(pos) | lglsize2cnf(size);
}
unsafe extern "C" fn lglsmallevalcnf(
    mut lgl: *mut LGL,
    mut cnf: Cnf,
    mut res: *mut uint64_t,
) {
    let mut tmp: Fun = [0; 64];
    let mut i: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    let mut p: libc::c_int = 0;
    let mut cls: libc::c_int = 0;
    p = lglcnf2pos(cnf);
    n = lglcnf2size(cnf);
    lgltruefun(res);
    i = 0 as libc::c_int;
    while i < n {
        cls = lglpeek(&mut (*(*lgl).c2rust_unnamed.elm).clv, p + i);
        lglsmallevalcls(cls as libc::c_uint, tmp.as_mut_ptr());
        lglandfun(res, tmp.as_mut_ptr() as *const uint64_t);
        i += 1;
        i;
    }
}
unsafe extern "C" fn lglnegcofactorfun(
    mut f: *const uint64_t,
    mut v: libc::c_int,
    mut res: *mut uint64_t,
) {
    let mut mask: Fun = [0; 64];
    let mut masked: Fun = [0; 64];
    lglvar2fun(v, mask.as_mut_ptr());
    lgland3negfun(masked.as_mut_ptr(), f, mask.as_mut_ptr() as *const uint64_t);
    lglfuncpy(res, masked.as_mut_ptr() as *const uint64_t);
    lglslfun(masked.as_mut_ptr(), (1 as libc::c_int) << v);
    lglorfun(res, masked.as_mut_ptr() as *const uint64_t);
}
unsafe extern "C" fn lglposcofactorfun(
    mut f: *const uint64_t,
    mut v: libc::c_int,
    mut res: *mut uint64_t,
) {
    let mut mask: Fun = [0; 64];
    let mut masked: Fun = [0; 64];
    lglvar2fun(v, mask.as_mut_ptr());
    lgland3fun(masked.as_mut_ptr(), f, mask.as_mut_ptr() as *const uint64_t);
    lglfuncpy(res, masked.as_mut_ptr() as *const uint64_t);
    lglsrfun(masked.as_mut_ptr(), (1 as libc::c_int) << v);
    lglorfun(res, masked.as_mut_ptr() as *const uint64_t);
}
unsafe extern "C" fn lglsmallfundeps0(mut f: *const uint64_t) -> libc::c_int {
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < (1 as libc::c_int) << 12 as libc::c_int - 6 as libc::c_int {
        if (*f.offset(i as isize) as libc::c_ulonglong
            & 0xaaaaaaaaaaaaaaaa as libc::c_ulonglong) >> 1 as libc::c_int
            != *f.offset(i as isize) as libc::c_ulonglong
                & 0x5555555555555555 as libc::c_ulonglong
        {
            return 1 as libc::c_int;
        }
        i += 1;
        i;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn lglsmallfundeps1(mut f: *const uint64_t) -> libc::c_int {
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < (1 as libc::c_int) << 12 as libc::c_int - 6 as libc::c_int {
        if (*f.offset(i as isize) as libc::c_ulonglong
            & 0xcccccccccccccccc as libc::c_ulonglong) >> 2 as libc::c_int
            != *f.offset(i as isize) as libc::c_ulonglong
                & 0x3333333333333333 as libc::c_ulonglong
        {
            return 1 as libc::c_int;
        }
        i += 1;
        i;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn lglsmallfundeps2(mut f: *const uint64_t) -> libc::c_int {
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < (1 as libc::c_int) << 12 as libc::c_int - 6 as libc::c_int {
        if (*f.offset(i as isize) as libc::c_ulonglong
            & 0xf0f0f0f0f0f0f0f0 as libc::c_ulonglong) >> 4 as libc::c_int
            != *f.offset(i as isize) as libc::c_ulonglong
                & 0xf0f0f0f0f0f0f0f as libc::c_ulonglong
        {
            return 1 as libc::c_int;
        }
        i += 1;
        i;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn lglsmallfundeps3(mut f: *const uint64_t) -> libc::c_int {
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < (1 as libc::c_int) << 12 as libc::c_int - 6 as libc::c_int {
        if (*f.offset(i as isize) as libc::c_ulonglong
            & 0xff00ff00ff00ff00 as libc::c_ulonglong) >> 8 as libc::c_int
            != *f.offset(i as isize) as libc::c_ulonglong
                & 0xff00ff00ff00ff as libc::c_ulonglong
        {
            return 1 as libc::c_int;
        }
        i += 1;
        i;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn lglsmallfundeps4(mut f: *const uint64_t) -> libc::c_int {
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < (1 as libc::c_int) << 12 as libc::c_int - 6 as libc::c_int {
        if (*f.offset(i as isize) as libc::c_ulonglong
            & 0xffff0000ffff0000 as libc::c_ulonglong) >> 16 as libc::c_int
            != *f.offset(i as isize) as libc::c_ulonglong
                & 0xffff0000ffff as libc::c_ulonglong
        {
            return 1 as libc::c_int;
        }
        i += 1;
        i;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn lglsmallfundeps5(mut f: *const uint64_t) -> libc::c_int {
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < (1 as libc::c_int) << 12 as libc::c_int - 6 as libc::c_int {
        if (*f.offset(i as isize) as libc::c_ulonglong
            & 0xffffffff00000000 as libc::c_ulonglong) >> 32 as libc::c_int
            != *f.offset(i as isize) as libc::c_ulonglong
                & 0xffffffff as libc::c_ulonglong
        {
            return 1 as libc::c_int;
        }
        i += 1;
        i;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn lglsmallfundepsgen(
    mut f: *const uint64_t,
    mut min: libc::c_int,
) -> libc::c_int {
    let c: libc::c_int = (1 as libc::c_int) << min - 6 as libc::c_int;
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < (1 as libc::c_int) << 12 as libc::c_int - 6 as libc::c_int {
        j = 0 as libc::c_int;
        while j < c {
            if *f.offset((i + j) as isize) != *f.offset((i + c + j) as isize) {
                return 1 as libc::c_int;
            }
            j += 1;
            j;
        }
        i += (1 as libc::c_int) << min - 5 as libc::c_int;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn lglsmalltopvar(
    mut f: *const uint64_t,
    mut min: libc::c_int,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    if min == 0 as libc::c_int && lglsmallfundeps0(f) != 0 {
        return 0 as libc::c_int;
    }
    if min == 1 as libc::c_int && lglsmallfundeps1(f) != 0 {
        return 1 as libc::c_int;
    }
    if min == 2 as libc::c_int && lglsmallfundeps2(f) != 0 {
        return 2 as libc::c_int;
    }
    if min == 3 as libc::c_int && lglsmallfundeps3(f) != 0 {
        return 3 as libc::c_int;
    }
    if min == 4 as libc::c_int && lglsmallfundeps4(f) != 0 {
        return 4 as libc::c_int;
    }
    if min == 5 as libc::c_int && lglsmallfundeps5(f) != 0 {
        return 5 as libc::c_int;
    }
    i = lglmax(6 as libc::c_int, min);
    while i <= 12 as libc::c_int - 2 as libc::c_int {
        if lglsmallfundepsgen(f, i) != 0 {
            return i;
        }
        i += 1;
        i;
    }
    return i;
}
unsafe extern "C" fn lglsmalladdlit2cnf(
    mut lgl: *mut LGL,
    mut cnf: Cnf,
    mut lit: libc::c_int,
) -> Cnf {
    let mut p: libc::c_int = 0;
    let mut m: libc::c_int = 0;
    let mut q: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut cls: libc::c_int = 0;
    let mut res: Cnf = 0;
    p = lglcnf2pos(cnf);
    m = lglcnf2size(cnf);
    q = lglcntstk(&mut (*(*lgl).c2rust_unnamed.elm).clv) as libc::c_int;
    i = 0 as libc::c_int;
    while i < m {
        cls = lglpeek(&mut (*(*lgl).c2rust_unnamed.elm).clv, p + i);
        cls |= lit;
        lglpushstk(lgl, &mut (*(*lgl).c2rust_unnamed.elm).clv, cls);
        i += 1;
        i;
    }
    n = (lglcntstk(&mut (*(*lgl).c2rust_unnamed.elm).clv)).wrapping_sub(q as size_t)
        as libc::c_int;
    res = lglcnf(q, n);
    return res;
}
unsafe extern "C" fn lglsmallipos(
    mut lgl: *mut LGL,
    mut U: *const uint64_t,
    mut L: *const uint64_t,
    mut min: libc::c_int,
) -> Cnf {
    let mut U0: Fun = [0; 64];
    let mut U1: Fun = [0; 64];
    let mut L0: Fun = [0; 64];
    let mut L1: Fun = [0; 64];
    let mut Unew: Fun = [0; 64];
    let mut ftmp: Fun = [0; 64];
    let mut c0: Cnf = 0;
    let mut c1: Cnf = 0;
    let mut cstar: Cnf = 0;
    let mut ctmp: Cnf = 0;
    let mut res: Cnf = 0;
    let mut x: libc::c_int = 0;
    let mut y: libc::c_int = 0;
    let mut z: libc::c_int = 0;
    if lglistruefun(U) != 0 {
        return 0 as libc::c_longlong as Cnf;
    }
    if lglisfalsefun(L) != 0 {
        return ((1 as libc::c_longlong) << 32 as libc::c_int) as Cnf;
    }
    (*(*lgl).stats).elm.ipos += 1;
    (*(*lgl).stats).elm.ipos;
    y = lglsmalltopvar(U, min);
    z = lglsmalltopvar(L, min);
    (*(*lgl).stats).steps += 1;
    (*(*lgl).stats).steps;
    (*(*lgl).stats).elm.steps += 1;
    (*(*lgl).stats).elm.steps;
    x = if y < z { y } else { z };
    lglnegcofactorfun(U, x, U0.as_mut_ptr());
    lglposcofactorfun(U, x, U1.as_mut_ptr());
    lglnegcofactorfun(L, x, L0.as_mut_ptr());
    lglposcofactorfun(L, x, L1.as_mut_ptr());
    lglor3negfun(
        ftmp.as_mut_ptr(),
        U0.as_mut_ptr() as *const uint64_t,
        L1.as_mut_ptr() as *const uint64_t,
    );
    c0 = lglsmallipos(
        lgl,
        ftmp.as_mut_ptr() as *const uint64_t,
        L0.as_mut_ptr() as *const uint64_t,
        min + 1 as libc::c_int,
    );
    lglor3negfun(
        ftmp.as_mut_ptr(),
        U1.as_mut_ptr() as *const uint64_t,
        L0.as_mut_ptr() as *const uint64_t,
    );
    c1 = lglsmallipos(
        lgl,
        ftmp.as_mut_ptr() as *const uint64_t,
        L1.as_mut_ptr() as *const uint64_t,
        min + 1 as libc::c_int,
    );
    lglsmallevalcnf(lgl, c0, ftmp.as_mut_ptr());
    lglor3negfun(
        Unew.as_mut_ptr(),
        U0.as_mut_ptr() as *const uint64_t,
        ftmp.as_mut_ptr() as *const uint64_t,
    );
    lglsmallevalcnf(lgl, c1, ftmp.as_mut_ptr());
    lglandornegfun(
        Unew.as_mut_ptr(),
        U1.as_mut_ptr() as *const uint64_t,
        ftmp.as_mut_ptr() as *const uint64_t,
    );
    lglor3fun(
        ftmp.as_mut_ptr(),
        L0.as_mut_ptr() as *const uint64_t,
        L1.as_mut_ptr() as *const uint64_t,
    );
    cstar = lglsmallipos(
        lgl,
        Unew.as_mut_ptr() as *const uint64_t,
        ftmp.as_mut_ptr() as *const uint64_t,
        min + 1 as libc::c_int,
    );
    ctmp = lglsmalladdlit2cnf(
        lgl,
        c1,
        (1 as libc::c_int) << 2 as libc::c_int * x + 1 as libc::c_int,
    );
    res = lglcnf2pos(ctmp) as Cnf;
    ctmp = lglsmalladdlit2cnf(lgl, c0, (1 as libc::c_int) << 2 as libc::c_int * x);
    if res as libc::c_longlong == 0 as libc::c_longlong {
        res = lglcnf2pos(ctmp) as Cnf;
    }
    ctmp = lglsmalladdlit2cnf(lgl, cstar, 0 as libc::c_int);
    if res as libc::c_longlong == 0 as libc::c_longlong {
        res = lglcnf2pos(ctmp) as Cnf;
    }
    res
        |= lglsize2cnf(
            (lglcntstk(&mut (*(*lgl).c2rust_unnamed.elm).clv))
                .wrapping_sub(res as size_t) as libc::c_int,
        );
    return res;
}
unsafe extern "C" fn lglsmallve(mut lgl: *mut LGL, mut cnf: Cnf) {
    let mut soc: *mut libc::c_int = ((*(*lgl).c2rust_unnamed.elm).clv.start)
        .offset(lglcnf2pos(cnf) as isize);
    let mut eoc: *mut libc::c_int = soc.offset(lglcnf2size(cnf) as isize);
    let mut p: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut cls: libc::c_int = 0;
    let mut v: libc::c_int = 0;
    let mut lit: libc::c_int = 0;
    let mut trivial: libc::c_int = 0;
    let mut val: Val = 0;
    p = soc;
    while (*lgl).mt == 0 && p < eoc {
        cls = *p;
        trivial = 0 as libc::c_int;
        let mut current_block_10: u64;
        v = 0 as libc::c_int;
        while v < 12 as libc::c_int {
            if cls & (1 as libc::c_int) << 2 as libc::c_int * v + 1 as libc::c_int != 0 {
                lit = -lglm2i(lgl, v + 2 as libc::c_int);
                current_block_10 = 1917311967535052937;
            } else if cls & (1 as libc::c_int) << 2 as libc::c_int * v != 0 {
                lit = lglm2i(lgl, v + 2 as libc::c_int);
                current_block_10 = 1917311967535052937;
            } else {
                current_block_10 = 6873731126896040597;
            }
            match current_block_10 {
                1917311967535052937 => {
                    val = lglval(lgl, lit);
                    if !((val as libc::c_int) < 0 as libc::c_int) {
                        if val as libc::c_int > 0 as libc::c_int {
                            trivial = 1 as libc::c_int;
                        }
                        lglpushstk(lgl, &mut (*lgl).clause, lit);
                    }
                }
                _ => {}
            }
            v += 1;
            v;
        }
        if trivial == 0 {
            (*(*lgl).stats).steps += 1;
            (*(*lgl).stats).steps;
            (*(*lgl).stats).elm.resolutions += 1;
            (*(*lgl).stats).elm.resolutions;
            lglpushstk(lgl, &mut (*lgl).clause, 0 as libc::c_int);
            lgldrupligaddcls(lgl, REDCS as libc::c_int);
            lgladdcls(lgl, 0 as libc::c_int, 0 as libc::c_int, 1 as libc::c_int);
        }
        lglclnstk(&mut (*lgl).clause);
        p = p.offset(1);
        p;
    }
}
unsafe extern "C" fn lglsmallisunitcls(
    mut lgl: *mut LGL,
    mut cls: libc::c_int,
) -> libc::c_int {
    let mut fidx: libc::c_int = 0;
    let mut fsign: libc::c_int = 0;
    let mut flit: libc::c_int = 0;
    let mut mlit: libc::c_int = 0;
    let mut ilit: libc::c_int = 0;
    ilit = 0 as libc::c_int;
    fidx = 0 as libc::c_int;
    while fidx < 12 as libc::c_int {
        fsign = 0 as libc::c_int;
        while fsign <= 1 as libc::c_int {
            flit = (1 as libc::c_int) << 2 as libc::c_int * fidx + fsign;
            if !(cls & flit == 0) {
                if ilit != 0 {
                    return 0 as libc::c_int;
                }
                mlit = (fidx + 2 as libc::c_int)
                    * (if fsign != 0 { -(1 as libc::c_int) } else { 1 as libc::c_int });
                ilit = lglm2i(lgl, mlit);
            }
            fsign += 1;
            fsign;
        }
        fidx += 1;
        fidx;
    }
    return ilit;
}
unsafe extern "C" fn lglsmallcnfunits(mut lgl: *mut LGL, mut cnf: Cnf) -> libc::c_int {
    let mut p: libc::c_int = 0;
    let mut m: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut res: libc::c_int = 0;
    let mut cls: libc::c_int = 0;
    let mut ilit: libc::c_int = 0;
    p = lglcnf2pos(cnf);
    m = lglcnf2size(cnf);
    res = 0 as libc::c_int;
    i = 0 as libc::c_int;
    while i < m {
        cls = lglpeek(&mut (*(*lgl).c2rust_unnamed.elm).clv, p + i);
        ilit = lglsmallisunitcls(lgl, cls);
        if !(ilit == 0) {
            lglunit(lgl, ilit);
            res += 1;
            res;
        }
        i += 1;
        i;
    }
    return res;
}
unsafe extern "C" fn lgltrysmallve(
    mut lgl: *mut LGL,
    mut idx: libc::c_int,
) -> libc::c_int {
    let mut res: libc::c_int = 0;
    let mut new: libc::c_int = 0;
    let mut old: libc::c_int = 0;
    let mut units: libc::c_int = 0;
    let mut pos: Fun = [0; 64];
    let mut neg: Fun = [0; 64];
    let mut fun: Fun = [0; 64];
    let mut ev: *mut EVar = 0 as *mut EVar;
    let mut cnf: Cnf = 0;
    if (*(*lgl).opts).smallve.val == 0 {
        return 0 as libc::c_int;
    }
    if (*(*lgl).opts).smallvewait.val != 0 && (*lgl).elmrtc == 0 {
        return 0 as libc::c_int;
    }
    lglpushstk(lgl, &mut (*(*lgl).c2rust_unnamed.elm).m2i, 0 as libc::c_int);
    lglpushstk(lgl, &mut (*(*lgl).c2rust_unnamed.elm).clv, 0 as libc::c_int);
    res = 0 as libc::c_int;
    if lglinitsmallve(lgl, idx, pos.as_mut_ptr()) != 0
        && lglinitsmallve(lgl, -idx, neg.as_mut_ptr()) != 0
    {
        lglor3fun(
            fun.as_mut_ptr(),
            pos.as_mut_ptr() as *const uint64_t,
            neg.as_mut_ptr() as *const uint64_t,
        );
        cnf = lglsmallipos(
            lgl,
            fun.as_mut_ptr() as *const uint64_t,
            fun.as_mut_ptr() as *const uint64_t,
            0 as libc::c_int,
        );
        new = lglcnf2size(cnf);
        units = lglsmallcnfunits(lgl, cnf);
        new -= units;
        ev = lglevar(lgl, idx);
        old = (*ev).occ[0 as libc::c_int as usize]
            + (*ev).occ[1 as libc::c_int as usize];
        (*(*lgl).stats).elm.small.tried += 1;
        (*(*lgl).stats).elm.small.tried;
        if new > old {
            if units > 0 as libc::c_int {
                res = 1 as libc::c_int;
            } else {
                (*(*lgl).stats).elm.small.failed += 1;
                (*(*lgl).stats).elm.small.failed;
            }
        } else {
            lglepusheliminated(lgl, idx);
            lglflushclauses(lgl, idx);
            lglflushclauses(lgl, -idx);
            lglsmallve(lgl, cnf);
            (*(*lgl).stats).elm.small.elm += 1;
            (*(*lgl).stats).elm.small.elm;
            res = 1 as libc::c_int;
        }
    }
    lglresetsmallve(lgl);
    return res;
}
unsafe extern "C" fn lgl2manyoccs4elm(
    mut lgl: *mut LGL,
    mut lit: libc::c_int,
) -> libc::c_int {
    return (lglocc(lgl, lit) as int64_t
        > lglfactor(lgl, (*(*lgl).opts).elmocclim.val, (*(*lgl).stats).elm.count))
        as libc::c_int;
}
unsafe extern "C" fn lglchkoccs4elmlit(
    mut lgl: *mut LGL,
    mut lit: libc::c_int,
) -> libc::c_int {
    let mut blit: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut red: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut other2: libc::c_int = 0;
    let mut lidx: libc::c_int = 0;
    let mut size: libc::c_int = 0;
    let mut lits: libc::c_int = 0;
    let mut count: libc::c_int = 0;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut w: *const libc::c_int = 0 as *const libc::c_int;
    let mut eow: *const libc::c_int = 0 as *const libc::c_int;
    let mut c: *const libc::c_int = 0 as *const libc::c_int;
    let mut l: *const libc::c_int = 0 as *const libc::c_int;
    let mut litslim: int64_t = 0;
    let mut hts: *mut HTS = 0 as *mut HTS;
    if (*(*lgl).opts).elmfull.val != 0 {
        return 1 as libc::c_int;
    }
    count = (*(*lgl).stats).elm.count;
    litslim = lglfactor(lgl, (*(*lgl).opts).elmlitslim.val, count);
    hts = lglhts(lgl, lit);
    w = lglhts2wchs(lgl, hts);
    eow = w.offset((*hts).count as isize);
    lits = 0 as libc::c_int;
    p = w;
    while p < eow {
        blit = *p;
        tag = blit & MASKCS as libc::c_int;
        red = blit & REDCS as libc::c_int;
        if tag == TRNCS as libc::c_int || tag == LRGCS as libc::c_int {
            p = p.offset(1);
            p;
        }
        if !(red != 0 || tag == LRGCS as libc::c_int) {
            if tag == BINCS as libc::c_int {
                other = blit >> RMSHFT as libc::c_int;
                if lgl2manyoccs4elm(lgl, other) != 0 {
                    return 0 as libc::c_int;
                }
                lits += 2 as libc::c_int;
            } else if tag == TRNCS as libc::c_int {
                other = blit >> RMSHFT as libc::c_int;
                if lgl2manyoccs4elm(lgl, other) != 0 {
                    return 0 as libc::c_int;
                }
                other2 = *p;
                if lgl2manyoccs4elm(lgl, other2) != 0 {
                    return 0 as libc::c_int;
                }
                lits += 3 as libc::c_int;
            } else {
                lidx = blit >> RMSHFT as libc::c_int;
                c = lglidx2lits(lgl, 0 as libc::c_int, lidx);
                size = 0 as libc::c_int;
                l = c;
                loop {
                    other = *l;
                    if !(other != 0) {
                        break;
                    }
                    if lgl2manyoccs4elm(lgl, other) != 0 {
                        return 0 as libc::c_int;
                    }
                    size += 1;
                    if size as int64_t
                        > lglfactor(lgl, (*(*lgl).opts).elmclslim.val, count)
                    {
                        return 0 as libc::c_int;
                    }
                    l = l.offset(1);
                    l;
                }
                lits += size;
            }
            if lits as int64_t > litslim {
                return 0 as libc::c_int;
            }
        }
        p = p.offset(1);
        p;
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn lglchkoccs4elm(
    mut lgl: *mut LGL,
    mut idx: libc::c_int,
) -> libc::c_int {
    let mut res: libc::c_int = 0;
    res = lglforcedve(lgl, idx);
    if res > 0 as libc::c_int {
        return 1 as libc::c_int;
    }
    if res < 0 as libc::c_int {
        return 0 as libc::c_int;
    }
    if lgl2manyoccs4elm(lgl, idx) != 0 {
        return 0 as libc::c_int;
    }
    if lgl2manyoccs4elm(lgl, -idx) != 0 {
        return 0 as libc::c_int;
    }
    if lglchkoccs4elmlit(lgl, idx) == 0 {
        return 0 as libc::c_int;
    }
    if lglchkoccs4elmlit(lgl, -idx) == 0 {
        return 0 as libc::c_int;
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn lglispure(mut lgl: *mut LGL, mut lit: libc::c_int) -> libc::c_int {
    if (*(*lgl).opts).pure_0.val == 0 {
        return 0 as libc::c_int;
    }
    if lglifrozen(lgl, lit) != 0 {
        return 0 as libc::c_int;
    }
    return (lglocc(lgl, -lit) == 0) as libc::c_int;
}
unsafe extern "C" fn lglpurelit(mut lgl: *mut LGL, mut lit: libc::c_int) -> libc::c_int {
    let mut res: libc::c_int = 0;
    res = lglflushclauses(lgl, lit);
    if (*lgl).blocking != 0 {
        (*(*lgl).stats).blk.pure_0 += 1;
        (*(*lgl).stats).blk.pure_0;
        (*(*lgl).stats).blk.clauses += res;
        (*(*lgl).stats).steps += res as int64_t;
        (*(*lgl).stats).blk.steps += res as int64_t;
    }
    if (*lgl).eliminating != 0 {
        (*(*lgl).stats).elm.pure_0 += 1;
        (*(*lgl).stats).elm.pure_0;
        (*(*lgl).stats).steps += res as int64_t;
        (*(*lgl).stats).elm.steps += res as int64_t;
    }
    lglepusheliminated(lgl, lit);
    return res;
}
unsafe extern "C" fn lglelimlit(mut lgl: *mut LGL, mut idx: libc::c_int) {
    let mut forced: libc::c_int = 0;
    if lglisfree(lgl, idx) == 0 {
        return;
    }
    if lglispure(lgl, idx) != 0 {
        lglpurelit(lgl, idx);
        return;
    }
    if lglispure(lgl, -idx) != 0 {
        lglpurelit(lgl, -idx);
        return;
    }
    if lglchkoccs4elm(lgl, idx) == 0 {
        return;
    }
    forced = lglforcedve(lgl, idx);
    if forced < 0 as libc::c_int {
        return;
    }
    if forced == 0 && lgltrysmallve(lgl, idx) != 0 {
        return;
    }
    lglinitecls(lgl, idx);
    lglelimlitaux(lgl, idx);
    if (*(*lgl).c2rust_unnamed.elm).pivot != 0 {
        lglrstecls(lgl);
    }
}
unsafe extern "C" fn lglblockcls(
    mut lgl: *mut LGL,
    mut lit: libc::c_int,
) -> libc::c_int {
    let mut blit: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut red: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut other2: libc::c_int = 0;
    let mut lidx: libc::c_int = 0;
    let mut val: libc::c_int = 0;
    let mut count: libc::c_int = 0;
    let mut size: libc::c_int = 0;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut w: *const libc::c_int = 0 as *const libc::c_int;
    let mut eow: *const libc::c_int = 0 as *const libc::c_int;
    let mut c: *const libc::c_int = 0 as *const libc::c_int;
    let mut l: *const libc::c_int = 0 as *const libc::c_int;
    let mut bc: libc::c_int = (*(*lgl).stats).blk.count;
    let mut hts: *mut HTS = 0 as *mut HTS;
    (*(*lgl).stats).steps += 1;
    (*(*lgl).stats).steps;
    (*(*lgl).stats).blk.steps += 1;
    (*(*lgl).stats).blk.steps;
    hts = lglhts(lgl, lit);
    if (*hts).count == 0 {
        return 1 as libc::c_int;
    }
    w = lglhts2wchs(lgl, hts);
    eow = w.offset((*hts).count as isize);
    count = 0 as libc::c_int;
    let mut current_block_29: u64;
    p = w;
    while p < eow {
        blit = *p;
        tag = blit & MASKCS as libc::c_int;
        if tag == TRNCS as libc::c_int || tag == LRGCS as libc::c_int {
            p = p.offset(1);
            p;
        }
        if !(tag == LRGCS as libc::c_int) {
            red = blit & REDCS as libc::c_int;
            if !(red != 0) {
                count += 1;
                count;
                (*(*lgl).stats).blk.res += 1;
                (*(*lgl).stats).blk.res;
                (*(*lgl).stats).steps += 1;
                (*(*lgl).stats).steps;
                (*(*lgl).stats).blk.steps += 1;
                (*(*lgl).stats).blk.steps;
                if tag == BINCS as libc::c_int || tag == TRNCS as libc::c_int {
                    other = blit >> RMSHFT as libc::c_int;
                    val = lglmarked(lgl, other);
                    if val < 0 as libc::c_int {
                        current_block_29 = 2473556513754201174;
                    } else if tag == TRNCS as libc::c_int {
                        other2 = *p;
                        val = lglmarked(lgl, other2);
                        if val < 0 as libc::c_int {
                            current_block_29 = 2473556513754201174;
                        } else {
                            current_block_29 = 2891135413264362348;
                        }
                    } else {
                        current_block_29 = 2891135413264362348;
                    }
                } else {
                    lidx = blit >> RMSHFT as libc::c_int;
                    c = lglidx2lits(lgl, 0 as libc::c_int, lidx);
                    size = 0 as libc::c_int;
                    l = c;
                    loop {
                        other = *l;
                        if !(other != 0) {
                            break;
                        }
                        val = lglmarked(lgl, other);
                        size += 1;
                        if size as int64_t
                            > lglfactor(lgl, (*(*lgl).opts).blkclslim.val, bc)
                        {
                            return 0 as libc::c_int;
                        }
                        if val < 0 as libc::c_int {
                            break;
                        }
                        l = l.offset(1);
                        l;
                    }
                    if other != 0 {
                        current_block_29 = 2473556513754201174;
                    } else {
                        current_block_29 = 2891135413264362348;
                    }
                }
                match current_block_29 {
                    2473556513754201174 => {}
                    _ => return 0 as libc::c_int,
                }
            }
        }
        p = p.offset(1);
        p;
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn lgl2manyoccs4blk(
    mut lgl: *mut LGL,
    mut lit: libc::c_int,
) -> libc::c_int {
    return ((*lglhts(lgl, lit)).count as int64_t
        > lglfactor(lgl, (*(*lgl).opts).blkocclim.val, (*(*lgl).stats).blk.count))
        as libc::c_int;
}
unsafe extern "C" fn lgldonotblocklit(
    mut lgl: *mut LGL,
    mut lit: libc::c_int,
) -> libc::c_int {
    let mut pocc: libc::c_int = lglocc(lgl, lit);
    let mut nocc: libc::c_int = lglocc(lgl, -lit);
    let mut count: libc::c_int = (*(*lgl).stats).blk.count;
    if pocc as int64_t >= lglfactor(lgl, (*(*lgl).opts).blkocclim1.val, count) {
        return 1 as libc::c_int;
    }
    if nocc as int64_t >= lglfactor(lgl, (*(*lgl).opts).blkocclim1.val, count) {
        return 1 as libc::c_int;
    }
    if (pocc as int64_t) < lglfactor(lgl, (*(*lgl).opts).blkocclim2.val, count) {
        return 0 as libc::c_int;
    }
    if (nocc as int64_t) < lglfactor(lgl, (*(*lgl).opts).blkocclim2.val, count) {
        return 0 as libc::c_int;
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn lglblocklit(
    mut lgl: *mut LGL,
    mut lit: libc::c_int,
    mut stk: *mut Stk,
) -> libc::c_int {
    let mut current_block: u64;
    let mut blit: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut red: libc::c_int = 0;
    let mut blocked: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut other2: libc::c_int = 0;
    let mut lidx: libc::c_int = 0;
    let mut count: libc::c_int = 0;
    let mut size: libc::c_int = 0;
    let mut bc: libc::c_int = (*(*lgl).stats).blk.count;
    let mut p: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut w: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut eow: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut c: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut l: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut hts: *mut HTS = 0 as *mut HTS;
    if lglval(lgl, lit) != 0 {
        return 0 as libc::c_int;
    }
    if lgldonotblocklit(lgl, lit) != 0 {
        return 0 as libc::c_int;
    }
    if lgl2manyoccs4blk(lgl, lit) != 0 {
        return 0 as libc::c_int;
    }
    hts = lglhts(lgl, lit);
    w = lglhts2wchs(lgl, hts);
    eow = w.offset((*hts).count as isize);
    count = 0 as libc::c_int;
    p = w;
    while p < eow {
        (*(*lgl).stats).steps += 1;
        (*(*lgl).stats).steps;
        let fresh192 = (*(*lgl).stats).blk.steps;
        (*(*lgl).stats).blk.steps = (*(*lgl).stats).blk.steps + 1;
        if fresh192 >= (*(*lgl).limits).blk.steps {
            break;
        }
        if lglterminate(lgl) != 0 {
            break;
        }
        blit = *p;
        tag = blit & MASKCS as libc::c_int;
        if tag == TRNCS as libc::c_int || tag == LRGCS as libc::c_int {
            p = p.offset(1);
            p;
        }
        if !(tag == LRGCS as libc::c_int) {
            red = blit & REDCS as libc::c_int;
            if !(red != 0) {
                blocked = 0 as libc::c_int;
                if tag == BINCS as libc::c_int || tag == TRNCS as libc::c_int {
                    if (*(*lgl).opts).blksmall.val == 0 {
                        current_block = 11812396948646013369;
                    } else {
                        other = blit >> RMSHFT as libc::c_int;
                        if lgl2manyoccs4blk(lgl, other) != 0 {
                            current_block = 11812396948646013369;
                        } else {
                            lglpushnmarkseen(lgl, other);
                            if tag == TRNCS as libc::c_int {
                                other2 = *p;
                                if lgl2manyoccs4blk(lgl, other2) != 0 {
                                    current_block = 16304286114859883648;
                                } else {
                                    lglpushnmarkseen(lgl, other2);
                                    current_block = 5529461102203738653;
                                }
                            } else {
                                current_block = 5529461102203738653;
                            }
                        }
                    }
                } else if (*(*lgl).opts).blklarge.val == 0 {
                    current_block = 11812396948646013369;
                } else {
                    lidx = blit >> RMSHFT as libc::c_int;
                    c = lglidx2lits(lgl, 0 as libc::c_int, lidx);
                    size = 0 as libc::c_int;
                    l = c;
                    loop {
                        other = *l;
                        if !(other != 0) {
                            current_block = 5529461102203738653;
                            break;
                        }
                        if !(other == lit) {
                            if lgl2manyoccs4blk(lgl, other) != 0 {
                                current_block = 16304286114859883648;
                                break;
                            }
                            size += 1;
                            if size as int64_t
                                > lglfactor(lgl, (*(*lgl).opts).blkclslim.val, bc)
                            {
                                current_block = 16304286114859883648;
                                break;
                            }
                            lglpushnmarkseen(lgl, other);
                        }
                        l = l.offset(1);
                        l;
                    }
                }
                match current_block {
                    11812396948646013369 => {}
                    _ => {
                        match current_block {
                            5529461102203738653 => {
                                blocked = lglblockcls(lgl, -lit);
                            }
                            _ => {}
                        }
                        lglpopnunmarkstk(lgl, &mut (*lgl).seen);
                        if !(blocked == 0) {
                            if tag == BINCS as libc::c_int {
                                other = blit >> RMSHFT as libc::c_int;
                                lglpushstk(
                                    lgl,
                                    stk.offset(2 as libc::c_int as isize),
                                    other,
                                );
                            } else if tag == TRNCS as libc::c_int {
                                other = blit >> RMSHFT as libc::c_int;
                                lglpushstk(
                                    lgl,
                                    stk.offset(3 as libc::c_int as isize),
                                    other,
                                );
                                other2 = *p;
                                lglpushstk(
                                    lgl,
                                    stk.offset(3 as libc::c_int as isize),
                                    other2,
                                );
                            } else {
                                lidx = blit >> RMSHFT as libc::c_int;
                                lglpushstk(
                                    lgl,
                                    stk.offset(4 as libc::c_int as isize),
                                    lidx,
                                );
                            }
                        }
                    }
                }
            }
        }
        p = p.offset(1);
        p;
    }
    while lglmtstk(stk.offset(2 as libc::c_int as isize)) == 0 {
        (*(*lgl).stats).steps += 1;
        (*(*lgl).stats).steps;
        let fresh193 = (*(*lgl).stats).blk.steps;
        (*(*lgl).stats).blk.steps = (*(*lgl).stats).blk.steps + 1;
        if fresh193 >= (*(*lgl).limits).blk.steps {
            break;
        }
        count += 1;
        count;
        other = lglpopstk(stk.offset(2 as libc::c_int as isize));
        lglrmbcls(lgl, lit, other, 0 as libc::c_int);
        lglepush(lgl, lit);
        lglepush(lgl, other);
        lglepush(lgl, 0 as libc::c_int);
        if lglmvbcls(lgl, lit, other) == 0 {
            lgldrupligdelclsarg(lgl, lit, other, 0 as libc::c_int);
        }
    }
    while lglmtstk(stk.offset(3 as libc::c_int as isize)) == 0 {
        (*(*lgl).stats).steps += 1;
        (*(*lgl).stats).steps;
        let fresh194 = (*(*lgl).stats).blk.steps;
        (*(*lgl).stats).blk.steps = (*(*lgl).stats).blk.steps + 1;
        if fresh194 >= (*(*lgl).limits).blk.steps {
            break;
        }
        count += 1;
        count;
        other2 = lglpopstk(stk.offset(3 as libc::c_int as isize));
        other = lglpopstk(stk.offset(3 as libc::c_int as isize));
        lglrmtcls(lgl, lit, other, other2, 0 as libc::c_int);
        lglepush(lgl, lit);
        lglepush(lgl, other);
        lglepush(lgl, other2);
        lglepush(lgl, 0 as libc::c_int);
        if lglmvtcls(lgl, lit, other, other2) == 0 {
            lgldrupligdelclsarg(lgl, lit, other, other2, 0 as libc::c_int);
        }
    }
    while lglmtstk(stk.offset(4 as libc::c_int as isize)) == 0 {
        (*(*lgl).stats).steps += 1;
        (*(*lgl).stats).steps;
        let fresh195 = (*(*lgl).stats).blk.steps;
        (*(*lgl).stats).blk.steps = (*(*lgl).stats).blk.steps + 1;
        if fresh195 >= (*(*lgl).limits).blk.steps {
            break;
        }
        lidx = lglpopstk(stk.offset(4 as libc::c_int as isize));
        count += 1;
        count;
        c = lglidx2lits(lgl, 0 as libc::c_int, lidx);
        lgldrupligdelclsaux(lgl, c);
        lglepush(lgl, lit);
        l = c;
        loop {
            other = *l;
            if !(other != 0) {
                break;
            }
            if other != lit {
                lglepush(lgl, other);
            }
            l = l.offset(1);
            l;
        }
        lglepush(lgl, 0 as libc::c_int);
        lglrmlcls(lgl, lidx, 0 as libc::c_int);
    }
    (*(*lgl).stats).blk.clauses += count;
    if count > 0 as libc::c_int {
        lglblockinglit(lgl, lit);
    }
    lglclnstk(stk.offset(2 as libc::c_int as isize));
    lglclnstk(stk.offset(3 as libc::c_int as isize));
    lglclnstk(stk.offset(4 as libc::c_int as isize));
    return count;
}
unsafe extern "C" fn lglsetblklim(mut lgl: *mut LGL) {
    let mut limit: int64_t = 0;
    let mut irrlim: int64_t = 0;
    let mut pen: libc::c_int = 0;
    let mut szpen: libc::c_int = 0;
    if (*(*lgl).opts).blkrtc.val != 0 {
        (*(*lgl).limits).blk.steps = 0x7fffffffffffffff as libc::c_longlong as int64_t;
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[block-%d] really no limit (run to completion)\0" as *const u8
                as *const libc::c_char,
            (*(*lgl).stats).blk.count,
        );
    } else {
        limit = (*(*lgl).opts).blkreleff.val as int64_t * lglvisearch(lgl)
            / 1000 as libc::c_int as int64_t;
        if limit < (*(*lgl).opts).blkmineff.val as int64_t {
            limit = (*(*lgl).opts).blkmineff.val as int64_t;
        }
        if (*(*lgl).opts).blkmaxeff.val >= 0 as libc::c_int
            && limit > (*(*lgl).opts).blkmaxeff.val as int64_t
        {
            limit = (*(*lgl).opts).blkmaxeff.val as int64_t;
        }
        if (*(*lgl).stats).blk.count <= 1 as libc::c_int && (*(*lgl).opts).boost.val != 0
            && lglrem(lgl) < (*(*lgl).opts).blkboostvlim.val
        {
            lglprt(
                lgl,
                1 as libc::c_int,
                b"[block-%d] boosting limit by %d\0" as *const u8 as *const libc::c_char,
                (*(*lgl).stats).blk.count,
                (*(*lgl).opts).blkboost.val,
            );
            limit *= (*(*lgl).opts).blkboost.val as int64_t;
        }
        szpen = lglszpen(lgl);
        pen = (*(*lgl).limits).blk.pen + szpen;
        limit >>= pen;
        irrlim = ((*(*lgl).stats).irr.clauses.cur / 2 as libc::c_int >> szpen)
            as int64_t;
        if (*(*lgl).opts).irrlim.val != 0 && limit < irrlim {
            limit = irrlim;
            lglprt(
                lgl,
                1 as libc::c_int,
                b"[block-%d] limit of %lld steps based on %d irredundant clauses penalty %d\0"
                    as *const u8 as *const libc::c_char,
                (*(*lgl).stats).blk.count,
                limit as libc::c_longlong,
                (*(*lgl).stats).irr.clauses.cur,
                szpen,
            );
        } else {
            lglprt(
                lgl,
                1 as libc::c_int,
                b"[block-%d] limit of %lld steps penalty %d = %d + %d\0" as *const u8
                    as *const libc::c_char,
                (*(*lgl).stats).blk.count,
                limit as libc::c_longlong,
                pen,
                (*(*lgl).limits).blk.pen,
                szpen,
            );
        }
        (*(*lgl).limits).blk.steps = (*(*lgl).stats).blk.steps + limit;
    };
}
unsafe extern "C" fn lgleschedrem(
    mut lgl: *mut LGL,
    mut this_time: libc::c_int,
) -> libc::c_int {
    let mut idx: libc::c_int = 0;
    let mut res: libc::c_int = 0 as libc::c_int;
    let mut count: libc::c_int = 0;
    let mut str: *const libc::c_char = 0 as *const libc::c_char;
    let mut av: *mut AVar = 0 as *mut AVar;
    idx = 2 as libc::c_int;
    while idx < (*lgl).nvars {
        if !(lglifrozen(lgl, idx) != 0) {
            if !(lglisfree(lgl, idx) == 0) {
                av = lglavar(lgl, idx);
                if !((*lgl).eliminating as libc::c_int != 0
                    && (*av).donotelm() as libc::c_int != 0)
                {
                    if !((*lgl).blocking as libc::c_int != 0
                        && (*av).donotblk() as libc::c_int != 0)
                    {
                        res += 1;
                        res;
                    }
                }
            }
        }
        idx += 1;
        idx;
    }
    if (*lgl).eliminating != 0 {
        count = (*(*lgl).stats).elm.count;
        str = b"elim\0" as *const u8 as *const libc::c_char;
    } else {
        count = (*(*lgl).stats).blk.count;
        str = b"block\0" as *const u8 as *const libc::c_char;
    }
    if res != 0 {
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[%s-%d] %d variables %.0f%% %s time\0" as *const u8 as *const libc::c_char,
            str,
            count,
            res,
            lglpcnt(res as libc::c_double, lglrem(lgl) as libc::c_double),
            if this_time != 0 {
                b"will be scheduled this\0" as *const u8 as *const libc::c_char
            } else {
                b"remain to be tried next\0" as *const u8 as *const libc::c_char
            },
        );
    } else {
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[%s-%d] no untried remaining variables left\0" as *const u8
                as *const libc::c_char,
            str,
            count,
        );
        idx = 2 as libc::c_int;
        while idx < (*lgl).nvars {
            av = lglavar(lgl, idx);
            if (*lgl).eliminating != 0 {
                (*av).set_donotelm(0 as libc::c_int as libc::c_uint);
            }
            if (*lgl).blocking != 0 {
                (*av).set_donotblk(0 as libc::c_int as libc::c_uint);
            }
            idx += 1;
            idx;
        }
    }
    return res;
}
unsafe extern "C" fn lglsetdonotesched(mut lgl: *mut LGL, mut completed: libc::c_int) {
    let mut av: *mut AVar = 0 as *mut AVar;
    let mut ev: *mut EVar = 0 as *mut EVar;
    let mut idx: libc::c_int = 0;
    idx = 2 as libc::c_int;
    while idx < (*lgl).nvars {
        av = lglavar(lgl, idx);
        ev = lglevar(lgl, idx);
        if (*lgl).eliminating != 0 {
            if completed != 0 {
                (*av).set_donotelm(0 as libc::c_int as libc::c_uint);
            } else if (*ev).pos < 0 as libc::c_int {
                (*av).set_donotelm(1 as libc::c_int as libc::c_uint);
            }
        }
        if (*lgl).blocking != 0 {
            if completed != 0 {
                (*av).set_donotblk(0 as libc::c_int as libc::c_uint);
            } else if (*ev).pos < 0 as libc::c_int {
                (*av).set_donotblk(1 as libc::c_int as libc::c_uint);
            }
        }
        idx += 1;
        idx;
    }
}
unsafe extern "C" fn lglblkdone(mut lgl: *mut LGL) -> libc::c_int {
    if lglsmallirr(lgl) == 0 {
        return 1 as libc::c_int;
    }
    if lglterminate(lgl) != 0 {
        return 1 as libc::c_int;
    }
    if lglmtstk(&mut (*lgl).esched) != 0 {
        return 1 as libc::c_int;
    }
    if (*(*lgl).stats).blk.steps >= (*(*lgl).limits).blk.steps {
        return 1 as libc::c_int;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn lglblock(mut lgl: *mut LGL) {
    let mut oldrem: libc::c_int = (*lgl).blkrem as libc::c_int;
    let mut oldall: libc::c_int = (*lgl).blkall as libc::c_int;
    let mut oldirr: libc::c_int = (*(*lgl).stats).irr.clauses.cur;
    let mut idx: libc::c_int = 0;
    let mut count: libc::c_int = 0;
    let mut all: libc::c_int = 0;
    let mut rem: libc::c_int = 0;
    let mut success: libc::c_int = 0;
    let mut blocked: [Stk; 5] = [Stk {
        start: 0 as *mut libc::c_int,
        top: 0 as *mut libc::c_int,
        end: 0 as *mut libc::c_int,
    }; 5];
    lglstart(lgl, &mut (*(*lgl).times).block);
    if (*lgl).level != 0 {
        lglbacktrack(lgl, 0 as libc::c_int);
    }
    (*lgl).occs = 1 as libc::c_int as libc::c_char;
    (*lgl).blocking = (*lgl).occs;
    (*lgl).simp = (*lgl).blocking;
    (*(*lgl).stats).blk.count += 1;
    (*(*lgl).stats).blk.count;
    lglgc(lgl);
    all = (oldrem == 0 || oldall == 0) as libc::c_int;
    if all != 0 {
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[block-%d] scheduling all variables this time\0" as *const u8
                as *const libc::c_char,
            (*(*lgl).stats).blk.count,
        );
    } else if lgleschedrem(lgl, 1 as libc::c_int) == 0 {
        all = 1 as libc::c_int;
        oldrem = 0 as libc::c_int;
    }
    if all == 0 {
        (*lgl).donotsched = 1 as libc::c_int as libc::c_char;
    }
    lgldense(lgl, 1 as libc::c_int);
    if all == 0 {
        (*lgl).donotsched = 0 as libc::c_int as libc::c_char;
    }
    lglsetblklim(lgl);
    memset(
        &mut blocked as *mut [Stk; 5] as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<[Stk; 5]>() as libc::c_ulong,
    );
    count = 0 as libc::c_int;
    if (*(*lgl).opts).blkresched.val == 0 {
        (*lgl).donotsched = 1 as libc::c_int as libc::c_char;
    }
    while lglblkdone(lgl) == 0 {
        idx = lglpopesched(lgl);
        let ref mut fresh196 = *lglavar(lgl, idx);
        (*fresh196).set_donotblk(1 as libc::c_int as libc::c_uint);
        if lglisfree(lgl, idx) == 0 {
            continue;
        }
        if lglispure(lgl, -idx) != 0 {
            count += lglpurelit(lgl, -idx);
        } else if lglispure(lgl, idx) != 0 {
            count += lglpurelit(lgl, idx);
        } else {
            if lglocc(lgl, -idx) > lglocc(lgl, idx) {
                idx = -idx;
            }
            count += lglblocklit(lgl, idx, blocked.as_mut_ptr());
            count += lglblocklit(lgl, -idx, blocked.as_mut_ptr());
        }
    }
    if (*(*lgl).opts).blkresched.val == 0 {
        (*lgl).donotsched = 0 as libc::c_int as libc::c_char;
    }
    rem = lglcntstk(&mut (*lgl).esched) as libc::c_int;
    if rem == 0 {
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[block-%d] fully completed\0" as *const u8 as *const libc::c_char,
            (*(*lgl).stats).blk.count,
        );
        (*lgl).blkrtc = 1 as libc::c_int as libc::c_char;
    } else {
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[block-%d] incomplete %d not tried %.0f%%\0" as *const u8
                as *const libc::c_char,
            (*(*lgl).stats).blk.count,
            rem,
            lglpcnt(
                rem as libc::c_double,
                ((*lgl).nvars - 2 as libc::c_int) as libc::c_double,
            ),
        );
    }
    lglsetdonotesched(lgl, (rem == 0) as libc::c_int);
    lglrelstk(lgl, &mut (*lgl).esched);
    lglsparse(lgl);
    lglgc(lgl);
    lglrelstk(lgl, blocked.as_mut_ptr().offset(2 as libc::c_int as isize));
    lglrelstk(lgl, blocked.as_mut_ptr().offset(3 as libc::c_int as isize));
    lglrelstk(lgl, blocked.as_mut_ptr().offset(4 as libc::c_int as isize));
    (*lgl).blkrem = (rem > 0 as libc::c_int) as libc::c_int as libc::c_char;
    (*lgl)
        .blkall = (all != 0 && (*lgl).blkrem as libc::c_int != 0) as libc::c_int
        as libc::c_char;
    lglprt(
        lgl,
        1 as libc::c_int,
        b"[block-%d] transition to [ all %d rem %d ] state\0" as *const u8
            as *const libc::c_char,
        (*(*lgl).stats).blk.count,
        (*lgl).blkall as libc::c_int,
        (*lgl).blkrem as libc::c_int,
    );
    (*lgl).occs = 0 as libc::c_int as libc::c_char;
    (*lgl).simp = (*lgl).occs;
    (*lgl).blocking = (*lgl).simp;
    (*(*lgl).stats).irrprgss += count as int64_t;
    lglprt(
        lgl,
        1 as libc::c_int,
        b"[block-%d] eliminated %d blocked clauses\0" as *const u8
            as *const libc::c_char,
        (*(*lgl).stats).blk.count,
        count,
    );
    if (*lgl).blkrtc == 0
        && (*(*lgl).stats).blk.count <= (*(*lgl).opts).blksuccessmaxwortc.val
    {
        success = 1 as libc::c_int;
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[block-%d] considered successful since not run to completion yet\0"
                as *const u8 as *const libc::c_char,
            (*(*lgl).stats).blk.count,
        );
    } else if count != 0 {
        success = (oldirr / (*(*lgl).opts).blksuccessrat.val <= count) as libc::c_int;
        if success == 0 {
            lglprt(
                lgl,
                1 as libc::c_int,
                b"[block-%d] %d < 1/%d * %d = %d considered unsuccessful\0" as *const u8
                    as *const libc::c_char,
                (*(*lgl).stats).blk.count,
                count,
                (*(*lgl).opts).blksuccessrat.val,
                oldirr,
                oldirr / (*(*lgl).opts).blksuccessrat.val,
            );
        }
    } else {
        success = 0 as libc::c_int;
    }
    if success != 0 && (*(*lgl).limits).blk.pen != 0 {
        (*(*lgl).limits).blk.pen -= 1;
        (*(*lgl).limits).blk.pen;
    }
    if success == 0 && (*(*lgl).limits).blk.pen < (*(*lgl).opts).penmax.val {
        (*(*lgl).limits).blk.pen += 1;
        (*(*lgl).limits).blk.pen;
    }
    if success != 0 && (*(*lgl).limits).blk.del.cur != 0 {
        (*(*lgl).limits).blk.del.cur /= 2 as libc::c_int;
    }
    if success == 0 && (*(*lgl).limits).blk.del.cur < (*(*lgl).opts).delmax.val {
        (*(*lgl).limits).blk.del.cur += 1;
        (*(*lgl).limits).blk.del.cur;
    }
    (*(*lgl).limits).blk.del.rem = (*(*lgl).limits).blk.del.cur;
    lglrep(lgl, 2 as libc::c_int, 'k' as i32 as libc::c_char);
    lglstop(lgl);
}
unsafe extern "C" fn lglsetccelim(mut lgl: *mut LGL) {
    let mut count: libc::c_int = (*(*lgl).stats).cce.count
        - (*(*lgl).opts).cceboostdel.val;
    let mut limit: int64_t = 0;
    let mut irrlim: int64_t = 0;
    let mut pen: libc::c_int = 0;
    let mut szpen: libc::c_int = 0;
    if (*(*lgl).opts).ccertc.val > 1 as libc::c_int {
        (*(*lgl).limits).cce.steps = 0x7fffffffffffffff as libc::c_longlong as int64_t;
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[cce-%d] really no limit (run to completion)\0" as *const u8
                as *const libc::c_char,
            (*(*lgl).stats).cce.count,
        );
    } else if (*(*lgl).opts).ccertc.val != 0
        || count > 0 as libc::c_int && lglrem(lgl) < (*(*lgl).opts).ccertcintvlim.val
            && count % (*(*lgl).opts).ccertcint.val == 0
    {
        limit = 4000000000 as libc::c_longlong as int64_t;
        (*(*lgl).limits).cce.steps = (*(*lgl).stats).cce.steps + limit;
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[cce-%d] almost no limit of %lld steps\0" as *const u8
                as *const libc::c_char,
            (*(*lgl).stats).cce.count,
            limit as libc::c_longlong,
        );
    } else {
        limit = (*(*lgl).opts).ccereleff.val as int64_t * lglvisearch(lgl)
            / 1000 as libc::c_int as int64_t;
        if limit < (*(*lgl).opts).ccemineff.val as int64_t {
            limit = (*(*lgl).opts).ccemineff.val as int64_t;
        }
        if (*(*lgl).opts).ccemaxeff.val >= 0 as libc::c_int
            && limit > (*(*lgl).opts).ccemaxeff.val as int64_t
        {
            limit = (*(*lgl).opts).ccemaxeff.val as int64_t;
        }
        if count > 0 as libc::c_int
            && (count <= 1 as libc::c_int || count % (*(*lgl).opts).cceboostint.val == 0)
            && (*(*lgl).opts).boost.val != 0
            && (*lgl).nvars < (*(*lgl).opts).cceboostvlim.val
        {
            lglprt(
                lgl,
                1 as libc::c_int,
                b"[cce-%d] boosting limit by %d\0" as *const u8 as *const libc::c_char,
                (*(*lgl).stats).cce.count,
                (*(*lgl).opts).cceboost.val,
            );
            limit *= (*(*lgl).opts).cceboost.val as int64_t;
        }
        szpen = lglszpen(lgl);
        pen = (*(*lgl).limits).cce.pen + szpen;
        limit >>= pen;
        irrlim = ((*(*lgl).stats).irr.clauses.cur >> szpen) as int64_t;
        if (*(*lgl).opts).irrlim.val != 0 && limit < irrlim {
            limit = irrlim;
            lglprt(
                lgl,
                1 as libc::c_int,
                b"[cce-%d] limit of %lld steps based on %d irredundant clauses penalty %d\0"
                    as *const u8 as *const libc::c_char,
                (*(*lgl).stats).cce.count,
                limit as libc::c_longlong,
                (*(*lgl).stats).irr.clauses.cur,
                szpen,
            );
        } else {
            lglprt(
                lgl,
                1 as libc::c_int,
                b"[cce-%d] limit of %lld steps penalty %d = %d + %d\0" as *const u8
                    as *const libc::c_char,
                (*(*lgl).stats).cce.count,
                limit as libc::c_longlong,
                pen,
                (*(*lgl).limits).cce.pen,
                szpen,
            );
        }
        (*(*lgl).limits).cce.steps = (*(*lgl).stats).cce.steps + limit;
    };
}
unsafe extern "C" fn lglsignedmark2(mut lgl: *mut LGL, mut lit: libc::c_int) {
    let mut av: *mut AVar = lglavar(lgl, lit);
    let mut bit: libc::c_int = (1 as libc::c_int)
        << 2 as libc::c_int + (lit < 0 as libc::c_int) as libc::c_int;
    if (*av).mark & bit != 0 {
        return;
    }
    (*av).mark |= bit;
}
unsafe extern "C" fn lglsignedunmark2(mut lgl: *mut LGL, mut lit: libc::c_int) {
    let mut av: *mut AVar = lglavar(lgl, lit);
    let mut bit: libc::c_int = (1 as libc::c_int)
        << 2 as libc::c_int + (lit < 0 as libc::c_int) as libc::c_int;
    if (*av).mark & bit == 0 {
        return;
    }
    (*av).mark &= !bit;
}
unsafe extern "C" fn lglsignedmarked2(
    mut lgl: *mut LGL,
    mut lit: libc::c_int,
) -> libc::c_int {
    let mut av: *mut AVar = lglavar(lgl, lit);
    let mut bit: libc::c_int = (1 as libc::c_int)
        << 2 as libc::c_int + (lit < 0 as libc::c_int) as libc::c_int;
    return (*av).mark & bit;
}
unsafe extern "C" fn lglabcecls(
    mut lgl: *mut LGL,
    mut lit: libc::c_int,
    mut c: *const libc::c_int,
) -> libc::c_int {
    let mut other: libc::c_int = 0;
    let mut found: libc::c_int = 0 as libc::c_int;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    p = c;
    loop {
        other = *p;
        if !(other != 0) {
            break;
        }
        if other == -lit {
            found += 1;
            found;
        } else if lglsignedmarked(lgl, -other) != 0 {
            return 1 as libc::c_int
        }
        p = p.offset(1);
        p;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn lglabce(mut lgl: *mut LGL, mut lit: libc::c_int) -> libc::c_int {
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut w: *const libc::c_int = 0 as *const libc::c_int;
    let mut eow: *const libc::c_int = 0 as *const libc::c_int;
    let mut c: *const libc::c_int = 0 as *const libc::c_int;
    let mut blit: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut cls: [libc::c_int; 4] = [0; 4];
    let mut hts: *mut HTS = 0 as *mut HTS;
    hts = lglhts(lgl, -lit);
    w = lglhts2wchs(lgl, hts);
    eow = w.offset((*hts).count as isize);
    cls[0 as libc::c_int as usize] = -lit;
    cls[3 as libc::c_int as usize] = 0 as libc::c_int;
    p = w;
    while p < eow {
        (*(*lgl).stats).steps += 1;
        (*(*lgl).stats).steps;
        let fresh197 = (*(*lgl).stats).cce.steps;
        (*(*lgl).stats).cce.steps = (*(*lgl).stats).cce.steps + 1;
        if (*(*lgl).limits).cce.steps <= fresh197 {
            return 0 as libc::c_int;
        }
        blit = *p;
        tag = blit & MASKCS as libc::c_int;
        if tag == TRNCS as libc::c_int || tag == LRGCS as libc::c_int {
            p = p.offset(1);
            p;
        }
        if !(blit & REDCS as libc::c_int != 0) {
            if !(tag == LRGCS as libc::c_int) {
                other = blit >> RMSHFT as libc::c_int;
                cls[1 as libc::c_int as usize] = other;
                if tag == BINCS as libc::c_int {
                    cls[2 as libc::c_int as usize] = 0 as libc::c_int;
                    c = cls.as_mut_ptr();
                } else if tag == TRNCS as libc::c_int {
                    cls[2 as libc::c_int as usize] = *p;
                    c = cls.as_mut_ptr();
                } else {
                    c = lglidx2lits(lgl, 0 as libc::c_int, other);
                }
                if lglabcecls(lgl, lit, c) == 0 {
                    return 0 as libc::c_int;
                }
            }
        }
        p = p.offset(1);
        p;
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn lglcceclause(
    mut lgl: *mut LGL,
    mut c: *const libc::c_int,
    mut igntag: libc::c_int,
    mut cce: libc::c_int,
) -> libc::c_int {
    let mut current_block: u64;
    let mut other: libc::c_int = 0;
    let mut res: libc::c_int = 0;
    let mut nextala: libc::c_int = 0;
    let mut nextcla: libc::c_int = 0;
    let mut lit: libc::c_int = 0;
    let mut blit: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut other2: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    let mut ala: libc::c_int = 0;
    let mut first: libc::c_int = 0;
    let mut old: libc::c_int = 0;
    let mut prev: libc::c_int = 0;
    let mut steps: libc::c_int = 0;
    let mut lidx: libc::c_int = 0;
    let mut newtop: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut d: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut q: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut r: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut eow: *const libc::c_int = 0 as *const libc::c_int;
    let mut w: *const libc::c_int = 0 as *const libc::c_int;
    let mut delta: ptrdiff_t = 0;
    let mut hts: *mut HTS = 0 as *mut HTS;
    p = c;
    loop {
        other = *p;
        if !(other != 0) {
            break;
        }
        lglpushstk(lgl, &mut (*lgl).seen, other);
        lglpushstk(lgl, &mut (*(*lgl).c2rust_unnamed.cce).cla, other);
        lglsignedmark(lgl, other);
        p = p.offset(1);
        p;
    }
    n = lglcntstk(&mut (*lgl).seen) as libc::c_int;
    i = n - 1 as libc::c_int;
    while i > 0 as libc::c_int {
        j = (lglrand(lgl)).wrapping_rem((i + 1 as libc::c_int) as libc::c_uint)
            as libc::c_int;
        if !(j == i) {
            let mut TMP: libc::c_int = *((*lgl).seen.start).offset(i as isize);
            *((*lgl).seen.start)
                .offset(i as isize) = *((*lgl).seen.start).offset(j as isize);
            *((*lgl).seen.start).offset(j as isize) = TMP;
            let mut TMP_0: libc::c_int = *((*(*lgl).c2rust_unnamed.cce).cla.start)
                .offset(i as isize);
            *((*(*lgl).c2rust_unnamed.cce).cla.start)
                .offset(
                    i as isize,
                ) = *((*(*lgl).c2rust_unnamed.cce).cla.start).offset(j as isize);
            *((*(*lgl).c2rust_unnamed.cce).cla.start).offset(j as isize) = TMP_0;
        }
        i -= 1;
        i;
    }
    res = 0 as libc::c_int;
    nextala = res;
    nextcla = nextala;
    's_123: loop {
        if res == 0 && nextala < lglcntstk(&mut (*lgl).seen) as libc::c_int {
            let fresh198 = nextala;
            nextala = nextala + 1;
            lit = lglpeek(&mut (*lgl).seen, fresh198);
            hts = lglhts(lgl, lit);
            newtop = lglhts2wchs(lgl, hts);
            w = newtop;
            eow = w.offset((*hts).count as isize);
            steps = 0 as libc::c_int;
            let mut current_block_98: u64;
            p = w;
            while res == 0 && p < eow {
                steps += 1;
                steps;
                blit = *p;
                let fresh199 = newtop;
                newtop = newtop.offset(1);
                *fresh199 = blit;
                tag = blit & MASKCS as libc::c_int;
                if tag == TRNCS as libc::c_int || tag == LRGCS as libc::c_int {
                    p = p.offset(1);
                    let fresh200 = newtop;
                    newtop = newtop.offset(1);
                    *fresh200 = *p;
                }
                if !(tag == OCCS as libc::c_int) {
                    if !(blit & REDCS as libc::c_int != 0) {
                        other = blit >> RMSHFT as libc::c_int;
                        if !(lglsignedmarked(lgl, -other) != 0) {
                            if tag == BINCS as libc::c_int {
                                if lglsignedmarked(lgl, other) != 0 {
                                    if igntag == BINCS as libc::c_int {
                                        if *c.offset(0 as libc::c_int as isize) == lit
                                            && *c.offset(1 as libc::c_int as isize) == other
                                        {
                                            current_block_98 = 7205609094909031804;
                                        } else if *c.offset(1 as libc::c_int as isize) == lit
                                            && *c.offset(0 as libc::c_int as isize) == other
                                        {
                                            current_block_98 = 7205609094909031804;
                                        } else {
                                            current_block_98 = 6717214610478484138;
                                        }
                                    } else {
                                        current_block_98 = 6717214610478484138;
                                    }
                                    match current_block_98 {
                                        7205609094909031804 => {}
                                        _ => {
                                            res = 1 as libc::c_int;
                                        }
                                    }
                                } else {
                                    lglsignedmark(lgl, -other);
                                    lglpushstk(lgl, &mut (*lgl).seen, -other);
                                }
                            } else if tag == TRNCS as libc::c_int {
                                other2 = *p;
                                if !(lglsignedmarked(lgl, -other2) != 0) {
                                    if lglsignedmarked(lgl, other) != 0 {
                                        if lglsignedmarked(lgl, other2) != 0 {
                                            if igntag == TRNCS as libc::c_int {
                                                if *c.offset(0 as libc::c_int as isize) == lit
                                                    && *c.offset(1 as libc::c_int as isize) == other
                                                    && *c.offset(2 as libc::c_int as isize) == other2
                                                {
                                                    current_block_98 = 7205609094909031804;
                                                } else if *c.offset(0 as libc::c_int as isize) == lit
                                                    && *c.offset(2 as libc::c_int as isize) == other
                                                    && *c.offset(1 as libc::c_int as isize) == other2
                                                {
                                                    current_block_98 = 7205609094909031804;
                                                } else if *c.offset(1 as libc::c_int as isize) == lit
                                                    && *c.offset(0 as libc::c_int as isize) == other
                                                    && *c.offset(2 as libc::c_int as isize) == other2
                                                {
                                                    current_block_98 = 7205609094909031804;
                                                } else if *c.offset(1 as libc::c_int as isize) == lit
                                                    && *c.offset(2 as libc::c_int as isize) == other
                                                    && *c.offset(0 as libc::c_int as isize) == other2
                                                {
                                                    current_block_98 = 7205609094909031804;
                                                } else if *c.offset(2 as libc::c_int as isize) == lit
                                                    && *c.offset(0 as libc::c_int as isize) == other
                                                    && *c.offset(1 as libc::c_int as isize) == other2
                                                {
                                                    current_block_98 = 7205609094909031804;
                                                } else if *c.offset(2 as libc::c_int as isize) == lit
                                                    && *c.offset(1 as libc::c_int as isize) == other
                                                    && *c.offset(0 as libc::c_int as isize) == other2
                                                {
                                                    current_block_98 = 7205609094909031804;
                                                } else {
                                                    current_block_98 = 317151059986244064;
                                                }
                                            } else {
                                                current_block_98 = 317151059986244064;
                                            }
                                            match current_block_98 {
                                                7205609094909031804 => {}
                                                _ => {
                                                    res = 1 as libc::c_int;
                                                }
                                            }
                                        } else {
                                            lglsignedmark(lgl, -other2);
                                            lglpushstk(lgl, &mut (*lgl).seen, -other2);
                                        }
                                    } else if lglsignedmarked(lgl, other2) != 0 {
                                        lglsignedmark(lgl, -other);
                                        lglpushstk(lgl, &mut (*lgl).seen, -other);
                                    }
                                }
                            } else {
                                lidx = *p;
                                d = lglidx2lits(lgl, 0 as libc::c_int, lidx);
                                if !(d == c as *mut libc::c_int) {
                                    if *d.offset(0 as libc::c_int as isize) == lit {
                                        let mut TMP_1: libc::c_int = *d
                                            .offset(0 as libc::c_int as isize);
                                        *d
                                            .offset(
                                                0 as libc::c_int as isize,
                                            ) = *d.offset(1 as libc::c_int as isize);
                                        *d.offset(1 as libc::c_int as isize) = TMP_1;
                                    }
                                    if !(lglsignedmarked(
                                        lgl,
                                        -*d.offset(0 as libc::c_int as isize),
                                    ) != 0)
                                    {
                                        q = d.offset(2 as libc::c_int as isize);
                                        loop {
                                            other = *q;
                                            if !(other != 0) {
                                                break;
                                            }
                                            if lglsignedmarked(lgl, -other) != 0 {
                                                break;
                                            }
                                            if lglsignedmarked(lgl, other) == 0 {
                                                break;
                                            }
                                            q = q.offset(1);
                                            q;
                                        }
                                        if other != 0 {
                                            newtop = newtop.offset(-(2 as libc::c_int as isize));
                                            let mut TMP_2: libc::c_int = *d
                                                .offset(1 as libc::c_int as isize);
                                            *d.offset(1 as libc::c_int as isize) = *q;
                                            *q = TMP_2;
                                            delta = lglwchlrg(
                                                lgl,
                                                *d.offset(1 as libc::c_int as isize),
                                                *d.offset(0 as libc::c_int as isize),
                                                0 as libc::c_int,
                                                lidx,
                                            );
                                            if delta != 0 {
                                                w = w.offset(delta as isize);
                                                p = p.offset(delta as isize);
                                                newtop = newtop.offset(delta as isize);
                                                eow = eow.offset(delta as isize);
                                            }
                                        } else if lglsignedmarked(
                                            lgl,
                                            *d.offset(0 as libc::c_int as isize),
                                        ) != 0
                                        {
                                            res = 1 as libc::c_int;
                                        } else {
                                            ala = -*d.offset(0 as libc::c_int as isize);
                                            lglsignedmark(lgl, ala);
                                            lglpushstk(lgl, &mut (*lgl).seen, ala);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                p = p.offset(1);
                p;
            }
            while p < eow {
                let fresh201 = p;
                p = p.offset(1);
                let fresh202 = newtop;
                newtop = newtop.offset(1);
                *fresh202 = *fresh201;
            }
            lglshrinkhts(lgl, hts, newtop.offset_from(w) as libc::c_long as libc::c_int);
            (*(*lgl).stats).steps += steps as int64_t;
            (*(*lgl).stats).cce.steps += steps as int64_t;
            if (*(*lgl).limits).cce.steps <= (*(*lgl).stats).cce.steps {
                current_block = 1119482098818444350;
                break;
            }
        } else {
            if res != 0 || (*(*lgl).opts).block.val == 0 || cce < 3 as libc::c_int {
                current_block = 2653719933422131694;
                break;
            }
            loop {
                if !(res == 0
                    && nextcla
                        < lglcntstk(&mut (*(*lgl).c2rust_unnamed.cce).cla)
                            as libc::c_int)
                {
                    current_block = 2653719933422131694;
                    break 's_123;
                }
                let fresh203 = nextcla;
                nextcla = nextcla + 1;
                lit = lglpeek(&mut (*(*lgl).c2rust_unnamed.cce).cla, fresh203);
                if lglifrozen(lgl, lit) != 0 {
                    continue;
                }
                hts = lglhts(lgl, -lit);
                w = lglhts2wchs(lgl, hts);
                eow = w.offset((*hts).count as isize);
                old = lglcntstk(&mut (*(*lgl).c2rust_unnamed.cce).cla) as libc::c_int;
                first = 1 as libc::c_int;
                p = w;
                while p < eow {
                    (*(*lgl).stats).steps += 1;
                    (*(*lgl).stats).steps;
                    let fresh204 = (*(*lgl).stats).cce.steps;
                    (*(*lgl).stats).cce.steps = (*(*lgl).stats).cce.steps + 1;
                    if (*(*lgl).limits).cce.steps <= fresh204 {
                        current_block = 1119482098818444350;
                        break 's_123;
                    }
                    blit = *p;
                    tag = blit & MASKCS as libc::c_int;
                    if tag == TRNCS as libc::c_int || tag == LRGCS as libc::c_int {
                        p = p.offset(1);
                        p;
                    }
                    if !(tag == LRGCS as libc::c_int) {
                        if !(blit & REDCS as libc::c_int != 0) {
                            other = blit >> RMSHFT as libc::c_int;
                            if first != 0 {
                                if tag == BINCS as libc::c_int {
                                    if lglsignedmarked(lgl, -other) != 0 {
                                        current_block = 228501038991332163;
                                    } else {
                                        if lglsignedmarked(lgl, other) == 0 {
                                            lglpushstk(
                                                lgl,
                                                &mut (*(*lgl).c2rust_unnamed.cce).cla,
                                                other,
                                            );
                                        }
                                        current_block = 9270770154621591809;
                                    }
                                } else if tag == TRNCS as libc::c_int {
                                    if lglsignedmarked(lgl, -other) != 0 {
                                        current_block = 228501038991332163;
                                    } else {
                                        other2 = *p;
                                        if lglsignedmarked(lgl, -other2) != 0 {
                                            current_block = 228501038991332163;
                                        } else {
                                            if lglsignedmarked(lgl, other) == 0 {
                                                lglpushstk(
                                                    lgl,
                                                    &mut (*(*lgl).c2rust_unnamed.cce).cla,
                                                    other,
                                                );
                                            }
                                            if lglsignedmarked(lgl, other2) == 0 {
                                                lglpushstk(
                                                    lgl,
                                                    &mut (*(*lgl).c2rust_unnamed.cce).cla,
                                                    other2,
                                                );
                                            }
                                            current_block = 9270770154621591809;
                                        }
                                    }
                                } else {
                                    d = lglidx2lits(lgl, 0 as libc::c_int, other);
                                    q = d;
                                    loop {
                                        other = *q;
                                        if !(other != 0) {
                                            break;
                                        }
                                        if !(other == -lit) {
                                            if lglsignedmarked(lgl, -other) != 0 {
                                                break;
                                            }
                                        }
                                        q = q.offset(1);
                                        q;
                                    }
                                    if other != 0 {
                                        current_block = 228501038991332163;
                                    } else {
                                        q = d;
                                        loop {
                                            other = *q;
                                            if !(other != 0) {
                                                break;
                                            }
                                            if other != -lit && lglsignedmarked(lgl, other) == 0 {
                                                lglpushstk(
                                                    lgl,
                                                    &mut (*(*lgl).c2rust_unnamed.cce).cla,
                                                    other,
                                                );
                                            }
                                            q = q.offset(1);
                                            q;
                                        }
                                        current_block = 9270770154621591809;
                                    }
                                }
                                match current_block {
                                    228501038991332163 => {}
                                    _ => {
                                        first = 0 as libc::c_int;
                                    }
                                }
                            } else {
                                r = ((*(*lgl).c2rust_unnamed.cce).cla.start)
                                    .offset(old as isize);
                                if tag == BINCS as libc::c_int {
                                    if lglsignedmarked(lgl, -other) != 0 {
                                        current_block = 228501038991332163;
                                    } else {
                                        q = r;
                                        while q < (*(*lgl).c2rust_unnamed.cce).cla.top {
                                            if *q == other {
                                                let fresh205 = r;
                                                r = r.offset(1);
                                                *fresh205 = *q;
                                            }
                                            q = q.offset(1);
                                            q;
                                        }
                                        current_block = 13077018311583886556;
                                    }
                                } else if tag == TRNCS as libc::c_int {
                                    if lglsignedmarked(lgl, -other) != 0 {
                                        current_block = 228501038991332163;
                                    } else {
                                        other2 = *p;
                                        if lglsignedmarked(lgl, -other2) != 0 {
                                            current_block = 228501038991332163;
                                        } else {
                                            q = r;
                                            while q < (*(*lgl).c2rust_unnamed.cce).cla.top {
                                                if *q == other || *q == other2 {
                                                    let fresh206 = r;
                                                    r = r.offset(1);
                                                    *fresh206 = *q;
                                                }
                                                q = q.offset(1);
                                                q;
                                            }
                                            current_block = 13077018311583886556;
                                        }
                                    }
                                } else {
                                    d = lglidx2lits(lgl, 0 as libc::c_int, other);
                                    q = d;
                                    loop {
                                        other = *q;
                                        if !(other != 0) {
                                            break;
                                        }
                                        if !(other == -lit) {
                                            if lglsignedmarked(lgl, -other) != 0 {
                                                break;
                                            }
                                        }
                                        q = q.offset(1);
                                        q;
                                    }
                                    if other != 0 {
                                        current_block = 228501038991332163;
                                    } else {
                                        q = d;
                                        loop {
                                            other = *q;
                                            if !(other != 0) {
                                                break;
                                            }
                                            if !(other == -lit) {
                                                lglsignedmark2(lgl, other);
                                            }
                                            q = q.offset(1);
                                            q;
                                        }
                                        q = r;
                                        while q < (*(*lgl).c2rust_unnamed.cce).cla.top {
                                            other = *q;
                                            if lglsignedmarked2(lgl, other) != 0 {
                                                let fresh207 = r;
                                                r = r.offset(1);
                                                *fresh207 = other;
                                            }
                                            q = q.offset(1);
                                            q;
                                        }
                                        q = d;
                                        loop {
                                            other = *q;
                                            if !(other != 0) {
                                                break;
                                            }
                                            if !(other == -lit) {
                                                lglsignedunmark2(lgl, other);
                                            }
                                            q = q.offset(1);
                                            q;
                                        }
                                        current_block = 13077018311583886556;
                                    }
                                }
                                match current_block {
                                    228501038991332163 => {}
                                    _ => {
                                        (*(*lgl).c2rust_unnamed.cce).cla.top = r;
                                        if (*(*lgl).c2rust_unnamed.cce).cla.top
                                            == ((*(*lgl).c2rust_unnamed.cce).cla.start)
                                                .offset(old as isize)
                                        {
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    p = p.offset(1);
                    p;
                }
                if lglcntstk(&mut (*(*lgl).c2rust_unnamed.cce).cla) as libc::c_int > old
                {
                    nextcla = 0 as libc::c_int;
                    lglpushstk(lgl, &mut (*(*lgl).c2rust_unnamed.cce).extend, lit);
                    q = (*(*lgl).c2rust_unnamed.cce).cla.start;
                    while q
                        < ((*(*lgl).c2rust_unnamed.cce).cla.start).offset(old as isize)
                    {
                        if *q != lit {
                            lglpushstk(
                                lgl,
                                &mut (*(*lgl).c2rust_unnamed.cce).extend,
                                *q,
                            );
                        }
                        q = q.offset(1);
                        q;
                    }
                    lglpushstk(
                        lgl,
                        &mut (*(*lgl).c2rust_unnamed.cce).extend,
                        0 as libc::c_int,
                    );
                }
                q = ((*(*lgl).c2rust_unnamed.cce).cla.start).offset(old as isize);
                while res == 0 && q < (*(*lgl).c2rust_unnamed.cce).cla.top {
                    if lglsignedmarked(lgl, -*q) != 0 {
                        res = 1 as libc::c_int;
                    } else {
                        lglpushstk(lgl, &mut (*lgl).seen, *q);
                        lglsignedmark(lgl, *q);
                    }
                    q = q.offset(1);
                    q;
                }
                if res == 0 && p == eow
                    && nextala < lglcntstk(&mut (*lgl).seen) as libc::c_int
                {
                    break;
                }
            }
        }
    }
    match current_block {
        2653719933422131694 => {
            if res != 0 {
                (*(*lgl).stats).cce.ate += 1;
                (*(*lgl).stats).cce.ate;
            } else if (*(*lgl).opts).block.val != 0 && cce >= 2 as libc::c_int {
                p = (*(*lgl).c2rust_unnamed.cce).cla.start;
                while p < (*(*lgl).c2rust_unnamed.cce).cla.top as *const libc::c_int {
                    other = *p;
                    if lglifrozen(lgl, other) == 0
                        && {
                            res = lglabce(lgl, other);
                            res != 0
                        }
                    {
                        break;
                    }
                    p = p.offset(1);
                    p;
                }
                if res != 0 {
                    lglpushstk(lgl, &mut (*(*lgl).c2rust_unnamed.cce).extend, other);
                    p = (*(*lgl).c2rust_unnamed.cce).cla.start;
                    while p < (*(*lgl).c2rust_unnamed.cce).cla.top as *const libc::c_int
                    {
                        if *p != other {
                            lglpushstk(
                                lgl,
                                &mut (*(*lgl).c2rust_unnamed.cce).extend,
                                *p,
                            );
                        }
                        p = p.offset(1);
                        p;
                    }
                    lglpushstk(
                        lgl,
                        &mut (*(*lgl).c2rust_unnamed.cce).extend,
                        0 as libc::c_int,
                    );
                    (*(*lgl).stats).cce.abce += 1;
                    (*(*lgl).stats).cce.abce;
                }
            }
            if res != 0 {
                (*(*lgl).stats).cce.eliminated += 1;
                (*(*lgl).stats).cce.eliminated;
            }
        }
        _ => {}
    }
    lglpopnunmarkstk(lgl, &mut (*lgl).seen);
    lglclnstk(&mut (*(*lgl).c2rust_unnamed.cce).cla);
    if res != 0 && lglmtstk(&mut (*(*lgl).c2rust_unnamed.cce).extend) == 0 {
        prev = 0 as libc::c_int;
        p = (*(*lgl).c2rust_unnamed.cce).extend.start;
        while p < (*(*lgl).c2rust_unnamed.cce).extend.top as *const libc::c_int {
            lit = *p;
            lglepush(lgl, lit);
            if prev == 0 {
                lglblockinglit(lgl, lit);
            }
            prev = lit;
            p = p.offset(1);
            p;
        }
    }
    lglclnstk(&mut (*(*lgl).c2rust_unnamed.cce).extend);
    return res;
}
unsafe extern "C" fn lglcce2str(mut cce: libc::c_int) -> *const libc::c_char {
    if cce == 3 as libc::c_int {
        return b"ACCE\0" as *const u8 as *const libc::c_char
    } else if cce == 2 as libc::c_int {
        return b"ABCE\0" as *const u8 as *const libc::c_char
    } else if cce == 1 as libc::c_int {
        return b"ATE\0" as *const u8 as *const libc::c_char
    } else {
        return b"none\0" as *const u8 as *const libc::c_char
    };
}
unsafe extern "C" fn lglccesmallclauses(
    mut lgl: *mut LGL,
    mut lit: libc::c_int,
) -> libc::c_int {
    let mut idx: libc::c_int = abs(lit);
    let mut blit: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut red: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut other2: libc::c_int = 0;
    let mut hts: *mut HTS = lglhts(lgl, lit);
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut w: *const libc::c_int = 0 as *const libc::c_int;
    let mut eow: *const libc::c_int = 0 as *const libc::c_int;
    let mut cce: *mut CCE = (*lgl).c2rust_unnamed.cce;
    let mut clauses: *mut Stk = 0 as *mut Stk;
    if lglisfree(lgl, lit) == 0 {
        return 1 as libc::c_int;
    }
    clauses = &mut (*cce).clauses;
    w = lglhts2wchs(lgl, hts);
    eow = w.offset((*hts).count as isize);
    (*(*lgl).stats).steps += 1;
    (*(*lgl).stats).steps;
    (*(*lgl).stats).cce.steps += 1;
    (*(*lgl).stats).cce.steps;
    let mut current_block_22: u64;
    p = w;
    while p < eow {
        blit = *p;
        tag = blit & MASKCS as libc::c_int;
        if !(tag == OCCS as libc::c_int) {
            if tag == TRNCS as libc::c_int || tag == LRGCS as libc::c_int {
                p = p.offset(1);
                p;
            }
            if !(tag == LRGCS as libc::c_int) {
                red = blit & REDCS as libc::c_int;
                if !(red != 0) {
                    other = blit >> RMSHFT as libc::c_int;
                    if !(abs(other) < idx) {
                        if !(lglisfree(lgl, other) == 0) {
                            if tag == TRNCS as libc::c_int {
                                other2 = *p;
                                if abs(other2) < idx {
                                    current_block_22 = 10879442775620481940;
                                } else if abs(other2) < abs(other) {
                                    current_block_22 = 10879442775620481940;
                                } else if lglisfree(lgl, other2) == 0 {
                                    current_block_22 = 10879442775620481940;
                                } else {
                                    lglpushstk(lgl, clauses, other2);
                                    (*cce).trn += 1;
                                    (*cce).trn;
                                    current_block_22 = 16203760046146113240;
                                }
                            } else {
                                (*cce).bin += 1;
                                (*cce).bin;
                                current_block_22 = 16203760046146113240;
                            }
                            match current_block_22 {
                                10879442775620481940 => {}
                                _ => {
                                    lglpushstk(lgl, clauses, other);
                                    lglpushstk(lgl, clauses, lit);
                                    lglpushstk(lgl, clauses, 0 as libc::c_int);
                                }
                            }
                        }
                    }
                }
            }
        }
        p = p.offset(1);
        p;
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn lglccesmall(
    mut lgl: *mut LGL,
    mut cce: libc::c_int,
    mut round: libc::c_int,
) {
    let mut count: libc::c_int = 0;
    let mut valid: libc::c_int = 0;
    let mut invalid: libc::c_int = 0;
    let mut tried: libc::c_int = 0;
    let mut eliminated: libc::c_int = 0;
    let mut elim2: libc::c_int = 0;
    let mut elim3: libc::c_int = 0;
    let mut size: libc::c_int = 0;
    let mut lit: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut c: *const libc::c_int = 0 as *const libc::c_int;
    let mut clauses: *mut Stk = 0 as *mut Stk;
    clauses = &mut (*(*lgl).c2rust_unnamed.cce).clauses;
    lglrandlitrav(
        lgl,
        Some(
            lglccesmallclauses
                as unsafe extern "C" fn(*mut LGL, libc::c_int) -> libc::c_int,
        ),
    );
    lglfitstk(lgl, &mut (*(*lgl).c2rust_unnamed.cce).clauses);
    count = (*(*lgl).c2rust_unnamed.cce).bin + (*(*lgl).c2rust_unnamed.cce).trn;
    lglprt(
        lgl,
        1 as libc::c_int,
        b"[cce-%d-%d] scheduling %d clauses = %d binary + %d ternary\0" as *const u8
            as *const libc::c_char,
        (*(*lgl).stats).cce.count,
        round,
        count,
        (*(*lgl).c2rust_unnamed.cce).bin,
        (*(*lgl).c2rust_unnamed.cce).trn,
    );
    elim3 = 0 as libc::c_int;
    elim2 = elim3;
    invalid = elim2;
    eliminated = invalid;
    tried = eliminated;
    c = (*clauses).start;
    while c < (*clauses).top as *const libc::c_int {
        if (*lgl).mt != 0 {
            break;
        }
        if lglterminate(lgl) != 0 {
            break;
        }
        if (*(*lgl).limits).cce.steps <= (*(*lgl).stats).cce.steps {
            break;
        }
        valid = 1 as libc::c_int;
        p = c;
        loop {
            lit = *p;
            if !(lit != 0) {
                break;
            }
            if lglisfree(lgl, lit) == 0 {
                valid = 0 as libc::c_int;
            }
            p = p.offset(1);
            p;
        }
        if valid != 0 {
            tried += 1;
            tried;
            size = p.offset_from(c) as libc::c_long as libc::c_int;
            tag = if size == 2 as libc::c_int {
                BINCS as libc::c_int
            } else {
                TRNCS as libc::c_int
            };
            if !(lglcceclause(lgl, c, tag, cce) == 0) {
                eliminated += 1;
                eliminated;
                if size == 2 as libc::c_int {
                    if lglrmvbcls(
                        lgl,
                        *c.offset(0 as libc::c_int as isize),
                        *c.offset(1 as libc::c_int as isize),
                    ) == 0
                    {
                        lgldrupligdelclsarg(
                            lgl,
                            *c.offset(0 as libc::c_int as isize),
                            *c.offset(1 as libc::c_int as isize),
                            0 as libc::c_int,
                        );
                    }
                    elim2 += 1;
                    elim2;
                } else {
                    if lglrmvtcls(
                        lgl,
                        *c.offset(0 as libc::c_int as isize),
                        *c.offset(1 as libc::c_int as isize),
                        *c.offset(2 as libc::c_int as isize),
                    ) == 0
                    {
                        lgldrupligdelclsarg(
                            lgl,
                            *c.offset(0 as libc::c_int as isize),
                            *c.offset(1 as libc::c_int as isize),
                            *c.offset(2 as libc::c_int as isize),
                            0 as libc::c_int,
                        );
                    }
                    elim3 += 1;
                    elim3;
                }
            }
        } else {
            invalid += 1;
            invalid;
        }
        c = p.offset(1 as libc::c_int as isize);
    }
    lglrelstk(lgl, &mut (*(*lgl).c2rust_unnamed.cce).clauses);
    if tried != 0 {
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[cce-%d-%d] tried to eliminate %d small clauses %.0f%%\0" as *const u8
                as *const libc::c_char,
            (*(*lgl).stats).cce.count,
            round,
            tried,
            lglpcnt(tried as libc::c_double, count as libc::c_double),
        );
    }
    if elim2 != 0 {
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[cce-%d-%d] eliminated %d binary clauses %.0f%%\0" as *const u8
                as *const libc::c_char,
            (*(*lgl).stats).cce.count,
            round,
            elim2,
            lglpcnt(
                elim2 as libc::c_double,
                (*(*lgl).c2rust_unnamed.cce).bin as libc::c_double,
            ),
        );
    }
    if elim3 != 0 {
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[cce-%d-%d] eliminated %d ternary clauses %.0f%%\0" as *const u8
                as *const libc::c_char,
            (*(*lgl).stats).cce.count,
            round,
            elim3,
            lglpcnt(
                elim3 as libc::c_double,
                (*(*lgl).c2rust_unnamed.cce).trn as libc::c_double,
            ),
        );
    }
    if eliminated != 0 {
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[cce-%d-%d] eliminated %d small clauses %.0f%%\0" as *const u8
                as *const libc::c_char,
            (*(*lgl).stats).cce.count,
            round,
            eliminated,
            lglpcnt(eliminated as libc::c_double, count as libc::c_double),
        );
    }
}
unsafe extern "C" fn lglcce(mut lgl: *mut LGL) -> libc::c_int {
    let mut oldvars: libc::c_int = (*lgl).nvars;
    let mut cce: libc::c_int = 0;
    let mut lenlim: libc::c_int = 0;
    let mut startirr: libc::c_int = 0;
    let mut success: libc::c_int = 0;
    let mut oldirr: libc::c_int = 0;
    let mut eliminated: libc::c_int = 0;
    let mut total: libc::c_int = 0;
    let mut idx: libc::c_int = 0;
    let mut round: libc::c_int = 0;
    let mut completedsmall: libc::c_int = 0;
    let mut completedlarge: libc::c_int = 0;
    let mut oldsteps: int64_t = 0;
    let mut deltasteps: int64_t = 0;
    let mut elmlarge: libc::c_int = 0;
    let mut elmsmall: libc::c_int = 0;
    lglstart(lgl, &mut (*(*lgl).times).cce);
    (*(*lgl).stats).cce.count += 1;
    (*(*lgl).stats).cce.count;
    lglsetccelim(lgl);
    total = 0 as libc::c_int;
    round = total;
    startirr = (*(*lgl).stats).irr.clauses.cur;
    loop {
        round += 1;
        round;
        lenlim = 2147483647 as libc::c_int;
        cce = (*(*lgl).opts).cce.val;
        if cce == 3 as libc::c_int && ((*lgl).ccertc as libc::c_int) < 2 as libc::c_int
            && (*(*lgl).opts).cce3wait.val >= (*(*lgl).stats).cce.count
        {
            lglprt(
                lgl,
                2 as libc::c_int,
                b"[cce-%d-%d] restricted to ABCE since ccertc=%s\0" as *const u8
                    as *const libc::c_char,
                (*(*lgl).stats).cce.count,
                round,
                lglcce2str((*lgl).ccertc as libc::c_int),
            );
            cce = 2 as libc::c_int;
        }
        if cce == 2 as libc::c_int && ((*lgl).ccertc as libc::c_int) < 1 as libc::c_int
            && (*(*lgl).opts).cce2wait.val >= (*(*lgl).stats).cce.count
        {
            lglprt(
                lgl,
                2 as libc::c_int,
                b"[cce-%d-%d] restricted to ATE since ccertc=%s\0" as *const u8
                    as *const libc::c_char,
                (*(*lgl).stats).cce.count,
                round,
                lglcce2str((*lgl).ccertc as libc::c_int),
            );
            cce = 1 as libc::c_int;
        }
        if cce > 1 as libc::c_int
            && (*(*lgl).stats).cce.count % (*(*lgl).opts).cceateint.val == 0
        {
            lglprt(
                lgl,
                2 as libc::c_int,
                b"[cce-%d-%d] restricted to ATE due to ATE interval %d\0" as *const u8
                    as *const libc::c_char,
                (*(*lgl).stats).cce.count,
                round,
                (*(*lgl).opts).cceateint.val,
            );
            cce = 1 as libc::c_int;
        }
        oldirr = (*(*lgl).stats).irr.clauses.cur;
        lglprt(
            lgl,
            2 as libc::c_int,
            b"[cce-%d-%d] starting round %d (%s)\0" as *const u8 as *const libc::c_char,
            (*(*lgl).stats).cce.count,
            round,
            round,
            lglcce2str(cce),
        );
        (*lgl).simp = 1 as libc::c_int as libc::c_char;
        (*lgl).cceing = (*lgl).simp;
        if (*lgl).level > 0 as libc::c_int {
            lglbacktrack(lgl, 0 as libc::c_int);
        }
        (*lgl)
            .c2rust_unnamed
            .cce = lglnew(
            lgl,
            (1 as libc::c_int as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<CCE>() as libc::c_ulong),
        ) as *mut CCE;
        (*(*lgl).c2rust_unnamed.cce)
            .rem = lglnew(
            lgl,
            (oldvars as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
        ) as *mut libc::c_int;
        idx = 2 as libc::c_int;
        while idx < oldvars {
            *((*(*lgl).c2rust_unnamed.cce).rem)
                .offset(idx as isize) = 2147483647 as libc::c_int;
            idx += 1;
            idx;
        }
        lglgc(lgl);
        lgldense(lgl, 1 as libc::c_int);
        oldsteps = (*(*lgl).stats).cce.steps;
        elmlarge = 0 as libc::c_int;
        while (*lgl).mt == 0 && lenlim > 4 as libc::c_int && lglterminate(lgl) == 0
            && (*(*lgl).limits).cce.steps > (*(*lgl).stats).cce.steps
        {
            let mut maxlen: libc::c_int = 0 as libc::c_int;
            let mut count: libc::c_int = 0;
            let mut p: *const libc::c_int = 0 as *const libc::c_int;
            let mut c: *const libc::c_int = 0 as *const libc::c_int;
            let mut lidcs: Stk = Stk {
                start: 0 as *mut libc::c_int,
                top: 0 as *mut libc::c_int,
                end: 0 as *mut libc::c_int,
            };
            memset(
                &mut lidcs as *mut Stk as *mut libc::c_void,
                0 as libc::c_int,
                ::core::mem::size_of::<Stk>() as libc::c_ulong,
            );
            c = (*lgl).irr.start;
            while c < (*lgl).irr.top as *const libc::c_int {
                let mut len: libc::c_int = 0;
                let mut lidx: libc::c_int = 0;
                p = c;
                if !(*p >= 2147483647 as libc::c_int >> RMSHFT as libc::c_int) {
                    while *p != 0 {
                        p = p.offset(1);
                        p;
                    }
                    len = p.offset_from(c) as libc::c_long as libc::c_int;
                    if !(len >= lenlim) {
                        if !(len < maxlen) {
                            if len > maxlen {
                                lglclnstk(&mut lidcs);
                                maxlen = len;
                            }
                            lidx = c.offset_from((*lgl).irr.start) as libc::c_long
                                as libc::c_int;
                            lglpushstk(lgl, &mut lidcs, lidx);
                        }
                    }
                }
                c = p.offset(1 as libc::c_int as isize);
            }
            (*(*lgl).stats).steps
                += (lglcntstk(&mut (*lgl).irr) as libc::c_int / 128 as libc::c_int)
                    as int64_t;
            (*(*lgl).stats).cce.steps
                += (lglcntstk(&mut (*lgl).irr) as libc::c_int / 128 as libc::c_int)
                    as int64_t;
            count = lglcntstk(&mut lidcs) as libc::c_int;
            lglprt(
                lgl,
                2 as libc::c_int,
                b"[cce-%d-%d] scheduling %d clauses of length %d\0" as *const u8
                    as *const libc::c_char,
                (*(*lgl).stats).cce.count,
                round,
                count,
                maxlen,
            );
            eliminated = 0 as libc::c_int;
            p = lidcs.start;
            while p < lidcs.top as *const libc::c_int && (*lgl).mt == 0
                && lglterminate(lgl) == 0
                && (*(*lgl).limits).cce.steps > (*(*lgl).stats).cce.steps
            {
                let mut lidx_0: libc::c_int = *p;
                c = ((*lgl).irr.start).offset(lidx_0 as isize);
                if !(*c >= 2147483647 as libc::c_int >> RMSHFT as libc::c_int) {
                    if !(lglcceclause(lgl, c, OCCS as libc::c_int, cce) == 0) {
                        lgldrupligdelclsaux(lgl, c);
                        lglrmlcls(lgl, lidx_0, 0 as libc::c_int);
                        eliminated += 1;
                        eliminated;
                    }
                }
                p = p.offset(1);
                p;
            }
            elmlarge += eliminated;
            lglrelstk(lgl, &mut lidcs);
            lenlim = maxlen;
            lglprt(
                lgl,
                1 as libc::c_int + (eliminated == 0) as libc::c_int,
                b"[cce-%d-%d] eliminated %d clauses out of %d (%.0f%%) of length %d\0"
                    as *const u8 as *const libc::c_char,
                (*(*lgl).stats).cce.count,
                round,
                eliminated,
                count,
                lglpcnt(eliminated as libc::c_double, count as libc::c_double),
                maxlen,
            );
        }
        completedlarge = ((*(*lgl).limits).cce.steps > (*(*lgl).stats).cce.steps)
            as libc::c_int;
        if completedlarge != 0 {
            lglprt(
                lgl,
                1 as libc::c_int,
                b"[cce-%d-%d] completed large round (%s)\0" as *const u8
                    as *const libc::c_char,
                (*(*lgl).stats).cce.count,
                round,
                lglcce2str(cce),
            );
        } else {
            lglprt(
                lgl,
                1 as libc::c_int,
                b"[cce-%d-%d] incomplete large round (%s)\0" as *const u8
                    as *const libc::c_char,
                (*(*lgl).stats).cce.count,
                round,
                lglcce2str(cce),
            );
        }
        deltasteps = (*(*lgl).stats).cce.steps - oldsteps;
        lglprt(
            lgl,
            1 as libc::c_int + (elmlarge == 0) as libc::c_int,
            b"[cce-%d-%d] eliminated %d large clauses in %lld steps\0" as *const u8
                as *const libc::c_char,
            (*(*lgl).stats).cce.count,
            round,
            elmlarge,
            deltasteps as libc::c_longlong,
        );
        deltasteps /= 2 as libc::c_int as int64_t;
        if 0x7fffffffffffffff as libc::c_longlong - deltasteps as libc::c_longlong
            > (*(*lgl).limits).cce.steps as libc::c_longlong
        {
            (*(*lgl).limits).cce.steps += deltasteps;
            lglprt(
                lgl,
                1 as libc::c_int,
                b"[cce-%d-%d] allowing another %lld steps for small clauses\0"
                    as *const u8 as *const libc::c_char,
                (*(*lgl).stats).cce.count,
                round,
                deltasteps,
            );
        } else {
            (*(*lgl).limits)
                .cce
                .steps = 0x7fffffffffffffff as libc::c_longlong as int64_t;
            lglprt(
                lgl,
                1 as libc::c_int,
                b"[cce-%d-%d] unlimited number of steps for small clauses\0" as *const u8
                    as *const libc::c_char,
                (*(*lgl).stats).cce.count,
                round,
            );
        }
        lglccesmall(lgl, cce, round);
        elmsmall = oldirr - (*(*lgl).stats).irr.clauses.cur - elmlarge;
        lglprt(
            lgl,
            1 as libc::c_int + (elmsmall == 0) as libc::c_int,
            b"[cce-%d-%d] eliminated %d small clauses in %lld steps\0" as *const u8
                as *const libc::c_char,
            (*(*lgl).stats).cce.count,
            round,
            elmsmall,
            (*(*lgl).stats).cce.steps as libc::c_longlong - oldsteps as libc::c_longlong
                - deltasteps as libc::c_longlong,
        );
        completedsmall = ((*(*lgl).limits).cce.steps > (*(*lgl).stats).cce.steps)
            as libc::c_int;
        if !(completedsmall == 0 && (*(*lgl).opts).ccertc.val > 1 as libc::c_int)
        {} else {
            fprintf(
                stderr,
                b"liblgl.a: %s:%d: %s: Coverage target `%s' reached.\0" as *const u8
                    as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 7], &[libc::c_char; 7]>(b"lglcce\0"))
                    .as_ptr(),
                16354 as libc::c_int,
                b"lglib.c\0" as *const u8 as *const libc::c_char,
                b"!completedsmall && lgl->opts->ccertc.val > 1\0" as *const u8
                    as *const libc::c_char,
            );
            if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
                fprintf(
                    stderr,
                    b" (tid %d)\0" as *const u8 as *const libc::c_char,
                    (*lgl).tid,
                );
            }
            fputc('\n' as i32, stderr);
            fflush(stderr);
            abort();
        }
        if completedsmall != 0 {
            lglprt(
                lgl,
                1 as libc::c_int,
                b"[cce-%d-%d] completed small round (%s)\0" as *const u8
                    as *const libc::c_char,
                (*(*lgl).stats).cce.count,
                round,
                lglcce2str(cce),
            );
        } else {
            lglprt(
                lgl,
                1 as libc::c_int,
                b"[cce-%d-%d] incomplete small round (%s)\0" as *const u8
                    as *const libc::c_char,
                (*(*lgl).stats).cce.count,
                round,
                lglcce2str(cce),
            );
        }
        if completedsmall != 0 && completedlarge != 0 {
            if ((*lgl).ccertc as libc::c_int) < cce {
                (*lgl).ccertc = cce as libc::c_char;
                lglprt(
                    lgl,
                    1 as libc::c_int,
                    b"[cce-%d-%d] completed small and large (%s)\0" as *const u8
                        as *const libc::c_char,
                    (*(*lgl).stats).cce.count,
                    round,
                    lglcce2str(cce),
                );
            }
        }
        lglsparse(lgl);
        lglgc(lgl);
        lglrelstk(lgl, &mut (*(*lgl).c2rust_unnamed.cce).extend);
        lglrelstk(lgl, &mut (*(*lgl).c2rust_unnamed.cce).cla);
        lgldel(
            lgl,
            (*(*lgl).c2rust_unnamed.cce).rem as *mut libc::c_void,
            (oldvars as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
        );
        (*(*lgl).c2rust_unnamed.cce).rem = 0 as *mut libc::c_int;
        lgldel(
            lgl,
            (*lgl).c2rust_unnamed.cce as *mut libc::c_void,
            (1 as libc::c_int as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<CCE>() as libc::c_ulong),
        );
        (*lgl).c2rust_unnamed.cce = 0 as *mut CCE;
        eliminated = oldirr - (*(*lgl).stats).irr.clauses.cur;
        total += eliminated;
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[cce-%d-%d] eliminated %d covered clauses in round %d\0" as *const u8
                as *const libc::c_char,
            (*(*lgl).stats).cce.count,
            round,
            eliminated,
            round,
        );
        (*lgl).simp = 0 as libc::c_int as libc::c_char;
        (*lgl).cceing = (*lgl).simp;
        if !((*lgl).mt == 0 && eliminated != 0 && lglterminate(lgl) == 0
            && round < (*(*lgl).opts).ccemaxround.val
            && (*(*lgl).limits).cce.steps > (*(*lgl).stats).cce.steps)
        {
            break;
        }
    }
    lglprt(
        lgl,
        1 as libc::c_int,
        b"[cce-%d] eliminated %d covered clauses in TOTAL during %d rounds\0"
            as *const u8 as *const libc::c_char,
        (*(*lgl).stats).cce.count,
        total,
        round,
    );
    if total != 0 {
        success = (startirr / (*(*lgl).opts).ccesuccessrat.val <= total) as libc::c_int;
        if success == 0 {
            lglprt(
                lgl,
                1 as libc::c_int,
                b"[cce-%d] %d < 1/%d * %d = %d considered unsuccessful\0" as *const u8
                    as *const libc::c_char,
                (*(*lgl).stats).cce.count,
                total,
                (*(*lgl).opts).ccesuccessrat.val,
                startirr,
                startirr / (*(*lgl).opts).ccesuccessrat.val,
            );
        }
    } else {
        success = 0 as libc::c_int;
    }
    if success != 0 && (*(*lgl).limits).cce.pen != 0 {
        (*(*lgl).limits).cce.pen -= 1;
        (*(*lgl).limits).cce.pen;
    }
    if success == 0 && (*(*lgl).limits).cce.pen < (*(*lgl).opts).penmax.val {
        (*(*lgl).limits).cce.pen += 1;
        (*(*lgl).limits).cce.pen;
    }
    if success != 0 && (*(*lgl).limits).cce.del.cur != 0 {
        (*(*lgl).limits).cce.del.cur /= 2 as libc::c_int;
    }
    if success == 0 && (*(*lgl).limits).cce.del.cur < (*(*lgl).opts).delmax.val {
        (*(*lgl).limits).cce.del.cur += 1;
        (*(*lgl).limits).cce.del.cur;
    }
    (*(*lgl).limits).cce.del.rem = (*(*lgl).limits).cce.del.cur;
    lglrep(lgl, 2 as libc::c_int, 'E' as i32 as libc::c_char);
    lglstop(lgl);
    lglbasicatestats(lgl);
    return ((*lgl).mt == 0) as libc::c_int;
}
unsafe extern "C" fn lglsetelmlim(mut lgl: *mut LGL, mut reschedptr: *mut libc::c_int) {
    let mut count: libc::c_int = (*(*lgl).stats).elm.count
        - (*(*lgl).opts).elmboostdel.val;
    let mut pen: libc::c_int = 0;
    let mut szpen: libc::c_int = 0;
    let mut resched: libc::c_int = 0 as libc::c_int;
    let mut limit: int64_t = 0;
    let mut irrlim: int64_t = 0;
    if (*(*lgl).opts).elmrtc.val > 1 as libc::c_int {
        (*(*lgl).limits).elm.steps = 0x7fffffffffffffff as libc::c_longlong as int64_t;
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[elim-%d] really no limit (run to completion)\0" as *const u8
                as *const libc::c_char,
            (*(*lgl).stats).elm.count,
        );
        resched = (*(*lgl).opts).elmresched.val & 4 as libc::c_int;
    } else if (*(*lgl).opts).elmrtc.val != 0
        || count > 0 as libc::c_int && lglrem(lgl) < (*(*lgl).opts).elmrtcintvlim.val
            && count % (*(*lgl).opts).elmrtcint.val == 0
    {
        limit = 100000000000 as libc::c_longlong as int64_t;
        (*(*lgl).limits).elm.steps = (*(*lgl).stats).elm.steps + limit;
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[elim-%d] almost no limit of %lld steps\0" as *const u8
                as *const libc::c_char,
            (*(*lgl).stats).elm.count,
            limit as libc::c_longlong,
        );
        resched = (*(*lgl).opts).elmresched.val & 4 as libc::c_int;
    } else {
        limit = (*(*lgl).opts).elmreleff.val as int64_t * lglvisearch(lgl)
            / 1000 as libc::c_int as int64_t;
        if limit < (*(*lgl).opts).elmineff.val as int64_t {
            limit = (*(*lgl).opts).elmineff.val as int64_t;
        }
        if (*(*lgl).opts).elmaxeff.val >= 0 as libc::c_int
            && limit > (*(*lgl).opts).elmaxeff.val as int64_t
        {
            limit = (*(*lgl).opts).elmaxeff.val as int64_t;
        }
        if count > 0 as libc::c_int
            && (count == 1 as libc::c_int || count % (*(*lgl).opts).elmboostint.val == 0)
            && lglrem(lgl) < (*(*lgl).opts).elmboostvlim.val
            && (*(*lgl).opts).boost.val != 0
            && (*(*lgl).opts).elmboost.val > 1 as libc::c_int
        {
            lglprt(
                lgl,
                1 as libc::c_int,
                b"[elim-%d] boosting limit by %d\0" as *const u8 as *const libc::c_char,
                (*(*lgl).stats).elm.count,
                (*(*lgl).opts).elmboost.val,
            );
            limit *= (*(*lgl).opts).elmboost.val as int64_t;
            resched = (*(*lgl).opts).elmresched.val & 2 as libc::c_int;
        } else {
            resched = (*(*lgl).opts).elmresched.val & 1 as libc::c_int;
        }
        szpen = lglszpen(lgl);
        pen = (*(*lgl).limits).elm.pen + szpen;
        limit >>= pen;
        irrlim = ((*(*lgl).stats).irr.clauses.cur >> szpen) as int64_t;
        if (*(*lgl).opts).irrlim.val != 0 && limit < irrlim {
            limit = irrlim;
            lglprt(
                lgl,
                1 as libc::c_int,
                b"[elim-%d] limit of %lld steps based on %d irredundant clauses penalty %d\0"
                    as *const u8 as *const libc::c_char,
                (*(*lgl).stats).elm.count,
                limit as libc::c_longlong,
                (*(*lgl).stats).irr.clauses.cur,
                szpen,
            );
        } else {
            lglprt(
                lgl,
                1 as libc::c_int,
                b"[elim-%d] limit of %lld steps penalty %d = %d + %d\0" as *const u8
                    as *const libc::c_char,
                (*(*lgl).stats).elm.count,
                limit as libc::c_longlong,
                pen,
                (*(*lgl).limits).elm.pen,
                szpen,
            );
        }
        (*(*lgl).limits).elm.steps = (*(*lgl).stats).elm.steps + limit;
    }
    lglprt(
        lgl,
        1 as libc::c_int,
        b"[elim-%d] rescheduling of touched variables %s\0" as *const u8
            as *const libc::c_char,
        (*(*lgl).stats).elm.count,
        if resched != 0 {
            b"enabled\0" as *const u8 as *const libc::c_char
        } else {
            b"disabled\0" as *const u8 as *const libc::c_char
        },
    );
    *reschedptr = resched;
}
unsafe extern "C" fn lglforceschedall(mut lgl: *mut LGL) -> libc::c_int {
    let oldonotsched: libc::c_int = (*lgl).donotsched as libc::c_int;
    let mut idx: libc::c_int = 0;
    let mut res: libc::c_int = 0 as libc::c_int;
    let mut av: *mut AVar = 0 as *mut AVar;
    (*lgl).touching = 0 as libc::c_int as libc::c_char;
    (*lgl).donotsched = 0 as libc::c_int as libc::c_char;
    idx = 2 as libc::c_int;
    while idx < (*lgl).nvars {
        if !(lglifrozen(lgl, idx) != 0) {
            if !(lglisfree(lgl, idx) == 0) {
                av = lglavar(lgl, idx);
                (*av).set_donotelm(0 as libc::c_int as libc::c_uint);
                lglesched(lgl, idx);
                res += 1;
                res;
            }
        }
        idx += 1;
        idx;
    }
    (*lgl).touching = 1 as libc::c_int as libc::c_char;
    if oldonotsched != 0 {
        (*lgl).donotsched = 1 as libc::c_int as libc::c_char;
    }
    lglprt(
        lgl,
        1 as libc::c_int,
        b"[elim-%d-%d] fully rescheduled %d variables %.0f%%\0" as *const u8
            as *const libc::c_char,
        (*(*lgl).stats).elm.count,
        (*(*lgl).c2rust_unnamed.elm).round,
        res,
        lglpcnt(
            res as libc::c_double,
            ((*lgl).nvars - 2 as libc::c_int) as libc::c_double,
        ),
    );
    return res;
}
unsafe extern "C" fn lgladdstrbincls(
    mut lgl: *mut LGL,
    mut a: libc::c_int,
    mut b: libc::c_int,
) {
    lglpushstk(lgl, &mut (*lgl).clause, a);
    lglpushstk(lgl, &mut (*lgl).clause, b);
    lglpushstk(lgl, &mut (*lgl).clause, 0 as libc::c_int);
    lgldrupligaddcls(lgl, REDCS as libc::c_int);
    lgladdcls(lgl, 0 as libc::c_int, 0 as libc::c_int, 1 as libc::c_int);
    lglclnstk(&mut (*lgl).clause);
}
unsafe extern "C" fn lglbackwardlit(
    mut lgl: *mut LGL,
    mut clause: *const libc::c_int,
    mut skip: *const libc::c_int,
    mut size: libc::c_int,
    mut minlit: libc::c_int,
    mut subptr: *mut libc::c_int,
    mut strptr: *mut libc::c_int,
) -> libc::c_int {
    let mut res: libc::c_int = 0;
    let mut blit: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut red: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut other2: libc::c_int = 0;
    let mut lidx: libc::c_int = 0;
    let mut count: libc::c_int = 0;
    let mut remove: libc::c_int = 0;
    let mut hit: libc::c_int = 0;
    let druplig: libc::c_int = (*(*lgl).opts).druplig.val;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut w: *const libc::c_int = 0 as *const libc::c_int;
    let mut eow: *const libc::c_int = 0 as *const libc::c_int;
    let mut c: *const libc::c_int = 0 as *const libc::c_int;
    let mut l: *const libc::c_int = 0 as *const libc::c_int;
    let mut marked: libc::c_int = 0;
    let mut marked2: libc::c_int = 0;
    let mut val: libc::c_int = 0;
    let mut saved: Stk = Stk {
        start: 0 as *mut libc::c_int,
        top: 0 as *mut libc::c_int,
        end: 0 as *mut libc::c_int,
    };
    let mut hts: *mut HTS = 0 as *mut HTS;
    memset(
        &mut saved as *mut Stk as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<Stk>() as libc::c_ulong,
    );
    (*(*lgl).stats).bkwd.tried.lits += 1;
    (*(*lgl).stats).bkwd.tried.lits;
    res = 0 as libc::c_int;
    hit = res;
    hts = lglhts(lgl, minlit);
    w = lglhts2wchs(lgl, hts);
    eow = w.offset((*hts).count as isize);
    let mut current_block_136: u64;
    p = w;
    while res == 0 && p < eow {
        blit = *p;
        tag = blit & MASKCS as libc::c_int;
        if tag == TRNCS as libc::c_int || tag == LRGCS as libc::c_int {
            p = p.offset(1);
            p;
        }
        if !(tag == LRGCS as libc::c_int) {
            if !(p == skip) {
                red = blit & REDCS as libc::c_int;
                if !(red != 0) {
                    (*(*lgl).stats).bkwd.tried.occs += 1;
                    (*(*lgl).stats).bkwd.tried.occs;
                    (*(*lgl).stats).steps += 1;
                    (*(*lgl).stats).steps;
                    (*(*lgl).stats).elm.steps += 1;
                    (*(*lgl).stats).elm.steps;
                    if tag == BINCS as libc::c_int {
                        if !(size > 2 as libc::c_int) {
                            other = blit >> RMSHFT as libc::c_int;
                            if !(lglisfree(lgl, other) == 0) {
                                marked = lglmarked(lgl, other);
                                if marked > 0 as libc::c_int {
                                    if !(size == 2 as libc::c_int
                                        && {
                                            let fresh208 = hit;
                                            hit = hit + 1;
                                            fresh208 == 0
                                        })
                                    {
                                        (*(*lgl).stats).steps += 2 as libc::c_int as int64_t;
                                        (*(*lgl).stats).elm.steps += 2 as libc::c_int as int64_t;
                                        if druplig != 0 {
                                            lgldrupligdelclsarg(lgl, minlit, other, 0 as libc::c_int);
                                        }
                                        lglrmbcls(lgl, minlit, other, 0 as libc::c_int);
                                        (*(*lgl).stats).bkwd.sub2 += 1;
                                        (*(*lgl).stats).bkwd.sub2;
                                        *subptr += 1 as libc::c_int;
                                        res = 1 as libc::c_int;
                                    }
                                } else if marked < 0 as libc::c_int {
                                    (*(*lgl).stats).steps += 2 as libc::c_int as int64_t;
                                    (*(*lgl).stats).elm.steps += 2 as libc::c_int as int64_t;
                                    lglunit(lgl, minlit);
                                    (*(*lgl).stats).bkwd.str2 += 1;
                                    (*(*lgl).stats).bkwd.str2;
                                    *strptr += 1 as libc::c_int;
                                    res = 1 as libc::c_int;
                                }
                            }
                        }
                    } else if tag == TRNCS as libc::c_int {
                        if !(size > 3 as libc::c_int) {
                            other = blit >> RMSHFT as libc::c_int;
                            other2 = *p;
                            if !(lglisfree(lgl, other) == 0) {
                                if !(lglisfree(lgl, other2) == 0) {
                                    marked = lglmarked(lgl, other);
                                    marked2 = lglmarked(lgl, other2);
                                    if size == 2 as libc::c_int
                                        && (marked > 0 as libc::c_int || marked2 > 0 as libc::c_int)
                                        || size == 3 as libc::c_int && marked > 0 as libc::c_int
                                            && marked2 > 0 as libc::c_int
                                    {
                                        if !(size == 3 as libc::c_int
                                            && {
                                                let fresh209 = hit;
                                                hit = hit + 1;
                                                fresh209 == 0
                                            })
                                        {
                                            (*(*lgl).stats).steps += 3 as libc::c_int as int64_t;
                                            (*(*lgl).stats).elm.steps += 3 as libc::c_int as int64_t;
                                            if druplig != 0 {
                                                lgldrupligdelclsarg(
                                                    lgl,
                                                    minlit,
                                                    other,
                                                    other2,
                                                    0 as libc::c_int,
                                                );
                                            }
                                            lglrmtcls(lgl, minlit, other, other2, 0 as libc::c_int);
                                            (*(*lgl).stats).bkwd.sub3 += 1;
                                            (*(*lgl).stats).bkwd.sub3;
                                            *subptr += 1 as libc::c_int;
                                            res = 1 as libc::c_int;
                                        }
                                    } else {
                                        if marked < 0 as libc::c_int && marked2 > 0 as libc::c_int {
                                            let mut tmp: libc::c_int = other;
                                            other = other2;
                                            other2 = tmp;
                                            current_block_136 = 1134115459065347084;
                                        } else if marked <= 0 as libc::c_int
                                            || marked2 >= 0 as libc::c_int
                                        {
                                            current_block_136 = 17965632435239708295;
                                        } else {
                                            current_block_136 = 1134115459065347084;
                                        }
                                        match current_block_136 {
                                            17965632435239708295 => {}
                                            _ => {
                                                lgladdstrbincls(lgl, minlit, other);
                                                if druplig != 0 {
                                                    lgldrupligdelclsarg(
                                                        lgl,
                                                        minlit,
                                                        other,
                                                        other2,
                                                        0 as libc::c_int,
                                                    );
                                                }
                                                lglrmtcls(lgl, minlit, other, other2, 0 as libc::c_int);
                                                if size == 3 as libc::c_int {
                                                    if druplig != 0 {
                                                        lgldrupligdelclsarg(
                                                            lgl,
                                                            minlit,
                                                            other,
                                                            -other2,
                                                            0 as libc::c_int,
                                                        );
                                                    }
                                                    lglrmtcls(lgl, minlit, other, -other2, 0 as libc::c_int);
                                                    (*(*lgl).stats).bkwd.str3self += 1;
                                                    (*(*lgl).stats).bkwd.str3self;
                                                }
                                                (*(*lgl).stats).steps += 3 as libc::c_int as int64_t;
                                                (*(*lgl).stats).elm.steps += 3 as libc::c_int as int64_t;
                                                (*(*lgl).stats).bkwd.str3 += 1;
                                                (*(*lgl).stats).bkwd.str3;
                                                *strptr += 1 as libc::c_int;
                                                res = 1 as libc::c_int;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        lidx = blit >> RMSHFT as libc::c_int;
                        c = lglidx2lits(lgl, 0 as libc::c_int, lidx);
                        if !(c == skip) {
                            (*(*lgl).stats).steps += 1;
                            (*(*lgl).stats).steps;
                            (*(*lgl).stats).elm.steps += 1;
                            (*(*lgl).stats).elm.steps;
                            count = size;
                            remove = 0 as libc::c_int;
                            l = c;
                            loop {
                                other = *l;
                                if !(other != 0) {
                                    break;
                                }
                                val = lglval(lgl, other) as libc::c_int;
                                if val > 0 as libc::c_int {
                                    remove = 2147483647 as libc::c_int;
                                    break;
                                } else {
                                    if !(val < 0 as libc::c_int) {
                                        marked = lglmarked(lgl, other);
                                        if !(marked == 0) {
                                            count -= 1;
                                            count;
                                            if !(marked > 0 as libc::c_int) {
                                                if remove != 0 {
                                                    remove = 2147483647 as libc::c_int;
                                                    break;
                                                } else {
                                                    remove = other;
                                                }
                                            }
                                        }
                                    }
                                    l = l.offset(1);
                                    l;
                                }
                            }
                            if !(count > 0 as libc::c_int) {
                                if !(remove == 2147483647 as libc::c_int) {
                                    if remove == 0 {
                                        (*(*lgl).stats).steps += l.offset_from(c) as libc::c_long;
                                        (*(*lgl).stats).elm.steps
                                            += l.offset_from(c) as libc::c_long;
                                        if druplig != 0 {
                                            lgldrupligdelclsaux(lgl, c);
                                        }
                                        lglrmlcls(lgl, lidx, 0 as libc::c_int);
                                        (*(*lgl).stats).bkwd.subl += 1;
                                        (*(*lgl).stats).bkwd.subl;
                                        *subptr += 1 as libc::c_int;
                                        res = 1 as libc::c_int;
                                    } else if lglsmallirr(lgl) != 0 {
                                        l = c;
                                        loop {
                                            other = *l;
                                            if !(other != 0) {
                                                break;
                                            }
                                            if druplig != 0 {
                                                lglpushstk(lgl, &mut saved, other);
                                            }
                                            if !(other == remove) {
                                                val = lglval(lgl, other) as libc::c_int;
                                                if !(val < 0 as libc::c_int) {
                                                    lglpushstk(lgl, &mut (*lgl).clause, other);
                                                }
                                            }
                                            l = l.offset(1);
                                            l;
                                        }
                                        lglpushstk(lgl, &mut (*lgl).clause, 0 as libc::c_int);
                                        if druplig != 0 {
                                            lgldrupligaddcls(lgl, REDCS as libc::c_int);
                                            lglpushstk(lgl, &mut saved, 0 as libc::c_int);
                                            lgldrupligdelclsaux(lgl, saved.start);
                                            lglclnstk(&mut saved);
                                        }
                                        (*(*lgl).stats).steps += l.offset_from(c) as libc::c_long;
                                        (*(*lgl).stats).elm.steps
                                            += l.offset_from(c) as libc::c_long;
                                        lglrmlcls(lgl, lidx, 0 as libc::c_int);
                                        if l.offset_from(c) as libc::c_long == size as libc::c_long
                                        {
                                            (*(*lgl).stats).bkwd.strlself += 1;
                                            (*(*lgl).stats).bkwd.strlself;
                                        }
                                        lgladdcls(
                                            lgl,
                                            0 as libc::c_int,
                                            0 as libc::c_int,
                                            1 as libc::c_int,
                                        );
                                        lglclnstk(&mut (*lgl).clause);
                                        (*(*lgl).stats).bkwd.strl += 1;
                                        (*(*lgl).stats).bkwd.strl;
                                        *strptr += 1 as libc::c_int;
                                        res = 1 as libc::c_int;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        p = p.offset(1);
        p;
    }
    lglrelstk(lgl, &mut saved);
    return res;
}
unsafe extern "C" fn lglbackwardclause(
    mut lgl: *mut LGL,
    mut clause: *const libc::c_int,
    mut skip: *const libc::c_int,
    mut subsumedptr: *mut libc::c_int,
    mut strengthenedptr: *mut libc::c_int,
) -> libc::c_int {
    let mut lit: libc::c_int = 0;
    let mut size: libc::c_int = 0;
    let mut minlit: libc::c_int = 0;
    let mut minlit2: libc::c_int = 0;
    let mut minocc: libc::c_int = 0;
    let mut minocc2: libc::c_int = 0;
    let mut tmpocc: libc::c_int = 0;
    let mut res: libc::c_int = 0;
    let mut large: libc::c_int = 0;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut delta: libc::c_long = 0;
    (*(*lgl).stats).bkwd.tried.clauses += 1;
    (*(*lgl).stats).bkwd.tried.clauses;
    (*(*lgl).stats).steps += 1;
    (*(*lgl).stats).steps;
    (*(*lgl).stats).elm.steps += 1;
    (*(*lgl).stats).elm.steps;
    minlit2 = 0 as libc::c_int;
    minocc2 = minlit2;
    minlit = minocc2;
    minocc = minlit;
    p = clause;
    loop {
        lit = *p;
        if !(lit != 0) {
            break;
        }
        lglmarkunmarked(lgl, lit);
        tmpocc = lglocc(lgl, lit);
        if minlit == 0 || tmpocc < minocc {
            minocc2 = minocc;
            minlit2 = minlit;
            minocc = tmpocc;
            minlit = lit;
        } else if minlit2 == 0 || tmpocc < minocc2 {
            minocc2 = tmpocc;
            minlit2 = lit;
        }
        p = p.offset(1);
        p;
    }
    size = p.offset_from(clause) as libc::c_long as libc::c_int;
    large = ((*lgl).irr.start <= clause as *mut libc::c_int
        && clause < (*lgl).irr.top as *const libc::c_int) as libc::c_int;
    delta = if large != 0 {
        clause.offset_from((*lgl).irr.start) as libc::c_long
    } else {
        0 as libc::c_int as libc::c_long
    };
    res = lglbackwardlit(lgl, clause, skip, size, minlit, subsumedptr, strengthenedptr);
    if res == 0 {
        res = lglbackwardlit(
            lgl,
            clause,
            skip,
            size,
            minlit2,
            subsumedptr,
            strengthenedptr,
        );
    }
    if res != 0 && large != 0 {
        clause = ((*lgl).irr.start).offset(delta as isize);
    }
    p = clause;
    loop {
        lit = *p;
        if !(lit != 0) {
            break;
        }
        lglunmark(lgl, lit);
        p = p.offset(1);
        p;
    }
    return res;
}
unsafe extern "C" fn lglbackward(
    mut lgl: *mut LGL,
    mut u: *mut libc::c_int,
    mut t: *mut libc::c_int,
    mut steps: int64_t,
    mut completedptr: *mut libc::c_int,
) {
    let mut current_block: u64;
    let mut idx: libc::c_int = 0;
    let mut sign: libc::c_int = 0;
    let mut lit: libc::c_int = 0;
    let mut blit: libc::c_int = 0;
    let mut red: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut other2: libc::c_int = 0;
    let mut clause: [libc::c_int; 4] = [0; 4];
    let mut w: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut oldtouched: libc::c_int = 0;
    let mut newtouched: libc::c_int = 0;
    let mut round: libc::c_int = 0;
    let mut touched: libc::c_int = 0;
    let mut limit: int64_t = 0;
    let mut delta: int64_t = 0;
    let mut scaled: int64_t = 0;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut eow: *const libc::c_int = 0 as *const libc::c_int;
    let mut c: *const libc::c_int = 0 as *const libc::c_int;
    let mut hts: *mut HTS = 0 as *mut HTS;
    let mut stk: Stk = Stk {
        start: 0 as *mut libc::c_int,
        top: 0 as *mut libc::c_int,
        end: 0 as *mut libc::c_int,
    };
    lglstart(lgl, &mut (*(*lgl).times).backward);
    (*(*lgl).c2rust_unnamed.elm)
        .bkwdocclim = lglfactor(
        lgl,
        (*(*lgl).opts).bkwdocclim.val,
        (*(*lgl).stats).elm.count,
    ) as libc::c_int;
    memset(
        &mut stk as *mut Stk as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<Stk>() as libc::c_ulong,
    );
    *t = 0 as libc::c_int;
    *u = *t;
    if 0x7fffffffffffffff as libc::c_longlong
        / (*(*lgl).opts).bkwdscale.val as libc::c_longlong
        <= (steps / 100 as libc::c_int as int64_t) as libc::c_longlong
    {
        scaled = 0x7fffffffffffffff as libc::c_longlong as int64_t;
    } else {
        scaled = steps / 100 as libc::c_int as int64_t
            * (*(*lgl).opts).bkwdscale.val as int64_t;
    }
    if (*(*lgl).limits).elm.steps - scaled <= (*(*lgl).stats).elm.steps {
        limit = (*(*lgl).limits).elm.steps;
    } else {
        limit = (*(*lgl).stats).elm.steps + scaled;
    }
    delta = limit - (*(*lgl).stats).elm.steps;
    lglprt(
        lgl,
        1 as libc::c_int,
        b"[elim-%d-%d] backward subsumption/strengthening limit %lld\0" as *const u8
            as *const libc::c_char,
        (*(*lgl).stats).elm.count,
        (*(*lgl).c2rust_unnamed.elm).round,
        delta,
    );
    round = 0 as libc::c_int;
    '_RESTARTOUCHED: loop {
        round += 1;
        round;
        oldtouched = lglcntstk(&mut (*(*lgl).c2rust_unnamed.elm).touched.stk)
            as libc::c_int;
        oldtouched -= (*(*lgl).c2rust_unnamed.elm).touched.mt;
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[elim-%d-%d-%d] backward checking %d touched variables %.0f%%\0"
                as *const u8 as *const libc::c_char,
            (*(*lgl).stats).elm.count,
            (*(*lgl).c2rust_unnamed.elm).round,
            round,
            oldtouched,
            lglpcnt(oldtouched as libc::c_double, lglrem(lgl) as libc::c_double),
        );
        *completedptr = 0 as libc::c_int;
        loop {
            idx = lglpoptouched(lgl);
            if !(idx != 0) {
                break;
            }
            sign = -(1 as libc::c_int);
            while sign <= 1 as libc::c_int {
                '_RESTARTLIT: loop {
                    if (*lgl).mt != 0 {
                        break '_RESTARTOUCHED;
                    }
                    if lglterminate(lgl) != 0 {
                        break '_RESTARTOUCHED;
                    }
                    if lglisfree(lgl, idx) == 0 {
                        break;
                    }
                    (*(*lgl).stats).steps += 1;
                    (*(*lgl).stats).steps;
                    let fresh210 = (*(*lgl).stats).elm.steps;
                    (*(*lgl).stats).elm.steps = (*(*lgl).stats).elm.steps + 1;
                    if fresh210 >= limit {
                        break '_RESTARTOUCHED;
                    }
                    lit = sign * idx;
                    hts = lglhts(lgl, lit);
                    w = lglhts2wchs(lgl, hts);
                    eow = w.offset((*hts).count as isize);
                    lglclnstk(&mut stk);
                    p = w;
                    while p < eow {
                        blit = *p;
                        tag = blit & MASKCS as libc::c_int;
                        if tag == TRNCS as libc::c_int || tag == LRGCS as libc::c_int {
                            p = p.offset(1);
                            p;
                        }
                        if !(tag != BINCS as libc::c_int) {
                            red = blit & REDCS as libc::c_int;
                            if !(red != 0) {
                                lglpushstk(lgl, &mut stk, blit);
                            }
                        }
                        p = p.offset(1);
                        p;
                    }
                    p = w;
                    while p < eow {
                        blit = *p;
                        tag = blit & MASKCS as libc::c_int;
                        if tag == TRNCS as libc::c_int || tag == LRGCS as libc::c_int {
                            p = p.offset(1);
                            p;
                        }
                        if !(tag != TRNCS as libc::c_int) {
                            red = blit & REDCS as libc::c_int;
                            if !(red != 0) {
                                lglpushstk(lgl, &mut stk, blit);
                                lglpushstk(lgl, &mut stk, *p);
                            }
                        }
                        p = p.offset(1);
                        p;
                    }
                    p = w;
                    while p < eow {
                        blit = *p;
                        tag = blit & MASKCS as libc::c_int;
                        if tag == TRNCS as libc::c_int || tag == LRGCS as libc::c_int {
                            p = p.offset(1);
                            p;
                        }
                        red = blit & REDCS as libc::c_int;
                        if !(red == 0
                            && (tag == BINCS as libc::c_int
                                || tag == TRNCS as libc::c_int))
                        {
                            lglpushstk(lgl, &mut stk, blit);
                            if tag == TRNCS as libc::c_int || tag == LRGCS as libc::c_int
                            {
                                lglpushstk(lgl, &mut stk, *p);
                            }
                        }
                        p = p.offset(1);
                        p;
                    }
                    memcpy(
                        w as *mut libc::c_void,
                        stk.start as *const libc::c_void,
                        (lglcntstk(&mut stk))
                            .wrapping_mul(
                                ::core::mem::size_of::<libc::c_int>() as libc::c_ulong,
                            ),
                    );
                    clause[0 as libc::c_int as usize] = lit;
                    p = w;
                    loop {
                        if !(p < eow) {
                            break '_RESTARTLIT;
                        }
                        blit = *p;
                        tag = blit & MASKCS as libc::c_int;
                        if tag == TRNCS as libc::c_int || tag == LRGCS as libc::c_int {
                            p = p.offset(1);
                            p;
                        }
                        if !(tag == LRGCS as libc::c_int) {
                            red = blit & REDCS as libc::c_int;
                            if !(red != 0) {
                                (*(*lgl).stats).steps += 1;
                                (*(*lgl).stats).steps;
                                let fresh211 = (*(*lgl).stats).elm.steps;
                                (*(*lgl).stats).elm.steps = (*(*lgl).stats).elm.steps + 1;
                                if fresh211 >= limit {
                                    break '_RESTARTOUCHED;
                                }
                                if tag == BINCS as libc::c_int {
                                    other = blit >> RMSHFT as libc::c_int;
                                    if abs(other) < idx {
                                        current_block = 5235537862154438448;
                                    } else {
                                        clause[1 as libc::c_int as usize] = other;
                                        clause[2 as libc::c_int as usize] = 0 as libc::c_int;
                                        if lglbackwardclause(lgl, clause.as_mut_ptr(), p, u, t) == 0
                                        {
                                            current_block = 5235537862154438448;
                                        } else {
                                            current_block = 5658374378798827547;
                                        }
                                    }
                                } else if tag == TRNCS as libc::c_int {
                                    other = blit >> RMSHFT as libc::c_int;
                                    if abs(other) < idx {
                                        current_block = 5235537862154438448;
                                    } else {
                                        other2 = *p;
                                        if abs(other2) < idx {
                                            current_block = 5235537862154438448;
                                        } else {
                                            clause[1 as libc::c_int as usize] = other;
                                            clause[2 as libc::c_int as usize] = other2;
                                            clause[3 as libc::c_int as usize] = 0 as libc::c_int;
                                            if lglbackwardclause(lgl, clause.as_mut_ptr(), p, u, t) == 0
                                            {
                                                current_block = 5235537862154438448;
                                            } else {
                                                current_block = 5658374378798827547;
                                            }
                                        }
                                    }
                                } else {
                                    current_block = 5235537862154438448;
                                }
                                match current_block {
                                    5235537862154438448 => {}
                                    _ => {
                                        if lglflush(lgl) != 0 {
                                            break;
                                        } else {
                                            break '_RESTARTOUCHED;
                                        }
                                    }
                                }
                            }
                        }
                        p = p.offset(1);
                        p;
                    }
                }
                sign += 2 as libc::c_int;
            }
        }
        c = (*lgl).irr.start;
        while c < (*lgl).irr.top as *const libc::c_int {
            if lglsmallirr(lgl) == 0 {
                break '_RESTARTOUCHED;
            }
            (*(*lgl).stats).steps += 1;
            (*(*lgl).stats).steps;
            let fresh212 = (*(*lgl).stats).elm.steps;
            (*(*lgl).stats).elm.steps = (*(*lgl).stats).elm.steps + 1;
            if fresh212 >= limit {
                break '_RESTARTOUCHED;
            }
            p = c;
            if !(*p >= 2147483647 as libc::c_int >> RMSHFT as libc::c_int) {
                touched = 0 as libc::c_int;
                loop {
                    lit = *p;
                    if !(lit != 0) {
                        break;
                    }
                    if touched == 0 && lgltouched(lgl, lit) != 0 {
                        touched = 1 as libc::c_int;
                    }
                    p = p.offset(1);
                    p;
                }
                if touched != 0 {
                    lglbackwardclause(lgl, c, c, u, t);
                }
            }
            c = p.offset(1 as libc::c_int as isize);
        }
        if round < (*(*lgl).opts).bkwdroundlim.val
            && lglmtstk(&mut (*(*lgl).c2rust_unnamed.elm).touched.stk) == 0
        {
            continue;
        }
        *completedptr = 1 as libc::c_int;
        break;
    }
    newtouched = lglcntstk(&mut (*(*lgl).c2rust_unnamed.elm).touched.stk) as libc::c_int;
    newtouched -= (*(*lgl).c2rust_unnamed.elm).touched.mt;
    if *completedptr != 0 {
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[elim-%d-%d-%d] fully completed backward checking in %d rounds\0"
                as *const u8 as *const libc::c_char,
            (*(*lgl).stats).elm.count,
            (*(*lgl).c2rust_unnamed.elm).round,
            round,
            round,
        );
    } else {
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[elim-%d-%d-%d] incomplete backward checking %d remain %.0f%%\0"
                as *const u8 as *const libc::c_char,
            (*(*lgl).stats).elm.count,
            (*(*lgl).c2rust_unnamed.elm).round,
            round,
            newtouched,
            lglpcnt(newtouched as libc::c_double, oldtouched as libc::c_double),
        );
    }
    lglrelstk(lgl, &mut stk);
    lglstop(lgl);
}
unsafe extern "C" fn lglelmdone(
    mut lgl: *mut LGL,
    mut allptr: *mut libc::c_int,
) -> libc::c_int {
    let mut newelmd: libc::c_int = 0;
    let mut eliminated: libc::c_int = 0;
    let mut subsumed: libc::c_int = 0;
    let mut strengthened: libc::c_int = 0;
    let mut bkwdcompleted: libc::c_int = 0;
    let oldonotsched: libc::c_int = (*lgl).donotsched as libc::c_int;
    let newdonotsched: libc::c_int = ((*(*lgl).opts).bkwdresched.val == 0)
        as libc::c_int;
    let mut steps: int64_t = 0;
    let mut oldsteps: int64_t = 0;
    if lglsmallirr(lgl) == 0 {
        return 1 as libc::c_int;
    }
    if lglterminate(lgl) != 0 {
        return 1 as libc::c_int;
    }
    if (*(*lgl).limits).elm.steps <= (*(*lgl).stats).elm.steps {
        return 1 as libc::c_int;
    }
    if lglmtstk(&mut (*lgl).esched) == 0 {
        return 0 as libc::c_int;
    }
    oldsteps = (*(*lgl).stats).elm.steps;
    steps = oldsteps - (*(*lgl).c2rust_unnamed.elm).oldsteps;
    newelmd = (*(*lgl).stats).elm.elmd;
    eliminated = newelmd - (*(*lgl).c2rust_unnamed.elm).oldelmd;
    if eliminated <= 0 as libc::c_int {
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[elim-%d-%d] no variable eliminated in round %d in %lld steps\0"
                as *const u8 as *const libc::c_char,
            (*(*lgl).stats).elm.count,
            (*(*lgl).c2rust_unnamed.elm).round,
            (*(*lgl).c2rust_unnamed.elm).round,
            steps as libc::c_longlong,
        );
        return 1 as libc::c_int;
    }
    lglprt(
        lgl,
        1 as libc::c_int,
        b"[elim-%d-%d] eliminated %d variables %.0f%% in round %d in %lld steps\0"
            as *const u8 as *const libc::c_char,
        (*(*lgl).stats).elm.count,
        (*(*lgl).c2rust_unnamed.elm).round,
        eliminated,
        lglpcnt(
            eliminated as libc::c_double,
            ((*lgl).nvars - 2 as libc::c_int) as libc::c_double,
        ),
        (*(*lgl).c2rust_unnamed.elm).round,
        steps as libc::c_longlong,
    );
    if oldonotsched != newdonotsched {
        (*lgl).donotsched = newdonotsched as libc::c_char;
    }
    lglbackward(lgl, &mut subsumed, &mut strengthened, steps, &mut bkwdcompleted);
    if oldonotsched != newdonotsched {
        (*lgl).donotsched = oldonotsched as libc::c_char;
    }
    steps = (*(*lgl).stats).elm.steps - oldsteps;
    lglprt(
        lgl,
        1 as libc::c_int,
        b"[elim-%d-%d] subsumed %d and strengthened %d clauses in %lld steps\0"
            as *const u8 as *const libc::c_char,
        (*(*lgl).stats).elm.count,
        (*(*lgl).c2rust_unnamed.elm).round,
        subsumed,
        strengthened,
        steps as libc::c_longlong,
    );
    (*(*lgl).stats).elm.rounds += 1;
    (*(*lgl).stats).elm.rounds;
    (*(*lgl).c2rust_unnamed.elm).oldelmd = newelmd;
    (*(*lgl).c2rust_unnamed.elm).oldsteps = (*(*lgl).stats).elm.steps;
    if (*lgl).mt != 0 {
        return 1 as libc::c_int;
    }
    if (*(*lgl).limits).elm.steps <= (*(*lgl).stats).elm.steps {
        return 1 as libc::c_int;
    }
    if (*(*lgl).c2rust_unnamed.elm).round >= (*(*lgl).opts).elmroundlim.val {
        return 1 as libc::c_int;
    }
    if lglmtstk(&mut (*lgl).esched) == 0 {
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[elim-%d-%d] rescheduled %d variables %.0f%% by backward subsumption\0"
                as *const u8 as *const libc::c_char,
            (*(*lgl).stats).elm.count,
            (*(*lgl).c2rust_unnamed.elm).round,
            lglcntstk(&mut (*lgl).esched),
            lglpcnt(
                lglcntstk(&mut (*lgl).esched) as libc::c_double,
                lglrem(lgl) as libc::c_double,
            ),
        );
        (*(*lgl).c2rust_unnamed.elm).round += 1;
        (*(*lgl).c2rust_unnamed.elm).round;
        return 0 as libc::c_int;
    }
    if bkwdcompleted != 0 && *allptr != 0 {
        return 1 as libc::c_int;
    }
    *allptr = 1 as libc::c_int;
    if lglforceschedall(lgl) == 0 {
        return 1 as libc::c_int;
    }
    (*(*lgl).c2rust_unnamed.elm).round += 1;
    (*(*lgl).c2rust_unnamed.elm).round;
    return 0 as libc::c_int;
}
unsafe extern "C" fn lglinitouched(mut lgl: *mut LGL) {
    let mut idx: libc::c_int = 0;
    (*(*lgl).c2rust_unnamed.elm).touched.nvars = (*lgl).nvars;
    (*(*lgl).c2rust_unnamed.elm)
        .touched
        .pos = lglnew(
        lgl,
        ((*lgl).nvars as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
    ) as *mut libc::c_int;
    idx = 2 as libc::c_int;
    while idx < (*lgl).nvars {
        *((*(*lgl).c2rust_unnamed.elm).touched.pos)
            .offset(idx as isize) = -(1 as libc::c_int);
        idx += 1;
        idx;
    }
}
unsafe extern "C" fn lglreltouched(mut lgl: *mut LGL) {
    lglrelstk(lgl, &mut (*(*lgl).c2rust_unnamed.elm).touched.stk);
    lgldel(
        lgl,
        (*(*lgl).c2rust_unnamed.elm).touched.pos as *mut libc::c_void,
        ((*(*lgl).c2rust_unnamed.elm).touched.nvars as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
    );
    (*(*lgl).c2rust_unnamed.elm).touched.pos = 0 as *mut libc::c_int;
}
unsafe extern "C" fn lglelim(mut lgl: *mut LGL) -> libc::c_int {
    let mut res: libc::c_int = 1 as libc::c_int;
    let mut idx: libc::c_int = 0;
    let mut elmd: libc::c_int = 0;
    let mut oldnvars: libc::c_int = 0;
    let mut sched: libc::c_int = 0;
    let mut success: libc::c_int = 0;
    let mut all: libc::c_int = 0;
    let mut rem: libc::c_int = 0;
    let mut oldrem: libc::c_int = (*lgl).elmrem as libc::c_int;
    let mut oldall: libc::c_int = (*lgl).elmall as libc::c_int;
    let mut resched: libc::c_int = 0;
    lglstart(lgl, &mut (*(*lgl).times).elim);
    (*(*lgl).stats).elm.count += 1;
    (*(*lgl).stats).elm.count;
    (*lgl).occs = 1 as libc::c_int as libc::c_char;
    (*lgl).simp = (*lgl).occs;
    (*lgl).eliminating = (*lgl).simp;
    (*lgl)
        .c2rust_unnamed
        .elm = lglnew(
        lgl,
        (1 as libc::c_int as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Elm>() as libc::c_ulong),
    ) as *mut Elm;
    (*(*lgl).c2rust_unnamed.elm).oldelmd = (*(*lgl).stats).elm.elmd;
    (*(*lgl).c2rust_unnamed.elm).round = 1 as libc::c_int;
    (*(*lgl).c2rust_unnamed.elm).oldsteps = (*(*lgl).stats).elm.steps;
    (*(*lgl).stats).elm.rounds += 1;
    (*(*lgl).stats).elm.rounds;
    if (*lgl).level > 0 as libc::c_int {
        lglbacktrack(lgl, 0 as libc::c_int);
    }
    oldnvars = lglrem(lgl);
    lglgc(lgl);
    all = (oldrem == 0 || oldall == 0) as libc::c_int;
    if all != 0 {
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[elim-%d] scheduling all variables this time\0" as *const u8
                as *const libc::c_char,
            (*(*lgl).stats).elm.count,
        );
    } else if lgleschedrem(lgl, 1 as libc::c_int) == 0 {
        all = 1 as libc::c_int;
        oldrem = 0 as libc::c_int;
    }
    if all == 0 {
        (*lgl).donotsched = 1 as libc::c_int as libc::c_char;
    }
    lgldense(lgl, 1 as libc::c_int);
    lglinitouched(lgl);
    if all == 0 {
        (*lgl).donotsched = 0 as libc::c_int as libc::c_char;
    }
    (*lgl).touching = 1 as libc::c_int as libc::c_char;
    lglsetelmlim(lgl, &mut resched);
    if resched == 0 {
        (*lgl).donotsched = 1 as libc::c_int as libc::c_char;
    }
    sched = lglcntstk(&mut (*lgl).esched) as libc::c_int;
    while res != 0 && lglelmdone(lgl, &mut all) == 0 {
        idx = lglpopesched(lgl);
        let ref mut fresh213 = *lglavar(lgl, idx);
        (*fresh213).set_donotelm(1 as libc::c_int as libc::c_uint);
        lglelimlit(lgl, idx);
        res = lglflush(lgl);
    }
    (*lgl).touching = 0 as libc::c_int as libc::c_char;
    if resched == 0 {
        (*lgl).donotsched = 0 as libc::c_int as libc::c_char;
    }
    rem = lglcntstk(&mut (*lgl).esched) as libc::c_int;
    if rem == 0 {
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[elim-%d] fully completed in %d rounds\0" as *const u8
                as *const libc::c_char,
            (*(*lgl).stats).elm.count,
            (*(*lgl).c2rust_unnamed.elm).round,
        );
        (*lgl).elmrtc = 1 as libc::c_int as libc::c_char;
    } else {
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[elim-%d] incomplete %d not tried %.0f%% in round %d\0" as *const u8
                as *const libc::c_char,
            (*(*lgl).stats).elm.count,
            rem,
            lglpcnt(
                rem as libc::c_double,
                ((*lgl).nvars - 2 as libc::c_int) as libc::c_double,
            ),
            (*(*lgl).c2rust_unnamed.elm).round,
        );
    }
    lglsetdonotesched(lgl, (rem == 0) as libc::c_int);
    lglrelstk(lgl, &mut (*lgl).esched);
    lglreltouched(lgl);
    lglrelecls(lgl);
    lglsparse(lgl);
    lglgc(lgl);
    lgldel(
        lgl,
        (*lgl).c2rust_unnamed.elm as *mut libc::c_void,
        (1 as libc::c_int as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Elm>() as libc::c_ulong),
    );
    (*lgl).c2rust_unnamed.elm = 0 as *mut Elm;
    (*lgl).elmrem = (rem > 0 as libc::c_int) as libc::c_int as libc::c_char;
    (*lgl)
        .elmall = (all != 0 && (*lgl).elmrem as libc::c_int != 0) as libc::c_int
        as libc::c_char;
    lglprt(
        lgl,
        1 as libc::c_int,
        b"[elim-%d] transition to [ all %d rem %d ] state\0" as *const u8
            as *const libc::c_char,
        (*(*lgl).stats).elm.count,
        (*lgl).elmall as libc::c_int,
        (*lgl).elmrem as libc::c_int,
    );
    elmd = oldnvars - lglrem(lgl);
    (*(*lgl).stats).irrprgss += elmd as int64_t;
    lglprt(
        lgl,
        1 as libc::c_int,
        b"[elim-%d] eliminated %d = %.0f%% variables out of %d scheduled\0" as *const u8
            as *const libc::c_char,
        (*(*lgl).stats).elm.count,
        elmd,
        lglpcnt(elmd as libc::c_double, sched as libc::c_double),
        sched,
    );
    if (*lgl).elmrtc == 0
        && (*(*lgl).stats).elm.count <= (*(*lgl).opts).elmsuccessmaxwortc.val
    {
        success = 1 as libc::c_int;
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[elim-%d] considered successful since not run to completion yet\0"
                as *const u8 as *const libc::c_char,
            (*(*lgl).stats).elm.count,
        );
    } else if elmd != 0 {
        success = (oldnvars / (*(*lgl).opts).elmsuccessrat.val <= elmd) as libc::c_int;
        if success == 0 {
            lglprt(
                lgl,
                1 as libc::c_int,
                b"[elim-%d] %d < 1/%d * %d = %d considered unsuccessful\0" as *const u8
                    as *const libc::c_char,
                (*(*lgl).stats).elm.count,
                elmd,
                (*(*lgl).opts).elmsuccessrat.val,
                sched,
                sched / (*(*lgl).opts).elmsuccessrat.val,
            );
        }
    } else {
        success = 0 as libc::c_int;
    }
    if success != 0 && (*(*lgl).limits).elm.pen != 0 {
        (*(*lgl).limits).elm.pen -= 1;
        (*(*lgl).limits).elm.pen;
    }
    if success == 0 && (*(*lgl).limits).elm.pen < (*(*lgl).opts).penmax.val {
        (*(*lgl).limits).elm.pen += 1;
        (*(*lgl).limits).elm.pen;
    }
    if success != 0 && (*(*lgl).limits).elm.del.cur != 0 {
        (*(*lgl).limits).elm.del.cur /= 2 as libc::c_int;
    }
    if success == 0 && (*(*lgl).limits).elm.del.cur < (*(*lgl).opts).delmax.val {
        (*(*lgl).limits).elm.del.cur += 1;
        (*(*lgl).limits).elm.del.cur;
    }
    (*(*lgl).limits).elm.del.rem = (*(*lgl).limits).elm.del.cur;
    lglrep(lgl, 2 as libc::c_int, 'e' as i32 as libc::c_char);
    (*lgl).occs = 0 as libc::c_int as libc::c_char;
    (*lgl).simp = (*lgl).occs;
    (*lgl).eliminating = (*lgl).simp;
    lglstop(lgl);
    return ((*lgl).mt == 0) as libc::c_int;
}
unsafe extern "C" fn lglsynceqs(mut lgl: *mut LGL) -> libc::c_int {
    let mut current_block: u64;
    let mut ereprs: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut emax: libc::c_int = (*lgl).maxext;
    let mut elit1: libc::c_int = 0;
    let mut erepr1: libc::c_int = 0;
    let mut elit2: libc::c_int = 0;
    let mut erepr2: libc::c_int = 0;
    let mut ilit1: libc::c_int = 0;
    let mut irepr1: libc::c_int = 0;
    let mut ilit2: libc::c_int = 0;
    let mut irepr2: libc::c_int = 0;
    let mut consumed: libc::c_int = 0 as libc::c_int;
    let mut produced: libc::c_int = 0 as libc::c_int;
    if (*lgl).nvars == 0 {
        return 1 as libc::c_int;
    }
    if ((*lgl).cbs).is_null() {
        return 1 as libc::c_int;
    }
    if ((*(*lgl).cbs).eqs.lock.fun).is_none() {
        return 1 as libc::c_int;
    }
    ereprs = ((*(*lgl).cbs).eqs.lock.fun)
        .expect("non-null function pointer")((*(*lgl).cbs).eqs.lock.state);
    consumed = 0 as libc::c_int;
    produced = consumed;
    elit1 = 1 as libc::c_int;
    loop {
        if !(elit1 <= emax) {
            current_block = 5330834795799507926;
            break;
        }
        if !(lglelitblockingoreliminated(lgl, elit1) != 0) {
            elit2 = lglptrjmp(ereprs, emax, elit1);
            if !(elit2 == elit1) {
                if !(lglelitblockingoreliminated(lgl, elit2) != 0) {
                    erepr1 = lglerepr(lgl, elit1);
                    if !(lglelitblockingoreliminated(lgl, erepr1) != 0) {
                        erepr2 = lglerepr(lgl, elit2);
                        if !(lglelitblockingoreliminated(lgl, erepr2) != 0) {
                            if !(erepr1 == erepr2) {
                                if erepr1 == -erepr2 {
                                    current_block = 18317007320854588510;
                                } else {
                                    ilit1 = lglimport(lgl, elit1);
                                    ilit2 = lglimport(lgl, elit2);
                                    if ilit1 == ilit2 {
                                        current_block = 13183875560443969876;
                                    } else if ilit1 == -ilit2 {
                                        current_block = 18317007320854588510;
                                    } else if abs(ilit1) <= 1 as libc::c_int {
                                        current_block = 13183875560443969876;
                                    } else if abs(ilit2) <= 1 as libc::c_int {
                                        current_block = 13183875560443969876;
                                    } else {
                                        irepr1 = lglirepr(lgl, ilit1);
                                        irepr2 = lglirepr(lgl, ilit2);
                                        if irepr1 == irepr2 {
                                            current_block = 13183875560443969876;
                                        } else if irepr1 == -irepr2 {
                                            current_block = 18317007320854588510;
                                        } else if abs(irepr1) <= 1 as libc::c_int {
                                            current_block = 13183875560443969876;
                                        } else if abs(irepr2) <= 1 as libc::c_int {
                                            current_block = 13183875560443969876;
                                        } else if lglisfree(lgl, irepr1) == 0 {
                                            current_block = 13183875560443969876;
                                        } else if lglisfree(lgl, irepr2) == 0 {
                                            current_block = 13183875560443969876;
                                        } else {
                                            consumed += 1;
                                            consumed;
                                            lglimerge(lgl, irepr1, irepr2);
                                            current_block = 13183875560443969876;
                                        }
                                    }
                                }
                                match current_block {
                                    13183875560443969876 => {}
                                    _ => {
                                        lglmt(lgl);
                                        current_block = 14771063396370343538;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        elit1 += 1;
        elit1;
    }
    match current_block {
        5330834795799507926 => {
            elit1 = 1 as libc::c_int;
            while elit1 <= emax {
                elit2 = lglerepr(lgl, elit1);
                if !(elit1 == elit2) {
                    erepr1 = lglptrjmp(ereprs, emax, elit1);
                    erepr2 = lglptrjmp(ereprs, emax, elit2);
                    if !(erepr1 == erepr2) {
                        produced += 1;
                        produced;
                        *ereprs
                            .offset(
                                abs(erepr1) as isize,
                            ) = if erepr1 < 0 as libc::c_int { -erepr2 } else { erepr2 };
                    }
                }
                elit1 += 1;
                elit1;
            }
        }
        _ => {}
    }
    if ((*(*lgl).cbs).eqs.unlock.fun).is_some() {
        ((*(*lgl).cbs).eqs.unlock.fun)
            .expect(
                "non-null function pointer",
            )((*(*lgl).cbs).eqs.unlock.state, consumed, produced);
    }
    return ((*lgl).mt == 0) as libc::c_int;
}
unsafe extern "C" fn lgldecomp(mut lgl: *mut LGL) -> libc::c_int {
    let mut res: libc::c_int = 1 as libc::c_int;
    let mut oldnvars: libc::c_int = (*lgl).nvars;
    let mut removed: libc::c_int = 0;
    lglstart(lgl, &mut (*(*lgl).times).decompose);
    (*(*lgl).stats).decomps += 1;
    (*(*lgl).stats).decomps;
    (*lgl).decomposing = 1 as libc::c_int as libc::c_char;
    (*lgl).simp += 1;
    (*lgl).simp;
    if (*lgl).level > 0 as libc::c_int {
        lglbacktrack(lgl, 0 as libc::c_int);
    }
    res = 0 as libc::c_int;
    lglgc(lgl);
    if !(lglsyncunits(lgl) == 0) {
        lglgc(lgl);
        if !((*lgl).mt != 0) {
            if !(lgltarjan(lgl) == 0) {
                if !(lglsynceqs(lgl) == 0) {
                    lglchkred(lgl);
                    lgldcpdis(lgl);
                    lgldcpcln(lgl);
                    lgldcpcon(lgl);
                    lglcompact(lgl);
                    lglmap(lgl);
                    if !((*lgl).mt != 0) {
                        if lglbcp(lgl) == 0 {
                            lglmt(lgl);
                        } else {
                            lglcount(lgl);
                            lglgc(lgl);
                            if !((*lgl).mt != 0) {
                                res = 1 as libc::c_int;
                            }
                        }
                    }
                }
            }
        }
    }
    if !((*lgl).repr).is_null() {
        lgldel(
            lgl,
            (*lgl).repr as *mut libc::c_void,
            ((*lgl).nvars as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
        );
        (*lgl).repr = 0 as *mut libc::c_int;
    }
    (*lgl).decomposing = 0 as libc::c_int as libc::c_char;
    (*lgl).simp -= 1;
    (*lgl).simp;
    removed = oldnvars - (*lgl).nvars;
    if removed != 0 {
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[decomp-%d] removed %d variables\0" as *const u8 as *const libc::c_char,
            (*(*lgl).stats).decomps,
            removed,
        );
    }
    lglrep(lgl, 2 as libc::c_int, 'd' as i32 as libc::c_char);
    lglstop(lgl);
    return res;
}
#[no_mangle]
pub unsafe extern "C" fn lglnvars(mut lgl: *mut LGL) -> libc::c_int {
    return lglrem(lgl);
}
#[no_mangle]
pub unsafe extern "C" fn lglnclauses(mut lgl: *mut LGL) -> libc::c_int {
    return (*(*lgl).stats).irr.clauses.cur;
}
unsafe extern "C" fn lgldstpull(mut lgl: *mut LGL, mut lit: libc::c_int) -> libc::c_int {
    let mut av: *mut AVar = 0 as *mut AVar;
    av = lglavar(lgl, lit);
    if (*av).mark != 0 {
        return 0 as libc::c_int;
    }
    if lglevel(lgl, lit) == 0 {
        return 0 as libc::c_int;
    }
    (*av).mark = 1 as libc::c_int;
    if lgldecision(lgl, lit) != 0 {
        lglpushstk(lgl, &mut (*lgl).clause, lit);
    } else {
        lglpushstk(lgl, &mut (*lgl).seen, -lit);
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn lglanalit(mut lgl: *mut LGL, mut lit: libc::c_int) -> libc::c_int {
    let mut r0: libc::c_int = 0;
    let mut r1: libc::c_int = 0;
    let mut antecedents: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut next: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut p: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut rsn: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut av: *mut AVar = 0 as *mut AVar;
    antecedents = 1 as libc::c_int;
    av = lglavar(lgl, lit);
    rsn = lglrsn(lgl, lit);
    r0 = *rsn.offset(0 as libc::c_int as isize);
    r1 = *rsn.offset(1 as libc::c_int as isize);
    lglpushstk(lgl, &mut (*lgl).clause, lit);
    (*av).mark = 1 as libc::c_int;
    next = 0 as libc::c_int;
    loop {
        tag = r0 & MASKCS as libc::c_int;
        if tag == BINCS as libc::c_int || tag == TRNCS as libc::c_int {
            other = r0 >> RMSHFT as libc::c_int;
            lgldstpull(lgl, other);
            if tag == TRNCS as libc::c_int {
                lgldstpull(lgl, r1);
            }
        } else if !(tag == UNITCS as libc::c_int) {
            if !(tag == DECISION as libc::c_int) {
                p = lglidx2lits(lgl, r0 & REDCS as libc::c_int, r1);
                loop {
                    other = *p;
                    if !(other != 0) {
                        break;
                    }
                    if other != lit {
                        lgldstpull(lgl, *p);
                    }
                    p = p.offset(1);
                    p;
                }
            }
        }
        if next == lglcntstk(&mut (*lgl).seen) as libc::c_int {
            break;
        }
        let fresh214 = next;
        next = next + 1;
        lit = lglpeek(&mut (*lgl).seen, fresh214);
        rsn = lglrsn(lgl, lit);
        r0 = *rsn.offset(0 as libc::c_int as isize);
        r1 = *rsn.offset(1 as libc::c_int as isize);
        antecedents += 1;
        antecedents;
    }
    lglpopnunmarkstk(lgl, &mut (*lgl).seen);
    return antecedents;
}
unsafe extern "C" fn lglfailedass(mut lgl: *mut LGL) -> libc::c_int {
    return ((*lgl).level == (*lgl).alevel && (*lgl).failed != 0) as libc::c_int;
}
unsafe extern "C" fn lglanafailed(mut lgl: *mut LGL) {
    let mut ilit: libc::c_int = 0;
    let mut elit: libc::c_int = 0;
    let mut erepr: libc::c_int = 0;
    let mut failed: libc::c_int = 0;
    let mut size: libc::c_int = 0;
    let mut bit: libc::c_uint = 0;
    let mut rbit: libc::c_uint = 0;
    let mut ibit: libc::c_uint = 0;
    let mut count: libc::c_uint = 0;
    let mut ext: *mut Ext = 0 as *mut Ext;
    let mut rext: *mut Ext = 0 as *mut Ext;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut av: *mut AVar = 0 as *mut AVar;
    if !((*lgl).mt != 0) {
        failed = (*lgl).failed;
        if failed == -(1 as libc::c_int) {
            elit = 0 as libc::c_int;
            p = (*lgl).eassume.start;
            while elit == 0 && p < (*lgl).eassume.top as *const libc::c_int {
                erepr = lglerepr(lgl, *p);
                if lglederef(lgl, erepr) < 0 as libc::c_int {
                    elit = *p;
                }
                p = p.offset(1);
                p;
            }
            ext = lglelit2ext(lgl, elit);
            bit = (1 as libc::c_uint) << (elit < 0 as libc::c_int) as libc::c_int;
            (*ext).set_failed((*ext).failed() | bit);
        } else {
            av = lglavar(lgl, failed);
            if (*av).assumed() as libc::c_int == 3 as libc::c_int {
                (*av).set_failed(3 as libc::c_int as libc::c_uint);
            } else {
                lglanalit(lgl, -failed);
                p = (*lgl).clause.start;
                while p < (*lgl).clause.top as *const libc::c_int {
                    ilit = *p;
                    av = lglavar(lgl, ilit);
                    bit = (1 as libc::c_uint)
                        << (ilit > 0 as libc::c_int) as libc::c_int;
                    (*av).set_failed((*av).failed() | bit);
                    p = p.offset(1);
                    p;
                }
                size = lglcntstk(&mut (*lgl).clause) as libc::c_int;
                lglpushstk(lgl, &mut (*lgl).clause, 0 as libc::c_int);
                lglprt(
                    lgl,
                    2 as libc::c_int,
                    b"[analyze-final] learned clause with size %d out of %d\0"
                        as *const u8 as *const libc::c_char,
                    size,
                    lglcntstk(&mut (*lgl).eassume),
                );
                lgldrupligaddcls(lgl, REDCS as libc::c_int);
                lgladdcls(lgl, REDCS as libc::c_int, size, 0 as libc::c_int);
                lglpopstk(&mut (*lgl).clause);
                lglpopnunmarkstk(lgl, &mut (*lgl).clause);
            }
            count = 0 as libc::c_int as libc::c_uint;
            p = (*lgl).eassume.start;
            while p < (*lgl).eassume.top as *const libc::c_int {
                elit = *p;
                bit = (1 as libc::c_uint) << (elit < 0 as libc::c_int) as libc::c_int;
                ext = lglelit2ext(lgl, elit);
                if !((*ext).failed() & bit != 0) {
                    if (*ext).equiv() != 0 {
                        erepr = (*ext).repr;
                        rbit = bit;
                        if erepr < 0 as libc::c_int {
                            rbit ^= 3 as libc::c_int as libc::c_uint;
                        }
                        if elit < 0 as libc::c_int {
                            erepr = -erepr;
                        }
                        rext = lglelit2ext(lgl, erepr);
                        if !((*rext).failed() & rbit != 0) {
                            ilit = (*rext).repr;
                            ibit = rbit;
                            if ilit < 0 as libc::c_int {
                                ilit = -ilit;
                                ibit ^= 3 as libc::c_int as libc::c_uint;
                            }
                            if !(ilit == 1 as libc::c_int) {
                                av = lglavar(lgl, ilit);
                                if !((*av).failed() & ibit == 0) {
                                    (*rext).set_failed((*rext).failed() | rbit);
                                    count = count.wrapping_add(1);
                                    count;
                                    if !((*rext).assumed() & rbit != 0) {
                                        (*ext).set_failed((*ext).failed() | bit);
                                    }
                                }
                            }
                        }
                    } else {
                        ilit = (*ext).repr;
                        ibit = bit;
                        if ilit < 0 as libc::c_int {
                            ilit = -ilit;
                            ibit ^= 3 as libc::c_int as libc::c_uint;
                        }
                        if !(ilit == 1 as libc::c_int) {
                            av = lglavar(lgl, ilit);
                            if !((*av).failed() & ibit == 0) {
                                (*ext).set_failed((*ext).failed() | bit);
                                count = count.wrapping_add(1);
                                count;
                            }
                        }
                    }
                }
                p = p.offset(1);
                p;
            }
        }
    }
    (*lgl).state = FAILED;
}
unsafe extern "C" fn lglternreslit(mut lgl: *mut LGL, mut lit: libc::c_int) {
    let mut pw: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut peow: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut nw: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut neow: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut p: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut n: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut pblit: libc::c_int = 0;
    let mut ptag: libc::c_int = 0;
    let mut pother: libc::c_int = 0;
    let mut pother2: libc::c_int = 0;
    let mut pdelta: libc::c_int = 0;
    let mut nblit: libc::c_int = 0;
    let mut ntag: libc::c_int = 0;
    let mut nother: libc::c_int = 0;
    let mut nother2: libc::c_int = 0;
    let mut ndelta: libc::c_int = 0;
    let mut phts: *mut HTS = 0 as *mut HTS;
    let mut nhts: *mut HTS = 0 as *mut HTS;
    let mut a: libc::c_int = 0;
    let mut b: libc::c_int = 0;
    let mut c: libc::c_int = 0;
    phts = lglhts(lgl, lit);
    pw = lglhts2wchs(lgl, phts);
    peow = pw.offset((*phts).count as isize);
    nhts = lglhts(lgl, -lit);
    nw = lglhts2wchs(lgl, nhts);
    neow = nw.offset((*nhts).count as isize);
    n = nw;
    while n < neow {
        (*(*lgl).stats).steps += 1;
        (*(*lgl).stats).steps;
        let fresh215 = (*(*lgl).stats).ternres.steps;
        (*(*lgl).stats).ternres.steps = (*(*lgl).stats).ternres.steps + 1;
        if fresh215 >= (*(*lgl).limits).ternres.steps {
            return;
        }
        nblit = *n;
        ntag = nblit & MASKCS as libc::c_int;
        if !(ntag == BINCS as libc::c_int || ntag == OCCS as libc::c_int) {
            if ntag == TRNCS as libc::c_int {
                break;
            }
            n = n.offset(1);
            n;
        }
        n = n.offset(1);
        n;
    }
    if n >= neow {
        return;
    }
    p = pw;
    while p < peow && (*(*lgl).stats).ternres.steps < (*(*lgl).limits).ternres.steps {
        (*(*lgl).stats).steps += 1;
        (*(*lgl).stats).steps;
        (*(*lgl).stats).ternres.steps += 1;
        (*(*lgl).stats).ternres.steps;
        pblit = *p;
        ptag = pblit & MASKCS as libc::c_int;
        if !(ptag == BINCS as libc::c_int || ptag == OCCS as libc::c_int) {
            if ptag == TRNCS as libc::c_int || ptag == LRGCS as libc::c_int {
                p = p.offset(1);
                p;
            }
            if !(ptag == LRGCS as libc::c_int) {
                pother = pblit >> RMSHFT as libc::c_int;
                if !(lglval(lgl, pother) != 0) {
                    pother2 = *p;
                    if !(lglval(lgl, pother2) != 0) {
                        let mut current_block_69: u64;
                        n = nw;
                        while n < neow
                            && (*(*lgl).stats).ternres.steps
                                < (*(*lgl).limits).ternres.steps
                        {
                            (*(*lgl).stats).steps += 1;
                            (*(*lgl).stats).steps;
                            (*(*lgl).stats).ternres.steps += 1;
                            (*(*lgl).stats).ternres.steps;
                            nblit = *n;
                            ntag = nblit & MASKCS as libc::c_int;
                            if !(ntag == BINCS as libc::c_int
                                || ntag == OCCS as libc::c_int)
                            {
                                if ntag == TRNCS as libc::c_int
                                    || ntag == LRGCS as libc::c_int
                                {
                                    n = n.offset(1);
                                    n;
                                }
                                if !(ntag == LRGCS as libc::c_int) {
                                    nother = nblit >> RMSHFT as libc::c_int;
                                    if !(lglval(lgl, nother) != 0) {
                                        nother2 = *n;
                                        if !(lglval(lgl, nother2) != 0) {
                                            if nother == pother && nother2 == pother2
                                                || nother == pother2 && nother2 == pother
                                            {
                                                a = nother;
                                                b = nother2;
                                                if lglhasbin(lgl, a, b) != 0 {
                                                    current_block_69 = 14818589718467733107;
                                                } else {
                                                    (*(*lgl).stats).ternres.bin += 1;
                                                    (*(*lgl).stats).ternres.bin;
                                                    lgldrupligaddclsarg(
                                                        lgl,
                                                        REDCS as libc::c_int,
                                                        a,
                                                        b,
                                                        0 as libc::c_int,
                                                    );
                                                    lglwchbin(lgl, a, b, REDCS as libc::c_int);
                                                    lglwchbin(lgl, b, a, REDCS as libc::c_int);
                                                    (*(*lgl).stats).red.bin += 1;
                                                    (*(*lgl).stats).red.bin;
                                                    lglwrktouch(lgl, a);
                                                    lglwrktouch(lgl, b);
                                                    current_block_69 = 1623252117315916725;
                                                }
                                            } else {
                                                a = nother;
                                                b = nother2;
                                                if nother == pother || nother2 == pother {
                                                    c = pother2;
                                                    current_block_69 = 11777552016271000781;
                                                } else if nother == pother2 || nother2 == pother2 {
                                                    c = pother;
                                                    current_block_69 = 11777552016271000781;
                                                } else {
                                                    current_block_69 = 14818589718467733107;
                                                }
                                                match current_block_69 {
                                                    14818589718467733107 => {}
                                                    _ => {
                                                        if a == -c || b == -c {
                                                            current_block_69 = 14818589718467733107;
                                                        } else if lglhastrn(lgl, a, b, c) != 0 {
                                                            current_block_69 = 14818589718467733107;
                                                        } else {
                                                            (*(*lgl).stats).ternres.trn += 1;
                                                            (*(*lgl).stats).ternres.trn;
                                                            lgldrupligaddclsarg(
                                                                lgl,
                                                                REDCS as libc::c_int,
                                                                a,
                                                                b,
                                                                c,
                                                                0 as libc::c_int,
                                                            );
                                                            lglwchtrn(lgl, a, b, c, REDCS as libc::c_int);
                                                            lglwchtrn(lgl, b, a, c, REDCS as libc::c_int);
                                                            lglwchtrn(lgl, c, a, b, REDCS as libc::c_int);
                                                            (*(*lgl).stats).red.trn += 1;
                                                            (*(*lgl).stats).red.trn;
                                                            lglwrktouch(lgl, a);
                                                            lglwrktouch(lgl, b);
                                                            lglwrktouch(lgl, c);
                                                            current_block_69 = 1623252117315916725;
                                                        }
                                                    }
                                                }
                                            }
                                            match current_block_69 {
                                                14818589718467733107 => {}
                                                _ => {
                                                    pdelta = p.offset_from(pw) as libc::c_long as libc::c_int;
                                                    phts = lglhts(lgl, lit);
                                                    pw = lglhts2wchs(lgl, phts);
                                                    peow = pw.offset((*phts).count as isize);
                                                    p = pw.offset(pdelta as isize);
                                                    ndelta = n.offset_from(nw) as libc::c_long as libc::c_int;
                                                    nhts = lglhts(lgl, -lit);
                                                    nw = lglhts2wchs(lgl, nhts);
                                                    neow = nw.offset((*nhts).count as isize);
                                                    n = nw.offset(ndelta as isize);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            n = n.offset(1);
                            n;
                        }
                    }
                }
            }
        }
        p = p.offset(1);
        p;
    }
}
unsafe extern "C" fn lglternresidx(mut lgl: *mut LGL, mut idx: libc::c_int) {
    lglternreslit(lgl, idx);
    lglternreslit(lgl, -idx);
}
unsafe extern "C" fn lglseternreslim(mut lgl: *mut LGL) {
    let mut limit: int64_t = 0;
    let mut irrlim: int64_t = 0;
    let mut pen: libc::c_int = 0;
    let mut szpen: libc::c_int = 0;
    if (*(*lgl).opts).ternresrtc.val != 0 {
        (*(*lgl).limits)
            .ternres
            .steps = 0x7fffffffffffffff as libc::c_longlong as int64_t;
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[ternres-%d] really no limit (run to completion)\0" as *const u8
                as *const libc::c_char,
            (*(*lgl).stats).ternres.count,
        );
    } else {
        limit = (*(*lgl).opts).trnreleff.val as int64_t * lglvisearch(lgl)
            / 1000 as libc::c_int as int64_t;
        if limit < (*(*lgl).opts).trnrmineff.val as int64_t {
            limit = (*(*lgl).opts).trnrmineff.val as int64_t;
        }
        if (*(*lgl).opts).trnrmaxeff.val >= 0 as libc::c_int
            && limit > (*(*lgl).opts).trnrmaxeff.val as int64_t
        {
            limit = (*(*lgl).opts).trnrmaxeff.val as int64_t;
        }
        if (*(*lgl).stats).ternres.count <= 1 as libc::c_int
            && (*(*lgl).opts).boost.val != 0
            && (*(*lgl).opts).ternresboost.val > 1 as libc::c_int
        {
            lglprt(
                lgl,
                1 as libc::c_int,
                b"[ternres-%d] boosting ternary resolution limit by %d\0" as *const u8
                    as *const libc::c_char,
                (*(*lgl).stats).ternres.count,
                (*(*lgl).opts).ternresboost.val,
            );
            limit *= (*(*lgl).opts).ternresboost.val as int64_t;
        }
        szpen = lglszpen(lgl);
        pen = (*(*lgl).limits).ternres.pen + szpen;
        limit >>= pen;
        irrlim = (4 as libc::c_int * (*(*lgl).stats).irr.clauses.cur >> szpen)
            as int64_t;
        if (*(*lgl).opts).irrlim.val != 0 && limit < irrlim {
            limit = irrlim;
            lglprt(
                lgl,
                1 as libc::c_int,
                b"[ternres-%d] limit %lld based on %d irredundant clauses penalty %d\0"
                    as *const u8 as *const libc::c_char,
                (*(*lgl).stats).ternres.count,
                limit as libc::c_longlong,
                (*(*lgl).stats).irr.clauses.cur,
                szpen,
            );
        } else {
            lglprt(
                lgl,
                1 as libc::c_int,
                b"[ternres-%d] limit %lld with penalty %d = %d + %d\0" as *const u8
                    as *const libc::c_char,
                (*(*lgl).stats).ternres.count,
                limit as libc::c_longlong,
                pen,
                (*(*lgl).limits).ternres.pen,
                szpen,
            );
        }
        (*(*lgl).limits).ternres.steps = (*(*lgl).stats).ternres.steps + limit;
    };
}
unsafe extern "C" fn lglprternresrem(mut lgl: *mut LGL) {
    let mut idx: libc::c_int = 0;
    let mut ret: libc::c_int = 0 as libc::c_int;
    let mut rem: libc::c_int = 0 as libc::c_int;
    let mut sum: libc::c_int = 0;
    idx = 2 as libc::c_int;
    while idx < (*lgl).nvars {
        if !(lglisfree(lgl, idx) == 0) {
            if (*lglavar(lgl, idx)).donoternres() != 0 {
                ret += 1;
                ret;
            } else {
                rem += 1;
                rem;
            }
        }
        idx += 1;
        idx;
    }
    if rem != 0 {
        sum = ret + rem;
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[ternres-%d] %d variables remain %.0f%% (%d retained %.0f%%)\0"
                as *const u8 as *const libc::c_char,
            (*(*lgl).stats).ternres.count,
            rem,
            lglpcnt(rem as libc::c_double, sum as libc::c_double),
            ret,
            lglpcnt(ret as libc::c_double, sum as libc::c_double),
        );
    } else {
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[ternres-%d] fully completed ternary resolution\0" as *const u8
                as *const libc::c_char,
            (*(*lgl).stats).ternres.count,
        );
        idx = 2 as libc::c_int;
        while idx < (*lgl).nvars {
            let ref mut fresh216 = *lglavar(lgl, idx);
            (*fresh216).set_donoternres(0 as libc::c_int as libc::c_uint);
            idx += 1;
            idx;
        }
    };
}
unsafe extern "C" fn lglternresinit(mut lgl: *mut LGL) {
    let mut idx: libc::c_int = 0;
    let mut schedulable: libc::c_int = 0 as libc::c_int;
    let mut donoternres: libc::c_int = 0 as libc::c_int;
    lglwrkinit(lgl, 1 as libc::c_int, 1 as libc::c_int);
    idx = 2 as libc::c_int;
    while idx < (*lgl).nvars {
        if !(lglisfree(lgl, idx) == 0) {
            if (*lglavar(lgl, idx)).donoternres() != 0 {
                donoternres += 1;
                donoternres;
            } else {
                schedulable += 1;
                schedulable;
            }
        }
        idx += 1;
        idx;
    }
    if schedulable == 0 {
        donoternres = 0 as libc::c_int;
        idx = 2 as libc::c_int;
        while idx < (*lgl).nvars {
            if !(lglisfree(lgl, idx) == 0) {
                let ref mut fresh217 = *lglavar(lgl, idx);
                (*fresh217).set_donoternres(0 as libc::c_int as libc::c_uint);
                schedulable += 1;
                schedulable;
            }
            idx += 1;
            idx;
        }
    }
    if donoternres == 0 {
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[ternres-%d] all %d free variables schedulable\0" as *const u8
                as *const libc::c_char,
            (*(*lgl).stats).ternres.count,
            schedulable,
        );
    } else {
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[ternres-%d] %d schedulable variables %.0f%%\0" as *const u8
                as *const libc::c_char,
            (*(*lgl).stats).ternres.count,
            schedulable,
            lglpcnt(
                schedulable as libc::c_double,
                ((*lgl).nvars - 2 as libc::c_int) as libc::c_double,
            ),
        );
    }
    (*lgl).donotsched = 1 as libc::c_int as libc::c_char;
    lglrandidxtrav(
        lgl,
        Some(lglwrktouch as unsafe extern "C" fn(*mut LGL, libc::c_int) -> libc::c_int),
    );
    (*lgl).donotsched = 0 as libc::c_int as libc::c_char;
}
unsafe extern "C" fn lglternres(mut lgl: *mut LGL) -> libc::c_int {
    let mut before: libc::c_int = 0;
    let mut after: libc::c_int = 0;
    let mut delta: libc::c_int = 0;
    let mut before2: libc::c_int = 0;
    let mut after2: libc::c_int = 0;
    let mut delta2: libc::c_int = 0;
    let mut before3: libc::c_int = 0;
    let mut after3: libc::c_int = 0;
    let mut delta3: libc::c_int = 0;
    let mut success: libc::c_int = 0;
    let mut lit: libc::c_int = 0;
    if (*lgl).nvars <= 2 as libc::c_int {
        return 1 as libc::c_int;
    }
    lglstart(lgl, &mut (*(*lgl).times).ternres);
    (*lgl).ternresing = 1 as libc::c_int as libc::c_char;
    (*lgl).simp = (*lgl).ternresing;
    (*(*lgl).stats).ternres.count += 1;
    (*(*lgl).stats).ternres.count;
    if (*lgl).level > 0 as libc::c_int {
        lglbacktrack(lgl, 0 as libc::c_int);
    }
    lglseternreslim(lgl);
    lglternresinit(lgl);
    before2 = (*(*lgl).stats).ternres.bin;
    before3 = (*(*lgl).stats).ternres.trn;
    while (*(*lgl).stats).ternres.steps < (*(*lgl).limits).ternres.steps {
        if lglterminate(lgl) != 0 {
            break;
        }
        if lglsyncunits(lgl) == 0 {
            break;
        }
        lit = lglwrknext(lgl);
        if lit == 0 {
            lglprt(
                lgl,
                2 as libc::c_int,
                b"[ternres-%d] saturated\0" as *const u8 as *const libc::c_char,
                (*(*lgl).stats).ternres.count,
            );
            break;
        } else {
            (*(*lgl).stats).steps += 1;
            (*(*lgl).stats).steps;
            (*(*lgl).stats).ternres.steps += 1;
            (*(*lgl).stats).ternres.steps;
            if lglisfree(lgl, lit) == 0 {
                continue;
            }
            let ref mut fresh218 = *lglavar(lgl, lit);
            (*fresh218).set_donoternres(1 as libc::c_int as libc::c_uint);
            lglternresidx(lgl, lit);
        }
    }
    after2 = (*(*lgl).stats).ternres.bin;
    after3 = (*(*lgl).stats).ternres.trn;
    after = after2 + after3;
    before = before2 + before3;
    delta2 = after2 - before2;
    delta3 = after3 - before3;
    delta = after - before;
    success = (before < after) as libc::c_int;
    lglprt(
        lgl,
        1 as libc::c_int,
        b"[ternres-%d] %d ternary resolvents (%d bin, %d trn)\0" as *const u8
            as *const libc::c_char,
        (*(*lgl).stats).ternres.count,
        delta,
        delta2,
        delta3,
    );
    if success != 0 && (*(*lgl).limits).ternres.pen != 0 {
        (*(*lgl).limits).ternres.pen -= 1;
        (*(*lgl).limits).ternres.pen;
    }
    if success == 0 && (*(*lgl).limits).ternres.pen < (*(*lgl).opts).penmax.val {
        (*(*lgl).limits).ternres.pen += 1;
        (*(*lgl).limits).ternres.pen;
    }
    if success != 0 && (*(*lgl).limits).ternres.del.cur != 0 {
        (*(*lgl).limits).ternres.del.cur /= 2 as libc::c_int;
    }
    if success == 0 && (*(*lgl).limits).ternres.del.cur < (*(*lgl).opts).delmax.val {
        (*(*lgl).limits).ternres.del.cur += 1;
        (*(*lgl).limits).ternres.del.cur;
    }
    (*(*lgl).limits).ternres.del.rem = (*(*lgl).limits).ternres.del.cur;
    (*lgl).ternresing = 0 as libc::c_int as libc::c_char;
    (*lgl).simp = (*lgl).ternresing;
    lglprternresrem(lgl);
    lglrep(lgl, 2 as libc::c_int, '3' as i32 as libc::c_char);
    lglwrkreset(lgl);
    lglstop(lgl);
    return ((*lgl).mt == 0) as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn lglcmposlidx(
    mut lgl: *mut LGL,
    mut lits: *mut libc::c_int,
    mut a: *mut POSLIDX,
    mut b: *mut POSLIDX,
) -> libc::c_int {
    let mut c: *const libc::c_int = lits.offset((*a).pos as isize);
    let mut d: *const libc::c_int = lits.offset((*b).pos as isize);
    let mut i: libc::c_int = 0;
    let mut l: libc::c_int = 0;
    let mut k: libc::c_int = 0;
    let mut p: libc::c_int = 0;
    let mut q: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < 4 as libc::c_int {
        l = *c.offset(i as isize);
        k = *d.offset(i as isize);
        p = abs(l);
        q = abs(k);
        if p < q {
            return -(1 as libc::c_int);
        }
        if p > q {
            return 1 as libc::c_int;
        }
        if l < k {
            return -(1 as libc::c_int);
        }
        if l > k {
            return 1 as libc::c_int;
        }
        i += 1;
        i;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn lglquatres1(
    mut lgl: *mut LGL,
    mut trnptr: *mut libc::c_int,
) -> libc::c_int {
    let mut mask: libc::c_int = 0;
    let mut size: libc::c_int = 0;
    let mut lidx: libc::c_int = 0;
    let mut count: libc::c_int = 0;
    let mut lrg: libc::c_int = 0;
    let mut total: libc::c_int = 0;
    let mut tlrg: libc::c_int = 0;
    let mut pos: libc::c_int = 0;
    let mut m: [libc::c_int; 4] = [0; 4];
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut k: libc::c_int = 0;
    let mut l: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    let mut glue: libc::c_int = 0;
    let mut maxglue: libc::c_int = lglscaleglue(lgl, 4 as libc::c_int);
    let mut pivot: libc::c_int = 0;
    let mut a: libc::c_int = 0;
    let mut b: libc::c_int = 0;
    let mut redi: libc::c_int = 0;
    let mut redj: libc::c_int = 0;
    let mut red: libc::c_int = 0;
    let mut assigned: libc::c_int = 0;
    let mut trn: libc::c_int = 0;
    let mut sub: libc::c_int = 0;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut c: *const libc::c_int = 0 as *const libc::c_int;
    let mut d: *const libc::c_int = 0 as *const libc::c_int;
    let mut pls: *mut POSLIDX = 0 as *mut POSLIDX;
    let mut lits: Stk = Stk {
        start: 0 as *mut libc::c_int,
        top: 0 as *mut libc::c_int,
        end: 0 as *mut libc::c_int,
    };
    let mut clauses: Stk = Stk {
        start: 0 as *mut libc::c_int,
        top: 0 as *mut libc::c_int,
        end: 0 as *mut libc::c_int,
    };
    let mut s: *mut Stk = 0 as *mut Stk;
    lglstart(lgl, &mut (*(*lgl).times).quatres1);
    memset(
        &mut lits as *mut Stk as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<Stk>() as libc::c_ulong,
    );
    memset(
        &mut clauses as *mut Stk as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<Stk>() as libc::c_ulong,
    );
    tlrg = 0 as libc::c_int;
    sub = tlrg;
    trn = sub;
    total = trn;
    glue = -(1 as libc::c_int);
    while glue <= maxglue {
        lrg = 0 as libc::c_int;
        count = lrg;
        if glue < 0 as libc::c_int {
            mask = ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int;
            s = &mut (*lgl).irr;
        } else {
            mask = glue;
            s = ((*lgl).red).offset(glue as isize);
        }
        c = (*s).start;
        while c < (*s).top as *const libc::c_int {
            if *c >= 2147483647 as libc::c_int {
                p = c;
            } else {
                if glue >= 0 as libc::c_int {
                    c = c.offset(1);
                    c;
                }
                assigned = 0 as libc::c_int;
                p = c;
                while *p != 0 {
                    if lglval(lgl, *p) != 0 {
                        assigned += 1;
                        assigned;
                    }
                    p = p.offset(1);
                    p;
                }
                if !(assigned != 0) {
                    size = p.offset_from(c) as libc::c_long as libc::c_int;
                    lrg += 1;
                    lrg;
                    if !(size > 4 as libc::c_int) {
                        lidx = c.offset_from((*s).start) as libc::c_long as libc::c_int;
                        lidx <<= 4 as libc::c_int;
                        lidx |= mask;
                        pos = lglcntstk(&mut lits) as libc::c_int;
                        lglpushstk(lgl, &mut clauses, pos);
                        lglpushstk(lgl, &mut clauses, lidx);
                        i = 0 as libc::c_int;
                        while i < 4 as libc::c_int {
                            m[i as usize] = *c.offset(i as isize);
                            i += 1;
                            i;
                        }
                        i = 0 as libc::c_int;
                        while i < 3 as libc::c_int {
                            j = i + 1 as libc::c_int;
                            while j < 4 as libc::c_int {
                                if abs(m[i as usize]) > abs(m[j as usize]) {
                                    let mut TMP: libc::c_int = m[i as usize];
                                    m[i as usize] = m[j as usize];
                                    m[j as usize] = TMP;
                                }
                                j += 1;
                                j;
                            }
                            i += 1;
                            i;
                        }
                        i = 0 as libc::c_int;
                        while i < 4 as libc::c_int {
                            lglpushstk(lgl, &mut lits, m[i as usize]);
                            i += 1;
                            i;
                        }
                        count += 1;
                        count;
                    }
                }
            }
            c = p.offset(1 as libc::c_int as isize);
        }
        if glue < 0 as libc::c_int {
            lglprt(
                lgl,
                2 as libc::c_int,
                b"[quatres-%d] found %d irredundant quaternary clauses %.0f%%\0"
                    as *const u8 as *const libc::c_char,
                (*(*lgl).stats).quatres.count,
                count,
                lglpcnt(count as libc::c_double, lrg as libc::c_double),
            );
        } else {
            lglprt(
                lgl,
                2 as libc::c_int,
                b"[quatres-%d] found %d glue %d quaternary clauses %.0f%%\0" as *const u8
                    as *const libc::c_char,
                (*(*lgl).stats).quatres.count,
                count,
                glue,
                lglpcnt(count as libc::c_double, lrg as libc::c_double),
            );
        }
        total += count;
        tlrg += lrg;
        glue += 1;
        glue;
    }
    lglfitstk(lgl, &mut lits);
    lglfitstk(lgl, &mut clauses);
    lglprt(
        lgl,
        1 as libc::c_int + (tlrg == 0) as libc::c_int,
        b"[quatres-%d] found %d quaternary clauses %.0f%% in total\0" as *const u8
            as *const libc::c_char,
        (*(*lgl).stats).quatres.count,
        total,
        lglpcnt(total as libc::c_double, tlrg as libc::c_double),
    );
    pls = clauses.start as *mut POSLIDX;
    let mut AA: *mut POSLIDX = pls;
    let NN: libc::c_int = total;
    let mut L: libc::c_int = 0 as libc::c_int;
    let mut R: libc::c_int = NN - 1 as libc::c_int;
    let mut M: libc::c_int = 0;
    let mut LL: libc::c_int = 0;
    let mut RR: libc::c_int = 0;
    let mut I: libc::c_int = 0;
    if !(R - L <= 10 as libc::c_int) {
        loop {
            M = (L + R) / 2 as libc::c_int;
            let mut TMP_0: POSLIDX = *AA.offset(M as isize);
            *AA.offset(M as isize) = *AA.offset((R - 1 as libc::c_int) as isize);
            *AA.offset((R - 1 as libc::c_int) as isize) = TMP_0;
            if lglcmposlidx(
                lgl,
                lits.start,
                &mut *AA.offset(L as isize),
                &mut *AA.offset((R - 1 as libc::c_int) as isize),
            ) > 0 as libc::c_int
            {
                let mut TMP_1: POSLIDX = *AA.offset(L as isize);
                *AA.offset(L as isize) = *AA.offset((R - 1 as libc::c_int) as isize);
                *AA.offset((R - 1 as libc::c_int) as isize) = TMP_1;
            }
            if lglcmposlidx(
                lgl,
                lits.start,
                &mut *AA.offset(L as isize),
                &mut *AA.offset(R as isize),
            ) > 0 as libc::c_int
            {
                let mut TMP_2: POSLIDX = *AA.offset(L as isize);
                *AA.offset(L as isize) = *AA.offset(R as isize);
                *AA.offset(R as isize) = TMP_2;
            }
            if lglcmposlidx(
                lgl,
                lits.start,
                &mut *AA.offset((R - 1 as libc::c_int) as isize),
                &mut *AA.offset(R as isize),
            ) > 0 as libc::c_int
            {
                let mut TMP_3: POSLIDX = *AA.offset((R - 1 as libc::c_int) as isize);
                *AA.offset((R - 1 as libc::c_int) as isize) = *AA.offset(R as isize);
                *AA.offset(R as isize) = TMP_3;
            }
            let mut PIVOT: POSLIDX = POSLIDX { pos: 0, lidx: 0 };
            let mut J: libc::c_int = R - 1 as libc::c_int;
            I = L + 1 as libc::c_int - 1 as libc::c_int;
            PIVOT = *AA.offset(J as isize);
            loop {
                loop {
                    I += 1;
                    if !(lglcmposlidx(
                        lgl,
                        lits.start,
                        &mut *AA.offset(I as isize),
                        &mut PIVOT,
                    ) < 0 as libc::c_int)
                    {
                        break;
                    }
                }
                loop {
                    J -= 1;
                    if !(lglcmposlidx(
                        lgl,
                        lits.start,
                        &mut PIVOT,
                        &mut *AA.offset(J as isize),
                    ) < 0 as libc::c_int)
                    {
                        break;
                    }
                    if J == L + 1 as libc::c_int {
                        break;
                    }
                }
                if I >= J {
                    break;
                }
                let mut TMP_4: POSLIDX = *AA.offset(I as isize);
                *AA.offset(I as isize) = *AA.offset(J as isize);
                *AA.offset(J as isize) = TMP_4;
            }
            let mut TMP_5: POSLIDX = *AA.offset(I as isize);
            *AA.offset(I as isize) = *AA.offset((R - 1 as libc::c_int) as isize);
            *AA.offset((R - 1 as libc::c_int) as isize) = TMP_5;
            if I - L < R - I {
                LL = I + 1 as libc::c_int;
                RR = R;
                R = I - 1 as libc::c_int;
            } else {
                LL = L;
                RR = I - 1 as libc::c_int;
                L = I + 1 as libc::c_int;
            }
            if R - L > 10 as libc::c_int {
                lglpushstk(lgl, &mut (*lgl).c2rust_unnamed_0.sortstk, LL);
                lglpushstk(lgl, &mut (*lgl).c2rust_unnamed_0.sortstk, RR);
            } else if RR - LL > 10 as libc::c_int {
                L = LL;
                R = RR;
            } else {
                if !(lglmtstk(&mut (*lgl).c2rust_unnamed_0.sortstk) == 0) {
                    break;
                }
                R = lglpopstk(&mut (*lgl).c2rust_unnamed_0.sortstk);
                L = lglpopstk(&mut (*lgl).c2rust_unnamed_0.sortstk);
            }
        }
    }
    let mut PIVOT_0: POSLIDX = POSLIDX { pos: 0, lidx: 0 };
    let mut L_0: libc::c_int = 0 as libc::c_int;
    let mut R_0: libc::c_int = NN - 1 as libc::c_int;
    let mut I_0: libc::c_int = 0;
    let mut J_0: libc::c_int = 0;
    I_0 = R_0;
    while I_0 > L_0 {
        if lglcmposlidx(
            lgl,
            lits.start,
            &mut *AA.offset((I_0 - 1 as libc::c_int) as isize),
            &mut *AA.offset(I_0 as isize),
        ) > 0 as libc::c_int
        {
            let mut TMP_6: POSLIDX = *AA.offset((I_0 - 1 as libc::c_int) as isize);
            *AA.offset((I_0 - 1 as libc::c_int) as isize) = *AA.offset(I_0 as isize);
            *AA.offset(I_0 as isize) = TMP_6;
        }
        I_0 -= 1;
        I_0;
    }
    I_0 = L_0 + 2 as libc::c_int;
    while I_0 <= R_0 {
        J_0 = I_0;
        PIVOT_0 = *AA.offset(I_0 as isize);
        while lglcmposlidx(
            lgl,
            lits.start,
            &mut PIVOT_0,
            &mut *AA.offset((J_0 - 1 as libc::c_int) as isize),
        ) < 0 as libc::c_int
        {
            *AA.offset(J_0 as isize) = *AA.offset((J_0 - 1 as libc::c_int) as isize);
            J_0 -= 1;
            J_0;
        }
        *AA.offset(J_0 as isize) = PIVOT_0;
        I_0 += 1;
        I_0;
    }
    i = 0 as libc::c_int;
    while i < total - 1 as libc::c_int {
        pos = (*pls.offset(i as isize)).pos;
        if !(pos < 0 as libc::c_int) {
            c = (lits.start).offset(pos as isize);
            j = i + 1 as libc::c_int;
            while j < total {
                if (*pls.offset(i as isize)).pos < 0 as libc::c_int {
                    break;
                }
                pos = (*pls.offset(j as isize)).pos;
                if pos < 0 as libc::c_int {
                    break;
                }
                d = (lits.start).offset(pos as isize);
                pivot = 0 as libc::c_int;
                k = 0 as libc::c_int;
                while k < 4 as libc::c_int {
                    a = *c.offset(k as isize);
                    b = *d.offset(k as isize);
                    if abs(a) != abs(b) {
                        break;
                    }
                    if !(a == b) {
                        if pivot != 0 {
                            break;
                        }
                        pivot = a;
                    }
                    k += 1;
                    k;
                }
                if k < 4 as libc::c_int {
                    break;
                }
                redi = if (*pls.offset(i as isize)).lidx
                    & ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int
                    == ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int
                {
                    0 as libc::c_int
                } else {
                    REDCS as libc::c_int
                };
                redj = if (*pls.offset(j as isize)).lidx
                    & ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int
                    == ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int
                {
                    0 as libc::c_int
                } else {
                    REDCS as libc::c_int
                };
                if pivot != 0 {
                    n = 0 as libc::c_int;
                    l = 0 as libc::c_int;
                    while l < 4 as libc::c_int {
                        if *c.offset(l as isize) != pivot {
                            let fresh219 = n;
                            n = n + 1;
                            m[fresh219 as usize] = *c.offset(l as isize);
                        }
                        l += 1;
                        l;
                    }
                    if !(lglhastrn(
                        lgl,
                        m[0 as libc::c_int as usize],
                        m[1 as libc::c_int as usize],
                        m[2 as libc::c_int as usize],
                    ) != 0)
                    {
                        red = redi & redj;
                        lgldrupligaddclsarg(
                            lgl,
                            REDCS as libc::c_int,
                            m[0 as libc::c_int as usize],
                            m[1 as libc::c_int as usize],
                            m[2 as libc::c_int as usize],
                            0 as libc::c_int,
                        );
                        lglwchtrn(
                            lgl,
                            m[0 as libc::c_int as usize],
                            m[1 as libc::c_int as usize],
                            m[2 as libc::c_int as usize],
                            red,
                        );
                        lglwchtrn(
                            lgl,
                            m[1 as libc::c_int as usize],
                            m[0 as libc::c_int as usize],
                            m[2 as libc::c_int as usize],
                            red,
                        );
                        lglwchtrn(
                            lgl,
                            m[2 as libc::c_int as usize],
                            m[0 as libc::c_int as usize],
                            m[1 as libc::c_int as usize],
                            red,
                        );
                        if red == 0 {
                            lglincirr(lgl, 3 as libc::c_int);
                        } else {
                            (*(*lgl).stats).red.trn += 1;
                            (*(*lgl).stats).red.trn;
                        }
                        (*(*lgl).stats).quatres.self2 += 1;
                        (*(*lgl).stats).quatres.self2;
                        *trnptr += 1 as libc::c_int;
                        trn += 1;
                        trn;
                        lgldrupligdelclsarg(
                            lgl,
                            *c.offset(0 as libc::c_int as isize),
                            *c.offset(1 as libc::c_int as isize),
                            *c.offset(2 as libc::c_int as isize),
                            *c.offset(3 as libc::c_int as isize),
                            0 as libc::c_int,
                        );
                        if redi != 0 {
                            lglrmlcls(
                                lgl,
                                (*pls.offset(i as isize)).lidx,
                                REDCS as libc::c_int,
                            );
                        } else {
                            lglrmlcls(
                                lgl,
                                (*pls.offset(i as isize)).lidx >> 4 as libc::c_int,
                                0 as libc::c_int,
                            );
                        }
                        lgldrupligdelclsarg(
                            lgl,
                            *d.offset(0 as libc::c_int as isize),
                            *d.offset(1 as libc::c_int as isize),
                            *d.offset(2 as libc::c_int as isize),
                            *d.offset(3 as libc::c_int as isize),
                            0 as libc::c_int,
                        );
                        if redj != 0 {
                            lglrmlcls(
                                lgl,
                                (*pls.offset(j as isize)).lidx,
                                REDCS as libc::c_int,
                            );
                        } else {
                            lglrmlcls(
                                lgl,
                                (*pls.offset(j as isize)).lidx >> 4 as libc::c_int,
                                0 as libc::c_int,
                            );
                        }
                        let ref mut fresh220 = (*pls.offset(j as isize)).pos;
                        *fresh220 = -(1 as libc::c_int);
                        (*pls.offset(i as isize)).pos = *fresh220;
                    }
                } else if redi != 0 {
                    (*(*lgl).stats).quatres.dup += 1;
                    (*(*lgl).stats).quatres.dup;
                    sub += 1;
                    sub;
                    lgldrupligdelclsarg(
                        lgl,
                        *c.offset(0 as libc::c_int as isize),
                        *c.offset(1 as libc::c_int as isize),
                        *c.offset(2 as libc::c_int as isize),
                        *c.offset(3 as libc::c_int as isize),
                        0 as libc::c_int,
                    );
                    lglrmlcls(lgl, (*pls.offset(i as isize)).lidx, REDCS as libc::c_int);
                    (*pls.offset(i as isize)).pos = -(1 as libc::c_int);
                } else if redj != 0 {
                    (*(*lgl).stats).quatres.dup += 1;
                    (*(*lgl).stats).quatres.dup;
                    lgldrupligdelclsarg(
                        lgl,
                        *d.offset(0 as libc::c_int as isize),
                        *d.offset(1 as libc::c_int as isize),
                        *d.offset(2 as libc::c_int as isize),
                        *d.offset(3 as libc::c_int as isize),
                        0 as libc::c_int,
                    );
                    lglrmlcls(lgl, (*pls.offset(j as isize)).lidx, REDCS as libc::c_int);
                    (*pls.offset(j as isize)).pos = -(1 as libc::c_int);
                } else {
                    (*(*lgl).stats).quatres.dup += 1;
                    (*(*lgl).stats).quatres.dup;
                    lgldrupligdelclsarg(
                        lgl,
                        *d.offset(0 as libc::c_int as isize),
                        *d.offset(1 as libc::c_int as isize),
                        *d.offset(2 as libc::c_int as isize),
                        *d.offset(3 as libc::c_int as isize),
                        0 as libc::c_int,
                    );
                    lglrmlcls(
                        lgl,
                        (*pls.offset(j as isize)).lidx >> 4 as libc::c_int,
                        0 as libc::c_int,
                    );
                    (*pls.offset(j as isize)).pos = -(1 as libc::c_int);
                }
                j += 1;
                j;
            }
        }
        i += 1;
        i;
    }
    lglrelstk(lgl, &mut lits);
    lglrelstk(lgl, &mut clauses);
    lglprt(
        lgl,
        1 as libc::c_int + (sub == 0) as libc::c_int,
        b"[quatres-%d-1] removed %d duplicate quaternary clauses\0" as *const u8
            as *const libc::c_char,
        (*(*lgl).stats).quatres.count,
        sub,
    );
    lglprt(
        lgl,
        1 as libc::c_int + (trn == 0) as libc::c_int,
        b"[quatres-%d-1] added %d double-self-subsuming ternary resolvents\0"
            as *const u8 as *const libc::c_char,
        (*(*lgl).stats).quatres.count,
        trn,
    );
    lglstop(lgl);
    return tlrg;
}
unsafe extern "C" fn lglhasquad(mut lgl: *mut LGL) -> libc::c_int {
    let mut blit: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut red: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut other2: libc::c_int = 0;
    let mut lidx: libc::c_int = 0;
    let mut glue: libc::c_int = 0;
    let mut count: libc::c_int = 0;
    let mut lit: libc::c_int = 0;
    let mut other3: libc::c_int = 0;
    let mut val: libc::c_int = 0;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut w: *const libc::c_int = 0 as *const libc::c_int;
    let mut eow: *const libc::c_int = 0 as *const libc::c_int;
    let mut q: *const libc::c_int = 0 as *const libc::c_int;
    let mut c: *const libc::c_int = 0 as *const libc::c_int;
    let mut d: *const libc::c_int = 0 as *const libc::c_int;
    let mut r: *const libc::c_int = 0 as *const libc::c_int;
    let mut l: *const libc::c_int = 0 as *const libc::c_int;
    let mut maxglue: libc::c_int = lglscaleglue(lgl, 4 as libc::c_int);
    let mut maxcount: libc::c_int = 0;
    let mut tmpcount: libc::c_int = 0;
    let mut maxlit: libc::c_int = 0;
    let mut hts: *mut HTS = 0 as *mut HTS;
    maxcount = -(1 as libc::c_int);
    maxlit = 0 as libc::c_int;
    c = (*lgl).clause.start;
    p = c;
    loop {
        lit = *p;
        if !(lit != 0) {
            break;
        }
        tmpcount = (*lglhts(lgl, lit)).count as libc::c_int;
        if !(tmpcount <= maxcount) {
            maxcount = tmpcount;
            maxlit = lit;
        }
        p = p.offset(1);
        p;
    }
    p = c;
    loop {
        lit = *p;
        if !(lit != 0) {
            break;
        }
        if !(lit == maxlit) {
            hts = lglhts(lgl, lit);
            w = lglhts2wchs(lgl, hts);
            eow = w.offset((*hts).count as isize);
            let mut current_block_49: u64;
            q = w;
            while q < eow {
                blit = *q;
                tag = blit & MASKCS as libc::c_int;
                if tag == BINCS as libc::c_int {
                    other = blit >> RMSHFT as libc::c_int;
                    r = c;
                    loop {
                        other3 = *r;
                        if !(other3 != 0) {
                            break;
                        }
                        if other3 == other {
                            return 1 as libc::c_int;
                        }
                        r = r.offset(1);
                        r;
                    }
                } else if tag == TRNCS as libc::c_int {
                    other = blit >> RMSHFT as libc::c_int;
                    q = q.offset(1);
                    other2 = *q;
                    count = 0 as libc::c_int;
                    r = c;
                    loop {
                        other3 = *r;
                        if !(other3 != 0) {
                            break;
                        }
                        if other3 == other {
                            count += 1;
                            if count == 2 as libc::c_int {
                                return 1 as libc::c_int;
                            }
                        } else if other3 == other2 {
                            count += 1;
                            if count == 2 as libc::c_int {
                                return 1 as libc::c_int;
                            }
                        }
                        r = r.offset(1);
                        r;
                    }
                } else {
                    red = blit & REDCS as libc::c_int;
                    q = q.offset(1);
                    lidx = *q;
                    if red != 0 {
                        glue = lidx
                            & ((1 as libc::c_int) << 4 as libc::c_int)
                                - 1 as libc::c_int;
                        if glue > maxglue {
                            current_block_49 = 10048703153582371463;
                        } else {
                            current_block_49 = 6450597802325118133;
                        }
                    } else {
                        current_block_49 = 6450597802325118133;
                    }
                    match current_block_49 {
                        10048703153582371463 => {}
                        _ => {
                            d = lglidx2lits(lgl, red, lidx);
                            count = 0 as libc::c_int;
                            l = d;
                            loop {
                                other = *l;
                                if !(other != 0) {
                                    break;
                                }
                                val = lglval(lgl, other) as libc::c_int;
                                if val > 0 as libc::c_int {
                                    break;
                                }
                                if !(val < 0 as libc::c_int) {
                                    if count >= 4 as libc::c_int {
                                        break;
                                    }
                                    r = c;
                                    loop {
                                        other3 = *r;
                                        if !(other3 != 0) {
                                            break;
                                        }
                                        if other3 == other {
                                            break;
                                        }
                                        r = r.offset(1);
                                        r;
                                    }
                                    if other3 == 0 {
                                        break;
                                    }
                                    count += 1;
                                    count;
                                }
                                l = l.offset(1);
                                l;
                            }
                            if other == 0 {
                                return 1 as libc::c_int;
                            }
                        }
                    }
                }
                q = q.offset(1);
                q;
            }
        }
        p = p.offset(1);
        p;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn lglquatres2(
    mut lgl: *mut LGL,
    mut trnptr: *mut libc::c_int,
    mut quadptr: *mut libc::c_int,
) {
    let mut lit: libc::c_int = 0;
    let mut sign: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut blit: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut red: libc::c_int = 0;
    let mut lidx: libc::c_int = 0;
    let mut trn: libc::c_int = 0;
    let mut quat: libc::c_int = 0;
    let mut glue: libc::c_int = 0;
    let mut glue2: libc::c_int = 0;
    let mut count: libc::c_int = 0;
    let mut pos: libc::c_int = 0;
    let mut neg: libc::c_int = 0;
    let mut extra: libc::c_int = 0;
    let mut pivot: libc::c_int = 0;
    let mut other2: libc::c_int = 0;
    let mut other3: libc::c_int = 0;
    let mut rednew: libc::c_int = 0;
    let mut start: *const libc::c_int = 0 as *const libc::c_int;
    let mut c: *const libc::c_int = 0 as *const libc::c_int;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut w: *const libc::c_int = 0 as *const libc::c_int;
    let mut eow: *const libc::c_int = 0 as *const libc::c_int;
    let mut q: *const libc::c_int = 0 as *const libc::c_int;
    let mut d: *const libc::c_int = 0 as *const libc::c_int;
    let mut l: *const libc::c_int = 0 as *const libc::c_int;
    let mut maxcheck: libc::c_int = (*(*lgl).stats).quatres.count;
    let mut check: libc::c_int = 0;
    let mut maxglue: libc::c_int = lglscaleglue(lgl, 4 as libc::c_int);
    let mut val: libc::c_int = 0;
    let mut delta: ptrdiff_t = 0;
    let mut hts: *mut HTS = 0 as *mut HTS;
    let mut s: *mut Stk = 0 as *mut Stk;
    lglstart(lgl, &mut (*(*lgl).times).quatres2);
    quat = 0 as libc::c_int;
    trn = quat;
    glue = -(1 as libc::c_int);
    while glue <= maxglue {
        s = if glue < 0 as libc::c_int {
            &mut (*lgl).irr
        } else {
            ((*lgl).red).offset(glue as isize)
        };
        let mut current_block_143: u64;
        start = (*s).start;
        c = start;
        while c < (*s).top as *const libc::c_int {
            if *c >= 2147483647 as libc::c_int {
                p = c;
            } else {
                if glue >= 0 as libc::c_int {
                    c = c.offset(1);
                    c;
                }
                count = 0 as libc::c_int;
                p = c;
                loop {
                    lit = *p;
                    if !(lit != 0) {
                        break;
                    }
                    val = lglval(lgl, lit) as libc::c_int;
                    if !(val < 0 as libc::c_int) {
                        if val > 0 as libc::c_int {
                            break;
                        }
                        count += 1;
                        if count > 4 as libc::c_int {
                            break;
                        }
                    }
                    p = p.offset(1);
                    p;
                }
                if lit != 0 {
                    loop {
                        p = p.offset(1);
                        if !(*p != 0) {
                            break;
                        }
                    }
                } else if !(count < 4 as libc::c_int) {
                    p = c;
                    loop {
                        lit = *p;
                        if !(lit != 0) {
                            break;
                        }
                        if lglval(lgl, lit) == 0 {
                            lglmark(lgl, lit);
                        }
                        p = p.offset(1);
                        p;
                    }
                    p = c;
                    's_147: loop {
                        lit = *p;
                        if !(lit != 0) {
                            current_block_143 = 5388205036907793036;
                            break;
                        }
                        if !(lglval(lgl, lit) != 0) {
                            sign = -(1 as libc::c_int);
                            while sign <= 1 as libc::c_int {
                                hts = lglhts(lgl, sign * lit);
                                w = lglhts2wchs(lgl, hts);
                                eow = w.offset((*hts).count as isize);
                                check = 0 as libc::c_int;
                                q = w;
                                while check < maxcheck && q < eow {
                                    blit = *q;
                                    tag = blit & MASKCS as libc::c_int;
                                    red = blit & REDCS as libc::c_int;
                                    if tag == TRNCS as libc::c_int
                                        || tag == LRGCS as libc::c_int
                                    {
                                        q = q.offset(1);
                                        q;
                                    }
                                    if maxglue
                                        < ((1 as libc::c_int) << 4 as libc::c_int)
                                            - 1 as libc::c_int && tag == LRGCS as libc::c_int
                                    {
                                        lidx = *q;
                                        if red != 0 {
                                            glue2 = lidx
                                                & ((1 as libc::c_int) << 4 as libc::c_int)
                                                    - 1 as libc::c_int;
                                            if glue2 > maxglue {
                                                current_block_143 = 6450636197030046351;
                                            } else {
                                                current_block_143 = 2122094917359643297;
                                            }
                                        } else {
                                            glue2 = -(1 as libc::c_int);
                                            current_block_143 = 2122094917359643297;
                                        }
                                        match current_block_143 {
                                            6450636197030046351 => {}
                                            _ => {
                                                if !(glue2 < glue) {
                                                    d = lglidx2lits(lgl, red, lidx);
                                                    if !(d == c) {
                                                        if !(glue2 == glue && d < c) {
                                                            check += 1;
                                                            check;
                                                            pivot = 0 as libc::c_int;
                                                            extra = pivot;
                                                            neg = extra;
                                                            pos = neg;
                                                            count = pos;
                                                            l = d;
                                                            loop {
                                                                other = *l;
                                                                if !(other != 0) {
                                                                    break;
                                                                }
                                                                val = lglval(lgl, other) as libc::c_int;
                                                                if !(val < 0 as libc::c_int) {
                                                                    if val > 0 as libc::c_int {
                                                                        break;
                                                                    }
                                                                    val = lglmarked(lgl, other);
                                                                    if val < 0 as libc::c_int {
                                                                        let fresh221 = neg;
                                                                        neg = neg + 1;
                                                                        if fresh221 != 0 {
                                                                            break;
                                                                        }
                                                                        pivot = other;
                                                                    } else if val > 0 as libc::c_int {
                                                                        pos += 1;
                                                                        if pos > 2 as libc::c_int {
                                                                            break;
                                                                        }
                                                                    } else {
                                                                        let fresh222 = count;
                                                                        count = count + 1;
                                                                        if fresh222 != 0 {
                                                                            break;
                                                                        }
                                                                        extra = other;
                                                                    }
                                                                }
                                                                l = l.offset(1);
                                                                l;
                                                            }
                                                            if !(other != 0) {
                                                                if !(neg != 1 as libc::c_int || pos != 2 as libc::c_int
                                                                    || count != 1 as libc::c_int)
                                                                {
                                                                    l = c;
                                                                    loop {
                                                                        other = *l;
                                                                        if !(other != 0) {
                                                                            break;
                                                                        }
                                                                        if !(lglval(lgl, other) != 0) {
                                                                            if !(other == pivot) {
                                                                                if !(other == -pivot) {
                                                                                    lglpushstk(lgl, &mut (*lgl).clause, other);
                                                                                }
                                                                            }
                                                                        }
                                                                        l = l.offset(1);
                                                                        l;
                                                                    }
                                                                    lglpushstk(lgl, &mut (*lgl).clause, extra);
                                                                    lglpushstk(lgl, &mut (*lgl).clause, 0 as libc::c_int);
                                                                    if lglhasquad(lgl) == 0 {
                                                                        lgldrupligaddcls(lgl, REDCS as libc::c_int);
                                                                        lgladdcls(
                                                                            lgl,
                                                                            REDCS as libc::c_int,
                                                                            4 as libc::c_int,
                                                                            0 as libc::c_int,
                                                                        );
                                                                        delta = ((*s).start).offset_from(start) as libc::c_long;
                                                                        if delta != 0 {
                                                                            c = c.offset(delta as isize);
                                                                            p = p.offset(delta as isize);
                                                                            start = (*s).start;
                                                                        }
                                                                        hts = lglhts(lgl, sign * lit);
                                                                        delta = (lglhts2wchs(lgl, hts)).offset_from(w)
                                                                            as libc::c_long;
                                                                        if delta != 0 {
                                                                            w = w.offset(delta as isize);
                                                                            q = q.offset(delta as isize);
                                                                        }
                                                                        if w.offset((*hts).count as isize) != eow {
                                                                            eow = w.offset((*hts).count as isize);
                                                                        }
                                                                        (*(*lgl).stats).quatres.quat += 1;
                                                                        (*(*lgl).stats).quatres.quat;
                                                                        *quadptr += 1 as libc::c_int;
                                                                        quat += 1;
                                                                        quat;
                                                                    }
                                                                    lglclnstk(&mut (*lgl).clause);
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    } else if tag == TRNCS as libc::c_int {
                                        if !(sign > 0 as libc::c_int) {
                                            other = blit >> RMSHFT as libc::c_int;
                                            if !(lglval(lgl, other) != 0) {
                                                if !(lglmarked(lgl, other) <= 0 as libc::c_int) {
                                                    other2 = *q;
                                                    if !(lglval(lgl, other2) != 0) {
                                                        if !(lglmarked(lgl, other2) <= 0 as libc::c_int) {
                                                            extra = 0 as libc::c_int;
                                                            l = c;
                                                            while extra == 0 {
                                                                other3 = *l;
                                                                if !(other3 == lit) {
                                                                    if !(other3 == other) {
                                                                        if !(other3 == other2) {
                                                                            val = lglval(lgl, other3) as libc::c_int;
                                                                            if !(val != 0) {
                                                                                extra = other3;
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                                l = l.offset(1);
                                                                l;
                                                            }
                                                            rednew = if glue >= 0 as libc::c_int {
                                                                REDCS as libc::c_int
                                                            } else {
                                                                0 as libc::c_int
                                                            };
                                                            lgldrupligaddclsarg(
                                                                lgl,
                                                                REDCS as libc::c_int,
                                                                other,
                                                                other2,
                                                                extra,
                                                                0 as libc::c_int,
                                                            );
                                                            lglwchtrn(lgl, other, other2, extra, rednew);
                                                            lglwchtrn(lgl, other2, other, extra, rednew);
                                                            lglwchtrn(lgl, extra, other, other2, rednew);
                                                            if rednew == 0 {
                                                                lglincirr(lgl, 3 as libc::c_int);
                                                            } else {
                                                                (*(*lgl).stats).red.trn += 1;
                                                                (*(*lgl).stats).red.trn;
                                                            }
                                                            (*(*lgl).stats).quatres.self1 += 1;
                                                            (*(*lgl).stats).quatres.self1;
                                                            *trnptr += 1 as libc::c_int;
                                                            trn += 1;
                                                            trn;
                                                            p = c;
                                                            loop {
                                                                other3 = *p;
                                                                if !(other3 != 0) {
                                                                    break;
                                                                }
                                                                if lglval(lgl, other3) == 0 {
                                                                    lglunmark(lgl, other3);
                                                                }
                                                                p = p.offset(1);
                                                                p;
                                                            }
                                                            lidx = c.offset_from(start) as libc::c_long as libc::c_int;
                                                            if rednew != 0 {
                                                                lidx <<= 4 as libc::c_int;
                                                                lidx |= glue;
                                                            }
                                                            lgldrupligdelclsaux(lgl, c);
                                                            lglrmlcls(lgl, lidx, rednew);
                                                            current_block_143 = 8515828400728868193;
                                                            break 's_147;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    q = q.offset(1);
                                    q;
                                }
                                sign += 2 as libc::c_int;
                            }
                        }
                        p = p.offset(1);
                        p;
                    }
                    match current_block_143 {
                        8515828400728868193 => {}
                        _ => {
                            p = c;
                            loop {
                                lit = *p;
                                if !(lit != 0) {
                                    break;
                                }
                                if lglval(lgl, lit) == 0 {
                                    lglunmark(lgl, lit);
                                }
                                p = p.offset(1);
                                p;
                            }
                        }
                    }
                }
            }
            c = p.offset(1 as libc::c_int as isize);
        }
        glue += 1;
        glue;
    }
    lglprt(
        lgl,
        1 as libc::c_int + (trn == 0) as libc::c_int,
        b"[quatres-%d-2] added %d single-self-subsuming ternary resolvents\0"
            as *const u8 as *const libc::c_char,
        (*(*lgl).stats).quatres.count,
        trn,
    );
    lglprt(
        lgl,
        1 as libc::c_int + (quat == 0) as libc::c_int,
        b"[quatres-%d-2] added %d quaternary resolvents\0" as *const u8
            as *const libc::c_char,
        (*(*lgl).stats).quatres.count,
        quat,
    );
    lglstop(lgl);
}
unsafe extern "C" fn lglquatres(mut lgl: *mut LGL) {
    let mut trn: libc::c_int = 0;
    let mut quad: libc::c_int = 0;
    lglstart(lgl, &mut (*(*lgl).times).quatres);
    if (*lgl).level != 0 {
        lglbacktrack(lgl, 0 as libc::c_int);
    }
    (*lgl).notrim = 1 as libc::c_int as libc::c_char;
    (*lgl).quatres = (*lgl).notrim;
    (*lgl).simp = (*lgl).quatres;
    (*(*lgl).stats).quatres.count += 1;
    (*(*lgl).stats).quatres.count;
    quad = 0 as libc::c_int;
    trn = quad;
    if lglquatres1(lgl, &mut trn) != 0 {
        lglquatres2(lgl, &mut trn, &mut quad);
    }
    if trn + quad != 0 && (*(*lgl).limits).quatres.pen != 0 {
        (*(*lgl).limits).quatres.pen -= 1;
        (*(*lgl).limits).quatres.pen;
    }
    if trn + quad == 0 && (*(*lgl).limits).quatres.pen < (*(*lgl).opts).penmax.val {
        (*(*lgl).limits).quatres.pen += 1;
        (*(*lgl).limits).quatres.pen;
    }
    if trn + quad != 0 && (*(*lgl).limits).quatres.del.cur != 0 {
        (*(*lgl).limits).quatres.del.cur /= 2 as libc::c_int;
    }
    if trn + quad == 0 && (*(*lgl).limits).quatres.del.cur < (*(*lgl).opts).delmax.val {
        (*(*lgl).limits).quatres.del.cur += 1;
        (*(*lgl).limits).quatres.del.cur;
    }
    (*(*lgl).limits).quatres.del.rem = (*(*lgl).limits).quatres.del.cur;
    (*lgl).notrim = 0 as libc::c_int as libc::c_char;
    (*lgl).quatres = (*lgl).notrim;
    (*lgl).simp = (*lgl).quatres;
    lglrep(lgl, 2 as libc::c_int, '4' as i32 as libc::c_char);
    lglstop(lgl);
}
unsafe extern "C" fn lgltrdbin(
    mut lgl: *mut LGL,
    mut start: libc::c_int,
    mut target: libc::c_int,
    mut irr: libc::c_int,
) -> libc::c_int {
    let mut lit: libc::c_int = 0;
    let mut next: libc::c_int = 0;
    let mut blit: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut red: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut p: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut w: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut eow: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut res: libc::c_int = 0;
    let mut ign: libc::c_int = 0;
    let mut val: libc::c_int = 0;
    let mut hts: *mut HTS = 0 as *mut HTS;
    (*(*lgl).stats).trd.bins += 1;
    (*(*lgl).stats).trd.bins;
    lglpushnmarkseen(lgl, -start);
    next = 0 as libc::c_int;
    res = 0 as libc::c_int;
    ign = 1 as libc::c_int;
    's_36: while next < lglcntstk(&mut (*lgl).seen) as libc::c_int {
        let fresh223 = next;
        next = next + 1;
        lit = lglpeek(&mut (*lgl).seen, fresh223);
        (*(*lgl).stats).steps += 1;
        (*(*lgl).stats).steps;
        (*(*lgl).stats).trd.steps += 1;
        (*(*lgl).stats).trd.steps;
        val = lglval(lgl, lit) as libc::c_int;
        if val != 0 {
            continue;
        }
        hts = lglhts(lgl, -lit);
        if (*hts).count == 0 {
            continue;
        }
        w = lglhts2wchs(lgl, hts);
        eow = w.offset((*hts).count as isize);
        p = w;
        while p < eow {
            blit = *p;
            tag = blit & MASKCS as libc::c_int;
            if tag == LRGCS as libc::c_int || tag == TRNCS as libc::c_int {
                p = p.offset(1);
                p;
            }
            if !(tag != BINCS as libc::c_int) {
                red = blit & REDCS as libc::c_int;
                if !(irr != 0 && red != 0) {
                    other = blit >> RMSHFT as libc::c_int;
                    if !(other == start) {
                        if other == target {
                            if lit == -start && ign != 0 {
                                ign = 0 as libc::c_int;
                            } else {
                                res = 1 as libc::c_int;
                                break 's_36;
                            }
                        } else {
                            val = lglmarked(lgl, other);
                            if !(val > 0 as libc::c_int) {
                                if val < 0 as libc::c_int {
                                    (*(*lgl).stats).trd.failed += 1;
                                    (*(*lgl).stats).trd.failed;
                                    lglunit(lgl, start);
                                    val = lglbcp(lgl);
                                    if val == 0 && (*lgl).mt == 0 {
                                        lglmt(lgl);
                                    }
                                    res = -(1 as libc::c_int);
                                    break 's_36;
                                } else {
                                    lglpushnmarkseen(lgl, other);
                                }
                            }
                        }
                    }
                }
            }
            p = p.offset(1);
            p;
        }
    }
    lglpopnunmarkstk(lgl, &mut (*lgl).seen);
    return res;
}
unsafe extern "C" fn lgltrdlit(mut lgl: *mut LGL, mut start: libc::c_int) {
    let mut target: libc::c_int = 0;
    let mut w: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut p: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut eow: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut blit: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut red: libc::c_int = 0;
    let mut val: libc::c_int = 0;
    let mut hts: *mut HTS = 0 as *mut HTS;
    val = lglval(lgl, start) as libc::c_int;
    if val != 0 {
        return;
    }
    hts = lglhts(lgl, start);
    if (*hts).count == 0 {
        return;
    }
    (*(*lgl).stats).trd.lits += 1;
    (*(*lgl).stats).trd.lits;
    w = lglhts2wchs(lgl, hts);
    eow = w.offset((*hts).count as isize);
    p = w;
    while p < eow && (*(*lgl).stats).trd.steps < (*(*lgl).limits).trd.steps {
        blit = *p;
        tag = blit & MASKCS as libc::c_int;
        if tag == TRNCS as libc::c_int || tag == LRGCS as libc::c_int {
            p = p.offset(1);
            p;
        }
        if !(tag != BINCS as libc::c_int) {
            target = blit >> RMSHFT as libc::c_int;
            if !(abs(start) > abs(target)) {
                red = blit & REDCS as libc::c_int;
                val = lgltrdbin(lgl, start, target, red ^ REDCS as libc::c_int);
                if !(val == 0) {
                    if val < 0 as libc::c_int {
                        break;
                    }
                    (*(*lgl).stats).trd.red += 1;
                    (*(*lgl).stats).trd.red;
                    (*(*lgl).stats).prgss += 1;
                    (*(*lgl).stats).prgss;
                    lgldrupligdelclsarg(lgl, start, target, 0 as libc::c_int);
                    lglrmbwch(lgl, start, target, red);
                    lglrmbwch(lgl, target, start, red);
                    if red != 0 {
                        (*(*lgl).stats).red.bin -= 1;
                        (*(*lgl).stats).red.bin;
                    } else {
                        lgldecirr(lgl, 2 as libc::c_int);
                    }
                    break;
                }
            }
        }
        p = p.offset(1);
        p;
    }
}
unsafe extern "C" fn lglsetrdlim(mut lgl: *mut LGL) {
    let mut limit: int64_t = 0;
    let mut irrlim: int64_t = 0;
    let mut pen: libc::c_int = 0;
    let mut szpen: libc::c_int = 0;
    limit = (*(*lgl).opts).trdreleff.val as int64_t * lglvisearch(lgl)
        / 1000 as libc::c_int as int64_t;
    if limit < (*(*lgl).opts).trdmineff.val as int64_t {
        limit = (*(*lgl).opts).trdmineff.val as int64_t;
    }
    if (*(*lgl).opts).trdmaxeff.val >= 0 as libc::c_int
        && limit > (*(*lgl).opts).trdmaxeff.val as int64_t
    {
        limit = (*(*lgl).opts).trdmaxeff.val as int64_t;
    }
    szpen = lglszpen(lgl);
    pen = (*(*lgl).limits).trd.pen + szpen;
    limit >>= pen;
    irrlim = ((*(*lgl).stats).irr.clauses.cur >> szpen) as int64_t;
    if (*(*lgl).opts).irrlim.val != 0 && limit < irrlim {
        limit = irrlim;
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[transred-%d] limit %lld based on %d irredundant clauses penalty %d\0"
                as *const u8 as *const libc::c_char,
            (*(*lgl).stats).trd.count,
            limit as libc::c_longlong,
            (*(*lgl).stats).irr.clauses.cur,
            szpen,
        );
    } else {
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[transred-%d] limit %lld with penalty %d = %d + %d\0" as *const u8
                as *const libc::c_char,
            (*(*lgl).stats).trd.count,
            limit as libc::c_longlong,
            pen,
            (*(*lgl).limits).trd.pen,
            szpen,
        );
    }
    (*(*lgl).limits).trd.steps = (*(*lgl).stats).trd.steps + limit;
}
unsafe extern "C" fn lgltrd(mut lgl: *mut LGL) -> libc::c_int {
    let mut pos: libc::c_uint = 0;
    let mut delta: libc::c_uint = 0;
    let mut mod_0: libc::c_uint = 0;
    let mut ulit: libc::c_uint = 0;
    let mut first: libc::c_uint = 0;
    let mut last: libc::c_uint = 0;
    let mut failed: libc::c_int = (*(*lgl).stats).trd.failed;
    let mut red: libc::c_int = (*(*lgl).stats).trd.red;
    let mut lit: libc::c_int = 0;
    let mut count: libc::c_int = 0;
    let mut success: libc::c_int = 0;
    if (*lgl).nvars <= 2 as libc::c_int {
        return 1 as libc::c_int;
    }
    (*(*lgl).stats).trd.count += 1;
    (*(*lgl).stats).trd.count;
    lglstart(lgl, &mut (*(*lgl).times).transred);
    (*lgl).simp = 1 as libc::c_int as libc::c_char;
    if (*lgl).level > 0 as libc::c_int {
        lglbacktrack(lgl, 0 as libc::c_int);
    }
    lglsetrdlim(lgl);
    mod_0 = (2 as libc::c_int * ((*lgl).nvars - 2 as libc::c_int)) as libc::c_uint;
    pos = (lglrand(lgl)).wrapping_rem(mod_0);
    delta = (lglrand(lgl)).wrapping_rem(mod_0);
    if delta == 0 {
        delta = delta.wrapping_add(1);
        delta;
    }
    while lglgcd(delta, mod_0) > 1 as libc::c_int as libc::c_uint {
        delta = delta.wrapping_add(1);
        if delta == mod_0 {
            delta = 1 as libc::c_int as libc::c_uint;
        }
    }
    first = mod_0;
    count = 0 as libc::c_int;
    while (*(*lgl).stats).trd.steps < (*(*lgl).limits).trd.steps {
        if lglterminate(lgl) != 0 {
            break;
        }
        if lglsyncunits(lgl) == 0 {
            break;
        }
        ulit = pos.wrapping_add(4 as libc::c_int as libc::c_uint);
        lit = lglilit(ulit as libc::c_int);
        lgltrdlit(lgl, lit);
        count += 1;
        count;
        if (*lgl).mt != 0 {
            break;
        }
        last = pos;
        pos = pos.wrapping_add(delta);
        if pos >= mod_0 {
            pos = pos.wrapping_sub(mod_0);
        }
        if pos == first {
            break;
        }
        if mod_0 == 1 as libc::c_int as libc::c_uint {
            break;
        }
        if first == mod_0 {
            first = last;
        }
    }
    failed = (*(*lgl).stats).trd.failed - failed;
    red = (*(*lgl).stats).trd.red - red;
    success = (failed != 0 || red != 0) as libc::c_int;
    if success != 0 && (*(*lgl).limits).trd.pen != 0 {
        (*(*lgl).limits).trd.pen -= 1;
        (*(*lgl).limits).trd.pen;
    }
    if success == 0 && (*(*lgl).limits).trd.pen < (*(*lgl).opts).penmax.val {
        (*(*lgl).limits).trd.pen += 1;
        (*(*lgl).limits).trd.pen;
    }
    if success != 0 && (*(*lgl).limits).trd.del.cur != 0 {
        (*(*lgl).limits).trd.del.cur /= 2 as libc::c_int;
    }
    if success == 0 && (*(*lgl).limits).trd.del.cur < (*(*lgl).opts).delmax.val {
        (*(*lgl).limits).trd.del.cur += 1;
        (*(*lgl).limits).trd.del.cur;
    }
    (*(*lgl).limits).trd.del.rem = (*(*lgl).limits).trd.del.cur;
    lglprt(
        lgl,
        1 as libc::c_int,
        b"[transred-%d] removed %d transitive binary clauses\0" as *const u8
            as *const libc::c_char,
        (*(*lgl).stats).trd.count,
        red,
    );
    lglprt(
        lgl,
        1 as libc::c_int + (failed == 0) as libc::c_int,
        b"[transred-%d] found %d units\0" as *const u8 as *const libc::c_char,
        (*(*lgl).stats).trd.count,
        failed,
    );
    (*lgl).simp = 0 as libc::c_int as libc::c_char;
    lglrep(lgl, 2 as libc::c_int, 'D' as i32 as libc::c_char);
    lglstop(lgl);
    return ((*lgl).mt == 0) as libc::c_int;
}
unsafe extern "C" fn lglunhdhasbins(
    mut lgl: *mut LGL,
    mut dfpr: *const DFPR,
    mut lit: libc::c_int,
    mut irronly: libc::c_int,
) -> libc::c_int {
    let mut blit: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut val: libc::c_int = 0;
    let mut red: libc::c_int = 0;
    let mut ulit: libc::c_int = 0;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut w: *const libc::c_int = 0 as *const libc::c_int;
    let mut eos: *const libc::c_int = 0 as *const libc::c_int;
    let mut hts: *mut HTS = 0 as *mut HTS;
    hts = lglhts(lgl, lit);
    w = lglhts2wchs(lgl, hts);
    eos = w.offset((*hts).count as isize);
    p = w;
    while p < eos {
        blit = *p;
        tag = blit & MASKCS as libc::c_int;
        if !(tag == OCCS as libc::c_int) {
            if tag == TRNCS as libc::c_int || tag == LRGCS as libc::c_int {
                p = p.offset(1);
                p;
            } else {
                red = blit & REDCS as libc::c_int;
                if !(irronly != 0 && red != 0) {
                    other = blit >> RMSHFT as libc::c_int;
                    val = lglval(lgl, other) as libc::c_int;
                    if !(val > 0 as libc::c_int) {
                        ulit = lglulit(other);
                        if (*dfpr.offset(ulit as isize)).discovered == 0 {
                            return 1 as libc::c_int;
                        }
                    }
                }
            }
        }
        p = p.offset(1);
        p;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn lglunhdisroot(
    mut lgl: *mut LGL,
    mut lit: libc::c_int,
    mut dfpr: *mut DFPR,
    mut irronly: libc::c_int,
) -> libc::c_int {
    let mut res: libc::c_int = (lglunhdhasbins(lgl, dfpr, lit, irronly) == 0)
        as libc::c_int;
    return res;
}
unsafe extern "C" fn lglmtwtk(mut wtk: *mut Wtk) -> libc::c_int {
    return ((*wtk).top == (*wtk).start) as libc::c_int;
}
unsafe extern "C" fn lglfullwtk(mut wtk: *mut Wtk) -> libc::c_int {
    return ((*wtk).top == (*wtk).end) as libc::c_int;
}
unsafe extern "C" fn lglsizewtk(mut wtk: *mut Wtk) -> libc::c_int {
    return ((*wtk).end).offset_from((*wtk).start) as libc::c_long as libc::c_int;
}
unsafe extern "C" fn lglcntwtk(mut wtk: *mut Wtk) -> libc::c_int {
    return ((*wtk).top).offset_from((*wtk).start) as libc::c_long as libc::c_int;
}
unsafe extern "C" fn lglrelwtk(mut lgl: *mut LGL, mut wtk: *mut Wtk) {
    lgldel(
        lgl,
        (*wtk).start as *mut libc::c_void,
        (lglsizewtk(wtk) as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Work>() as libc::c_ulong),
    );
    (*wtk).start = 0 as *mut Work;
    memset(
        wtk as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<Wtk>() as libc::c_ulong,
    );
}
unsafe extern "C" fn lglenlwtk(mut lgl: *mut LGL, mut wtk: *mut Wtk) {
    let mut oldsize: libc::c_int = lglsizewtk(wtk);
    let mut newsize: libc::c_int = if oldsize != 0 {
        2 as libc::c_int * oldsize
    } else {
        1 as libc::c_int
    };
    let mut count: libc::c_int = lglcntwtk(wtk);
    (*wtk)
        .start = lglrsz(
        lgl,
        (*wtk).start as *mut libc::c_void,
        (oldsize as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Work>() as libc::c_ulong),
        (newsize as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Work>() as libc::c_ulong),
    ) as *mut Work;
    (*wtk).top = ((*wtk).start).offset(count as isize);
    (*wtk).end = ((*wtk).start).offset(newsize as isize);
}
unsafe extern "C" fn lglpushwtk(
    mut lgl: *mut LGL,
    mut wtk: *mut Wtk,
    mut wrag: Wrag,
    mut lit: libc::c_int,
    mut other: libc::c_int,
    mut red: libc::c_int,
) {
    let mut w: Work = Work {
        wrag_lit_other_red_removed: [0; 8],
    };
    if lglfullwtk(wtk) != 0 {
        lglenlwtk(lgl, wtk);
    }
    w.set_wrag(wrag as libc::c_uint);
    w.set_other(other);
    w.set_red(
        (if red != 0 { 1 as libc::c_int } else { 0 as libc::c_int }) as libc::c_uint,
    );
    w.set_removed(0 as libc::c_int as libc::c_uint);
    w.set_lit(lit);
    let fresh224 = (*wtk).top;
    (*wtk).top = ((*wtk).top).offset(1);
    *fresh224 = w;
}
unsafe extern "C" fn lglstamp(
    mut lgl: *mut LGL,
    mut root: libc::c_int,
    mut dfpr: *mut DFPR,
    mut dfopf: *mut DFOPF,
    mut work: *mut Wtk,
    mut units: *mut Stk,
    mut sccs: *mut Stk,
    mut trds: *mut Stk,
    mut visitedptr: *mut libc::c_int,
    mut stamp: libc::c_int,
    mut irronly: libc::c_int,
) -> libc::c_int {
    let mut uroot: libc::c_int = 0;
    let mut lit: libc::c_int = 0;
    let mut ulit: libc::c_int = 0;
    let mut blit: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut red: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut failed: libc::c_int = 0;
    let mut uother: libc::c_int = 0;
    let mut unotother: libc::c_int = 0;
    let mut observed: libc::c_int = 0;
    let mut discovered: libc::c_int = 0;
    let mut pos: libc::c_int = 0;
    let mut undiscovered: libc::c_int = 0;
    let mut start: libc::c_uint = 0;
    let mut end: libc::c_uint = 0;
    let mut mod_0: libc::c_uint = 0;
    let mut i: libc::c_uint = 0;
    let mut j: libc::c_uint = 0;
    let mut sccsize: libc::c_uint = 0;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut w: *const libc::c_int = 0 as *const libc::c_int;
    let mut eos: *const libc::c_int = 0 as *const libc::c_int;
    let mut startstamp: libc::c_int = 0;
    let mut r: *const Work = 0 as *const Work;
    let mut removed: libc::c_int = 0;
    let mut hts: *mut HTS = 0 as *mut HTS;
    let mut wrag: Wrag = PREFIX;
    if lglval(lgl, root) != 0 {
        return stamp;
    }
    uroot = lglulit(root);
    if (*dfpr.offset(uroot as isize)).discovered != 0 {
        return stamp;
    }
    startstamp = 0 as libc::c_int;
    lglpushwtk(lgl, work, PREFIX, root, 0 as libc::c_int, 0 as libc::c_int);
    while lglmtwtk(work) == 0 {
        (*(*lgl).stats).steps += 1;
        (*(*lgl).stats).steps;
        (*(*lgl).stats).unhd.steps += 1;
        (*(*lgl).stats).unhd.steps;
        (*work).top = ((*work).top).offset(-1);
        (*work).top;
        wrag = (*(*work).top).wrag() as Wrag;
        lit = (*(*work).top).lit();
        other = (*(*work).top).other();
        red = if (*(*work).top).red() as libc::c_int != 0 {
            REDCS as libc::c_int
        } else {
            0 as libc::c_int
        };
        removed = (*(*work).top).removed() as libc::c_int;
        if removed != 0 {
            continue;
        }
        if wrag as libc::c_uint == PREFIX as libc::c_int as libc::c_uint {
            ulit = lglulit(lit);
            if (*dfpr.offset(ulit as isize)).discovered != 0 {
                (*dfopf.offset(ulit as isize)).observed = stamp;
            } else {
                stamp += 1;
                (*dfpr.offset(ulit as isize)).discovered = stamp;
                (*dfopf.offset(ulit as isize)).observed = stamp;
                *visitedptr += 1 as libc::c_int;
                if startstamp == 0 {
                    startstamp = stamp;
                    (*dfpr.offset(ulit as isize)).root = lit;
                }
                lglpushwtk(lgl, work, POSTFIX, lit, 0 as libc::c_int, 0 as libc::c_int);
                (*dfopf.offset(ulit as isize)).pushed = lglcntwtk(work);
                (*dfopf.offset(ulit as isize)).flag = 1 as libc::c_int;
                lglpushstk(lgl, sccs, lit);
                hts = lglhts(lgl, -lit);
                w = lglhts2wchs(lgl, hts);
                eos = w.offset((*hts).count as isize);
                undiscovered = 0 as libc::c_int;
                while undiscovered <= 1 as libc::c_int {
                    start = lglcntwtk(work) as libc::c_uint;
                    p = w;
                    while p < eos {
                        blit = *p;
                        tag = blit & MASKCS as libc::c_int;
                        if !(tag == OCCS as libc::c_int) {
                            if tag == TRNCS as libc::c_int || tag == LRGCS as libc::c_int
                            {
                                p = p.offset(1);
                                p;
                            } else {
                                red = blit & REDCS as libc::c_int;
                                if !(irronly != 0 && red != 0) {
                                    other = blit >> RMSHFT as libc::c_int;
                                    if !(lglval(lgl, other) != 0) {
                                        uother = lglulit(other);
                                        if !(undiscovered
                                            != ((*dfpr.offset(uother as isize)).discovered == 0)
                                                as libc::c_int)
                                        {
                                            if !(lglsignedmarked(lgl, other) > 0 as libc::c_int)
                                            {} else {
                                                fprintf(
                                                    stderr,
                                                    b"liblgl.a: %s:%d: %s: Coverage target `%s' reached.\0"
                                                        as *const u8 as *const libc::c_char,
                                                    (*::core::mem::transmute::<
                                                        &[u8; 9],
                                                        &[libc::c_char; 9],
                                                    >(b"lglstamp\0"))
                                                        .as_ptr(),
                                                    18326 as libc::c_int,
                                                    b"lglib.c\0" as *const u8 as *const libc::c_char,
                                                    b"lglsignedmarked (lgl, other) > 0\0" as *const u8
                                                        as *const libc::c_char,
                                                );
                                                if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
                                                    fprintf(
                                                        stderr,
                                                        b" (tid %d)\0" as *const u8 as *const libc::c_char,
                                                        (*lgl).tid,
                                                    );
                                                }
                                                fputc('\n' as i32, stderr);
                                                fflush(stderr);
                                                abort();
                                            }
                                            if !(lglsignedmarked(lgl, other) > 0 as libc::c_int) {
                                                lglsignedmark(lgl, other);
                                                lglpushwtk(lgl, work, BEFORE, lit, other, red);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        p = p.offset(1);
                        p;
                    }
                    end = lglcntwtk(work) as libc::c_uint;
                    r = ((*work).start).offset(start as isize);
                    while r < (*work).top as *const Work {
                        lglunmark(lgl, (*r).other());
                        r = r.offset(1);
                        r;
                    }
                    mod_0 = end.wrapping_sub(start);
                    if !(mod_0 <= 1 as libc::c_int as libc::c_uint) {
                        i = start;
                        while i < end.wrapping_sub(1 as libc::c_int as libc::c_uint) {
                            let fresh225 = mod_0;
                            mod_0 = mod_0.wrapping_sub(1);
                            j = (lglrand(lgl)).wrapping_rem(fresh225);
                            if !(j == 0) {
                                j = i.wrapping_add(j);
                                let mut TMP: Work = *((*work).start).offset(i as isize);
                                *((*work).start)
                                    .offset(i as isize) = *((*work).start).offset(j as isize);
                                *((*work).start).offset(j as isize) = TMP;
                            }
                            i = i.wrapping_add(1);
                            i;
                        }
                    }
                    undiscovered += 1;
                    undiscovered;
                }
            }
        } else if wrag as libc::c_uint == BEFORE as libc::c_int as libc::c_uint {
            lglpushwtk(lgl, work, AFTER, lit, other, red);
            ulit = lglulit(lit);
            uother = lglulit(other);
            unotother = lglulit(-other);
            if (*(*lgl).opts).unhdextstamp.val != 0 && (irronly != 0 || red != 0)
                && (*dfopf.offset(uother as isize)).observed
                    > (*dfpr.offset(ulit as isize)).discovered
            {
                (*(*lgl).stats).unhd.stamp.trds += 1;
                (*(*lgl).stats).unhd.stamp.trds;
                (*(*lgl).stats).prgss += 1;
                (*(*lgl).stats).prgss;
                if red != 0 {
                    (*(*lgl).stats).unhd.tauts.red += 1;
                    (*(*lgl).stats).unhd.tauts.red;
                }
                lglrmbcls(lgl, -lit, other, red);
                pos = (*dfopf.offset(unotother as isize)).pushed;
                if pos >= 0 as libc::c_int {
                    while pos < lglcntwtk(work) {
                        if (*((*work).start).offset(pos as isize)).lit() != -other {
                            break;
                        }
                        if (*((*work).start).offset(pos as isize)).other() == -lit {
                            let ref mut fresh226 = *((*work).start).offset(pos as isize);
                            (*fresh226).set_removed(1 as libc::c_int as libc::c_uint);
                        }
                        pos += 1;
                        pos;
                    }
                }
                (*work).top = ((*work).top).offset(-1);
                (*work).top;
            } else {
                observed = (*dfopf.offset(unotother as isize)).observed;
                if (*(*lgl).opts).unhdextstamp.val != 0 && startstamp <= observed {
                    failed = lit;
                    while (*dfpr.offset(lglulit(failed) as isize)).discovered > observed
                    {
                        failed = (*dfpr.offset(lglulit(failed) as isize)).parent;
                    }
                    lglpushstk(lgl, units, -failed);
                    (*(*lgl).stats).unhd.stamp.failed += 1;
                    (*(*lgl).stats).unhd.stamp.failed;
                    if (*dfpr.offset(unotother as isize)).discovered != 0
                        && (*dfpr.offset(unotother as isize)).finished == 0
                    {
                        (*work).top = ((*work).top).offset(-1);
                        (*work).top;
                        continue;
                    }
                }
                if (*dfpr.offset(uother as isize)).discovered == 0 {
                    (*dfpr.offset(uother as isize)).parent = lit;
                    (*dfpr.offset(uother as isize)).root = root;
                    lglpushwtk(
                        lgl,
                        work,
                        PREFIX,
                        other,
                        0 as libc::c_int,
                        0 as libc::c_int,
                    );
                }
            }
        } else if wrag as libc::c_uint == AFTER as libc::c_int as libc::c_uint {
            uother = lglulit(other);
            ulit = lglulit(lit);
            if (*(*lgl).opts).unhdextstamp.val != 0
                && (*dfpr.offset(uother as isize)).finished == 0
                && (*dfpr.offset(uother as isize)).discovered
                    < (*dfpr.offset(ulit as isize)).discovered
            {
                (*dfpr.offset(ulit as isize))
                    .discovered = (*dfpr.offset(uother as isize)).discovered;
                if (*dfopf.offset(ulit as isize)).flag != 0 {
                    (*dfopf.offset(ulit as isize)).flag = 0 as libc::c_int;
                }
            }
            (*dfopf.offset(uother as isize)).observed = stamp;
        } else {
            ulit = lglulit(lit);
            if (*dfopf.offset(ulit as isize)).flag != 0 {
                stamp += 1;
                stamp;
                sccsize = 0 as libc::c_int as libc::c_uint;
                discovered = (*dfpr.offset(ulit as isize)).discovered;
                loop {
                    other = lglpopstk(sccs);
                    uother = lglulit(other);
                    (*dfopf.offset(uother as isize)).pushed = -(1 as libc::c_int);
                    (*dfopf.offset(uother as isize)).flag = 0 as libc::c_int;
                    (*dfpr.offset(uother as isize)).discovered = discovered;
                    (*dfpr.offset(uother as isize)).finished = stamp;
                    sccsize = sccsize.wrapping_add(1);
                    sccsize;
                    if !(other != lit) {
                        break;
                    }
                }
                if sccsize > 1 as libc::c_int as libc::c_uint {
                    (*(*lgl).stats).unhd.stamp.sumsccsizes += sccsize as int64_t;
                    (*(*lgl).stats).unhd.stamp.sccs += 1;
                    (*(*lgl).stats).unhd.stamp.sccs;
                }
            }
        }
    }
    return stamp;
}
unsafe extern "C" fn lglunhlca(
    mut lgl: *mut LGL,
    mut dfpr: *const DFPR,
    mut a: libc::c_int,
    mut b: libc::c_int,
) -> libc::c_int {
    let mut c: *const DFPR = 0 as *const DFPR;
    let mut d: *const DFPR = 0 as *const DFPR;
    let mut u: libc::c_int = 0;
    let mut v: libc::c_int = 0;
    let mut p: libc::c_int = 0;
    if a == b {
        return a;
    }
    u = lglulit(a);
    v = lglulit(b);
    c = dfpr.offset(u as isize);
    d = dfpr.offset(v as isize);
    if (*c).discovered <= (*d).discovered {
        p = a;
    } else {
        p = b;
        let mut TMP: *const DFPR = c;
        c = d;
        d = TMP;
    }
    while !((*d).finished <= (*c).finished) {
        p = (*c).parent;
        if p == 0 {
            break;
        }
        u = lglulit(p);
        c = dfpr.offset(u as isize);
    }
    return p;
}
unsafe extern "C" fn lglunhidefailed(
    mut lgl: *mut LGL,
    mut dfpr: *const DFPR,
) -> libc::c_int {
    let mut idx: libc::c_int = 0;
    let mut sign: libc::c_int = 0;
    let mut lit: libc::c_int = 0;
    let mut unit: libc::c_int = 0;
    let mut nfailed: libc::c_int = 0 as libc::c_int;
    idx = 2 as libc::c_int;
    while idx < (*lgl).nvars {
        let mut current_block_25: u64;
        sign = -(1 as libc::c_int);
        while sign <= 1 as libc::c_int {
            if lglterminate(lgl) != 0 {
                return 0 as libc::c_int;
            }
            if lglsyncunits(lgl) == 0 {
                return 0 as libc::c_int;
            }
            (*(*lgl).stats).steps += 1;
            (*(*lgl).stats).steps;
            (*(*lgl).stats).unhd.steps += 1;
            (*(*lgl).stats).unhd.steps;
            lit = sign * idx;
            if !(lglval(lgl, lit) != 0) {
                if !((*dfpr.offset(lglulit(lit) as isize)).discovered == 0) {
                    if lglunhimplincl(dfpr, lit, -lit) != 0 {
                        unit = -lit;
                        current_block_25 = 12147880666119273379;
                    } else if lglunhimplincl(dfpr, -lit, lit) != 0 {
                        unit = lit;
                        current_block_25 = 12147880666119273379;
                    } else {
                        current_block_25 = 14155750587950065367;
                    }
                    match current_block_25 {
                        14155750587950065367 => {}
                        _ => {
                            lglunit(lgl, unit);
                            (*(*lgl).stats).unhd.failed.lits += 1;
                            (*(*lgl).stats).unhd.failed.lits;
                            nfailed += 1;
                            nfailed;
                            if !(lglbcp(lgl) != 0) {
                                lglmt(lgl);
                                return 0 as libc::c_int;
                            }
                        }
                    }
                }
            }
            sign += 2 as libc::c_int;
        }
        idx += 1;
        idx;
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn lglunhroot(
    mut dfpr: *const DFPR,
    mut lit: libc::c_int,
) -> libc::c_int {
    return (*dfpr.offset(lglulit(lit) as isize)).root;
}
unsafe extern "C" fn lglunhidebintrn(
    mut lgl: *mut LGL,
    mut dfpr: *const DFPR,
    mut irronly: libc::c_int,
) -> libc::c_int {
    let mut current_block: u64;
    let mut idx: libc::c_int = 0;
    let mut sign: libc::c_int = 0;
    let mut lit: libc::c_int = 0;
    let mut blit: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut red: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut other2: libc::c_int = 0;
    let mut unit: libc::c_int = 0;
    let mut root: libc::c_int = 0;
    let mut lca: libc::c_int = 0;
    let mut nbinred: libc::c_int = 0;
    let mut ntrnred: libc::c_int = 0;
    let mut nbinunits: libc::c_int = 0;
    let mut ntrnunits: libc::c_int = 0;
    let mut ntrnstr: libc::c_int = 0;
    let mut ntrnhbrs: libc::c_int = 0;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut eow: *const libc::c_int = 0 as *const libc::c_int;
    let mut ulit: libc::c_int = 0;
    let mut uother: libc::c_int = 0;
    let mut delta: ptrdiff_t = 0;
    let mut w: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut q: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut hts: *mut HTS = 0 as *mut HTS;
    ntrnhbrs = 0 as libc::c_int;
    ntrnstr = ntrnhbrs;
    ntrnunits = ntrnstr;
    nbinunits = ntrnunits;
    ntrnred = nbinunits;
    nbinred = ntrnred;
    idx = 2 as libc::c_int;
    while idx < (*lgl).nvars {
        sign = -(1 as libc::c_int);
        's_28: while sign <= 1 as libc::c_int {
            if lglterminate(lgl) != 0 {
                return 0 as libc::c_int;
            }
            if lglsyncunits(lgl) == 0 {
                return 0 as libc::c_int;
            }
            (*(*lgl).stats).steps += 1;
            (*(*lgl).stats).steps;
            (*(*lgl).stats).unhd.steps += 1;
            (*(*lgl).stats).unhd.steps;
            lit = sign * idx;
            if !(lglval(lgl, lit) != 0) {
                ulit = lglulit(lit);
                if !((*dfpr.offset(ulit as isize)).discovered == 0) {
                    hts = lglhts(lgl, lit);
                    w = lglhts2wchs(lgl, hts);
                    eow = w.offset((*hts).count as isize);
                    q = w;
                    p = w;
                    while p < eow {
                        blit = *p;
                        let fresh227 = q;
                        q = q.offset(1);
                        *fresh227 = blit;
                        tag = blit & MASKCS as libc::c_int;
                        if tag == TRNCS as libc::c_int || tag == LRGCS as libc::c_int {
                            p = p.offset(1);
                            let fresh228 = q;
                            q = q.offset(1);
                            *fresh228 = *p;
                        }
                        if !(tag == LRGCS as libc::c_int) {
                            red = blit & REDCS as libc::c_int;
                            other = blit >> RMSHFT as libc::c_int;
                            if !(lglval(lgl, other) != 0) {
                                uother = lglulit(other);
                                if tag == BINCS as libc::c_int {
                                    if lglunhimplies2(dfpr, other, lit) != 0 {
                                        (*(*lgl).stats).unhd.units.bin += 1;
                                        (*(*lgl).stats).unhd.units.bin;
                                        nbinunits += 1;
                                        nbinunits;
                                        unit = lit;
                                        current_block = 13919125070642190772;
                                    } else {
                                        root = lglunhroot(dfpr, -lit);
                                        if root != 0 && lglval(lgl, root) == 0
                                            && root == lglunhroot(dfpr, -other)
                                        {
                                            (*(*lgl).stats).unhd.failed.bin += 1;
                                            (*(*lgl).stats).unhd.failed.bin;
                                            lca = lglunhlca(lgl, dfpr, -lit, -other);
                                            unit = -lca;
                                            current_block = 13919125070642190772;
                                        } else if irronly == 0 && red == 0 {
                                            current_block = 7149356873433890176;
                                        } else if (*dfpr.offset(uother as isize)).parent == -lit {
                                            current_block = 7149356873433890176;
                                        } else if (*dfpr.offset(ulit as isize)).parent == -other {
                                            current_block = 7149356873433890176;
                                        } else if lglunhimplies2(dfpr, -lit, other) == 0 {
                                            current_block = 7149356873433890176;
                                        } else {
                                            (*(*lgl).stats).unhd.tauts.bin += 1;
                                            (*(*lgl).stats).unhd.tauts.bin;
                                            (*(*lgl).stats).prgss += 1;
                                            (*(*lgl).stats).prgss;
                                            if red != 0 {
                                                (*(*lgl).stats).unhd.tauts.red += 1;
                                                (*(*lgl).stats).unhd.tauts.red;
                                            }
                                            nbinred += 1;
                                            nbinred;
                                            lglrmbwch(lgl, other, lit, red);
                                            lgldeclscnt(lgl, 2 as libc::c_int, red, 0 as libc::c_int);
                                            q = q.offset(-1);
                                            q;
                                            current_block = 7149356873433890176;
                                        }
                                    }
                                } else {
                                    other2 = *p;
                                    if lglval(lgl, other2) != 0 {
                                        current_block = 7149356873433890176;
                                    } else if lglunhimplies2incl(dfpr, other, lit) != 0
                                        && lglunhimplies2incl(dfpr, other2, lit) != 0
                                    {
                                        (*(*lgl).stats).unhd.str_0.trn += 2 as libc::c_int;
                                        if red != 0 {
                                            (*(*lgl).stats).unhd.str_0.red += 2 as libc::c_int;
                                        }
                                        (*(*lgl).stats).unhd.units.trn += 1;
                                        (*(*lgl).stats).unhd.units.trn;
                                        ntrnunits += 1;
                                        ntrnunits;
                                        unit = lit;
                                        current_block = 13919125070642190772;
                                    } else {
                                        root = lglunhroot(dfpr, -lit);
                                        if root != 0 && lglval(lgl, root) == 0
                                            && root == lglunhroot(dfpr, -other)
                                            && root == lglunhroot(dfpr, -other2)
                                        {
                                            (*(*lgl).stats).unhd.failed.trn += 1;
                                            (*(*lgl).stats).unhd.failed.trn;
                                            lca = lglunhlca(lgl, dfpr, -lit, -other);
                                            lca = lglunhlca(lgl, dfpr, lca, -other2);
                                            unit = -lca;
                                            current_block = 13919125070642190772;
                                        } else {
                                            if (red != 0 || irronly != 0)
                                                && (lglunhimplies2incl(dfpr, -lit, other) != 0
                                                    || lglunhimplies2incl(dfpr, -lit, other2) != 0)
                                            {
                                                if !((*(*lgl).opts).unhdatrn.val == 0) {
                                                    if !(red != 0
                                                        && (*(*lgl).opts).unhdatrn.val == 1 as libc::c_int)
                                                    {
                                                        (*(*lgl).stats).unhd.tauts.trn += 1;
                                                        (*(*lgl).stats).unhd.tauts.trn;
                                                        (*(*lgl).stats).prgss += 1;
                                                        (*(*lgl).stats).prgss;
                                                        if red != 0 {
                                                            (*(*lgl).stats).unhd.tauts.red += 1;
                                                            (*(*lgl).stats).unhd.tauts.red;
                                                        }
                                                        ntrnred += 1;
                                                        ntrnred;
                                                        lglrmtwch(lgl, other, lit, other2, red);
                                                        lglrmtwch(lgl, other2, lit, other, red);
                                                        lgldeclscnt(lgl, 3 as libc::c_int, red, 0 as libc::c_int);
                                                        if red == 0 && (*(*lgl).opts).move_0.val >= 2 as libc::c_int
                                                        {
                                                            *q.offset(-(2 as libc::c_int) as isize)
                                                                |= REDCS as libc::c_int;
                                                            delta = lglwchtrn(
                                                                lgl,
                                                                other,
                                                                lit,
                                                                other2,
                                                                REDCS as libc::c_int,
                                                            );
                                                            delta
                                                                += lglwchtrn(lgl, other2, lit, other, REDCS as libc::c_int);
                                                            if delta != 0 {
                                                                w = w.offset(delta as isize);
                                                                eow = eow.offset(delta as isize);
                                                                p = p.offset(delta as isize);
                                                                q = q.offset(delta as isize);
                                                            }
                                                            (*(*lgl).stats).red.trn += 1;
                                                            (*(*lgl).stats).red.trn;
                                                            (*(*lgl).stats).moved.trn += 1;
                                                            (*(*lgl).stats).moved.trn;
                                                        } else {
                                                            q = q.offset(-(2 as libc::c_int as isize));
                                                        }
                                                    }
                                                }
                                            } else {
                                                if lglunhimplies2incl(dfpr, other2, lit) != 0 {
                                                    current_block = 2793352396589381719;
                                                } else if lglunhimplies2incl(dfpr, other, lit) != 0 {
                                                    let mut TMP: libc::c_int = other;
                                                    other = other2;
                                                    other2 = TMP;
                                                    current_block = 2793352396589381719;
                                                } else if (*(*lgl).opts).unhdhbr.val != 0
                                                    && {
                                                        root = lglunhroot(dfpr, -lit);
                                                        root != 0
                                                    } && lglval(lgl, root) == 0
                                                {
                                                    if root == lglunhroot(dfpr, -other2) {
                                                        lca = lglunhlca(lgl, dfpr, -lit, -other2);
                                                        current_block = 9838996637140935403;
                                                    } else if root == lglunhroot(dfpr, -other) {
                                                        lca = lglunhlca(lgl, dfpr, -lit, -other);
                                                        let mut TMP_0: libc::c_int = other;
                                                        other = other2;
                                                        other2 = TMP_0;
                                                        current_block = 9838996637140935403;
                                                    } else if lglunhimplies2incl(dfpr, root, -other2) != 0 {
                                                        lca = root;
                                                        current_block = 9838996637140935403;
                                                    } else if lglunhimplies2incl(dfpr, root, -other) != 0 {
                                                        lca = root;
                                                        let mut TMP_1: libc::c_int = other;
                                                        other = other2;
                                                        other2 = TMP_1;
                                                        current_block = 9838996637140935403;
                                                    } else {
                                                        current_block = 7149356873433890176;
                                                    }
                                                    match current_block {
                                                        7149356873433890176 => {}
                                                        _ => {
                                                            if abs(lca) == abs(lit) {
                                                                current_block = 7149356873433890176;
                                                            } else if abs(lca) == abs(other) {
                                                                current_block = 7149356873433890176;
                                                            } else if abs(lca) == abs(other2) {
                                                                current_block = 7149356873433890176;
                                                            } else if lglunhimplies2incl(dfpr, lca, other) != 0 {
                                                                current_block = 7149356873433890176;
                                                            } else {
                                                                (*(*lgl).stats).unhd.hbrs.trn += 1;
                                                                (*(*lgl).stats).unhd.hbrs.trn;
                                                                if red != 0 {
                                                                    (*(*lgl).stats).unhd.hbrs.red += 1;
                                                                    (*(*lgl).stats).unhd.hbrs.red;
                                                                }
                                                                (*(*lgl).stats).prgss += 1;
                                                                (*(*lgl).stats).prgss;
                                                                ntrnhbrs += 1;
                                                                ntrnhbrs;
                                                                lgldrupligaddclsarg(
                                                                    lgl,
                                                                    REDCS as libc::c_int,
                                                                    -lca,
                                                                    other,
                                                                    0 as libc::c_int,
                                                                );
                                                                (*(*lgl).stats).red.bin += 1;
                                                                (*(*lgl).stats).red.bin;
                                                                delta = lglwchbin(lgl, -lca, other, REDCS as libc::c_int);
                                                                if delta != 0 {
                                                                    p = p.offset(delta as isize);
                                                                    q = q.offset(delta as isize);
                                                                    eow = eow.offset(delta as isize);
                                                                    w = w.offset(delta as isize);
                                                                }
                                                                delta = lglwchbin(lgl, other, -lca, REDCS as libc::c_int);
                                                                if delta != 0 {
                                                                    p = p.offset(delta as isize);
                                                                    q = q.offset(delta as isize);
                                                                    eow = eow.offset(delta as isize);
                                                                    w = w.offset(delta as isize);
                                                                }
                                                                current_block = 7149356873433890176;
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    current_block = 7149356873433890176;
                                                }
                                                match current_block {
                                                    7149356873433890176 => {}
                                                    _ => {
                                                        (*(*lgl).stats).unhd.str_0.trn += 1;
                                                        (*(*lgl).stats).unhd.str_0.trn;
                                                        (*(*lgl).stats).prgss += 1;
                                                        (*(*lgl).stats).prgss;
                                                        if red != 0 {
                                                            (*(*lgl).stats).unhd.str_0.red += 1;
                                                            (*(*lgl).stats).unhd.str_0.red;
                                                        }
                                                        ntrnstr += 1;
                                                        ntrnstr;
                                                        lglrmtwch(lgl, other, lit, other2, red);
                                                        lglrmtwch(lgl, other2, lit, other, red);
                                                        lgldeclscnt(lgl, 3 as libc::c_int, red, 0 as libc::c_int);
                                                        if red == 0 {
                                                            lglincirr(lgl, 2 as libc::c_int);
                                                        } else {
                                                            (*(*lgl).stats).red.bin += 1;
                                                            (*(*lgl).stats).red.bin;
                                                        }
                                                        delta = lglwchbin(lgl, other, lit, red);
                                                        if delta != 0 {
                                                            p = p.offset(delta as isize);
                                                            q = q.offset(delta as isize);
                                                            eow = eow.offset(delta as isize);
                                                            w = w.offset(delta as isize);
                                                        }
                                                        q = q.offset(-1);
                                                        *q
                                                            .offset(
                                                                -(1 as libc::c_int) as isize,
                                                            ) = red | BINCS as libc::c_int
                                                            | ((other as libc::c_uint) << RMSHFT as libc::c_int)
                                                                as libc::c_int;
                                                        lgldrupligaddclsarg(
                                                            lgl,
                                                            REDCS as libc::c_int,
                                                            lit,
                                                            other,
                                                            0 as libc::c_int,
                                                        );
                                                    }
                                                }
                                            }
                                            current_block = 7149356873433890176;
                                        }
                                    }
                                }
                                match current_block {
                                    7149356873433890176 => {}
                                    _ => {
                                        lglunit(lgl, unit);
                                        p = p.offset(1);
                                        p;
                                        while p < eow {
                                            let fresh229 = p;
                                            p = p.offset(1);
                                            let fresh230 = q;
                                            q = q.offset(1);
                                            *fresh230 = *fresh229;
                                        }
                                        lglshrinkhts(
                                            lgl,
                                            hts,
                                            ((*hts).count as libc::c_long
                                                - p.offset_from(q) as libc::c_long) as libc::c_int,
                                        );
                                        if lglbcp(lgl) != 0 {
                                            break 's_28;
                                        }
                                        lglmt(lgl);
                                        return 0 as libc::c_int;
                                    }
                                }
                            }
                        }
                        p = p.offset(1);
                        p;
                    }
                    lglshrinkhts(
                        lgl,
                        hts,
                        ((*hts).count as libc::c_long - p.offset_from(q) as libc::c_long)
                            as libc::c_int,
                    );
                }
            }
            sign += 2 as libc::c_int;
        }
        idx += 1;
        idx;
    }
    nbinred != 0;
    nbinunits != 0;
    ntrnred != 0;
    ntrnstr != 0;
    ntrnunits != 0;
    ntrnstr != 0;
    return 1 as libc::c_int;
}
unsafe extern "C" fn lglcmpdfl(mut a: *const DFL, mut b: *const DFL) -> libc::c_int {
    return (*a).discovered - (*b).discovered;
}
unsafe extern "C" fn lglunhideglue(
    mut lgl: *mut LGL,
    mut dfpr: *const DFPR,
    mut glue: libc::c_int,
    mut irronly: libc::c_int,
) -> libc::c_int {
    let mut current_block: u64;
    let mut dfl: *mut DFL = 0 as *mut DFL;
    let mut eodfl: *mut DFL = 0 as *mut DFL;
    let mut d: *mut DFL = 0 as *mut DFL;
    let mut e: *mut DFL = 0 as *mut DFL;
    let mut szdfl: libc::c_int = 0;
    let mut posdfl: libc::c_int = 0;
    let mut negdfl: libc::c_int = 0;
    let mut ndfl: libc::c_int = 0;
    let mut res: libc::c_int = 0;
    let mut oldsize: libc::c_int = 0;
    let mut newsize: libc::c_int = 0;
    let mut hastobesatisfied: libc::c_int = 0;
    let mut satisfied: libc::c_int = 0;
    let mut tautological: libc::c_int = 0;
    let mut watched: libc::c_int = 0;
    let mut lit: libc::c_int = 0;
    let mut ulit: libc::c_int = 0;
    let mut val: libc::c_int = 0;
    let mut sign: libc::c_int = 0;
    let mut nonfalse: libc::c_int = 0;
    let mut root: libc::c_int = 0;
    let mut lca: libc::c_int = 0;
    let mut unit: libc::c_int = 0;
    let mut ntaut: libc::c_int = 0 as libc::c_int;
    let mut nstr: libc::c_int = 0 as libc::c_int;
    let mut nunits: libc::c_int = 0 as libc::c_int;
    let mut nhbrs: libc::c_int = 0 as libc::c_int;
    let mut lidx: libc::c_int = 0;
    let mut p: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut q: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut c: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut eoc: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut red: libc::c_int = 0;
    let mut lca1: libc::c_int = 0;
    let mut lca2: libc::c_int = 0;
    let mut root1: libc::c_int = 0;
    let mut root2: libc::c_int = 0;
    let mut lits: *mut Stk = 0 as *mut Stk;
    if glue < 0 as libc::c_int {
        lits = &mut (*lgl).irr;
        red = 0 as libc::c_int;
    } else {
        lits = ((*lgl).red).offset(glue as isize);
        red = REDCS as libc::c_int;
    }
    res = 1 as libc::c_int;
    dfl = 0 as *mut DFL;
    szdfl = 0 as libc::c_int;
    c = (*lits).start;
    while (*lgl).mt == 0 && c < (*lits).top {
        if lglterminate(lgl) != 0 || lglsyncunits(lgl) == 0 {
            res = 0 as libc::c_int;
            break;
        } else {
            eoc = c;
            lit = *eoc;
            if !(lit >= 2147483647 as libc::c_int >> RMSHFT as libc::c_int) {
                (*(*lgl).stats).steps += 1;
                (*(*lgl).stats).steps;
                (*(*lgl).stats).unhd.steps += 1;
                (*(*lgl).stats).unhd.steps;
                lidx = c.offset_from((*lits).start) as libc::c_long as libc::c_int;
                if red != 0 {
                    lidx <<= 4 as libc::c_int;
                    lidx |= glue;
                }
                watched = 1 as libc::c_int;
                while *eoc != 0 {
                    eoc = eoc.offset(1);
                    eoc;
                }
                oldsize = eoc.offset_from(c) as libc::c_long as libc::c_int;
                ndfl = 0 as libc::c_int;
                tautological = ndfl;
                satisfied = tautological;
                hastobesatisfied = satisfied;
                unit = hastobesatisfied;
                q = c;
                negdfl = 0 as libc::c_int;
                posdfl = negdfl;
                nonfalse = posdfl;
                p = c;
                while p < eoc {
                    lit = *p;
                    val = lglval(lgl, lit) as libc::c_int;
                    if val > 0 as libc::c_int {
                        satisfied = 1 as libc::c_int;
                        q = c.offset(2 as libc::c_int as isize);
                        break;
                    } else {
                        if val < 0 as libc::c_int {
                            if p < c.offset(2 as libc::c_int as isize) {
                                let fresh231 = q;
                                q = q.offset(1);
                                *fresh231 = lit;
                                hastobesatisfied = 1 as libc::c_int;
                            }
                        } else {
                            let fresh232 = q;
                            q = q.offset(1);
                            *fresh232 = lit;
                            nonfalse += 1;
                            nonfalse;
                            if (*dfpr.offset(lglulit(lit) as isize)).discovered != 0 {
                                posdfl += 1;
                                posdfl;
                            }
                            if (*dfpr.offset(lglulit(-lit) as isize)).discovered != 0 {
                                negdfl += 1;
                                negdfl;
                            }
                        }
                        p = p.offset(1);
                        p;
                    }
                }
                eoc = q;
                *eoc = 0 as libc::c_int;
                ndfl = posdfl + negdfl;
                hastobesatisfied != 0;
                if !(satisfied != 0 || ndfl < 2 as libc::c_int) {
                    if nonfalse != negdfl {
                        current_block = 11121186179978336569;
                    } else {
                        root = lglunhroot(dfpr, -*c);
                        if lglval(lgl, root) != 0 {
                            current_block = 11121186179978336569;
                        } else {
                            p = c.offset(1 as libc::c_int as isize);
                            while p < eoc && lglunhroot(dfpr, -*p) == root {
                                p = p.offset(1);
                                p;
                            }
                            if p < eoc {
                                current_block = 11121186179978336569;
                            } else {
                                lca = -*c;
                                p = c.offset(1 as libc::c_int as isize);
                                while p < eoc {
                                    lca = lglunhlca(lgl, dfpr, -*p, lca);
                                    p = p.offset(1);
                                    p;
                                }
                                (*(*lgl).stats).unhd.failed.lrg += 1;
                                (*(*lgl).stats).unhd.failed.lrg;
                                unit = -lca;
                                current_block = 9360437562037878177;
                            }
                        }
                    }
                    match current_block {
                        9360437562037878177 => {}
                        _ => {
                            if glue < 0 as libc::c_int && irronly == 0 {
                                current_block = 14806697813296735783;
                            } else if posdfl < 2 as libc::c_int
                                || negdfl < 2 as libc::c_int
                            {
                                current_block = 14806697813296735783;
                            } else {
                                if ndfl > szdfl {
                                    dfl = lglrsz(
                                        lgl,
                                        dfl as *mut libc::c_void,
                                        (szdfl as libc::c_ulong)
                                            .wrapping_mul(
                                                ::core::mem::size_of::<DFL>() as libc::c_ulong,
                                            ),
                                        (ndfl as libc::c_ulong)
                                            .wrapping_mul(
                                                ::core::mem::size_of::<DFL>() as libc::c_ulong,
                                            ),
                                    ) as *mut DFL;
                                    szdfl = ndfl;
                                }
                                ndfl = 0 as libc::c_int;
                                p = c;
                                while p < eoc {
                                    sign = -(1 as libc::c_int);
                                    while sign <= 1 as libc::c_int {
                                        lit = *p;
                                        ulit = lglulit(sign * lit);
                                        if !((*dfpr.offset(ulit as isize)).discovered == 0) {
                                            (*dfl.offset(ndfl as isize))
                                                .discovered = (*dfpr.offset(ulit as isize)).discovered;
                                            (*dfl.offset(ndfl as isize))
                                                .finished = (*dfpr.offset(ulit as isize)).finished;
                                            (*dfl.offset(ndfl as isize)).c2rust_unnamed.sign = sign;
                                            ndfl += 1;
                                            ndfl;
                                        }
                                        sign += 2 as libc::c_int;
                                    }
                                    p = p.offset(1);
                                    p;
                                }
                                (*(*lgl).stats).steps += 6 as libc::c_int as int64_t;
                                (*(*lgl).stats).unhd.steps += 6 as libc::c_int as int64_t;
                                let mut AA: *mut DFL = dfl;
                                let NN: libc::c_int = ndfl;
                                let mut L: libc::c_int = 0 as libc::c_int;
                                let mut R: libc::c_int = NN - 1 as libc::c_int;
                                let mut M: libc::c_int = 0;
                                let mut LL: libc::c_int = 0;
                                let mut RR: libc::c_int = 0;
                                let mut I: libc::c_int = 0;
                                if !(R - L <= 10 as libc::c_int) {
                                    loop {
                                        M = (L + R) / 2 as libc::c_int;
                                        let mut TMP: DFL = *AA.offset(M as isize);
                                        *AA
                                            .offset(
                                                M as isize,
                                            ) = *AA.offset((R - 1 as libc::c_int) as isize);
                                        *AA.offset((R - 1 as libc::c_int) as isize) = TMP;
                                        if lglcmpdfl(
                                            &mut *AA.offset(L as isize),
                                            &mut *AA.offset((R - 1 as libc::c_int) as isize),
                                        ) > 0 as libc::c_int
                                        {
                                            let mut TMP_0: DFL = *AA.offset(L as isize);
                                            *AA
                                                .offset(
                                                    L as isize,
                                                ) = *AA.offset((R - 1 as libc::c_int) as isize);
                                            *AA.offset((R - 1 as libc::c_int) as isize) = TMP_0;
                                        }
                                        if lglcmpdfl(
                                            &mut *AA.offset(L as isize),
                                            &mut *AA.offset(R as isize),
                                        ) > 0 as libc::c_int
                                        {
                                            let mut TMP_1: DFL = *AA.offset(L as isize);
                                            *AA.offset(L as isize) = *AA.offset(R as isize);
                                            *AA.offset(R as isize) = TMP_1;
                                        }
                                        if lglcmpdfl(
                                            &mut *AA.offset((R - 1 as libc::c_int) as isize),
                                            &mut *AA.offset(R as isize),
                                        ) > 0 as libc::c_int
                                        {
                                            let mut TMP_2: DFL = *AA
                                                .offset((R - 1 as libc::c_int) as isize);
                                            *AA
                                                .offset(
                                                    (R - 1 as libc::c_int) as isize,
                                                ) = *AA.offset(R as isize);
                                            *AA.offset(R as isize) = TMP_2;
                                        }
                                        let mut PIVOT: DFL = DFL {
                                            discovered: 0,
                                            finished: 0,
                                            c2rust_unnamed: C2RustUnnamed_140 { lit: 0 },
                                        };
                                        let mut J: libc::c_int = R - 1 as libc::c_int;
                                        I = L + 1 as libc::c_int - 1 as libc::c_int;
                                        PIVOT = *AA.offset(J as isize);
                                        loop {
                                            loop {
                                                I += 1;
                                                if !(lglcmpdfl(&mut *AA.offset(I as isize), &mut PIVOT)
                                                    < 0 as libc::c_int)
                                                {
                                                    break;
                                                }
                                            }
                                            loop {
                                                J -= 1;
                                                if !(lglcmpdfl(&mut PIVOT, &mut *AA.offset(J as isize))
                                                    < 0 as libc::c_int)
                                                {
                                                    break;
                                                }
                                                if J == L + 1 as libc::c_int {
                                                    break;
                                                }
                                            }
                                            if I >= J {
                                                break;
                                            }
                                            let mut TMP_3: DFL = *AA.offset(I as isize);
                                            *AA.offset(I as isize) = *AA.offset(J as isize);
                                            *AA.offset(J as isize) = TMP_3;
                                        }
                                        let mut TMP_4: DFL = *AA.offset(I as isize);
                                        *AA
                                            .offset(
                                                I as isize,
                                            ) = *AA.offset((R - 1 as libc::c_int) as isize);
                                        *AA.offset((R - 1 as libc::c_int) as isize) = TMP_4;
                                        if I - L < R - I {
                                            LL = I + 1 as libc::c_int;
                                            RR = R;
                                            R = I - 1 as libc::c_int;
                                        } else {
                                            LL = L;
                                            RR = I - 1 as libc::c_int;
                                            L = I + 1 as libc::c_int;
                                        }
                                        if R - L > 10 as libc::c_int {
                                            lglpushstk(lgl, &mut (*lgl).c2rust_unnamed_0.sortstk, LL);
                                            lglpushstk(lgl, &mut (*lgl).c2rust_unnamed_0.sortstk, RR);
                                        } else if RR - LL > 10 as libc::c_int {
                                            L = LL;
                                            R = RR;
                                        } else {
                                            if !(lglmtstk(&mut (*lgl).c2rust_unnamed_0.sortstk) == 0) {
                                                break;
                                            }
                                            R = lglpopstk(&mut (*lgl).c2rust_unnamed_0.sortstk);
                                            L = lglpopstk(&mut (*lgl).c2rust_unnamed_0.sortstk);
                                        }
                                    }
                                }
                                let mut PIVOT_0: DFL = DFL {
                                    discovered: 0,
                                    finished: 0,
                                    c2rust_unnamed: C2RustUnnamed_140 { lit: 0 },
                                };
                                let mut L_0: libc::c_int = 0 as libc::c_int;
                                let mut R_0: libc::c_int = NN - 1 as libc::c_int;
                                let mut I_0: libc::c_int = 0;
                                let mut J_0: libc::c_int = 0;
                                I_0 = R_0;
                                while I_0 > L_0 {
                                    if lglcmpdfl(
                                        &mut *AA.offset((I_0 - 1 as libc::c_int) as isize),
                                        &mut *AA.offset(I_0 as isize),
                                    ) > 0 as libc::c_int
                                    {
                                        let mut TMP_5: DFL = *AA
                                            .offset((I_0 - 1 as libc::c_int) as isize);
                                        *AA
                                            .offset(
                                                (I_0 - 1 as libc::c_int) as isize,
                                            ) = *AA.offset(I_0 as isize);
                                        *AA.offset(I_0 as isize) = TMP_5;
                                    }
                                    I_0 -= 1;
                                    I_0;
                                }
                                I_0 = L_0 + 2 as libc::c_int;
                                while I_0 <= R_0 {
                                    J_0 = I_0;
                                    PIVOT_0 = *AA.offset(I_0 as isize);
                                    while lglcmpdfl(
                                        &mut PIVOT_0,
                                        &mut *AA.offset((J_0 - 1 as libc::c_int) as isize),
                                    ) < 0 as libc::c_int
                                    {
                                        *AA
                                            .offset(
                                                J_0 as isize,
                                            ) = *AA.offset((J_0 - 1 as libc::c_int) as isize);
                                        J_0 -= 1;
                                        J_0;
                                    }
                                    *AA.offset(J_0 as isize) = PIVOT_0;
                                    I_0 += 1;
                                    I_0;
                                }
                                eodfl = dfl.offset(ndfl as isize);
                                d = dfl;
                                while d < eodfl.offset(-(1 as libc::c_int as isize)) {
                                    if (*d).c2rust_unnamed.sign < 0 as libc::c_int {
                                        break;
                                    }
                                    d = d.offset(1);
                                    d;
                                }
                                's_880: loop {
                                    if !(d < eodfl.offset(-(1 as libc::c_int as isize))) {
                                        current_block = 14806697813296735783;
                                        break;
                                    }
                                    e = d.offset(1 as libc::c_int as isize);
                                    while e < eodfl && (*e).finished < (*d).finished {
                                        if (*e).c2rust_unnamed.sign < 0 as libc::c_int {
                                            e = e.offset(1);
                                            e;
                                        } else {
                                            ntaut += 1;
                                            ntaut;
                                            (*(*lgl).stats).unhd.tauts.lrg += 1;
                                            (*(*lgl).stats).unhd.tauts.lrg;
                                            if red != 0 {
                                                (*(*lgl).stats).unhd.tauts.red += 1;
                                                (*(*lgl).stats).unhd.tauts.red;
                                            }
                                            (*(*lgl).stats).prgss += 1;
                                            (*(*lgl).stats).prgss;
                                            tautological = 1 as libc::c_int;
                                            current_block = 9360437562037878177;
                                            break 's_880;
                                        }
                                    }
                                    d = e;
                                    while d < eodfl
                                        && (*d).c2rust_unnamed.sign > 0 as libc::c_int
                                    {
                                        d = d.offset(1);
                                        d;
                                    }
                                }
                            }
                            match current_block {
                                9360437562037878177 => {}
                                _ => {
                                    if !(negdfl < 2 as libc::c_int) {
                                        if negdfl > szdfl {
                                            dfl = lglrsz(
                                                lgl,
                                                dfl as *mut libc::c_void,
                                                (szdfl as libc::c_ulong)
                                                    .wrapping_mul(
                                                        ::core::mem::size_of::<DFL>() as libc::c_ulong,
                                                    ),
                                                (negdfl as libc::c_ulong)
                                                    .wrapping_mul(
                                                        ::core::mem::size_of::<DFL>() as libc::c_ulong,
                                                    ),
                                            ) as *mut DFL;
                                            szdfl = negdfl;
                                        }
                                        (*(*lgl).stats).steps += 1;
                                        (*(*lgl).stats).steps;
                                        (*(*lgl).stats).unhd.steps += 1;
                                        (*(*lgl).stats).unhd.steps;
                                        ndfl = 0 as libc::c_int;
                                        p = c;
                                        while p < eoc {
                                            lit = *p;
                                            ulit = lglulit(-lit);
                                            if !((*dfpr.offset(ulit as isize)).discovered == 0) {
                                                (*dfl.offset(ndfl as isize))
                                                    .discovered = (*dfpr.offset(ulit as isize)).discovered;
                                                (*dfl.offset(ndfl as isize))
                                                    .finished = (*dfpr.offset(ulit as isize)).finished;
                                                (*dfl.offset(ndfl as isize)).c2rust_unnamed.lit = lit;
                                                ndfl += 1;
                                                ndfl;
                                            }
                                            p = p.offset(1);
                                            p;
                                        }
                                        if !(ndfl < 2 as libc::c_int) {
                                            (*(*lgl).stats).steps += 3 as libc::c_int as int64_t;
                                            (*(*lgl).stats).unhd.steps += 3 as libc::c_int as int64_t;
                                            let mut AA_0: *mut DFL = dfl;
                                            let NN_0: libc::c_int = ndfl;
                                            let mut L_1: libc::c_int = 0 as libc::c_int;
                                            let mut R_1: libc::c_int = NN_0 - 1 as libc::c_int;
                                            let mut M_0: libc::c_int = 0;
                                            let mut LL_0: libc::c_int = 0;
                                            let mut RR_0: libc::c_int = 0;
                                            let mut I_1: libc::c_int = 0;
                                            if !(R_1 - L_1 <= 10 as libc::c_int) {
                                                loop {
                                                    M_0 = (L_1 + R_1) / 2 as libc::c_int;
                                                    let mut TMP_6: DFL = *AA_0.offset(M_0 as isize);
                                                    *AA_0
                                                        .offset(
                                                            M_0 as isize,
                                                        ) = *AA_0.offset((R_1 - 1 as libc::c_int) as isize);
                                                    *AA_0.offset((R_1 - 1 as libc::c_int) as isize) = TMP_6;
                                                    if lglcmpdfl(
                                                        &mut *AA_0.offset(L_1 as isize),
                                                        &mut *AA_0.offset((R_1 - 1 as libc::c_int) as isize),
                                                    ) > 0 as libc::c_int
                                                    {
                                                        let mut TMP_7: DFL = *AA_0.offset(L_1 as isize);
                                                        *AA_0
                                                            .offset(
                                                                L_1 as isize,
                                                            ) = *AA_0.offset((R_1 - 1 as libc::c_int) as isize);
                                                        *AA_0.offset((R_1 - 1 as libc::c_int) as isize) = TMP_7;
                                                    }
                                                    if lglcmpdfl(
                                                        &mut *AA_0.offset(L_1 as isize),
                                                        &mut *AA_0.offset(R_1 as isize),
                                                    ) > 0 as libc::c_int
                                                    {
                                                        let mut TMP_8: DFL = *AA_0.offset(L_1 as isize);
                                                        *AA_0.offset(L_1 as isize) = *AA_0.offset(R_1 as isize);
                                                        *AA_0.offset(R_1 as isize) = TMP_8;
                                                    }
                                                    if lglcmpdfl(
                                                        &mut *AA_0.offset((R_1 - 1 as libc::c_int) as isize),
                                                        &mut *AA_0.offset(R_1 as isize),
                                                    ) > 0 as libc::c_int
                                                    {
                                                        let mut TMP_9: DFL = *AA_0
                                                            .offset((R_1 - 1 as libc::c_int) as isize);
                                                        *AA_0
                                                            .offset(
                                                                (R_1 - 1 as libc::c_int) as isize,
                                                            ) = *AA_0.offset(R_1 as isize);
                                                        *AA_0.offset(R_1 as isize) = TMP_9;
                                                    }
                                                    let mut PIVOT_1: DFL = DFL {
                                                        discovered: 0,
                                                        finished: 0,
                                                        c2rust_unnamed: C2RustUnnamed_140 { lit: 0 },
                                                    };
                                                    let mut J_1: libc::c_int = R_1 - 1 as libc::c_int;
                                                    I_1 = L_1 + 1 as libc::c_int - 1 as libc::c_int;
                                                    PIVOT_1 = *AA_0.offset(J_1 as isize);
                                                    loop {
                                                        loop {
                                                            I_1 += 1;
                                                            if !(lglcmpdfl(
                                                                &mut *AA_0.offset(I_1 as isize),
                                                                &mut PIVOT_1,
                                                            ) < 0 as libc::c_int)
                                                            {
                                                                break;
                                                            }
                                                        }
                                                        loop {
                                                            J_1 -= 1;
                                                            if !(lglcmpdfl(
                                                                &mut PIVOT_1,
                                                                &mut *AA_0.offset(J_1 as isize),
                                                            ) < 0 as libc::c_int)
                                                            {
                                                                break;
                                                            }
                                                            if J_1 == L_1 + 1 as libc::c_int {
                                                                break;
                                                            }
                                                        }
                                                        if I_1 >= J_1 {
                                                            break;
                                                        }
                                                        let mut TMP_10: DFL = *AA_0.offset(I_1 as isize);
                                                        *AA_0.offset(I_1 as isize) = *AA_0.offset(J_1 as isize);
                                                        *AA_0.offset(J_1 as isize) = TMP_10;
                                                    }
                                                    let mut TMP_11: DFL = *AA_0.offset(I_1 as isize);
                                                    *AA_0
                                                        .offset(
                                                            I_1 as isize,
                                                        ) = *AA_0.offset((R_1 - 1 as libc::c_int) as isize);
                                                    *AA_0.offset((R_1 - 1 as libc::c_int) as isize) = TMP_11;
                                                    if I_1 - L_1 < R_1 - I_1 {
                                                        LL_0 = I_1 + 1 as libc::c_int;
                                                        RR_0 = R_1;
                                                        R_1 = I_1 - 1 as libc::c_int;
                                                    } else {
                                                        LL_0 = L_1;
                                                        RR_0 = I_1 - 1 as libc::c_int;
                                                        L_1 = I_1 + 1 as libc::c_int;
                                                    }
                                                    if R_1 - L_1 > 10 as libc::c_int {
                                                        lglpushstk(lgl, &mut (*lgl).c2rust_unnamed_0.sortstk, LL_0);
                                                        lglpushstk(lgl, &mut (*lgl).c2rust_unnamed_0.sortstk, RR_0);
                                                    } else if RR_0 - LL_0 > 10 as libc::c_int {
                                                        L_1 = LL_0;
                                                        R_1 = RR_0;
                                                    } else {
                                                        if !(lglmtstk(&mut (*lgl).c2rust_unnamed_0.sortstk) == 0) {
                                                            break;
                                                        }
                                                        R_1 = lglpopstk(&mut (*lgl).c2rust_unnamed_0.sortstk);
                                                        L_1 = lglpopstk(&mut (*lgl).c2rust_unnamed_0.sortstk);
                                                    }
                                                }
                                            }
                                            let mut PIVOT_2: DFL = DFL {
                                                discovered: 0,
                                                finished: 0,
                                                c2rust_unnamed: C2RustUnnamed_140 { lit: 0 },
                                            };
                                            let mut L_2: libc::c_int = 0 as libc::c_int;
                                            let mut R_2: libc::c_int = NN_0 - 1 as libc::c_int;
                                            let mut I_2: libc::c_int = 0;
                                            let mut J_2: libc::c_int = 0;
                                            I_2 = R_2;
                                            while I_2 > L_2 {
                                                if lglcmpdfl(
                                                    &mut *AA_0.offset((I_2 - 1 as libc::c_int) as isize),
                                                    &mut *AA_0.offset(I_2 as isize),
                                                ) > 0 as libc::c_int
                                                {
                                                    let mut TMP_12: DFL = *AA_0
                                                        .offset((I_2 - 1 as libc::c_int) as isize);
                                                    *AA_0
                                                        .offset(
                                                            (I_2 - 1 as libc::c_int) as isize,
                                                        ) = *AA_0.offset(I_2 as isize);
                                                    *AA_0.offset(I_2 as isize) = TMP_12;
                                                }
                                                I_2 -= 1;
                                                I_2;
                                            }
                                            I_2 = L_2 + 2 as libc::c_int;
                                            while I_2 <= R_2 {
                                                J_2 = I_2;
                                                PIVOT_2 = *AA_0.offset(I_2 as isize);
                                                while lglcmpdfl(
                                                    &mut PIVOT_2,
                                                    &mut *AA_0.offset((J_2 - 1 as libc::c_int) as isize),
                                                ) < 0 as libc::c_int
                                                {
                                                    *AA_0
                                                        .offset(
                                                            J_2 as isize,
                                                        ) = *AA_0.offset((J_2 - 1 as libc::c_int) as isize);
                                                    J_2 -= 1;
                                                    J_2;
                                                }
                                                *AA_0.offset(J_2 as isize) = PIVOT_2;
                                                I_2 += 1;
                                                I_2;
                                            }
                                            eodfl = dfl.offset(ndfl as isize);
                                            d = dfl;
                                            while d < eodfl.offset(-(1 as libc::c_int as isize)) {
                                                e = d.offset(1 as libc::c_int as isize);
                                                while e < eodfl && (*d).finished >= (*e).finished {
                                                    lit = (*e).c2rust_unnamed.lit;
                                                    (*e).c2rust_unnamed.lit = 0 as libc::c_int;
                                                    nstr += 1;
                                                    nstr;
                                                    (*(*lgl).stats).unhd.str_0.lrg += 1;
                                                    (*(*lgl).stats).unhd.str_0.lrg;
                                                    if red != 0 {
                                                        (*(*lgl).stats).unhd.str_0.red += 1;
                                                        (*(*lgl).stats).unhd.str_0.red;
                                                    }
                                                    (*(*lgl).stats).prgss += 1;
                                                    (*(*lgl).stats).prgss;
                                                    if !(watched == 0) {
                                                        if !(lit != *c.offset(0 as libc::c_int as isize)
                                                            && lit != *c.offset(1 as libc::c_int as isize))
                                                        {
                                                            lglrmlwch(
                                                                lgl,
                                                                *c.offset(0 as libc::c_int as isize),
                                                                red,
                                                                lidx,
                                                            );
                                                            lglrmlwch(
                                                                lgl,
                                                                *c.offset(1 as libc::c_int as isize),
                                                                red,
                                                                lidx,
                                                            );
                                                            watched = 0 as libc::c_int;
                                                        }
                                                    }
                                                    e = e.offset(1);
                                                    e;
                                                }
                                                d = e;
                                            }
                                            q = c;
                                            if watched != 0 {
                                                q = q.offset(2 as libc::c_int as isize);
                                            }
                                            p = q;
                                            while p < eoc {
                                                lit = *p;
                                                ulit = lglulit(-lit);
                                                if !((*dfpr.offset(ulit as isize)).discovered != 0) {
                                                    let fresh233 = q;
                                                    q = q.offset(1);
                                                    *fresh233 = lit;
                                                }
                                                p = p.offset(1);
                                                p;
                                            }
                                            d = dfl;
                                            while d < eodfl {
                                                lit = (*d).c2rust_unnamed.lit;
                                                if !(lit == 0) {
                                                    if !(watched != 0
                                                        && lit == *c.offset(0 as libc::c_int as isize))
                                                    {
                                                        if !(watched != 0
                                                            && lit == *c.offset(1 as libc::c_int as isize))
                                                        {
                                                            let fresh234 = q;
                                                            q = q.offset(1);
                                                            *fresh234 = lit;
                                                        }
                                                    }
                                                }
                                                d = d.offset(1);
                                                d;
                                            }
                                            eoc = q;
                                            *eoc = 0 as libc::c_int;
                                        }
                                    }
                                    if posdfl < 2 as libc::c_int {
                                        current_block = 7591767349337963548;
                                    } else {
                                        if posdfl > szdfl {
                                            dfl = lglrsz(
                                                lgl,
                                                dfl as *mut libc::c_void,
                                                (szdfl as libc::c_ulong)
                                                    .wrapping_mul(
                                                        ::core::mem::size_of::<DFL>() as libc::c_ulong,
                                                    ),
                                                (posdfl as libc::c_ulong)
                                                    .wrapping_mul(
                                                        ::core::mem::size_of::<DFL>() as libc::c_ulong,
                                                    ),
                                            ) as *mut DFL;
                                            szdfl = posdfl;
                                        }
                                        ndfl = 0 as libc::c_int;
                                        p = c;
                                        while p < eoc {
                                            lit = *p;
                                            ulit = lglulit(lit);
                                            if !((*dfpr.offset(ulit as isize)).discovered == 0) {
                                                (*dfl.offset(ndfl as isize))
                                                    .discovered = -(*dfpr.offset(ulit as isize)).discovered;
                                                (*dfl.offset(ndfl as isize))
                                                    .finished = -(*dfpr.offset(ulit as isize)).finished;
                                                (*dfl.offset(ndfl as isize)).c2rust_unnamed.lit = lit;
                                                ndfl += 1;
                                                ndfl;
                                            }
                                            p = p.offset(1);
                                            p;
                                        }
                                        if ndfl < 2 as libc::c_int {
                                            current_block = 9360437562037878177;
                                        } else {
                                            (*(*lgl).stats).steps += 3 as libc::c_int as int64_t;
                                            (*(*lgl).stats).unhd.steps += 3 as libc::c_int as int64_t;
                                            let mut AA_1: *mut DFL = dfl;
                                            let NN_1: libc::c_int = ndfl;
                                            let mut L_3: libc::c_int = 0 as libc::c_int;
                                            let mut R_3: libc::c_int = NN_1 - 1 as libc::c_int;
                                            let mut M_1: libc::c_int = 0;
                                            let mut LL_1: libc::c_int = 0;
                                            let mut RR_1: libc::c_int = 0;
                                            let mut I_3: libc::c_int = 0;
                                            if !(R_3 - L_3 <= 10 as libc::c_int) {
                                                loop {
                                                    M_1 = (L_3 + R_3) / 2 as libc::c_int;
                                                    let mut TMP_13: DFL = *AA_1.offset(M_1 as isize);
                                                    *AA_1
                                                        .offset(
                                                            M_1 as isize,
                                                        ) = *AA_1.offset((R_3 - 1 as libc::c_int) as isize);
                                                    *AA_1.offset((R_3 - 1 as libc::c_int) as isize) = TMP_13;
                                                    if lglcmpdfl(
                                                        &mut *AA_1.offset(L_3 as isize),
                                                        &mut *AA_1.offset((R_3 - 1 as libc::c_int) as isize),
                                                    ) > 0 as libc::c_int
                                                    {
                                                        let mut TMP_14: DFL = *AA_1.offset(L_3 as isize);
                                                        *AA_1
                                                            .offset(
                                                                L_3 as isize,
                                                            ) = *AA_1.offset((R_3 - 1 as libc::c_int) as isize);
                                                        *AA_1.offset((R_3 - 1 as libc::c_int) as isize) = TMP_14;
                                                    }
                                                    if lglcmpdfl(
                                                        &mut *AA_1.offset(L_3 as isize),
                                                        &mut *AA_1.offset(R_3 as isize),
                                                    ) > 0 as libc::c_int
                                                    {
                                                        let mut TMP_15: DFL = *AA_1.offset(L_3 as isize);
                                                        *AA_1.offset(L_3 as isize) = *AA_1.offset(R_3 as isize);
                                                        *AA_1.offset(R_3 as isize) = TMP_15;
                                                    }
                                                    if lglcmpdfl(
                                                        &mut *AA_1.offset((R_3 - 1 as libc::c_int) as isize),
                                                        &mut *AA_1.offset(R_3 as isize),
                                                    ) > 0 as libc::c_int
                                                    {
                                                        let mut TMP_16: DFL = *AA_1
                                                            .offset((R_3 - 1 as libc::c_int) as isize);
                                                        *AA_1
                                                            .offset(
                                                                (R_3 - 1 as libc::c_int) as isize,
                                                            ) = *AA_1.offset(R_3 as isize);
                                                        *AA_1.offset(R_3 as isize) = TMP_16;
                                                    }
                                                    let mut PIVOT_3: DFL = DFL {
                                                        discovered: 0,
                                                        finished: 0,
                                                        c2rust_unnamed: C2RustUnnamed_140 { lit: 0 },
                                                    };
                                                    let mut J_3: libc::c_int = R_3 - 1 as libc::c_int;
                                                    I_3 = L_3 + 1 as libc::c_int - 1 as libc::c_int;
                                                    PIVOT_3 = *AA_1.offset(J_3 as isize);
                                                    loop {
                                                        loop {
                                                            I_3 += 1;
                                                            if !(lglcmpdfl(
                                                                &mut *AA_1.offset(I_3 as isize),
                                                                &mut PIVOT_3,
                                                            ) < 0 as libc::c_int)
                                                            {
                                                                break;
                                                            }
                                                        }
                                                        loop {
                                                            J_3 -= 1;
                                                            if !(lglcmpdfl(
                                                                &mut PIVOT_3,
                                                                &mut *AA_1.offset(J_3 as isize),
                                                            ) < 0 as libc::c_int)
                                                            {
                                                                break;
                                                            }
                                                            if J_3 == L_3 + 1 as libc::c_int {
                                                                break;
                                                            }
                                                        }
                                                        if I_3 >= J_3 {
                                                            break;
                                                        }
                                                        let mut TMP_17: DFL = *AA_1.offset(I_3 as isize);
                                                        *AA_1.offset(I_3 as isize) = *AA_1.offset(J_3 as isize);
                                                        *AA_1.offset(J_3 as isize) = TMP_17;
                                                    }
                                                    let mut TMP_18: DFL = *AA_1.offset(I_3 as isize);
                                                    *AA_1
                                                        .offset(
                                                            I_3 as isize,
                                                        ) = *AA_1.offset((R_3 - 1 as libc::c_int) as isize);
                                                    *AA_1.offset((R_3 - 1 as libc::c_int) as isize) = TMP_18;
                                                    if I_3 - L_3 < R_3 - I_3 {
                                                        LL_1 = I_3 + 1 as libc::c_int;
                                                        RR_1 = R_3;
                                                        R_3 = I_3 - 1 as libc::c_int;
                                                    } else {
                                                        LL_1 = L_3;
                                                        RR_1 = I_3 - 1 as libc::c_int;
                                                        L_3 = I_3 + 1 as libc::c_int;
                                                    }
                                                    if R_3 - L_3 > 10 as libc::c_int {
                                                        lglpushstk(lgl, &mut (*lgl).c2rust_unnamed_0.sortstk, LL_1);
                                                        lglpushstk(lgl, &mut (*lgl).c2rust_unnamed_0.sortstk, RR_1);
                                                    } else if RR_1 - LL_1 > 10 as libc::c_int {
                                                        L_3 = LL_1;
                                                        R_3 = RR_1;
                                                    } else {
                                                        if !(lglmtstk(&mut (*lgl).c2rust_unnamed_0.sortstk) == 0) {
                                                            break;
                                                        }
                                                        R_3 = lglpopstk(&mut (*lgl).c2rust_unnamed_0.sortstk);
                                                        L_3 = lglpopstk(&mut (*lgl).c2rust_unnamed_0.sortstk);
                                                    }
                                                }
                                            }
                                            let mut PIVOT_4: DFL = DFL {
                                                discovered: 0,
                                                finished: 0,
                                                c2rust_unnamed: C2RustUnnamed_140 { lit: 0 },
                                            };
                                            let mut L_4: libc::c_int = 0 as libc::c_int;
                                            let mut R_4: libc::c_int = NN_1 - 1 as libc::c_int;
                                            let mut I_4: libc::c_int = 0;
                                            let mut J_4: libc::c_int = 0;
                                            I_4 = R_4;
                                            while I_4 > L_4 {
                                                if lglcmpdfl(
                                                    &mut *AA_1.offset((I_4 - 1 as libc::c_int) as isize),
                                                    &mut *AA_1.offset(I_4 as isize),
                                                ) > 0 as libc::c_int
                                                {
                                                    let mut TMP_19: DFL = *AA_1
                                                        .offset((I_4 - 1 as libc::c_int) as isize);
                                                    *AA_1
                                                        .offset(
                                                            (I_4 - 1 as libc::c_int) as isize,
                                                        ) = *AA_1.offset(I_4 as isize);
                                                    *AA_1.offset(I_4 as isize) = TMP_19;
                                                }
                                                I_4 -= 1;
                                                I_4;
                                            }
                                            I_4 = L_4 + 2 as libc::c_int;
                                            while I_4 <= R_4 {
                                                J_4 = I_4;
                                                PIVOT_4 = *AA_1.offset(I_4 as isize);
                                                while lglcmpdfl(
                                                    &mut PIVOT_4,
                                                    &mut *AA_1.offset((J_4 - 1 as libc::c_int) as isize),
                                                ) < 0 as libc::c_int
                                                {
                                                    *AA_1
                                                        .offset(
                                                            J_4 as isize,
                                                        ) = *AA_1.offset((J_4 - 1 as libc::c_int) as isize);
                                                    J_4 -= 1;
                                                    J_4;
                                                }
                                                *AA_1.offset(J_4 as isize) = PIVOT_4;
                                                I_4 += 1;
                                                I_4;
                                            }
                                            eodfl = dfl.offset(ndfl as isize);
                                            d = dfl;
                                            while d < eodfl.offset(-(1 as libc::c_int as isize)) {
                                                e = d.offset(1 as libc::c_int as isize);
                                                while e < eodfl && (*d).finished >= (*e).finished {
                                                    lit = (*e).c2rust_unnamed.lit;
                                                    (*e).c2rust_unnamed.lit = 0 as libc::c_int;
                                                    nstr += 1;
                                                    nstr;
                                                    (*(*lgl).stats).unhd.str_0.lrg += 1;
                                                    (*(*lgl).stats).unhd.str_0.lrg;
                                                    if red != 0 {
                                                        (*(*lgl).stats).unhd.str_0.red += 1;
                                                        (*(*lgl).stats).unhd.str_0.red;
                                                    }
                                                    (*(*lgl).stats).prgss += 1;
                                                    (*(*lgl).stats).prgss;
                                                    if !(watched == 0) {
                                                        if !(lit != *c.offset(0 as libc::c_int as isize)
                                                            && lit != *c.offset(1 as libc::c_int as isize))
                                                        {
                                                            lglrmlwch(
                                                                lgl,
                                                                *c.offset(0 as libc::c_int as isize),
                                                                red,
                                                                lidx,
                                                            );
                                                            lglrmlwch(
                                                                lgl,
                                                                *c.offset(1 as libc::c_int as isize),
                                                                red,
                                                                lidx,
                                                            );
                                                            watched = 0 as libc::c_int;
                                                        }
                                                    }
                                                    e = e.offset(1);
                                                    e;
                                                }
                                                d = e;
                                            }
                                            q = c;
                                            if watched != 0 {
                                                q = q.offset(2 as libc::c_int as isize);
                                            }
                                            p = q;
                                            while p < eoc {
                                                lit = *p;
                                                ulit = lglulit(lit);
                                                if !((*dfpr.offset(ulit as isize)).discovered != 0) {
                                                    let fresh235 = q;
                                                    q = q.offset(1);
                                                    *fresh235 = lit;
                                                }
                                                p = p.offset(1);
                                                p;
                                            }
                                            d = dfl;
                                            while d < eodfl {
                                                lit = (*d).c2rust_unnamed.lit;
                                                if !(lit == 0) {
                                                    if !(watched != 0
                                                        && lit == *c.offset(0 as libc::c_int as isize))
                                                    {
                                                        if !(watched != 0
                                                            && lit == *c.offset(1 as libc::c_int as isize))
                                                        {
                                                            let fresh236 = q;
                                                            q = q.offset(1);
                                                            *fresh236 = lit;
                                                        }
                                                    }
                                                }
                                                d = d.offset(1);
                                                d;
                                            }
                                            eoc = q;
                                            *eoc = 0 as libc::c_int;
                                            current_block = 7591767349337963548;
                                        }
                                    }
                                    match current_block {
                                        9360437562037878177 => {}
                                        _ => {
                                            if !((*(*lgl).opts).unhdhbr.val == 0) {
                                                if !((eoc.offset_from(c) as libc::c_long)
                                                    < 3 as libc::c_int as libc::c_long)
                                                {
                                                    lca2 = 0 as libc::c_int;
                                                    lca1 = lca2;
                                                    root2 = lca1;
                                                    root1 = root2;
                                                    p = c;
                                                    loop {
                                                        lit = *p;
                                                        if !(lit != 0) {
                                                            current_block = 3633482119941412886;
                                                            break;
                                                        }
                                                        root = lglunhroot(dfpr, -lit);
                                                        if root == 0 {
                                                            root = -lit;
                                                        }
                                                        if root1 == 0 {
                                                            root1 = root;
                                                        } else if !(root1 == root) {
                                                            if root2 == 0 {
                                                                root2 = root;
                                                            } else if !(root2 == root) {
                                                                if lglunhimplies2incl(dfpr, root1, -lit) != 0 {
                                                                    lca1 = root1;
                                                                } else {
                                                                    if !(lglunhimplies2incl(dfpr, root2, -lit) != 0) {
                                                                        current_block = 9360437562037878177;
                                                                        break;
                                                                    }
                                                                    lca2 = root2;
                                                                }
                                                            }
                                                        }
                                                        p = p.offset(1);
                                                        p;
                                                    }
                                                    match current_block {
                                                        9360437562037878177 => {}
                                                        _ => {
                                                            if !(root2 == 0) {
                                                                if !(root1 == -root2) {
                                                                    if !(lglunhimplies2incl(dfpr, root1, -root2) != 0) {
                                                                        if lca1 == 0 && lca2 == 0 {
                                                                            p = c;
                                                                            loop {
                                                                                lit = *p;
                                                                                if !(lit != 0) {
                                                                                    break;
                                                                                }
                                                                                root = lglunhroot(dfpr, -lit);
                                                                                if root != 0 {
                                                                                    if root == root1 {
                                                                                        lca1 = if lca1 != 0 {
                                                                                            lglunhlca(lgl, dfpr, lca1, -lit)
                                                                                        } else {
                                                                                            -lit
                                                                                        };
                                                                                    }
                                                                                    if root == root2 {
                                                                                        lca2 = if lca2 != 0 {
                                                                                            lglunhlca(lgl, dfpr, lca2, -lit)
                                                                                        } else {
                                                                                            -lit
                                                                                        };
                                                                                    }
                                                                                } else if lca1 != 0 {
                                                                                    lca2 = -lit;
                                                                                } else {
                                                                                    lca1 = -lit;
                                                                                }
                                                                                p = p.offset(1);
                                                                                p;
                                                                            }
                                                                        } else {
                                                                            if lca1 == 0 {
                                                                                lca1 = root1;
                                                                            }
                                                                            if lca2 == 0 {
                                                                                lca2 = root2;
                                                                            }
                                                                        }
                                                                        if !(lca1 == -lca2) {
                                                                            if !(lglunhimplies2incl(dfpr, lca1, -lca2) != 0) {
                                                                                (*(*lgl).stats).unhd.hbrs.lrg += 1;
                                                                                (*(*lgl).stats).unhd.hbrs.lrg;
                                                                                if red != 0 {
                                                                                    (*(*lgl).stats).unhd.hbrs.red += 1;
                                                                                    (*(*lgl).stats).unhd.hbrs.red;
                                                                                }
                                                                                lgldrupligaddclsarg(
                                                                                    lgl,
                                                                                    REDCS as libc::c_int,
                                                                                    -lca1,
                                                                                    -lca2,
                                                                                    0 as libc::c_int,
                                                                                );
                                                                                lglwchbin(lgl, -lca1, -lca2, REDCS as libc::c_int);
                                                                                lglwchbin(lgl, -lca2, -lca1, REDCS as libc::c_int);
                                                                                (*(*lgl).stats).red.bin += 1;
                                                                                (*(*lgl).stats).red.bin;
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                newsize = eoc.offset_from(c) as libc::c_long as libc::c_int;
                if newsize <= 3 as libc::c_int || satisfied != 0 || tautological != 0 {
                    lgldeclscnt(lgl, oldsize, red, glue);
                    if watched != 0 {
                        lglrmlwch(lgl, *c.offset(0 as libc::c_int as isize), red, lidx);
                        lglrmlwch(lgl, *c.offset(1 as libc::c_int as isize), red, lidx);
                    }
                } else if red == 0 {
                    (*(*lgl).stats)
                        .irr
                        .lits
                        .cur = ((*(*lgl).stats).irr.lits.cur as libc::c_long
                        - c.offset(oldsize as isize).offset_from(eoc) as libc::c_long)
                        as libc::c_int;
                }
                p = c.offset(oldsize as isize);
                while p > eoc {
                    *p = 2147483647 as libc::c_int;
                    p = p.offset(-1);
                    p;
                }
                if satisfied != 0 || tautological != 0 {
                    while p >= c {
                        let fresh237 = p;
                        p = p.offset(-1);
                        *fresh237 = 2147483647 as libc::c_int;
                    }
                    if red != 0 {
                        *c
                            .offset(
                                -(1 as libc::c_int) as isize,
                            ) = 2147483647 as libc::c_int;
                    }
                    eoc = c.offset(oldsize as isize);
                } else {
                    if newsize < oldsize {
                        lgldrupligaddclsaux(lgl, REDCS as libc::c_int, c);
                    }
                    if red != 0 && newsize <= 3 as libc::c_int {
                        *c
                            .offset(
                                -(1 as libc::c_int) as isize,
                            ) = 2147483647 as libc::c_int;
                    }
                    if newsize > 3 as libc::c_int && watched == 0 {
                        lglwchlrg(
                            lgl,
                            *c.offset(0 as libc::c_int as isize),
                            *c.offset(1 as libc::c_int as isize),
                            red,
                            lidx,
                        );
                        lglwchlrg(
                            lgl,
                            *c.offset(1 as libc::c_int as isize),
                            *c.offset(0 as libc::c_int as isize),
                            red,
                            lidx,
                        );
                    } else if newsize == 3 as libc::c_int {
                        lglwchtrn(
                            lgl,
                            *c.offset(0 as libc::c_int as isize),
                            *c.offset(1 as libc::c_int as isize),
                            *c.offset(2 as libc::c_int as isize),
                            red,
                        );
                        lglwchtrn(
                            lgl,
                            *c.offset(1 as libc::c_int as isize),
                            *c.offset(0 as libc::c_int as isize),
                            *c.offset(2 as libc::c_int as isize),
                            red,
                        );
                        lglwchtrn(
                            lgl,
                            *c.offset(2 as libc::c_int as isize),
                            *c.offset(0 as libc::c_int as isize),
                            *c.offset(1 as libc::c_int as isize),
                            red,
                        );
                        if red == 0 {
                            lglincirr(lgl, 3 as libc::c_int);
                        } else {
                            (*(*lgl).stats).red.trn += 1;
                            (*(*lgl).stats).red.trn;
                        }
                        *eoc = 2147483647 as libc::c_int;
                        let ref mut fresh238 = *c.offset(2 as libc::c_int as isize);
                        *fresh238 = *eoc;
                        let ref mut fresh239 = *c.offset(1 as libc::c_int as isize);
                        *fresh239 = *fresh238;
                        *c.offset(0 as libc::c_int as isize) = *fresh239;
                    } else if newsize == 2 as libc::c_int {
                        lglwchbin(
                            lgl,
                            *c.offset(0 as libc::c_int as isize),
                            *c.offset(1 as libc::c_int as isize),
                            red,
                        );
                        lglwchbin(
                            lgl,
                            *c.offset(1 as libc::c_int as isize),
                            *c.offset(0 as libc::c_int as isize),
                            red,
                        );
                        if red == 0 {
                            lglincirr(lgl, 2 as libc::c_int);
                        } else {
                            (*(*lgl).stats).red.bin += 1;
                            (*(*lgl).stats).red.bin;
                        }
                        *eoc = 2147483647 as libc::c_int;
                        let ref mut fresh240 = *c.offset(1 as libc::c_int as isize);
                        *fresh240 = *eoc;
                        *c.offset(0 as libc::c_int as isize) = *fresh240;
                    } else if newsize == 1 as libc::c_int {
                        unit = *c.offset(0 as libc::c_int as isize);
                        *eoc = 2147483647 as libc::c_int;
                        *c.offset(0 as libc::c_int as isize) = *eoc;
                        (*(*lgl).stats).unhd.units.lrg += 1;
                        (*(*lgl).stats).unhd.units.lrg;
                        nunits += 1;
                        nunits;
                    }
                    if !(unit == 0) {
                        lglunit(lgl, unit);
                        if !(lglbcp(lgl) != 0) {
                            lglmt(lgl);
                            res = 0 as libc::c_int;
                        }
                    }
                }
            }
            c = eoc.offset(1 as libc::c_int as isize);
        }
    }
    nunits != 0;
    ntaut != 0;
    nstr != 0;
    nhbrs != 0;
    if !dfl.is_null() {
        lgldel(
            lgl,
            dfl as *mut libc::c_void,
            (szdfl as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<DFL>() as libc::c_ulong),
        );
        dfl = 0 as *mut DFL;
    }
    return res;
}
unsafe extern "C" fn lglfixlrgwchs(mut lgl: *mut LGL) {
    let mut idx: libc::c_int = 0;
    let mut sign: libc::c_int = 0;
    let mut lit: libc::c_int = 0;
    let mut blit: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut red: libc::c_int = 0;
    let mut lidx: libc::c_int = 0;
    let mut fixed: libc::c_int = 0;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut eow: *const libc::c_int = 0 as *const libc::c_int;
    let mut c: *const libc::c_int = 0 as *const libc::c_int;
    let mut q: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut w: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut hts: *mut HTS = 0 as *mut HTS;
    fixed = 0 as libc::c_int;
    idx = 2 as libc::c_int;
    while idx < (*lgl).nvars {
        sign = -(1 as libc::c_int);
        while sign <= 1 as libc::c_int {
            lit = sign * idx;
            hts = lglhts(lgl, lit);
            w = lglhts2wchs(lgl, hts);
            eow = w.offset((*hts).count as isize);
            q = w;
            p = w;
            while p < eow {
                blit = *p;
                tag = blit & MASKCS as libc::c_int;
                if tag == BINCS as libc::c_int {
                    let fresh241 = q;
                    q = q.offset(1);
                    *fresh241 = blit;
                } else {
                    p = p.offset(1);
                    lidx = *p;
                    if tag == TRNCS as libc::c_int {
                        let fresh242 = q;
                        q = q.offset(1);
                        *fresh242 = blit;
                        let fresh243 = q;
                        q = q.offset(1);
                        *fresh243 = lidx;
                    } else {
                        red = blit & REDCS as libc::c_int;
                        c = lglidx2lits(lgl, red, lidx);
                        if *c >= 2147483647 as libc::c_int >> RMSHFT as libc::c_int {
                            fixed += 1;
                            fixed;
                        } else {
                            let fresh244 = q;
                            q = q.offset(1);
                            *fresh244 = blit;
                            let fresh245 = q;
                            q = q.offset(1);
                            *fresh245 = lidx;
                        }
                    }
                }
                p = p.offset(1);
                p;
            }
            lglshrinkhts(
                lgl,
                hts,
                ((*hts).count as libc::c_long - p.offset_from(q) as libc::c_long)
                    as libc::c_int,
            );
            sign += 2 as libc::c_int;
        }
        idx += 1;
        idx;
    }
    fixed != 0;
}
unsafe extern "C" fn lglunhidelrg(
    mut lgl: *mut LGL,
    mut dfpr: *const DFPR,
    mut irronly: libc::c_int,
) -> libc::c_int {
    let mut glue: libc::c_int = 0;
    let mut res: libc::c_int = 1 as libc::c_int;
    glue = -(1 as libc::c_int);
    while res != 0 && glue < ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int
    {
        res = lglunhideglue(lgl, dfpr, glue, irronly);
        glue += 1;
        glue;
    }
    lglfixlrgwchs(lgl);
    return res;
}
unsafe extern "C" fn lglunhdunits(mut lgl: *mut LGL) -> libc::c_int {
    let mut res: libc::c_int = (*(*lgl).stats).unhd.units.bin;
    res += (*(*lgl).stats).unhd.units.trn;
    res += (*(*lgl).stats).unhd.units.lrg;
    return res;
}
unsafe extern "C" fn lglunhdfailed(mut lgl: *mut LGL) -> libc::c_int {
    let mut res: libc::c_int = (*(*lgl).stats).unhd.stamp.failed;
    res += (*(*lgl).stats).unhd.failed.lits;
    res += (*(*lgl).stats).unhd.failed.bin;
    res += (*(*lgl).stats).unhd.failed.trn;
    res += (*(*lgl).stats).unhd.failed.lrg;
    return res;
}
unsafe extern "C" fn lglunhdhbrs(mut lgl: *mut LGL) -> libc::c_int {
    let mut res: libc::c_int = (*(*lgl).stats).unhd.hbrs.trn;
    res += (*(*lgl).stats).unhd.hbrs.lrg;
    return res;
}
unsafe extern "C" fn lglunhdtauts(mut lgl: *mut LGL) -> libc::c_int {
    let mut res: libc::c_int = (*(*lgl).stats).unhd.stamp.trds;
    res += (*(*lgl).stats).unhd.tauts.bin;
    res += (*(*lgl).stats).unhd.tauts.trn;
    res += (*(*lgl).stats).unhd.tauts.lrg;
    return res;
}
unsafe extern "C" fn lglunhdstrd(mut lgl: *mut LGL) -> libc::c_int {
    let mut res: libc::c_int = (*(*lgl).stats).unhd.units.bin;
    res += (*(*lgl).stats).unhd.str_0.trn;
    res += (*(*lgl).stats).unhd.str_0.lrg;
    return res;
}
unsafe extern "C" fn lglrmbindup(mut lgl: *mut LGL) {
    let mut idx: libc::c_int = 0;
    let mut sign: libc::c_int = 0;
    let mut lit: libc::c_int = 0;
    let mut blit: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut red: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut round: libc::c_int = 0;
    let mut redrem: libc::c_int = 0;
    let mut irrem: libc::c_int = 0;
    let mut w: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut eow: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut p: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut q: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut hts: *mut HTS = 0 as *mut HTS;
    irrem = 0 as libc::c_int;
    redrem = irrem;
    idx = 2 as libc::c_int;
    while idx < (*lgl).nvars {
        sign = -(1 as libc::c_int);
        while sign <= 1 as libc::c_int {
            lit = sign * idx;
            round = 0 as libc::c_int;
            while round < 2 as libc::c_int {
                hts = lglhts(lgl, lit);
                w = lglhts2wchs(lgl, hts);
                eow = w.offset((*hts).count as isize);
                q = w;
                p = w;
                while p < eow {
                    blit = *p;
                    tag = blit & MASKCS as libc::c_int;
                    if tag != BINCS as libc::c_int {
                        let fresh246 = q;
                        q = q.offset(1);
                        *fresh246 = blit;
                    }
                    if tag == LRGCS as libc::c_int || tag == TRNCS as libc::c_int {
                        p = p.offset(1);
                        let fresh247 = q;
                        q = q.offset(1);
                        *fresh247 = *p;
                    }
                    if !(tag != BINCS as libc::c_int) {
                        red = blit & REDCS as libc::c_int;
                        other = blit >> RMSHFT as libc::c_int;
                        let mut current_block_36: u64;
                        if lglsignedmarked(lgl, other) != 0 {
                            if round != 0 && red == 0 {
                                current_block_36 = 13693168871757163229;
                            } else {
                                if red != 0 {
                                    redrem += 1;
                                    redrem;
                                } else {
                                    irrem += 1;
                                    irrem;
                                }
                                if abs(lit) > abs(other) {
                                    lgldeclscnt(lgl, 2 as libc::c_int, red, 0 as libc::c_int);
                                    if red == 0 && (*lgl).dense as libc::c_int != 0 {
                                        lgldecocc(lgl, lit);
                                        lgldecocc(lgl, other);
                                    }
                                    (*(*lgl).stats).bindup.removed += 1;
                                    (*(*lgl).stats).bindup.removed;
                                    if red != 0 {
                                        (*(*lgl).stats).bindup.red += 1;
                                        (*(*lgl).stats).bindup.red;
                                    }
                                }
                                current_block_36 = 8845338526596852646;
                            }
                        } else {
                            if round == 0 && red == 0 || round != 0 && red != 0 {
                                lglsignedmarknpushseen(lgl, other);
                            }
                            current_block_36 = 13693168871757163229;
                        }
                        match current_block_36 {
                            13693168871757163229 => {
                                let fresh248 = q;
                                q = q.offset(1);
                                *fresh248 = blit;
                            }
                            _ => {}
                        }
                    }
                    p = p.offset(1);
                    p;
                }
                lglshrinkhts(
                    lgl,
                    hts,
                    ((*hts).count as libc::c_long - p.offset_from(q) as libc::c_long)
                        as libc::c_int,
                );
                round += 1;
                round;
            }
            lglpopnunmarkstk(lgl, &mut (*lgl).seen);
            sign += 2 as libc::c_int;
        }
        idx += 1;
        idx;
    }
}
unsafe extern "C" fn lglstampall(
    mut lgl: *mut LGL,
    mut irronly: libc::c_int,
) -> *mut DFPR {
    let mut current_block: u64;
    let mut roots: libc::c_int = 0;
    let mut searches: libc::c_int = 0;
    let mut noimpls: libc::c_int = 0;
    let mut unassigned: libc::c_int = 0;
    let mut visited: libc::c_int = 0;
    let mut pos: libc::c_uint = 0;
    let mut delta: libc::c_uint = 0;
    let mut mod_0: libc::c_uint = 0;
    let mut ulit: libc::c_uint = 0;
    let mut first: libc::c_uint = 0;
    let mut last: libc::c_uint = 0;
    let mut count: libc::c_uint = 0;
    let mut root: libc::c_int = 0;
    let mut stamp: libc::c_int = 0;
    let mut rootsonly: libc::c_int = 0;
    let mut lit: libc::c_int = 0;
    let mut units: Stk = Stk {
        start: 0 as *mut libc::c_int,
        top: 0 as *mut libc::c_int,
        end: 0 as *mut libc::c_int,
    };
    let mut sccs: Stk = Stk {
        start: 0 as *mut libc::c_int,
        top: 0 as *mut libc::c_int,
        end: 0 as *mut libc::c_int,
    };
    let mut trds: Stk = Stk {
        start: 0 as *mut libc::c_int,
        top: 0 as *mut libc::c_int,
        end: 0 as *mut libc::c_int,
    };
    let mut dfopf: *mut DFOPF = 0 as *mut DFOPF;
    let mut q: *mut DFOPF = 0 as *mut DFOPF;
    let mut dfpr: *mut DFPR = 0 as *mut DFPR;
    let mut work: Wtk = Wtk {
        start: 0 as *mut Work,
        top: 0 as *mut Work,
        end: 0 as *mut Work,
    };
    let mut val: Val = 0;
    if (*lgl).nvars <= 2 as libc::c_int {
        return 0 as *mut DFPR;
    }
    lglrmbindup(lgl);
    dfpr = lglnew(
        lgl,
        ((2 as libc::c_int * (*lgl).nvars) as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<DFPR>() as libc::c_ulong),
    ) as *mut DFPR;
    dfopf = lglnew(
        lgl,
        ((2 as libc::c_int * (*lgl).nvars) as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<DFOPF>() as libc::c_ulong),
    ) as *mut DFOPF;
    memset(
        &mut work as *mut Wtk as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<Wtk>() as libc::c_ulong,
    );
    memset(
        &mut sccs as *mut Stk as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<Stk>() as libc::c_ulong,
    );
    memset(
        &mut trds as *mut Stk as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<Stk>() as libc::c_ulong,
    );
    memset(
        &mut units as *mut Stk as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<Stk>() as libc::c_ulong,
    );
    q = dfopf;
    while q < dfopf.offset((2 as libc::c_int * (*lgl).nvars) as isize) {
        (*q).pushed = -(1 as libc::c_int);
        q = q.offset(1);
        q;
    }
    visited = 0 as libc::c_int;
    stamp = visited;
    unassigned = stamp;
    noimpls = unassigned;
    roots = noimpls;
    searches = roots;
    rootsonly = 1 as libc::c_int;
    's_123: loop {
        if !(rootsonly >= 0 as libc::c_int) {
            current_block = 5854763015135596753;
            break;
        }
        count = 0 as libc::c_int as libc::c_uint;
        mod_0 = (2 as libc::c_int * ((*lgl).nvars - 2 as libc::c_int)) as libc::c_uint;
        first = mod_0;
        pos = (lglrand(lgl)).wrapping_rem(mod_0);
        delta = (lglrand(lgl)).wrapping_rem(mod_0);
        if delta == 0 {
            delta = delta.wrapping_add(1);
            delta;
        }
        while lglgcd(delta, mod_0) > 1 as libc::c_int as libc::c_uint {
            delta = delta.wrapping_add(1);
            if delta == mod_0 {
                delta = 1 as libc::c_int as libc::c_uint;
            }
        }
        loop {
            if lglterminate(lgl) != 0 {
                searches = 0 as libc::c_int;
                current_block = 17561254369962025775;
                break 's_123;
            } else {
                if lglsyncunits(lgl) == 0 {
                    current_block = 17561254369962025775;
                    break 's_123;
                }
                ulit = pos.wrapping_add(4 as libc::c_int as libc::c_uint);
                root = lglilit(ulit as libc::c_int);
                (*(*lgl).stats).steps += 1;
                (*(*lgl).stats).steps;
                (*(*lgl).stats).unhd.steps += 1;
                (*(*lgl).stats).unhd.steps;
                count = count.wrapping_add(1);
                count;
                if !(lglval(lgl, root) != 0) {
                    if rootsonly != 0 {
                        unassigned += 1;
                        unassigned;
                    }
                    if !((*dfpr.offset(lglulit(root) as isize)).discovered != 0) {
                        if !(rootsonly != 0
                            && lglunhdisroot(lgl, root, dfpr, irronly) == 0)
                        {
                            if lglunhdhasbins(lgl, dfpr, -root, irronly) == 0 {
                                if rootsonly != 0 {
                                    noimpls += 1;
                                    noimpls;
                                }
                            } else {
                                if rootsonly != 0 {
                                    roots += 1;
                                    roots;
                                }
                                searches += 1;
                                searches;
                                stamp = lglstamp(
                                    lgl,
                                    root,
                                    dfpr,
                                    dfopf,
                                    &mut work,
                                    &mut units,
                                    &mut sccs,
                                    &mut trds,
                                    &mut visited,
                                    stamp,
                                    irronly,
                                );
                                while lglmtstk(&mut units) == 0 {
                                    lit = lglpopstk(&mut units);
                                    val = lglval(lgl, lit);
                                    if val as libc::c_int > 0 as libc::c_int {
                                        continue;
                                    }
                                    if (val as libc::c_int) < 0 as libc::c_int {
                                        lglmt(lgl);
                                        current_block = 17561254369962025775;
                                        break 's_123;
                                    } else {
                                        lglunit(lgl, lit);
                                        if !(lglbcp(lgl) == 0) {
                                            continue;
                                        }
                                        lglmt(lgl);
                                        current_block = 17561254369962025775;
                                        break 's_123;
                                    }
                                }
                            }
                        }
                    }
                }
                last = pos;
                pos = pos.wrapping_add(delta);
                if pos >= mod_0 {
                    pos = pos.wrapping_sub(mod_0);
                }
                if pos == first {
                    break;
                }
                if mod_0 == 1 as libc::c_int as libc::c_uint {
                    break;
                }
                if first == mod_0 {
                    first = last;
                }
            }
        }
        rootsonly -= 1;
        rootsonly;
    }
    match current_block {
        5854763015135596753 => {
            lglprt(
                lgl,
                2 as libc::c_int,
                b"[unhd-%d-%d] %d unassigned variables out of %d (%.0f%%)\0" as *const u8
                    as *const libc::c_char,
                (*(*lgl).stats).unhd.count,
                (*(*lgl).stats).unhd.rounds,
                (*lgl).unassigned,
                (*lgl).nvars - 2 as libc::c_int,
                lglpcnt(
                    (*lgl).unassigned as libc::c_double,
                    ((*lgl).nvars - 2 as libc::c_int) as libc::c_double,
                ),
            );
            lglprt(
                lgl,
                2 as libc::c_int,
                b"[unhd-%d-%d] %d root literals out of %d (%.0f%%)\0" as *const u8
                    as *const libc::c_char,
                (*(*lgl).stats).unhd.count,
                (*(*lgl).stats).unhd.rounds,
                roots,
                unassigned,
                lglpcnt(roots as libc::c_double, unassigned as libc::c_double),
            );
            lglprt(
                lgl,
                2 as libc::c_int,
                b"[unhd-%d-%d] %d additional non-root searches out of %d (%.0f%%)\0"
                    as *const u8 as *const libc::c_char,
                (*(*lgl).stats).unhd.count,
                (*(*lgl).stats).unhd.rounds,
                searches - roots,
                unassigned,
                lglpcnt(
                    (searches - roots) as libc::c_double,
                    unassigned as libc::c_double,
                ),
            );
            lglprt(
                lgl,
                2 as libc::c_int,
                b"[unhd-%d-%d] %d literals not in F2 out of %d (%.0f%%)\0" as *const u8
                    as *const libc::c_char,
                (*(*lgl).stats).unhd.count,
                (*(*lgl).stats).unhd.rounds,
                noimpls,
                unassigned,
                lglpcnt(noimpls as libc::c_double, unassigned as libc::c_double),
            );
            lglprt(
                lgl,
                2 as libc::c_int,
                b"[unhd-%d-%d] %d visited literals out of %d (%.0f%%)\0" as *const u8
                    as *const libc::c_char,
                (*(*lgl).stats).unhd.count,
                (*(*lgl).stats).unhd.rounds,
                visited,
                unassigned,
                lglpcnt(visited as libc::c_double, unassigned as libc::c_double),
            );
            lglprt(
                lgl,
                2 as libc::c_int,
                b"[unhd-%d-%d] %.2f average number visited literals per search\0"
                    as *const u8 as *const libc::c_char,
                (*(*lgl).stats).unhd.count,
                (*(*lgl).stats).unhd.rounds,
                lglavg(visited as libc::c_double, searches as libc::c_double),
            );
        }
        _ => {}
    }
    if searches == 0 || (*lgl).mt != 0 {
        lgldel(
            lgl,
            dfpr as *mut libc::c_void,
            ((2 as libc::c_int * (*lgl).nvars) as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<DFPR>() as libc::c_ulong),
        );
        dfpr = 0 as *mut DFPR;
        dfpr = 0 as *mut DFPR;
    }
    lglrelwtk(lgl, &mut work);
    lglrelstk(lgl, &mut units);
    lglrelstk(lgl, &mut sccs);
    lglrelstk(lgl, &mut trds);
    lgldel(
        lgl,
        dfopf as *mut libc::c_void,
        ((2 as libc::c_int * (*lgl).nvars) as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<DFOPF>() as libc::c_ulong),
    );
    dfopf = 0 as *mut DFOPF;
    return dfpr;
}
unsafe extern "C" fn lglsetunhdlim(mut lgl: *mut LGL) {
    let mut limit: int64_t = 0;
    let mut irrlim: int64_t = 0;
    let mut pen: libc::c_int = 0;
    let mut szpen: libc::c_int = 0;
    limit = (*(*lgl).opts).unhdreleff.val as int64_t * lglvisearch(lgl)
        / 1000 as libc::c_int as int64_t;
    if limit < (*(*lgl).opts).unhdmineff.val as int64_t {
        limit = (*(*lgl).opts).unhdmineff.val as int64_t;
    }
    if (*(*lgl).opts).unhdmaxeff.val >= 0 as libc::c_int
        && limit > (*(*lgl).opts).unhdmaxeff.val as int64_t
    {
        limit = (*(*lgl).opts).unhdmaxeff.val as int64_t;
    }
    szpen = lglszpenaux(lgl, 1 as libc::c_int, 1 as libc::c_int);
    pen = (*(*lgl).limits).unhd.pen + szpen;
    limit >>= pen;
    irrlim = ((*(*lgl).stats).irr.clauses.cur / 16 as libc::c_int >> szpen) as int64_t;
    if (*(*lgl).opts).irrlim.val != 0 && limit < irrlim {
        limit = irrlim;
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[unhide-%d] limit %lld based on %d irredundant clauses penalty %d\0"
                as *const u8 as *const libc::c_char,
            (*(*lgl).stats).unhd.count,
            limit as libc::c_longlong,
            (*(*lgl).stats).irr.clauses.cur,
            szpen,
        );
    } else {
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[unhide-%d] limit %lld with penalty %d = %d + %d\0" as *const u8
                as *const libc::c_char,
            (*(*lgl).stats).unhd.count,
            limit as libc::c_longlong,
            pen,
            (*(*lgl).limits).unhd.pen,
            szpen,
        );
    }
    (*(*lgl).limits).unhd.steps = (*(*lgl).stats).unhd.steps + limit;
}
unsafe extern "C" fn lglunhide(mut lgl: *mut LGL) -> libc::c_int {
    let mut irronly: libc::c_int = 0;
    let mut round: libc::c_int = 0;
    let mut maxrounds: libc::c_int = 0;
    let mut noprgssrounds: libc::c_int = 0;
    let mut success: libc::c_int = 0;
    let mut oldunits: libc::c_int = 0;
    let mut oldfailed: libc::c_int = 0;
    let mut oldtauts: libc::c_int = 0;
    let mut oldhbrs: libc::c_int = 0;
    let mut oldstrd: libc::c_int = 0;
    let mut deltaunits: libc::c_int = 0;
    let mut deltafailed: libc::c_int = 0;
    let mut roundprgss: int64_t = 0 as libc::c_int as int64_t;
    let mut dfpr: *mut DFPR = 0 as *mut DFPR;
    if (*lgl).nvars <= 2 as libc::c_int {
        return 1 as libc::c_int;
    }
    (*(*lgl).stats).unhd.count += 1;
    (*(*lgl).stats).unhd.count;
    (*lgl).unhiding = 1 as libc::c_int as libc::c_char;
    (*lgl).simp = 1 as libc::c_int as libc::c_char;
    lglstart(lgl, &mut (*(*lgl).times).unhide);
    irronly = ((*(*lgl).stats).red.bin == 0
        || (*(*lgl).stats).unhd.count & 1 as libc::c_int != 0) as libc::c_int;
    if (*lgl).level > 0 as libc::c_int {
        lglbacktrack(lgl, 0 as libc::c_int);
    }
    maxrounds = (*(*lgl).opts).unhdroundlim.val;
    lglsetunhdlim(lgl);
    oldunits = lglunhdunits(lgl);
    oldfailed = lglunhdfailed(lgl);
    oldtauts = lglunhdtauts(lgl);
    oldhbrs = lglunhdhbrs(lgl);
    oldstrd = lglunhdstrd(lgl);
    round = 0 as libc::c_int;
    noprgssrounds = round;
    while (*lgl).mt == 0 {
        if round >= maxrounds {
            break;
        }
        if round > 0 as libc::c_int && roundprgss == (*(*lgl).stats).prgss
            && {
                let fresh249 = noprgssrounds;
                noprgssrounds = noprgssrounds + 1;
                fresh249 == (*(*lgl).opts).unhdlnpr.val
            }
        {
            break;
        }
        round += 1;
        round;
        roundprgss = (*(*lgl).stats).prgss;
        (*(*lgl).stats).unhd.rounds += 1;
        (*(*lgl).stats).unhd.rounds;
        lglgc(lgl);
        if (*lgl).nvars == 0 || (*lgl).mt != 0 {
            break;
        }
        dfpr = lglstampall(lgl, irronly);
        if dfpr.is_null() {
            break;
        }
        if lglunhidefailed(lgl, dfpr) == 0 {
            break;
        }
        if lglunhidebintrn(lgl, dfpr, irronly) == 0 {
            break;
        }
        if lglunhidelrg(lgl, dfpr, irronly) == 0 {
            break;
        }
        if (*(*lgl).stats).unhd.steps >= (*(*lgl).limits).unhd.steps {
            break;
        }
        irronly = ((*(*lgl).stats).red.bin == 0 || irronly == 0) as libc::c_int;
        lgldel(
            lgl,
            dfpr as *mut libc::c_void,
            ((2 as libc::c_int * (*lgl).nvars) as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<DFPR>() as libc::c_ulong),
        );
        dfpr = 0 as *mut DFPR;
    }
    if !dfpr.is_null() {
        lgldel(
            lgl,
            dfpr as *mut libc::c_void,
            ((2 as libc::c_int * (*lgl).nvars) as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<DFPR>() as libc::c_ulong),
        );
        dfpr = 0 as *mut DFPR;
    }
    deltaunits = lglunhdunits(lgl) - oldunits;
    deltafailed = lglunhdfailed(lgl) - oldfailed;
    lglprt(
        lgl,
        1 as libc::c_int,
        b"[unhide-%d-%d] %d units, %d failed, %d tauts, %d hbrs, %d literals\0"
            as *const u8 as *const libc::c_char,
        (*(*lgl).stats).unhd.count,
        (*(*lgl).stats).unhd.rounds,
        deltaunits,
        deltafailed,
        lglunhdtauts(lgl) - oldtauts,
        lglunhdhbrs(lgl) - oldhbrs,
        lglunhdstrd(lgl) - oldstrd,
    );
    success = deltaunits + deltafailed;
    if success != 0 && (*(*lgl).limits).unhd.pen != 0 {
        (*(*lgl).limits).unhd.pen -= 1;
        (*(*lgl).limits).unhd.pen;
    }
    if success == 0 && (*(*lgl).limits).unhd.pen < (*(*lgl).opts).penmax.val {
        (*(*lgl).limits).unhd.pen += 1;
        (*(*lgl).limits).unhd.pen;
    }
    if success != 0 && (*(*lgl).limits).unhd.del.cur != 0 {
        (*(*lgl).limits).unhd.del.cur /= 2 as libc::c_int;
    }
    if success == 0 && (*(*lgl).limits).unhd.del.cur < (*(*lgl).opts).delmax.val {
        (*(*lgl).limits).unhd.del.cur += 1;
        (*(*lgl).limits).unhd.del.cur;
    }
    (*(*lgl).limits).unhd.del.rem = (*(*lgl).limits).unhd.del.cur;
    (*lgl).simp = 0 as libc::c_int as libc::c_char;
    (*lgl).unhiding = 0 as libc::c_int as libc::c_char;
    lglrep(lgl, 2 as libc::c_int, 'u' as i32 as libc::c_char);
    lglstop(lgl);
    return ((*lgl).mt == 0) as libc::c_int;
}
unsafe extern "C" fn lglpar64(mut i: uint64_t) -> libc::c_int {
    let mut x: libc::c_uint = 0;
    let mut res: libc::c_int = 0 as libc::c_int;
    x = i as libc::c_uint;
    while x != 0 {
        res = (res == 0) as libc::c_int;
        x = x & x.wrapping_sub(1 as libc::c_int as libc::c_uint);
    }
    return res;
}
unsafe extern "C" fn lgldec64(mut i: uint64_t) -> uint64_t {
    let mut res: uint64_t = 0;
    res = i.wrapping_sub(1 as libc::c_int as uint64_t);
    while lglpar64(res) != 0 {
        res = res.wrapping_sub(1);
        res;
    }
    return res;
}
unsafe extern "C" fn lglgdump(mut lgl: *mut LGL) {}
unsafe extern "C" fn lglgaussubclsaux(
    mut lgl: *mut LGL,
    mut signs: uint64_t,
    mut c: *const libc::c_int,
) -> libc::c_int {
    let mut lit: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut min: libc::c_int = 0;
    let mut minocc: libc::c_int = 0;
    let mut tmpocc: libc::c_int = 0;
    let mut blit: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut other2: libc::c_int = 0;
    let mut red: libc::c_int = 0;
    let mut lidx: libc::c_int = 0;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut w: *const libc::c_int = 0 as *const libc::c_int;
    let mut eow: *const libc::c_int = 0 as *const libc::c_int;
    let mut d: *const libc::c_int = 0 as *const libc::c_int;
    let mut q: *const libc::c_int = 0 as *const libc::c_int;
    let mut hts: *mut HTS = 0 as *mut HTS;
    minocc = 2147483647 as libc::c_int;
    i = 0 as libc::c_int;
    min = i;
    (*(*lgl).stats).steps += 1;
    (*(*lgl).stats).steps;
    (*(*lgl).stats).gauss.steps.extr += 1;
    (*(*lgl).stats).gauss.steps.extr;
    p = c;
    loop {
        lit = *p;
        if !(lit != 0) {
            break;
        }
        if lglmarked(lgl, lit) != 0 {
            return 0 as libc::c_int;
        }
        let fresh250 = i;
        i = i + 1;
        if signs as libc::c_ulonglong & (1 as libc::c_ulonglong) << fresh250 != 0 {
            lit = -lit;
        }
        lglsignedmark(lgl, lit);
        tmpocc = (lglocc(lgl, lit) as libc::c_uint)
            .wrapping_add((*lglhts(lgl, lit)).count) as libc::c_int;
        if !(tmpocc >= minocc) {
            minocc = tmpocc;
            min = lit;
        }
        p = p.offset(1);
        p;
    }
    hts = lglhts(lgl, min);
    w = lglhts2wchs(lgl, hts);
    eow = w.offset((*hts).count as isize);
    p = w;
    while p < eow {
        (*(*lgl).stats).steps += 1;
        (*(*lgl).stats).steps;
        (*(*lgl).stats).gauss.steps.extr += 1;
        (*(*lgl).stats).gauss.steps.extr;
        blit = *p;
        tag = blit & MASKCS as libc::c_int;
        if tag == TRNCS as libc::c_int || tag == LRGCS as libc::c_int {
            p = p.offset(1);
            p;
        }
        if !(tag == LRGCS as libc::c_int) {
            if tag == BINCS as libc::c_int {
                other = blit >> RMSHFT as libc::c_int;
                if lglsignedmarked(lgl, other) != 0 {
                    return 1 as libc::c_int;
                }
            } else if tag == TRNCS as libc::c_int {
                other = blit >> RMSHFT as libc::c_int;
                if !(lglsignedmarked(lgl, other) == 0) {
                    other2 = *p;
                    if lglsignedmarked(lgl, other2) != 0 {
                        return 1 as libc::c_int;
                    }
                }
            } else {
                red = blit & REDCS as libc::c_int;
                lidx = blit >> RMSHFT as libc::c_int;
                d = lglidx2lits(lgl, red, lidx);
                q = d;
                loop {
                    other = *q;
                    if !(other != 0) {
                        break;
                    }
                    if lglsignedmarked(lgl, other) == 0 {
                        break;
                    }
                    q = q.offset(1);
                    q;
                }
                if other == 0 {
                    return 1 as libc::c_int;
                }
            }
        }
        p = p.offset(1);
        p;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn lglgaussubcls(
    mut lgl: *mut LGL,
    mut signs: uint64_t,
    mut c: *const libc::c_int,
) -> libc::c_int {
    let mut res: libc::c_int = lglgaussubclsaux(lgl, signs, c);
    let mut lit: libc::c_int = 0;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    p = c;
    loop {
        lit = *p;
        if !(lit != 0) {
            break;
        }
        lglunmark(lgl, lit);
        p = p.offset(1);
        p;
    }
    return res;
}
unsafe extern "C" fn lglgaussextractedxorincstats(
    mut lgl: *mut LGL,
    mut size: libc::c_int,
) {
    (*(*lgl).stats).gauss.arity.sum.total += size as int64_t;
    if (*(*lgl).stats).gauss.arity.max.total < size {
        (*(*lgl).stats).gauss.arity.max.total = size;
    }
    if (*(*lgl).stats).gauss.arity.max.last < size {
        (*(*lgl).stats).gauss.arity.max.last = size;
    }
    (*(*lgl).stats).gauss.extracted.total += 1;
    (*(*lgl).stats).gauss.extracted.total;
    (*(*lgl).stats).gauss.extracted.last += 1;
    (*(*lgl).stats).gauss.extracted.last;
}
unsafe extern "C" fn lglgaussextractxoraux(
    mut lgl: *mut LGL,
    mut c: *const libc::c_int,
) -> libc::c_int {
    let mut lit: libc::c_int = 0;
    let mut val: libc::c_int = 0;
    let mut size: libc::c_int = 0;
    let mut maxsize: libc::c_int = 0;
    let mut negs: libc::c_int = 0;
    let mut start: libc::c_int = 0;
    let mut max: libc::c_int = 0;
    let mut d: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut q: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut allxors: libc::c_int = (*(*lgl).opts).gaussextrall.val;
    let mut signs: uint64_t = 0;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    maxsize = (*(*lgl).opts).gaussmaxor.val;
    size = 0 as libc::c_int;
    negs = size;
    max = negs;
    start = lglcntstk(&mut (*(*lgl).c2rust_unnamed.gauss).xors) as libc::c_int;
    p = c;
    loop {
        lit = *p;
        if !(lit != 0) {
            break;
        }
        val = lglval(lgl, lit) as libc::c_int;
        if val > 0 as libc::c_int {
            return 0 as libc::c_int;
        }
        if !(val < 0 as libc::c_int) {
            if lit < 0 as libc::c_int {
                if allxors == 0 && negs != 0 {
                    return 0 as libc::c_int;
                }
                negs = (negs == 0) as libc::c_int;
            }
            if max == 0 || abs(max) < abs(lit) {
                max = lit;
            }
            lglpushstk(lgl, &mut (*(*lgl).c2rust_unnamed.gauss).xors, lit);
            size += 1;
            if size > maxsize {
                return 0 as libc::c_int;
            }
        }
        p = p.offset(1);
        p;
    }
    if size <= 1 as libc::c_int {
        return 0 as libc::c_int;
    }
    if allxors == 0 && negs != 0 && max > 0 as libc::c_int {
        return 0 as libc::c_int;
    }
    lglpushstk(lgl, &mut (*(*lgl).c2rust_unnamed.gauss).xors, 0 as libc::c_int);
    d = ((*(*lgl).c2rust_unnamed.gauss).xors.start).offset(start as isize);
    signs = lgldec64(((1 as libc::c_ulonglong) << size) as uint64_t);
    while !(lglgaussubcls(lgl, signs, d) == 0) {
        signs = lgldec64(signs);
        if !(signs != 0
            && (*(*lgl).stats).gauss.steps.extr < (*(*lgl).limits).gauss.steps.extr)
        {
            break;
        }
    }
    if signs != 0 {
        return 0 as libc::c_int;
    }
    q = d;
    loop {
        lit = *q;
        if !(lit != 0) {
            break;
        }
        *q = abs(lit);
        q = q.offset(1);
        q;
    }
    *q = (negs == 0) as libc::c_int;
    lglgaussextractedxorincstats(lgl, size);
    return 1 as libc::c_int;
}
unsafe extern "C" fn lglgaussextractexactly1(
    mut lgl: *mut LGL,
    mut c: *const libc::c_int,
) -> libc::c_int {
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut q: *const libc::c_int = 0 as *const libc::c_int;
    let mut l: libc::c_int = 0;
    let mut k: libc::c_int = 0;
    let mut size: libc::c_int = 0;
    let mut par: libc::c_int = 0;
    if (*(*lgl).opts).gausscardweak.val == 0 {
        return 0 as libc::c_int;
    }
    p = c;
    loop {
        l = *p;
        if !(l != 0) {
            break;
        }
        if (*(*lgl).stats).gauss.steps.extr >= (*(*lgl).limits).gauss.steps.extr {
            return 0 as libc::c_int;
        }
        q = p.offset(1 as libc::c_int as isize);
        loop {
            k = *q;
            if !(k != 0) {
                break;
            }
            (*(*lgl).stats).steps += 1;
            (*(*lgl).stats).steps;
            (*(*lgl).stats).gauss.steps.extr += 1;
            (*(*lgl).stats).gauss.steps.extr;
            if lglhasbin(lgl, -l, -k) == 0 {
                return 0 as libc::c_int;
            }
            q = q.offset(1);
            q;
        }
        p = p.offset(1);
        p;
    }
    par = 1 as libc::c_int;
    size = p.offset_from(c) as libc::c_long as libc::c_int;
    p = c;
    loop {
        l = *p;
        if !(l != 0) {
            break;
        }
        if l < 0 as libc::c_int {
            l = -l;
            par = (par == 0) as libc::c_int;
        }
        lglpushstk(lgl, &mut (*(*lgl).c2rust_unnamed.gauss).xors, l);
        p = p.offset(1);
        p;
    }
    lglpushstk(lgl, &mut (*(*lgl).c2rust_unnamed.gauss).xors, par);
    lglgaussextractedxorincstats(lgl, size);
    (*(*lgl).stats).gauss.arity.sum.exactly1 += size as int64_t;
    (*(*lgl).stats).gauss.extracted.exactly1 += 1;
    (*(*lgl).stats).gauss.extracted.exactly1;
    return 1 as libc::c_int;
}
unsafe extern "C" fn lglgaussextractxor(
    mut lgl: *mut LGL,
    mut c: *const libc::c_int,
) -> libc::c_int {
    let mut res: libc::c_int = 0;
    if lglgaussextractexactly1(lgl, c) != 0 {
        res = 1 as libc::c_int;
    } else {
        let mut old: libc::c_int = lglcntstk(&mut (*(*lgl).c2rust_unnamed.gauss).xors)
            as libc::c_int;
        res = lglgaussextractxoraux(lgl, c);
        if res == 0 {
            lglrststk(&mut (*(*lgl).c2rust_unnamed.gauss).xors, old);
        }
    }
    return res;
}
unsafe extern "C" fn lglgaussextractsmallit(
    mut lgl: *mut LGL,
    mut lit: libc::c_int,
) -> libc::c_int {
    let mut allxors: libc::c_int = (*(*lgl).opts).gaussextrall.val;
    let mut cls: [libc::c_int; 4] = [0; 4];
    let mut blit: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut other2: libc::c_int = 0;
    let mut w: *const libc::c_int = 0 as *const libc::c_int;
    let mut eow: *const libc::c_int = 0 as *const libc::c_int;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut hts: *mut HTS = 0 as *mut HTS;
    if (*(*lgl).stats).gauss.steps.extr >= (*(*lgl).limits).gauss.steps.extr {
        return 0 as libc::c_int;
    }
    if lglval(lgl, lit) as libc::c_int > 0 as libc::c_int {
        return 1 as libc::c_int;
    }
    hts = lglhts(lgl, lit);
    w = lglhts2wchs(lgl, hts);
    eow = w.offset((*hts).count as isize);
    let mut current_block_21: u64;
    p = w;
    while p < eow {
        blit = *p;
        tag = blit & MASKCS as libc::c_int;
        if tag == TRNCS as libc::c_int || tag == LRGCS as libc::c_int {
            p = p.offset(1);
            p;
        }
        if !(tag == OCCS as libc::c_int || tag == LRGCS as libc::c_int) {
            other = blit >> RMSHFT as libc::c_int;
            if !(allxors == 0 && abs(other) < lit) {
                cls[0 as libc::c_int as usize] = lit;
                cls[1 as libc::c_int as usize] = other;
                if tag == TRNCS as libc::c_int {
                    other2 = *p;
                    if allxors == 0 && abs(other2) < lit {
                        current_block_21 = 4906268039856690917;
                    } else {
                        cls[2 as libc::c_int as usize] = other2;
                        cls[3 as libc::c_int as usize] = 0 as libc::c_int;
                        current_block_21 = 12147880666119273379;
                    }
                } else {
                    cls[2 as libc::c_int as usize] = 0 as libc::c_int;
                    current_block_21 = 12147880666119273379;
                }
                match current_block_21 {
                    4906268039856690917 => {}
                    _ => {
                        lglgaussextractxor(lgl, cls.as_mut_ptr());
                    }
                }
            }
        }
        p = p.offset(1);
        p;
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn lglgaussextractsmall(mut lgl: *mut LGL) -> libc::c_int {
    let mut before: int64_t = (*(*lgl).stats).gauss.extracted.total;
    let mut after: int64_t = 0;
    let mut delta: int64_t = 0;
    let mut res: libc::c_int = 0;
    lglrandlitrav(
        lgl,
        Some(
            lglgaussextractsmallit
                as unsafe extern "C" fn(*mut LGL, libc::c_int) -> libc::c_int,
        ),
    );
    after = (*(*lgl).stats).gauss.extracted.total;
    delta = after - before;
    res = (if delta > 2147483647 as libc::c_int as int64_t {
        2147483647 as libc::c_int as int64_t
    } else {
        delta
    }) as libc::c_int;
    return res;
}
unsafe extern "C" fn lglgaussextractlarge(mut lgl: *mut LGL) -> libc::c_int {
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut c: *const libc::c_int = 0 as *const libc::c_int;
    let mut res: libc::c_int = 0 as libc::c_int;
    c = (*lgl).irr.start;
    while c < (*lgl).irr.top as *const libc::c_int {
        if (*(*lgl).stats).gauss.steps.extr >= (*(*lgl).limits).gauss.steps.extr {
            break;
        }
        p = c;
        if !(*p >= 2147483647 as libc::c_int >> RMSHFT as libc::c_int) {
            res += lglgaussextractxor(lgl, c);
            while *p != 0 {
                p = p.offset(1);
                p;
            }
        }
        c = p.offset(1 as libc::c_int as isize);
    }
    return res;
}
unsafe extern "C" fn lglgaussconeqn(mut lgl: *mut LGL, mut eqn: libc::c_int) {
    let mut xors: *const libc::c_int = (*(*lgl).c2rust_unnamed.gauss).xors.start;
    let mut i: libc::c_int = 0;
    let mut var: libc::c_int = 0;
    (*(*lgl).stats).steps += 1;
    (*(*lgl).stats).steps;
    (*(*lgl).stats).gauss.steps.elim += 1;
    (*(*lgl).stats).gauss.steps.elim;
    i = eqn;
    loop {
        var = *xors.offset(i as isize);
        if !(var > 1 as libc::c_int) {
            break;
        }
        lglpushstk(lgl, ((*(*lgl).c2rust_unnamed.gauss).occs).offset(var as isize), eqn);
        i += 1;
        i;
    };
}
unsafe extern "C" fn lglgaussdiseqn(mut lgl: *mut LGL, mut eqn: libc::c_int) {
    let mut xors: *mut libc::c_int = (*(*lgl).c2rust_unnamed.gauss).xors.start;
    let mut i: libc::c_int = 0;
    let mut var: libc::c_int = 0;
    i = eqn;
    loop {
        var = *xors.offset(i as isize);
        if !(var > 1 as libc::c_int) {
            break;
        }
        *xors.offset(i as isize) = 2147483647 as libc::c_int >> RMSHFT as libc::c_int;
        (*(*lgl).c2rust_unnamed.gauss).garbage += 1;
        (*(*lgl).c2rust_unnamed.gauss).garbage;
        (*(*lgl).stats).steps += 1;
        (*(*lgl).stats).steps;
        (*(*lgl).stats).gauss.steps.elim += 1;
        (*(*lgl).stats).gauss.steps.elim;
        lglrmstk(((*(*lgl).c2rust_unnamed.gauss).occs).offset(var as isize), eqn);
        i += 1;
        i;
    }
    *xors.offset(i as isize) = 2147483647 as libc::c_int >> RMSHFT as libc::c_int;
    (*(*lgl).c2rust_unnamed.gauss).garbage += 1;
    (*(*lgl).c2rust_unnamed.gauss).garbage;
}
unsafe extern "C" fn lglgaussconnect(mut lgl: *mut LGL) {
    let mut c: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut eox: libc::c_int = lglcntstk(&mut (*(*lgl).c2rust_unnamed.gauss).xors)
        as libc::c_int;
    let mut connected: libc::c_int = 0;
    let mut var: libc::c_int = 0;
    let mut vars: libc::c_int = 0;
    let mut xors: *const libc::c_int = (*(*lgl).c2rust_unnamed.gauss).xors.start;
    let mut occs: *mut Stk = 0 as *mut Stk;
    (*(*lgl).c2rust_unnamed.gauss)
        .occs = lglnew(
        lgl,
        ((*lgl).nvars as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Stk>() as libc::c_ulong),
    ) as *mut Stk;
    connected = 0 as libc::c_int;
    vars = connected;
    c = 0 as libc::c_int;
    while c < eox {
        (*(*lgl).stats).steps += 1;
        (*(*lgl).stats).steps;
        (*(*lgl).stats).gauss.steps.elim += 1;
        (*(*lgl).stats).gauss.steps.elim;
        i = c;
        loop {
            var = *xors.offset(i as isize);
            if !(var > 1 as libc::c_int) {
                break;
            }
            occs = ((*(*lgl).c2rust_unnamed.gauss).occs).offset(var as isize);
            if lglmtstk(occs) != 0 {
                vars += 1;
                vars;
            }
            lglpushstk(
                lgl,
                ((*(*lgl).c2rust_unnamed.gauss).occs).offset(var as isize),
                c,
            );
            connected += 1;
            connected;
            i += 1;
            i;
        }
        c = i + 1 as libc::c_int;
    }
    lglprt(
        lgl,
        1 as libc::c_int,
        b"[gauss-%d] connected %d occurrences of %d variables (average %.1f)\0"
            as *const u8 as *const libc::c_char,
        (*(*lgl).stats).gauss.count,
        connected,
        vars,
        lglavg(connected as libc::c_double, vars as libc::c_double),
    );
}
unsafe extern "C" fn lglgaussorderidx(
    mut lgl: *mut LGL,
    mut var: libc::c_int,
) -> libc::c_int {
    if lglmtstk(((*(*lgl).c2rust_unnamed.gauss).occs).offset(var as isize)) == 0 {
        lglpushstk(lgl, &mut (*(*lgl).c2rust_unnamed.gauss).order, var);
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn lglgaussorder(mut lgl: *mut LGL) {
    lglrandidxtrav(
        lgl,
        Some(
            lglgaussorderidx
                as unsafe extern "C" fn(*mut LGL, libc::c_int) -> libc::c_int,
        ),
    );
    (*(*lgl).c2rust_unnamed.gauss)
        .eliminated = lglnew(
        lgl,
        ((*lgl).nvars as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_schar>() as libc::c_ulong),
    ) as *mut libc::c_schar;
}
unsafe extern "C" fn lglgaussdisconnect(mut lgl: *mut LGL) {
    let mut idx: libc::c_int = 0;
    idx = 2 as libc::c_int;
    while idx < (*lgl).nvars {
        lglrelstk(lgl, ((*(*lgl).c2rust_unnamed.gauss).occs).offset(idx as isize));
        idx += 1;
        idx;
    }
    lgldel(
        lgl,
        (*(*lgl).c2rust_unnamed.gauss).occs as *mut libc::c_void,
        ((*lgl).nvars as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Stk>() as libc::c_ulong),
    );
    (*(*lgl).c2rust_unnamed.gauss).occs = 0 as *mut Stk;
}
unsafe extern "C" fn lglgaussextract(mut lgl: *mut LGL) {
    let mut extracted: libc::c_int = 0;
    let mut lits: libc::c_int = 0;
    if (*lgl).level != 0 {
        lglbacktrack(lgl, 0 as libc::c_int);
    }
    lglgc(lgl);
    if (*lgl).mt != 0 {
        return;
    }
    lgldense(lgl, 0 as libc::c_int);
    extracted = lglgaussextractsmall(lgl);
    extracted += lglgaussextractlarge(lgl);
    lits = (lglcntstk(&mut (*(*lgl).c2rust_unnamed.gauss).xors))
        .wrapping_sub(extracted as size_t) as libc::c_int;
    lglprt(
        lgl,
        1 as libc::c_int,
        b"[gauss-%d] extracted %d xors of average arity %.1f\0" as *const u8
            as *const libc::c_char,
        (*(*lgl).stats).gauss.count,
        extracted,
        lglavg(lits as libc::c_double, extracted as libc::c_double),
    );
    lglsparse(lgl);
    lglgc(lgl);
    if (*lgl).mt != 0 {
        return;
    }
    lglfitstk(lgl, &mut (*(*lgl).c2rust_unnamed.gauss).xors);
}
unsafe extern "C" fn lglgaussoccs(mut lgl: *mut LGL, mut a: libc::c_int) -> libc::c_int {
    return lglcntstk(((*(*lgl).c2rust_unnamed.gauss).occs).offset(a as isize))
        as libc::c_int;
}
unsafe extern "C" fn lglcmpgauss(
    mut lgl: *mut LGL,
    mut a: libc::c_int,
    mut b: libc::c_int,
) -> libc::c_int {
    let mut res: libc::c_int = lglgaussoccs(lgl, a) - lglgaussoccs(lgl, b);
    if res == 0 {
        res = a - b;
    }
    return res;
}
unsafe extern "C" fn lglgaussort(mut lgl: *mut LGL) {
    let mut max: libc::c_int = lglcntstk(&mut (*(*lgl).c2rust_unnamed.gauss).order)
        as libc::c_int;
    let mut rest: libc::c_int = 0;
    let mut start: *mut libc::c_int = 0 as *mut libc::c_int;
    rest = max - (*(*lgl).c2rust_unnamed.gauss).next;
    start = ((*(*lgl).c2rust_unnamed.gauss).order.start)
        .offset((*(*lgl).c2rust_unnamed.gauss).next as isize);
    (*(*lgl).stats).steps += rest as int64_t;
    (*(*lgl).stats).gauss.steps.elim += rest as int64_t;
    let mut AA: *mut libc::c_int = start;
    let NN: libc::c_int = rest;
    let mut L: libc::c_int = 0 as libc::c_int;
    let mut R: libc::c_int = NN - 1 as libc::c_int;
    let mut M: libc::c_int = 0;
    let mut LL: libc::c_int = 0;
    let mut RR: libc::c_int = 0;
    let mut I: libc::c_int = 0;
    if !(R - L <= 10 as libc::c_int) {
        loop {
            M = (L + R) / 2 as libc::c_int;
            let mut TMP: libc::c_int = *AA.offset(M as isize);
            *AA.offset(M as isize) = *AA.offset((R - 1 as libc::c_int) as isize);
            *AA.offset((R - 1 as libc::c_int) as isize) = TMP;
            if lglcmpgauss(
                lgl,
                *AA.offset(L as isize),
                *AA.offset((R - 1 as libc::c_int) as isize),
            ) > 0 as libc::c_int
            {
                let mut TMP_0: libc::c_int = *AA.offset(L as isize);
                *AA.offset(L as isize) = *AA.offset((R - 1 as libc::c_int) as isize);
                *AA.offset((R - 1 as libc::c_int) as isize) = TMP_0;
            }
            if lglcmpgauss(lgl, *AA.offset(L as isize), *AA.offset(R as isize))
                > 0 as libc::c_int
            {
                let mut TMP_1: libc::c_int = *AA.offset(L as isize);
                *AA.offset(L as isize) = *AA.offset(R as isize);
                *AA.offset(R as isize) = TMP_1;
            }
            if lglcmpgauss(
                lgl,
                *AA.offset((R - 1 as libc::c_int) as isize),
                *AA.offset(R as isize),
            ) > 0 as libc::c_int
            {
                let mut TMP_2: libc::c_int = *AA.offset((R - 1 as libc::c_int) as isize);
                *AA.offset((R - 1 as libc::c_int) as isize) = *AA.offset(R as isize);
                *AA.offset(R as isize) = TMP_2;
            }
            let mut PIVOT: libc::c_int = 0;
            let mut J: libc::c_int = R - 1 as libc::c_int;
            I = L + 1 as libc::c_int - 1 as libc::c_int;
            PIVOT = *AA.offset(J as isize);
            loop {
                loop {
                    I += 1;
                    if !(lglcmpgauss(lgl, *AA.offset(I as isize), PIVOT)
                        < 0 as libc::c_int)
                    {
                        break;
                    }
                }
                loop {
                    J -= 1;
                    if !(lglcmpgauss(lgl, PIVOT, *AA.offset(J as isize))
                        < 0 as libc::c_int)
                    {
                        break;
                    }
                    if J == L + 1 as libc::c_int {
                        break;
                    }
                }
                if I >= J {
                    break;
                }
                let mut TMP_3: libc::c_int = *AA.offset(I as isize);
                *AA.offset(I as isize) = *AA.offset(J as isize);
                *AA.offset(J as isize) = TMP_3;
            }
            let mut TMP_4: libc::c_int = *AA.offset(I as isize);
            *AA.offset(I as isize) = *AA.offset((R - 1 as libc::c_int) as isize);
            *AA.offset((R - 1 as libc::c_int) as isize) = TMP_4;
            if I - L < R - I {
                LL = I + 1 as libc::c_int;
                RR = R;
                R = I - 1 as libc::c_int;
            } else {
                LL = L;
                RR = I - 1 as libc::c_int;
                L = I + 1 as libc::c_int;
            }
            if R - L > 10 as libc::c_int {
                lglpushstk(lgl, &mut (*lgl).c2rust_unnamed_0.sortstk, LL);
                lglpushstk(lgl, &mut (*lgl).c2rust_unnamed_0.sortstk, RR);
            } else if RR - LL > 10 as libc::c_int {
                L = LL;
                R = RR;
            } else {
                if !(lglmtstk(&mut (*lgl).c2rust_unnamed_0.sortstk) == 0) {
                    break;
                }
                R = lglpopstk(&mut (*lgl).c2rust_unnamed_0.sortstk);
                L = lglpopstk(&mut (*lgl).c2rust_unnamed_0.sortstk);
            }
        }
    }
    let mut PIVOT_0: libc::c_int = 0;
    let mut L_0: libc::c_int = 0 as libc::c_int;
    let mut R_0: libc::c_int = NN - 1 as libc::c_int;
    let mut I_0: libc::c_int = 0;
    let mut J_0: libc::c_int = 0;
    I_0 = R_0;
    while I_0 > L_0 {
        if lglcmpgauss(
            lgl,
            *AA.offset((I_0 - 1 as libc::c_int) as isize),
            *AA.offset(I_0 as isize),
        ) > 0 as libc::c_int
        {
            let mut TMP_5: libc::c_int = *AA.offset((I_0 - 1 as libc::c_int) as isize);
            *AA.offset((I_0 - 1 as libc::c_int) as isize) = *AA.offset(I_0 as isize);
            *AA.offset(I_0 as isize) = TMP_5;
        }
        I_0 -= 1;
        I_0;
    }
    I_0 = L_0 + 2 as libc::c_int;
    while I_0 <= R_0 {
        J_0 = I_0;
        PIVOT_0 = *AA.offset(I_0 as isize);
        while lglcmpgauss(lgl, PIVOT_0, *AA.offset((J_0 - 1 as libc::c_int) as isize))
            < 0 as libc::c_int
        {
            *AA.offset(J_0 as isize) = *AA.offset((J_0 - 1 as libc::c_int) as isize);
            J_0 -= 1;
            J_0;
        }
        *AA.offset(J_0 as isize) = PIVOT_0;
        I_0 += 1;
        I_0;
    }
    lglprt(
        lgl,
        3 as libc::c_int,
        b"[gauss-%d] sorted %d remaining variables\0" as *const u8
            as *const libc::c_char,
        (*(*lgl).stats).gauss.count,
        rest,
    );
}
unsafe extern "C" fn lglgausspickeqn(
    mut lgl: *mut LGL,
    mut pivot: libc::c_int,
) -> libc::c_int {
    let mut res: libc::c_int = 0;
    let mut cand: libc::c_int = 0;
    let mut weight: libc::c_int = 0;
    let mut size: libc::c_int = 0;
    let mut tmp: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut found: libc::c_int = 0;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut e: *const libc::c_int = 0 as *const libc::c_int;
    let mut q: *const libc::c_int = 0 as *const libc::c_int;
    let mut occs: *mut Stk = 0 as *mut Stk;
    res = -(1 as libc::c_int);
    weight = 2147483647 as libc::c_int;
    size = 2147483647 as libc::c_int;
    occs = ((*(*lgl).c2rust_unnamed.gauss).occs).offset(pivot as isize);
    p = (*occs).start;
    while p < (*occs).top as *const libc::c_int {
        cand = *p;
        e = ((*(*lgl).c2rust_unnamed.gauss).xors.start).offset(cand as isize);
        tmp = 0 as libc::c_int;
        found = tmp;
        (*(*lgl).stats).steps += 1;
        (*(*lgl).stats).steps;
        (*(*lgl).stats).gauss.steps.elim += 1;
        (*(*lgl).stats).gauss.steps.elim;
        q = e;
        loop {
            other = *q;
            if !(other > 1 as libc::c_int) {
                break;
            }
            if *((*(*lgl).c2rust_unnamed.gauss).eliminated).offset(other as isize) != 0 {
                break;
            }
            if other == pivot {
                found += 1;
                found;
            } else {
                tmp += lglgaussoccs(lgl, other) - 1 as libc::c_int;
            }
            q = q.offset(1);
            q;
        }
        if !(other > 1 as libc::c_int) {
            if !(res >= 0 as libc::c_int
                && q.offset_from(e) as libc::c_long >= size as libc::c_long)
            {
                if !(res >= 0 as libc::c_int
                    && q.offset_from(e) as libc::c_long == size as libc::c_long
                    && tmp >= weight)
                {
                    weight = tmp;
                    size = q.offset_from(e) as libc::c_long as libc::c_int;
                    res = cand;
                }
            }
        }
        p = p.offset(1);
        p;
    }
    res >= 0 as libc::c_int;
    return res;
}
unsafe extern "C" fn lglcpystk(mut lgl: *mut LGL, mut dst: *mut Stk, mut src: *mut Stk) {
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    p = (*src).start;
    while p < (*src).top as *const libc::c_int {
        lglpushstk(lgl, dst, *p);
        p = p.offset(1);
        p;
    }
}
unsafe extern "C" fn lglgaussaddeqn(
    mut lgl: *mut LGL,
    mut eqn: libc::c_int,
) -> libc::c_int {
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut av: *mut AVar = 0 as *mut AVar;
    let mut var: libc::c_int = 0;
    p = ((*(*lgl).c2rust_unnamed.gauss).xors.start).offset(eqn as isize);
    loop {
        var = *p;
        if !(var > 1 as libc::c_int) {
            break;
        }
        av = lglavar(lgl, var);
        if (*av).mark == 0 {
            lglpushstk(lgl, &mut (*lgl).clause, var);
        }
        (*av).mark = ((*av).mark == 0) as libc::c_int;
        p = p.offset(1);
        p;
    }
    return var;
}
unsafe extern "C" fn lglgaussubst(
    mut lgl: *mut LGL,
    mut pivot: libc::c_int,
    mut subst: libc::c_int,
) {
    let mut occs: *mut Stk = ((*(*lgl).c2rust_unnamed.gauss).occs)
        .offset(pivot as isize);
    let mut eqn: libc::c_int = 0;
    let mut rhs: libc::c_int = 0;
    let mut res: libc::c_int = 0;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut q: *mut libc::c_int = 0 as *mut libc::c_int;
    while lglcntstk(occs) > 1 as libc::c_int as size_t {
        if lglterminate(lgl) != 0 {
            return;
        }
        eqn = *((*occs).start).offset(0 as libc::c_int as isize);
        if eqn == subst {
            eqn = *((*occs).start).offset(1 as libc::c_int as isize);
        }
        rhs = lglgaussaddeqn(lgl, eqn);
        if lglgaussaddeqn(lgl, subst) != 0 {
            rhs = (rhs == 0) as libc::c_int;
        }
        lglgaussdiseqn(lgl, eqn);
        q = (*lgl).clause.start;
        p = q;
        while p < (*lgl).clause.top as *const libc::c_int {
            if lglmarked(lgl, *p) != 0 {
                let fresh251 = q;
                q = q.offset(1);
                *fresh251 = *p;
            }
            p = p.offset(1);
            p;
        }
        (*lgl).clause.top = q;
        if lglmtstk(&mut (*lgl).clause) == 0 {
            res = lglcntstk(&mut (*(*lgl).c2rust_unnamed.gauss).xors) as libc::c_int;
            lglcpystk(lgl, &mut (*(*lgl).c2rust_unnamed.gauss).xors, &mut (*lgl).clause);
            lglpushstk(lgl, &mut (*(*lgl).c2rust_unnamed.gauss).xors, rhs);
            lglgaussconeqn(lgl, res);
        } else if !(rhs == 0 as libc::c_int) {
            (*lgl).mt = 1 as libc::c_int;
        }
        lglpopnunmarkstk(lgl, &mut (*lgl).clause);
    }
}
unsafe extern "C" fn lglgausschkeliminated(mut lgl: *mut LGL) {}
unsafe extern "C" fn lglgaussgc(mut lgl: *mut LGL) {
    let mut count: libc::c_int = lglcntstk(&mut (*(*lgl).c2rust_unnamed.gauss).xors)
        as libc::c_int;
    let mut q: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    if (*(*lgl).c2rust_unnamed.gauss).garbage
        < count / 2 as libc::c_int + 10000 as libc::c_int
    {
        return;
    }
    (*(*lgl).stats).gauss.gcs += 1;
    (*(*lgl).stats).gauss.gcs;
    lglprt(
        lgl,
        2 as libc::c_int,
        b"[gauss-%d] collecting %d garbage out of %d\0" as *const u8
            as *const libc::c_char,
        (*(*lgl).stats).gauss.count,
        (*(*lgl).c2rust_unnamed.gauss).garbage,
        count,
    );
    lglgaussdisconnect(lgl);
    q = (*(*lgl).c2rust_unnamed.gauss).xors.start;
    p = q;
    while p < (*(*lgl).c2rust_unnamed.gauss).xors.top as *const libc::c_int {
        if *p != 2147483647 as libc::c_int >> RMSHFT as libc::c_int {
            let fresh252 = q;
            q = q.offset(1);
            *fresh252 = *p;
        }
        p = p.offset(1);
        p;
    }
    (*(*lgl).c2rust_unnamed.gauss).xors.top = q;
    lglfitstk(lgl, &mut (*(*lgl).c2rust_unnamed.gauss).xors);
    lglgaussconnect(lgl);
    (*(*lgl).c2rust_unnamed.gauss).garbage = 0 as libc::c_int;
}
unsafe extern "C" fn lglgausselimvar(
    mut lgl: *mut LGL,
    mut pivot: libc::c_int,
) -> libc::c_int {
    let mut subst: libc::c_int = 0;
    let mut changed: libc::c_int = 0;
    let mut occs: libc::c_int = 0;
    let mut eliminated: libc::c_int = 0;
    occs = lglgaussoccs(lgl, pivot);
    if occs == 0 {
        eliminated = 2 as libc::c_int;
        changed = 0 as libc::c_int;
    } else if occs == 1 as libc::c_int {
        eliminated = 1 as libc::c_int;
        changed = 0 as libc::c_int;
    } else {
        lglgaussgc(lgl);
        subst = lglgausspickeqn(lgl, pivot);
        if subst >= 0 as libc::c_int {
            lglgaussubst(lgl, pivot, subst);
            eliminated = 1 as libc::c_int;
            changed = 1 as libc::c_int;
        } else {
            eliminated = 3 as libc::c_int;
            changed = 0 as libc::c_int;
        }
    }
    *((*(*lgl).c2rust_unnamed.gauss).eliminated)
        .offset(pivot as isize) = eliminated as libc::c_schar;
    lglgausschkeliminated(lgl);
    return changed;
}
unsafe extern "C" fn lglgausselim(mut lgl: *mut LGL) {
    let mut pivot: libc::c_int = 0;
    let mut changed: libc::c_int = 1 as libc::c_int;
    while (*lgl).mt == 0
        && (*(*lgl).c2rust_unnamed.gauss).next
            < lglcntstk(&mut (*(*lgl).c2rust_unnamed.gauss).order) as libc::c_int
    {
        if (*(*lgl).stats).gauss.steps.elim >= (*(*lgl).limits).gauss.steps.elim {
            break;
        }
        if lglterminate(lgl) != 0 {
            break;
        }
        if changed != 0 {
            lglgaussort(lgl);
        }
        let fresh253 = (*(*lgl).c2rust_unnamed.gauss).next;
        (*(*lgl).c2rust_unnamed.gauss).next = (*(*lgl).c2rust_unnamed.gauss).next + 1;
        pivot = lglpeek(&mut (*(*lgl).c2rust_unnamed.gauss).order, fresh253);
        changed = lglgausselimvar(lgl, pivot);
    }
}
unsafe extern "C" fn lglgaussinit(mut lgl: *mut LGL) {
    (*lgl)
        .c2rust_unnamed
        .gauss = lglnew(
        lgl,
        (1 as libc::c_int as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Gauss>() as libc::c_ulong),
    ) as *mut Gauss;
}
unsafe extern "C" fn lglgaussreset(mut lgl: *mut LGL) {
    if !((*(*lgl).c2rust_unnamed.gauss).occs).is_null() {
        lglgaussdisconnect(lgl);
    }
    if !((*(*lgl).c2rust_unnamed.gauss).eliminated).is_null() {
        lgldel(
            lgl,
            (*(*lgl).c2rust_unnamed.gauss).eliminated as *mut libc::c_void,
            ((*lgl).nvars as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<libc::c_schar>() as libc::c_ulong),
        );
        (*(*lgl).c2rust_unnamed.gauss).eliminated = 0 as *mut libc::c_schar;
    }
    lglrelstk(lgl, &mut (*(*lgl).c2rust_unnamed.gauss).xors);
    lglrelstk(lgl, &mut (*(*lgl).c2rust_unnamed.gauss).order);
    lgldel(
        lgl,
        (*lgl).c2rust_unnamed.gauss as *mut libc::c_void,
        (1 as libc::c_int as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Gauss>() as libc::c_ulong),
    );
    (*lgl).c2rust_unnamed.gauss = 0 as *mut Gauss;
}
unsafe extern "C" fn lglgaussexp2(
    mut lgl: *mut LGL,
    mut a: libc::c_int,
    mut b: libc::c_int,
) -> libc::c_int {
    if lglhasbin(lgl, a, b) != 0 {
        return 0 as libc::c_int;
    }
    lglpushstk(lgl, &mut (*lgl).clause, a);
    lglpushstk(lgl, &mut (*lgl).clause, b);
    lglpushstk(lgl, &mut (*lgl).clause, 0 as libc::c_int);
    lgladdcls(lgl, REDCS as libc::c_int, 0 as libc::c_int, 0 as libc::c_int);
    lglclnstk(&mut (*lgl).clause);
    return 1 as libc::c_int;
}
unsafe extern "C" fn lglgaussexp3(
    mut lgl: *mut LGL,
    mut a: libc::c_int,
    mut b: libc::c_int,
    mut c: libc::c_int,
) -> libc::c_int {
    if lglhastrn(lgl, a, b, c) != 0 {
        return 0 as libc::c_int;
    }
    lglpushstk(lgl, &mut (*lgl).clause, a);
    lglpushstk(lgl, &mut (*lgl).clause, b);
    lglpushstk(lgl, &mut (*lgl).clause, c);
    lglpushstk(lgl, &mut (*lgl).clause, 0 as libc::c_int);
    lgladdcls(lgl, REDCS as libc::c_int, 0 as libc::c_int, 0 as libc::c_int);
    lglclnstk(&mut (*lgl).clause);
    return 1 as libc::c_int;
}
unsafe extern "C" fn lglgaussexport(mut lgl: *mut LGL) -> libc::c_int {
    let mut var: libc::c_int = 0;
    let mut size: libc::c_int = 0;
    let mut val: libc::c_int = 0;
    let mut rhs: libc::c_int = 0;
    let mut unit: libc::c_int = 0;
    let mut a: libc::c_int = 0;
    let mut b: libc::c_int = 0;
    let mut c: libc::c_int = 0;
    let mut exported: libc::c_int = 0;
    let mut e: *const libc::c_int = 0 as *const libc::c_int;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut q: *const libc::c_int = 0 as *const libc::c_int;
    e = (*(*lgl).c2rust_unnamed.gauss).xors.start;
    while e < (*(*lgl).c2rust_unnamed.gauss).xors.top as *const libc::c_int {
        p = e;
        if !(*p >= 2147483647 as libc::c_int >> RMSHFT as libc::c_int) {
            loop {
                var = *p;
                if !(var > 1 as libc::c_int) {
                    break;
                }
                p = p.offset(1);
                p;
            }
            rhs = *p;
            q = e;
            while q < p {
                var = *q;
                val = lglval(lgl, var) as libc::c_int;
                if !(val < 0 as libc::c_int) {
                    if val > 0 as libc::c_int {
                        rhs = (rhs == 0) as libc::c_int;
                    } else {
                        lglpushstk(lgl, &mut (*lgl).clause, var);
                    }
                }
                q = q.offset(1);
                q;
            }
            size = lglcntstk(&mut (*lgl).clause) as libc::c_int;
            if !(size == 0 && rhs == 0) {
                if size == 0 && rhs != 0 {
                    return 0 as libc::c_int;
                }
                a = if size > 0 as libc::c_int {
                    *((*lgl).clause.start).offset(0 as libc::c_int as isize)
                } else {
                    0 as libc::c_int
                };
                b = if size > 1 as libc::c_int {
                    *((*lgl).clause.start).offset(1 as libc::c_int as isize)
                } else {
                    0 as libc::c_int
                };
                c = if size > 2 as libc::c_int {
                    *((*lgl).clause.start).offset(2 as libc::c_int as isize)
                } else {
                    0 as libc::c_int
                };
                lglclnstk(&mut (*lgl).clause);
                if size == 1 as libc::c_int {
                    unit = a;
                    if rhs == 0 {
                        unit = -unit;
                    }
                    (*(*lgl).stats).gauss.units += 1;
                    (*(*lgl).stats).gauss.units;
                    lglunit(lgl, unit);
                } else if size == 2 as libc::c_int {
                    if rhs != 0 {
                        b = -b;
                    }
                    exported = lglgaussexp2(lgl, -a, b);
                    exported |= lglgaussexp2(lgl, a, -b);
                    if exported != 0 {
                        (*(*lgl).stats).gauss.equivs += 1;
                        (*(*lgl).stats).gauss.equivs;
                    }
                } else if size == 3 as libc::c_int && (*(*lgl).opts).gaussexptrn.val != 0
                {
                    if rhs == 0 {
                        c = -c;
                    }
                    exported = lglgaussexp3(lgl, a, b, c);
                    exported |= lglgaussexp3(lgl, a, -b, -c);
                    exported |= lglgaussexp3(lgl, -a, b, -c);
                    exported |= lglgaussexp3(lgl, -a, -b, c);
                    if exported != 0 {
                        (*(*lgl).stats).gauss.trneqs += 1;
                        (*(*lgl).stats).gauss.trneqs;
                    }
                }
            }
        }
        e = p.offset(1 as libc::c_int as isize);
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn lglsetgausslim(mut lgl: *mut LGL) {
    let mut limit: int64_t = 0;
    let mut irrlim: int64_t = 0;
    let mut pen: libc::c_int = 0;
    let mut szpen: libc::c_int = 0;
    limit = (*(*lgl).opts).gaussreleff.val as int64_t * lglvisearch(lgl)
        / 1000 as libc::c_int as int64_t;
    if limit < (*(*lgl).opts).gaussmineff.val as int64_t {
        limit = (*(*lgl).opts).gaussmineff.val as int64_t;
    }
    if (*(*lgl).opts).gaussmaxeff.val >= 0 as libc::c_int
        && limit > (*(*lgl).opts).gaussmaxeff.val as int64_t
    {
        limit = (*(*lgl).opts).gaussmaxeff.val as int64_t;
    }
    szpen = lglszpen(lgl);
    pen = (*(*lgl).limits).gauss.pen + szpen;
    limit >>= pen;
    irrlim = ((*(*lgl).stats).irr.clauses.cur / 2 as libc::c_int >> szpen) as int64_t;
    if (*(*lgl).opts).irrlim.val != 0 && limit < irrlim {
        limit = irrlim;
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[gauss-%d] limit %lld based on %d irredundant clauses penalty %d\0"
                as *const u8 as *const libc::c_char,
            (*(*lgl).stats).gauss.count,
            limit as libc::c_longlong,
            (*(*lgl).stats).irr.clauses.cur,
            szpen,
        );
    } else {
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[gauss-%d] limit %lld penalty %d = %d + %d\0" as *const u8
                as *const libc::c_char,
            (*(*lgl).stats).gauss.count,
            limit as libc::c_longlong,
            pen,
            (*(*lgl).limits).gauss.pen,
            szpen,
        );
    }
    (*(*lgl).limits).gauss.steps.extr = (*(*lgl).stats).gauss.steps.extr + limit;
    (*(*lgl).limits).gauss.steps.elim = (*(*lgl).stats).gauss.steps.elim + limit;
}
unsafe extern "C" fn lglgauss(mut lgl: *mut LGL) -> libc::c_int {
    let mut oldunits: libc::c_int = 0;
    let mut oldequivs: libc::c_int = 0;
    let mut oldtrneqs: libc::c_int = 0;
    let mut units: libc::c_int = 0;
    let mut equivs: libc::c_int = 0;
    let mut trneqs: libc::c_int = 0;
    let mut success: libc::c_int = 0;
    if (*lgl).mt != 0 {
        return 0 as libc::c_int;
    }
    if (*lgl).nvars <= 2 as libc::c_int {
        return 1 as libc::c_int;
    }
    lglstart(lgl, &mut (*(*lgl).times).gauss);
    (*lgl).gaussing = 1 as libc::c_int as libc::c_char;
    (*lgl).simp = (*lgl).gaussing;
    (*(*lgl).stats).gauss.count += 1;
    (*(*lgl).stats).gauss.count;
    (*(*lgl).stats).gauss.extracted.last = 0 as libc::c_int as int64_t;
    (*(*lgl).stats).gauss.arity.max.last = 0 as libc::c_int;
    lglsetgausslim(lgl);
    lglgaussinit(lgl);
    lglgaussextract(lgl);
    oldunits = (*(*lgl).stats).gauss.units;
    oldequivs = (*(*lgl).stats).gauss.equivs;
    oldtrneqs = (*(*lgl).stats).gauss.trneqs;
    if lglmtstk(&mut (*(*lgl).c2rust_unnamed.gauss).xors) == 0 {
        lglgaussconnect(lgl);
        lglgaussorder(lgl);
        lglsetgausslim(lgl);
        lglgausselim(lgl);
        if (*lgl).mt == 0 && lglterminate(lgl) == 0 {
            if (*(*lgl).opts).verbose.val >= 3 as libc::c_int {
                lglgdump(lgl);
            }
            lglgaussdisconnect(lgl);
            if lglgaussexport(lgl) == 0 || lglbcp(lgl) == 0 {
                lglmt(lgl);
            } else if (*(*lgl).limits).gauss.steps.extr
                > (*(*lgl).stats).gauss.steps.extr
                && (*(*lgl).limits).gauss.steps.elim > (*(*lgl).stats).gauss.steps.elim
            {
                lglprt(
                    lgl,
                    1 as libc::c_int,
                    b"[gauss-%d] fully completed\0" as *const u8 as *const libc::c_char,
                    (*(*lgl).stats).gauss.count,
                );
            }
        }
    }
    lglgaussreset(lgl);
    units = (*(*lgl).stats).gauss.units - oldunits;
    equivs = (*(*lgl).stats).gauss.equivs - oldequivs;
    trneqs = (*(*lgl).stats).gauss.trneqs - oldtrneqs;
    success = (units != 0 || equivs != 0) as libc::c_int;
    if (*lgl).mt == 0 && success != 0 && lglterminate(lgl) == 0
        && (*(*lgl).opts).decompose.val != 0
    {
        lgldecomp(lgl);
    }
    if trneqs != 0 {
        success = 1 as libc::c_int;
    }
    if (*lgl).mt != 0 {
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[gauss-%d] proved unsatisfiability\0" as *const u8 as *const libc::c_char,
            (*(*lgl).stats).gauss.count,
        );
    } else {
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[gauss-%d] exported %d unary, %d binary and %d ternary equations\0"
                as *const u8 as *const libc::c_char,
            (*(*lgl).stats).gauss.count,
            units,
            equivs,
            trneqs,
        );
    }
    if success != 0 && (*(*lgl).limits).gauss.pen != 0 {
        (*(*lgl).limits).gauss.pen -= 1;
        (*(*lgl).limits).gauss.pen;
    }
    if success == 0 && (*(*lgl).limits).gauss.pen < (*(*lgl).opts).penmax.val {
        (*(*lgl).limits).gauss.pen += 1;
        (*(*lgl).limits).gauss.pen;
    }
    if success != 0 && (*(*lgl).limits).gauss.del.cur != 0 {
        (*(*lgl).limits).gauss.del.cur /= 2 as libc::c_int;
    }
    if success == 0 && (*(*lgl).limits).gauss.del.cur < (*(*lgl).opts).delmax.val {
        (*(*lgl).limits).gauss.del.cur += 1;
        (*(*lgl).limits).gauss.del.cur;
    }
    (*(*lgl).limits).gauss.del.rem = (*(*lgl).limits).gauss.del.cur;
    lglrep(lgl, 2 as libc::c_int, 'G' as i32 as libc::c_char);
    (*lgl).gaussing = 0 as libc::c_int as libc::c_char;
    (*lgl).simp = (*lgl).gaussing;
    lglstop(lgl);
    return ((*lgl).mt == 0) as libc::c_int;
}
unsafe extern "C" fn lglcardsub(
    mut lgl: *mut LGL,
    mut lits: *const libc::c_int,
    mut bound: libc::c_int,
) -> libc::c_int {
    let mut count: libc::c_int = 0;
    let mut size: libc::c_int = 0;
    let mut res: libc::c_int = 0;
    let mut minlit: libc::c_int = 0;
    let mut minocc: libc::c_int = 0;
    let mut nocc: libc::c_int = 0;
    let mut lit: libc::c_int = 0;
    let mut pos: libc::c_int = 0;
    let mut otherbound: libc::c_int = 0;
    let mut card: *mut Card = (*lgl).c2rust_unnamed.card;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut c: *const libc::c_int = 0 as *const libc::c_int;
    let mut q: *const libc::c_int = 0 as *const libc::c_int;
    let mut s: *mut Stk = 0 as *mut Stk;
    minocc = 2147483647 as libc::c_int;
    minlit = 0 as libc::c_int;
    p = lits;
    while minocc != 0
        && {
            lit = *p;
            lit != 0
        }
    {
        lglmarkunmarked(lgl, lit);
        s = ((*card).occs).offset(lit as isize);
        (*(*lgl).stats).steps += 1;
        (*(*lgl).stats).steps;
        (*(*lgl).stats).card.steps += 1;
        (*(*lgl).stats).card.steps;
        nocc = lglcntstk(s) as libc::c_int;
        if !(nocc > minocc) {
            minlit = lit;
            minocc = nocc;
        }
        p = p.offset(1);
        p;
    }
    res = 0 as libc::c_int;
    if minocc != 0 && minlit != 0 {
        size = p.offset_from(lits) as libc::c_long as libc::c_int;
        s = ((*card).occs).offset(minlit as isize);
        p = (*s).start;
        while p < (*s).top as *const libc::c_int {
            pos = *p;
            c = ((*card).cards.start).offset(pos as isize);
            (*(*lgl).stats).steps += 1;
            (*(*lgl).stats).steps;
            (*(*lgl).stats).card.steps += 1;
            (*(*lgl).stats).card.steps;
            otherbound = *c;
            if !(otherbound > bound) {
                count = 0 as libc::c_int;
                (*(*lgl).stats).steps += 1;
                (*(*lgl).stats).steps;
                (*(*lgl).stats).card.steps += 1;
                (*(*lgl).stats).card.steps;
                q = c.offset(1 as libc::c_int as isize);
                while *q != 0 {
                    count += 1;
                    count;
                    q = q.offset(1);
                    q;
                }
                if !(count < size) {
                    count = 0 as libc::c_int;
                    (*(*lgl).stats).steps += 1;
                    (*(*lgl).stats).steps;
                    (*(*lgl).stats).card.steps += 1;
                    (*(*lgl).stats).card.steps;
                    q = c.offset(1 as libc::c_int as isize);
                    while count < size
                        && {
                            lit = *q;
                            lit != 0
                        }
                    {
                        if lglmarked(lgl, lit) > 0 as libc::c_int {
                            count += 1;
                            count;
                        }
                        q = q.offset(1);
                        q;
                    }
                    if count >= size {
                        res = 1 as libc::c_int;
                    }
                }
            }
            p = p.offset(1);
            p;
        }
    }
    p = lits;
    loop {
        lit = *p;
        if !(lit != 0) {
            break;
        }
        lglunmark(lgl, lit);
        p = p.offset(1);
        p;
    }
    return res;
}
unsafe extern "C" fn lglcard1sub(
    mut lgl: *mut LGL,
    mut lits: *const libc::c_int,
) -> libc::c_int {
    let mut res: libc::c_int = 0;
    let mut minlit: libc::c_int = 0;
    let mut minocc: libc::c_int = 0;
    let mut nocc: libc::c_int = 0;
    let mut lit: libc::c_int = 0;
    let mut count: libc::c_int = 0;
    let mut size: libc::c_int = 0;
    let mut card: *mut Card = (*lgl).c2rust_unnamed.card;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut c: *const libc::c_int = 0 as *const libc::c_int;
    let mut q: *const libc::c_int = 0 as *const libc::c_int;
    let mut s: *mut Stk = 0 as *mut Stk;
    minocc = 2147483647 as libc::c_int;
    minlit = 0 as libc::c_int;
    p = lits;
    while minocc != 0
        && {
            lit = *p;
            lit != 0
        }
    {
        lglmarkunmarked(lgl, lit);
        s = ((*card).occs).offset(lit as isize);
        (*(*lgl).stats).steps += 1;
        (*(*lgl).stats).steps;
        (*(*lgl).stats).card.steps += 1;
        (*(*lgl).stats).card.steps;
        nocc = lglcntstk(s) as libc::c_int;
        if !(nocc > minocc) {
            minlit = lit;
            minocc = nocc;
        }
        p = p.offset(1);
        p;
    }
    res = 0 as libc::c_int;
    if !(minocc == 0 || minlit == 0) {
        size = p.offset_from(lits) as libc::c_long as libc::c_int;
        s = ((*card).occs).offset(minlit as isize);
        count = 0 as libc::c_int;
        p = (*s).start;
        while res == 0 && p < (*s).top as *const libc::c_int {
            c = ((*card).atmost1.start).offset(*p as isize);
            q = c;
            loop {
                lit = *q;
                if !(lit != 0) {
                    break;
                }
                if lglmarked(lgl, lit) != 0
                    && {
                        count += 1;
                        count >= size
                    }
                {
                    break;
                }
                q = q.offset(1);
                q;
            }
            if !(lit == 0) {
                res = 1 as libc::c_int;
            }
            p = p.offset(1);
            p;
        }
    }
    p = lits;
    loop {
        lit = *p;
        if !(lit != 0) {
            break;
        }
        lglunmark(lgl, lit);
        p = p.offset(1);
        p;
    }
    return res;
}
unsafe extern "C" fn lglcard2sub(
    mut lgl: *mut LGL,
    mut lits: *const libc::c_int,
    mut minlitptr: *mut libc::c_int,
) -> libc::c_int {
    let mut res: libc::c_int = 0;
    let mut minlit: libc::c_int = 0;
    let mut minocc: libc::c_int = 0;
    let mut nocc: libc::c_int = 0;
    let mut lit: libc::c_int = 0;
    let mut count: libc::c_int = 0;
    let mut size: libc::c_int = 0;
    let mut card: *mut Card = (*lgl).c2rust_unnamed.card;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut c: *const libc::c_int = 0 as *const libc::c_int;
    let mut q: *const libc::c_int = 0 as *const libc::c_int;
    let mut s: *mut Stk = 0 as *mut Stk;
    minocc = 2147483647 as libc::c_int;
    minlit = 0 as libc::c_int;
    p = lits;
    while minocc != 0
        && {
            lit = *p;
            lit != 0
        }
    {
        lglmarkunmarked(lgl, lit);
        s = ((*card).occs).offset(lit as isize);
        (*(*lgl).stats).steps += 1;
        (*(*lgl).stats).steps;
        (*(*lgl).stats).card.steps += 1;
        (*(*lgl).stats).card.steps;
        nocc = lglcntstk(s) as libc::c_int;
        if !(nocc > minocc) {
            minlit = lit;
            minocc = nocc;
        }
        p = p.offset(1);
        p;
    }
    res = 0 as libc::c_int;
    if !(minocc == 0 || minlit == 0 || *minlitptr == minlit) {
        *minlitptr = minlit;
        size = p.offset_from(lits) as libc::c_long as libc::c_int;
        s = ((*card).occs).offset(minlit as isize);
        count = 0 as libc::c_int;
        p = (*s).start;
        while res == 0 && p < (*s).top as *const libc::c_int {
            c = ((*card).atmost2.start).offset(*p as isize);
            q = c;
            loop {
                lit = *q;
                if !(lit != 0) {
                    break;
                }
                if lglmarked(lgl, lit) != 0
                    && {
                        count += 1;
                        count >= size
                    }
                {
                    break;
                }
                q = q.offset(1);
                q;
            }
            if !(lit == 0) {
                res = 1 as libc::c_int;
            }
            p = p.offset(1);
            p;
        }
    }
    p = lits;
    loop {
        lit = *p;
        if !(lit != 0) {
            break;
        }
        lglunmark(lgl, lit);
        p = p.offset(1);
        p;
    }
    return res;
}
unsafe extern "C" fn lgladdcard(
    mut lgl: *mut LGL,
    mut lits: *const libc::c_int,
    mut bound: libc::c_int,
    mut subsumed_ptr: *mut libc::c_int,
) -> libc::c_int {
    let mut card: *mut Card = (*lgl).c2rust_unnamed.card;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut start: libc::c_int = 0;
    let mut lit: libc::c_int = 0;
    if lglcardsub(lgl, lits, bound) != 0 {
        (*(*lgl).stats).card.subsumed += 1;
        (*(*lgl).stats).card.subsumed;
        if !subsumed_ptr.is_null() {
            *subsumed_ptr += 1 as libc::c_int;
        }
        return 0 as libc::c_int;
    }
    start = lglcntstk(&mut (*card).cards) as libc::c_int;
    lglpushstk(lgl, &mut (*card).cards, bound);
    p = lits;
    loop {
        lit = *p;
        if !(lit != 0) {
            break;
        }
        lglpushstk(lgl, &mut (*card).cards, lit);
        lglpushstk(lgl, ((*card).occs).offset(lit as isize), start);
        p = p.offset(1);
        p;
    }
    lglpushstk(lgl, &mut (*card).cards, 0 as libc::c_int);
    return 1 as libc::c_int;
}
unsafe extern "C" fn lglcardfmstep(
    mut lgl: *mut LGL,
    mut pivot: libc::c_int,
    mut cardposidx: libc::c_int,
    mut cardnegidx: libc::c_int,
) {
    let mut bn: libc::c_int = 0;
    let mut bp: libc::c_int = 0;
    let mut ln: libc::c_int = 0;
    let mut lp: libc::c_int = 0;
    let mut b: libc::c_int = 0;
    let mut c: libc::c_int = 0;
    let mut s: libc::c_int = 0;
    let mut lit: libc::c_int = 0;
    let mut idx: libc::c_int = 0;
    let mut addcard: libc::c_int = 0;
    let mut len: libc::c_int = 0;
    let mut unit: [libc::c_int; 2] = [0; 2];
    let mut div: libc::c_int = 0;
    let mut elim: libc::c_int = 0;
    let cardcut: libc::c_int = (*(*lgl).opts).cardcut.val;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut q: *const libc::c_int = 0 as *const libc::c_int;
    let mut cn: *const libc::c_int = 0 as *const libc::c_int;
    let mut cp: *const libc::c_int = 0 as *const libc::c_int;
    let mut r: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut divsame: libc::c_int = 0;
    let mut cardmaxlen: libc::c_int = 0;
    let mut card: *mut Card = (*lgl).c2rust_unnamed.card;
    (*(*lgl).stats).steps += 1;
    (*(*lgl).stats).steps;
    (*(*lgl).stats).card.steps += 1;
    (*(*lgl).stats).card.steps;
    (*(*lgl).stats).card.resolved += 1;
    (*(*lgl).stats).card.resolved;
    cp = ((*card).cards.start).offset(cardposidx as isize);
    cn = ((*card).cards.start).offset(cardnegidx as isize);
    let fresh254 = cp;
    cp = cp.offset(1);
    bp = *fresh254;
    let fresh255 = cn;
    cn = cn.offset(1);
    bn = *fresh255;
    b = bp + bn;
    p = cp;
    loop {
        lit = *p;
        if !(lit != 0) {
            break;
        }
        idx = abs(lit);
        lglpushstk(lgl, &mut (*lgl).clause, idx);
        let ref mut fresh256 = *((*card).count).offset(idx as isize);
        *fresh256 = (*fresh256 as libc::c_int + lglsgn(lit)) as libc::c_schar;
        p = p.offset(1);
        p;
    }
    lp = p.offset_from(cp) as libc::c_long as libc::c_int;
    elim = 0 as libc::c_int;
    div = 1 as libc::c_int;
    q = cn;
    loop {
        lit = *q;
        if !(lit != 0) {
            break;
        }
        idx = abs(lit);
        c = *((*card).count).offset(idx as isize) as libc::c_int;
        s = lglsgn(lit);
        if c == 0 {
            lglpushstk(lgl, &mut (*lgl).clause, idx);
        }
        let ref mut fresh257 = *((*card).count).offset(idx as isize);
        *fresh257 = (*fresh257 as libc::c_int + s) as libc::c_schar;
        if c != 0 && c != s {
            elim += 1;
            elim;
        }
        if c == s {
            div = 2 as libc::c_int;
        }
        q = q.offset(1);
        q;
    }
    ln = q.offset_from(cn) as libc::c_long as libc::c_int;
    divsame = 1 as libc::c_int;
    p = (*lgl).clause.start;
    while divsame != 0 && p < (*lgl).clause.top as *const libc::c_int {
        idx = abs(*p);
        c = *((*card).count).offset(idx as isize) as libc::c_int;
        if !(c == 0) {
            if c < 0 as libc::c_int {
                c = -c;
            }
            divsame = (c == div) as libc::c_int;
        }
        p = p.offset(1);
        p;
    }
    r = (*lgl).clause.start;
    p = r;
    while p < (*lgl).clause.top as *const libc::c_int {
        idx = *p;
        c = *((*card).count).offset(idx as isize) as libc::c_int;
        if divsame != 0 || cardcut == 1 as libc::c_int {
            c /= div;
        } else if abs(c) != 1 as libc::c_int && cardcut == 2 as libc::c_int
            && div == 2 as libc::c_int
        {
            c = 0 as libc::c_int;
        }
        if !(c == 0) {
            lit = if c < 0 as libc::c_int { -idx } else { idx };
            let fresh258 = r;
            r = r.offset(1);
            *fresh258 = lit;
        }
        p = p.offset(1);
        p;
    }
    (*lgl).clause.top = r;
    b -= elim;
    if (divsame != 0 || cardcut == 1 as libc::c_int) && div == 2 as libc::c_int {
        b /= 2 as libc::c_int;
    }
    len = lglcntstk(&mut (*lgl).clause) as libc::c_int;
    lglpushstk(lgl, &mut (*lgl).clause, 0 as libc::c_int);
    addcard = 0 as libc::c_int;
    cardmaxlen = lglfactor(
        lgl,
        (*(*lgl).stats).card.count,
        (*(*lgl).opts).cardmaxlen.val,
    ) as libc::c_int;
    if !(cardcut == 0 && div > 1 as libc::c_int) {
        if b < 0 as libc::c_int {
            lglmt(lgl);
        } else if b == 0 as libc::c_int {
            p = (*lgl).clause.start;
            while p
                < ((*lgl).clause.top).offset(-(1 as libc::c_int as isize))
                    as *const libc::c_int
            {
                lit = *p;
                (*(*lgl).stats).card.units += 1;
                (*(*lgl).stats).card.units;
                lglpushstk(lgl, &mut (*(*lgl).c2rust_unnamed.card).units, -lit);
                *((*card).count)
                    .offset(abs(lit) as isize) = 0 as libc::c_int as libc::c_schar;
                unit[0 as libc::c_int as usize] = lit;
                unit[1 as libc::c_int as usize] = 0 as libc::c_int;
                lgladdcard(
                    lgl,
                    unit.as_mut_ptr(),
                    0 as libc::c_int,
                    0 as *mut libc::c_int,
                );
                p = p.offset(1);
                p;
            }
        } else if !(b >= len) {
            if !(len > cardmaxlen) {
                addcard = 1 as libc::c_int;
                if b == 1 as libc::c_int
                    && (ln >= 3 as libc::c_int && lp >= 3 as libc::c_int
                        || lglcntstk(&mut (*lgl).clause) as int64_t
                            > lglfactor(
                                lgl,
                                (*(*lgl).stats).card.count,
                                (*(*lgl).opts).cardexpam1.val,
                            ))
                {
                    p = (*lgl).clause.start;
                    while p < (*lgl).clause.top as *const libc::c_int {
                        lglpushstk(lgl, &mut (*(*lgl).c2rust_unnamed.card).expam1, *p);
                        p = p.offset(1);
                        p;
                    }
                }
            }
        }
    }
    cp = ((*card).cards.start)
        .offset(cardposidx as isize)
        .offset(1 as libc::c_int as isize);
    cn = ((*card).cards.start)
        .offset(cardnegidx as isize)
        .offset(1 as libc::c_int as isize);
    p = cp;
    loop {
        lit = *p;
        if !(lit != 0) {
            break;
        }
        *((*card).count).offset(abs(lit) as isize) = 0 as libc::c_int as libc::c_schar;
        p = p.offset(1);
        p;
    }
    q = cn;
    loop {
        lit = *q;
        if !(lit != 0) {
            break;
        }
        *((*card).count).offset(abs(lit) as isize) = 0 as libc::c_int as libc::c_schar;
        q = q.offset(1);
        q;
    }
    if addcard > 0 as libc::c_int {
        lgladdcard(lgl, (*lgl).clause.start, b, 0 as *mut libc::c_int);
    }
    lglclnstk(&mut (*lgl).clause);
}
unsafe extern "C" fn lglrmcardexcept(
    mut lgl: *mut LGL,
    mut cardidx: libc::c_int,
    mut except: libc::c_int,
) {
    let mut card: *mut Card = (*lgl).c2rust_unnamed.card;
    let mut c: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut p: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut lit: libc::c_int = 0;
    c = ((*card).cards.start).offset(cardidx as isize).offset(1 as libc::c_int as isize);
    p = c;
    loop {
        lit = *p;
        if !(lit != 0) {
            break;
        }
        if lit != except {
            lglrmstk(((*card).occs).offset(lit as isize), cardidx);
        }
        p = p.offset(1);
        p;
    };
}
unsafe extern "C" fn lglcardocc(mut lgl: *mut LGL, mut a: libc::c_int) -> libc::c_int {
    return lglcntstk(((*(*lgl).c2rust_unnamed.card).occs).offset(a as isize))
        as libc::c_int;
}
unsafe extern "C" fn lglcmpcard(
    mut lgl: *mut LGL,
    mut a: libc::c_int,
    mut b: libc::c_int,
) -> libc::c_int {
    let mut s: int64_t = lglcardocc(lgl, a) as int64_t * lglcardocc(lgl, -a) as int64_t;
    let mut t: int64_t = lglcardocc(lgl, b) as int64_t * lglcardocc(lgl, -b) as int64_t;
    if s > t {
        return -(1 as libc::c_int);
    }
    if s < t {
        return 1 as libc::c_int;
    }
    return b - a;
}
unsafe extern "C" fn lglcardresched(mut lgl: *mut LGL) {
    let mut elim: *mut Stk = &mut (*(*lgl).c2rust_unnamed.card).elim;
    let mut count: libc::c_int = lglcntstk(elim) as libc::c_int;
    (*(*lgl).stats).steps += (4 as libc::c_int * count) as int64_t;
    (*(*lgl).stats).card.steps += (4 as libc::c_int * count) as int64_t;
    let mut AA: *mut libc::c_int = (*elim).start;
    let NN: libc::c_int = lglcntstk(elim) as libc::c_int;
    let mut L: libc::c_int = 0 as libc::c_int;
    let mut R: libc::c_int = NN - 1 as libc::c_int;
    let mut M: libc::c_int = 0;
    let mut LL: libc::c_int = 0;
    let mut RR: libc::c_int = 0;
    let mut I: libc::c_int = 0;
    if !(R - L <= 10 as libc::c_int) {
        loop {
            M = (L + R) / 2 as libc::c_int;
            let mut TMP: libc::c_int = *AA.offset(M as isize);
            *AA.offset(M as isize) = *AA.offset((R - 1 as libc::c_int) as isize);
            *AA.offset((R - 1 as libc::c_int) as isize) = TMP;
            if lglcmpcard(
                lgl,
                *AA.offset(L as isize),
                *AA.offset((R - 1 as libc::c_int) as isize),
            ) > 0 as libc::c_int
            {
                let mut TMP_0: libc::c_int = *AA.offset(L as isize);
                *AA.offset(L as isize) = *AA.offset((R - 1 as libc::c_int) as isize);
                *AA.offset((R - 1 as libc::c_int) as isize) = TMP_0;
            }
            if lglcmpcard(lgl, *AA.offset(L as isize), *AA.offset(R as isize))
                > 0 as libc::c_int
            {
                let mut TMP_1: libc::c_int = *AA.offset(L as isize);
                *AA.offset(L as isize) = *AA.offset(R as isize);
                *AA.offset(R as isize) = TMP_1;
            }
            if lglcmpcard(
                lgl,
                *AA.offset((R - 1 as libc::c_int) as isize),
                *AA.offset(R as isize),
            ) > 0 as libc::c_int
            {
                let mut TMP_2: libc::c_int = *AA.offset((R - 1 as libc::c_int) as isize);
                *AA.offset((R - 1 as libc::c_int) as isize) = *AA.offset(R as isize);
                *AA.offset(R as isize) = TMP_2;
            }
            let mut PIVOT: libc::c_int = 0;
            let mut J: libc::c_int = R - 1 as libc::c_int;
            I = L + 1 as libc::c_int - 1 as libc::c_int;
            PIVOT = *AA.offset(J as isize);
            loop {
                loop {
                    I += 1;
                    if !(lglcmpcard(lgl, *AA.offset(I as isize), PIVOT)
                        < 0 as libc::c_int)
                    {
                        break;
                    }
                }
                loop {
                    J -= 1;
                    if !(lglcmpcard(lgl, PIVOT, *AA.offset(J as isize))
                        < 0 as libc::c_int)
                    {
                        break;
                    }
                    if J == L + 1 as libc::c_int {
                        break;
                    }
                }
                if I >= J {
                    break;
                }
                let mut TMP_3: libc::c_int = *AA.offset(I as isize);
                *AA.offset(I as isize) = *AA.offset(J as isize);
                *AA.offset(J as isize) = TMP_3;
            }
            let mut TMP_4: libc::c_int = *AA.offset(I as isize);
            *AA.offset(I as isize) = *AA.offset((R - 1 as libc::c_int) as isize);
            *AA.offset((R - 1 as libc::c_int) as isize) = TMP_4;
            if I - L < R - I {
                LL = I + 1 as libc::c_int;
                RR = R;
                R = I - 1 as libc::c_int;
            } else {
                LL = L;
                RR = I - 1 as libc::c_int;
                L = I + 1 as libc::c_int;
            }
            if R - L > 10 as libc::c_int {
                lglpushstk(lgl, &mut (*lgl).c2rust_unnamed_0.sortstk, LL);
                lglpushstk(lgl, &mut (*lgl).c2rust_unnamed_0.sortstk, RR);
            } else if RR - LL > 10 as libc::c_int {
                L = LL;
                R = RR;
            } else {
                if !(lglmtstk(&mut (*lgl).c2rust_unnamed_0.sortstk) == 0) {
                    break;
                }
                R = lglpopstk(&mut (*lgl).c2rust_unnamed_0.sortstk);
                L = lglpopstk(&mut (*lgl).c2rust_unnamed_0.sortstk);
            }
        }
    }
    let mut PIVOT_0: libc::c_int = 0;
    let mut L_0: libc::c_int = 0 as libc::c_int;
    let mut R_0: libc::c_int = NN - 1 as libc::c_int;
    let mut I_0: libc::c_int = 0;
    let mut J_0: libc::c_int = 0;
    I_0 = R_0;
    while I_0 > L_0 {
        if lglcmpcard(
            lgl,
            *AA.offset((I_0 - 1 as libc::c_int) as isize),
            *AA.offset(I_0 as isize),
        ) > 0 as libc::c_int
        {
            let mut TMP_5: libc::c_int = *AA.offset((I_0 - 1 as libc::c_int) as isize);
            *AA.offset((I_0 - 1 as libc::c_int) as isize) = *AA.offset(I_0 as isize);
            *AA.offset(I_0 as isize) = TMP_5;
        }
        I_0 -= 1;
        I_0;
    }
    I_0 = L_0 + 2 as libc::c_int;
    while I_0 <= R_0 {
        J_0 = I_0;
        PIVOT_0 = *AA.offset(I_0 as isize);
        while lglcmpcard(lgl, PIVOT_0, *AA.offset((J_0 - 1 as libc::c_int) as isize))
            < 0 as libc::c_int
        {
            *AA.offset(J_0 as isize) = *AA.offset((J_0 - 1 as libc::c_int) as isize);
            J_0 -= 1;
            J_0;
        }
        *AA.offset(J_0 as isize) = PIVOT_0;
        I_0 += 1;
        I_0;
    }
    (*(*lgl).stats).card.resched += 1;
    (*(*lgl).stats).card.resched;
}
unsafe extern "C" fn lglcardfmlit(mut lgl: *mut LGL, mut pivot: libc::c_int) {
    let mut poccs: *mut Stk = ((*(*lgl).c2rust_unnamed.card).occs)
        .offset(pivot as isize);
    let mut noccs: *mut Stk = ((*(*lgl).c2rust_unnamed.card).occs)
        .offset(-(pivot as isize));
    let mut pcnt: libc::c_int = lglcntstk(poccs) as libc::c_int;
    let mut ncnt: libc::c_int = lglcntstk(noccs) as libc::c_int;
    let mut count: libc::c_int = (*(*lgl).stats).card.count;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut q: *const libc::c_int = 0 as *const libc::c_int;
    if !(pcnt == 0 || ncnt == 0) {
        if !(pcnt as int64_t > lglfactor(lgl, (*(*lgl).opts).cardocclim1.val, count)) {
            if !(ncnt as int64_t > lglfactor(lgl, (*(*lgl).opts).cardocclim1.val, count))
            {
                if !(pcnt as int64_t
                    > lglfactor(lgl, (*(*lgl).opts).cardocclim2.val, count)
                    && ncnt as int64_t
                        > lglfactor(lgl, (*(*lgl).opts).cardocclim2.val, count))
                {
                    (*(*lgl).stats).card.eliminated += 1;
                    (*(*lgl).stats).card.eliminated;
                    *((*(*lgl).c2rust_unnamed.card).eliminated)
                        .offset(pivot as isize) = 1 as libc::c_int as libc::c_char;
                    p = (*poccs).start;
                    while (*lgl).mt == 0 && p < (*poccs).top as *const libc::c_int {
                        q = (*noccs).start;
                        while (*lgl).mt == 0 && q < (*noccs).top as *const libc::c_int {
                            lglcardfmstep(lgl, pivot, *p, *q);
                            q = q.offset(1);
                            q;
                        }
                        p = p.offset(1);
                        p;
                    }
                }
            }
        }
    }
    p = (*poccs).start;
    while (*lgl).mt == 0 && p < (*poccs).top as *const libc::c_int {
        lglrmcardexcept(lgl, *p, pivot);
        (*(*lgl).stats).steps += 1;
        (*(*lgl).stats).steps;
        (*(*lgl).stats).card.steps += 1;
        (*(*lgl).stats).card.steps;
        p = p.offset(1);
        p;
    }
    q = (*noccs).start;
    while (*lgl).mt == 0 && q < (*noccs).top as *const libc::c_int {
        lglrmcardexcept(lgl, *q, -pivot);
        (*(*lgl).stats).steps += 1;
        (*(*lgl).stats).steps;
        (*(*lgl).stats).card.steps += 1;
        (*(*lgl).stats).card.steps;
        q = q.offset(1);
        q;
    }
    lglrelstk(lgl, poccs);
    lglrelstk(lgl, noccs);
    if (*(*lgl).stats).card.eliminated % (*(*lgl).opts).cardreschedint.val as int64_t
        == 0
    {
        lglcardresched(lgl);
    }
}
unsafe extern "C" fn lglcardfm(mut lgl: *mut LGL) {
    let mut elim: *mut Stk = 0 as *mut Stk;
    lglcardresched(lgl);
    elim = &mut (*(*lgl).c2rust_unnamed.card).elim;
    while (*lgl).mt == 0 && lglmtstk(elim) == 0 && lglterminate(lgl) == 0
        && {
            (*(*lgl).stats).steps += 1;
            (*(*lgl).stats).steps;
            let fresh259 = (*(*lgl).stats).card.steps;
            (*(*lgl).stats).card.steps = (*(*lgl).stats).card.steps + 1;
            (*(*lgl).limits).card.steps >= fresh259
        }
    {
        lglcardfmlit(lgl, lglpopstk(elim));
    }
}
unsafe extern "C" fn lglsetcardlim(mut lgl: *mut LGL) -> int64_t {
    let mut limit: int64_t = 0;
    let mut irrlim: int64_t = 0;
    let mut pen: libc::c_int = 0;
    let mut szpen: libc::c_int = 0;
    limit = (*(*lgl).opts).cardreleff.val as int64_t * lglvisearch(lgl)
        / 1000 as libc::c_int as int64_t;
    if limit < (*(*lgl).opts).cardmineff.val as int64_t {
        limit = (*(*lgl).opts).cardmineff.val as int64_t;
    }
    if (*(*lgl).opts).cardmaxeff.val >= 0 as libc::c_int
        && limit > (*(*lgl).opts).cardmaxeff.val as int64_t
    {
        limit = (*(*lgl).opts).cardmaxeff.val as int64_t;
    }
    szpen = lglszpen(lgl);
    pen = (*(*lgl).limits).card.pen + szpen;
    limit >>= pen;
    irrlim = ((*(*lgl).stats).irr.clauses.cur / 4 as libc::c_int >> szpen) as int64_t;
    if (*(*lgl).opts).irrlim.val != 0 && limit < irrlim {
        limit = irrlim;
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[card-%d] limit %lld based on %d irredundant clauses penalty %d\0"
                as *const u8 as *const libc::c_char,
            (*(*lgl).stats).card.count,
            limit as libc::c_longlong,
            (*(*lgl).stats).irr.clauses.cur,
            szpen,
        );
    } else {
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[card-%d] limit %lld penalty %d = %d + %d\0" as *const u8
                as *const libc::c_char,
            (*(*lgl).stats).card.count,
            limit as libc::c_longlong,
            pen,
            (*(*lgl).limits).card.pen,
            szpen,
        );
    }
    (*(*lgl).limits).card.steps = (*(*lgl).stats).card.steps + limit;
    return limit;
}
unsafe extern "C" fn lglsetcardlimagain(mut lgl: *mut LGL, mut limit: int64_t) {
    lglprt(
        lgl,
        1 as libc::c_int,
        b"[card-%d] using previous limit %lld for elimination\0" as *const u8
            as *const libc::c_char,
        (*(*lgl).stats).card.count,
        limit as libc::c_longlong,
        (*(*lgl).stats).irr.clauses.cur,
    );
    (*(*lgl).limits).card.steps = (*(*lgl).stats).card.steps + limit;
}
unsafe extern "C" fn lglcard1extractlit(
    mut lgl: *mut LGL,
    mut lit: libc::c_int,
) -> libc::c_int {
    let ignused: libc::c_int = (*(*lgl).opts).cardignused.val;
    let mut blit: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut other2: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut cntother: libc::c_int = 0;
    let mut start: libc::c_int = 0;
    let mut size: libc::c_int = 0;
    let mut trivial: libc::c_int = 0;
    let mut subsumed: libc::c_int = 0;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut w: *const libc::c_int = 0 as *const libc::c_int;
    let mut eow: *const libc::c_int = 0 as *const libc::c_int;
    let mut card: *mut Card = 0 as *mut Card;
    let mut hts: *mut HTS = 0 as *mut HTS;
    (*(*lgl).stats).card.found.am1.last.cnt = 0 as libc::c_int;
    (*(*lgl).stats).card.found.am1.last.max = 0 as libc::c_int;
    if lglterminate(lgl) != 0 {
        return 0 as libc::c_int;
    }
    (*(*lgl).stats).steps += 1;
    (*(*lgl).stats).steps;
    let fresh260 = (*(*lgl).stats).card.steps;
    (*(*lgl).stats).card.steps = (*(*lgl).stats).card.steps + 1;
    if (*(*lgl).limits).card.steps < fresh260 {
        return 0 as libc::c_int;
    }
    card = (*lgl).c2rust_unnamed.card;
    if ignused != 0 && *((*card).lit2used).offset(lit as isize) as libc::c_int != 0 {
        return 1 as libc::c_int;
    }
    start = lglcntstk(&mut (*card).atmost1) as libc::c_int;
    lglpushstk(lgl, &mut (*card).atmost1, lit);
    *((*card).marked).offset(lit as isize) = 1 as libc::c_int as libc::c_char;
    hts = lglhts(lgl, -lit);
    w = lglhts2wchs(lgl, hts);
    eow = w.offset((*hts).count as isize);
    (*(*lgl).stats).steps += 1;
    (*(*lgl).stats).steps;
    (*(*lgl).stats).card.steps += 1;
    (*(*lgl).stats).card.steps;
    p = w;
    while p < eow {
        blit = *p;
        tag = blit & MASKCS as libc::c_int;
        if tag == TRNCS as libc::c_int || tag == LRGCS as libc::c_int {
            p = p.offset(1);
            p;
        }
        if !(tag != BINCS as libc::c_int) {
            other = -(blit >> RMSHFT as libc::c_int);
            if !(ignused != 0
                && *((*card).lit2used).offset(other as isize) as libc::c_int != 0)
            {
                i = start + 1 as libc::c_int;
                while i < lglcntstk(&mut (*card).atmost1) as libc::c_int {
                    other2 = lglpeek(&mut (*card).atmost1, i);
                    if lglhasbin(lgl, -other, -other2) == 0 {
                        break;
                    }
                    i += 1;
                    i;
                }
                if !(i < lglcntstk(&mut (*card).atmost1) as libc::c_int) {
                    *((*card).marked)
                        .offset(other as isize) = 1 as libc::c_int as libc::c_char;
                    lglpushstk(lgl, &mut (*card).atmost1, other);
                    cntother = (*lglhts(lgl, -other)).count as libc::c_int;
                    j = start + 1 as libc::c_int;
                    while j < i {
                        let mut tmp: libc::c_int = lglpeek(&mut (*card).atmost1, j);
                        let mut cntmp: libc::c_int = (*lglhts(lgl, -tmp)).count
                            as libc::c_int;
                        if cntmp > cntother {
                            break;
                        }
                        j += 1;
                        j;
                    }
                    if j < i {
                        let mut k: libc::c_int = 0;
                        k = i;
                        while k > j {
                            *((*card).atmost1.start)
                                .offset(
                                    k as isize,
                                ) = *((*card).atmost1.start)
                                .offset((k - 1 as libc::c_int) as isize);
                            k -= 1;
                            k;
                        }
                        *((*card).atmost1.start).offset(j as isize) = other;
                    }
                }
            }
        }
        p = p.offset(1);
        p;
    }
    size = (lglcntstk(&mut (*card).atmost1)).wrapping_sub(start as size_t)
        as libc::c_int;
    trivial = (size <= 2 as libc::c_int) as libc::c_int;
    if ignused == 0 {
        lglpushstk(lgl, &mut (*card).atmost1, 0 as libc::c_int);
        subsumed = lglcard1sub(lgl, ((*card).atmost1.start).offset(start as isize));
        lglpopstk(&mut (*card).atmost1);
    } else {
        subsumed = 0 as libc::c_int;
    }
    p = ((*card).atmost1.start).offset(start as isize);
    while p < (*card).atmost1.top as *const libc::c_int {
        other = *p;
        *((*card).marked).offset(other as isize) = 0 as libc::c_int as libc::c_char;
        if trivial == 0 && subsumed == 0 {
            *((*card).lit2used)
                .offset(other as isize) = 1 as libc::c_int as libc::c_char;
        }
        p = p.offset(1);
        p;
    }
    if trivial != 0 || subsumed != 0 {
        lglrststk(&mut (*card).atmost1, start);
    } else {
        if ignused == 0 {
            i = start;
            while i < start + size {
                other = lglpeek(&mut (*card).atmost1, i);
                lglpushstk(lgl, &mut *((*card).occs).offset(other as isize), start);
                i += 1;
                i;
            }
        }
        lglpushstk(lgl, &mut (*card).atmost1, 0 as libc::c_int);
        (*(*lgl).stats).card.found.am1.total.sum += size as int64_t;
        (*(*lgl).stats).card.found.am1.total.cnt += 1;
        (*(*lgl).stats).card.found.am1.total.cnt;
        (*(*lgl).stats).card.found.am1.last.cnt += 1;
        (*(*lgl).stats).card.found.am1.last.cnt;
        if (*(*lgl).stats).card.found.am1.total.max < size {
            (*(*lgl).stats).card.found.am1.total.max = size;
        }
        if (*(*lgl).stats).card.found.am1.last.max < size {
            (*(*lgl).stats).card.found.am1.last.max = size;
        }
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn lglcardreloccs(mut lgl: *mut LGL) {
    let mut card: *mut Card = (*lgl).c2rust_unnamed.card;
    let mut sign: libc::c_int = 0;
    let mut idx: libc::c_int = 0;
    let mut lit: libc::c_int = 0;
    sign = -(1 as libc::c_int);
    while sign <= 1 as libc::c_int {
        idx = 2 as libc::c_int;
        while idx < (*lgl).nvars {
            lit = sign * idx;
            lglrelstk(lgl, &mut *((*card).occs).offset(lit as isize));
            idx += 1;
            idx;
        }
        sign += 2 as libc::c_int;
    }
    (*card).occs = ((*card).occs).offset(-((*lgl).nvars as isize));
    lgldel(
        lgl,
        (*card).occs as *mut libc::c_void,
        ((2 as libc::c_int * (*lgl).nvars) as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Stk>() as libc::c_ulong),
    );
    (*card).occs = 0 as *mut Stk;
}
unsafe extern "C" fn lglcard1extract(mut lgl: *mut LGL) -> libc::c_int {
    let mut before: C2RustUnnamed_142 = C2RustUnnamed_142 {
        cnt: 0,
        sum: 0,
    };
    let mut after: C2RustUnnamed_142 = C2RustUnnamed_142 {
        cnt: 0,
        sum: 0,
    };
    let mut delta: C2RustUnnamed_142 = C2RustUnnamed_142 {
        cnt: 0,
        sum: 0,
    };
    let ignused: libc::c_int = (*(*lgl).opts).cardignused.val;
    let mut card: *mut Card = (*lgl).c2rust_unnamed.card;
    lglpushstk(lgl, &mut (*card).atmost1, 0 as libc::c_int);
    (*card)
        .lit2used = lglnew(
        lgl,
        ((2 as libc::c_int * (*lgl).nvars) as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_char>() as libc::c_ulong),
    ) as *mut libc::c_char;
    (*card).lit2used = ((*card).lit2used).offset((*lgl).nvars as isize);
    (*card)
        .marked = lglnew(
        lgl,
        ((2 as libc::c_int * (*lgl).nvars) as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_char>() as libc::c_ulong),
    ) as *mut libc::c_char;
    (*card).marked = ((*card).marked).offset((*lgl).nvars as isize);
    if ignused == 0 {
        (*card)
            .occs = lglnew(
            lgl,
            ((2 as libc::c_int * (*lgl).nvars) as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<Stk>() as libc::c_ulong),
        ) as *mut Stk;
        (*card).occs = ((*card).occs).offset((*lgl).nvars as isize);
    }
    before.cnt = (*(*lgl).stats).card.found.am1.total.cnt as libc::c_int;
    before.sum = (*(*lgl).stats).card.found.am1.total.sum;
    lglrandlitrav(
        lgl,
        Some(
            lglcard1extractlit
                as unsafe extern "C" fn(*mut LGL, libc::c_int) -> libc::c_int,
        ),
    );
    after.cnt = (*(*lgl).stats).card.found.am1.total.cnt as libc::c_int;
    after.sum = (*(*lgl).stats).card.found.am1.total.sum;
    delta.cnt = after.cnt - before.cnt;
    delta.sum = after.sum - before.sum;
    (*card).lit2used = ((*card).lit2used).offset(-((*lgl).nvars as isize));
    lgldel(
        lgl,
        (*card).lit2used as *mut libc::c_void,
        ((2 as libc::c_int * (*lgl).nvars) as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_char>() as libc::c_ulong),
    );
    (*card).lit2used = 0 as *mut libc::c_char;
    (*card).marked = ((*card).marked).offset(-((*lgl).nvars as isize));
    lgldel(
        lgl,
        (*card).marked as *mut libc::c_void,
        ((2 as libc::c_int * (*lgl).nvars) as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_char>() as libc::c_ulong),
    );
    (*card).marked = 0 as *mut libc::c_char;
    if ignused == 0 {
        lglcardreloccs(lgl);
    }
    if delta.cnt != 0 {
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[card-%d] found %d at-most-one constraints of average size %.1f\0"
                as *const u8 as *const libc::c_char,
            (*(*lgl).stats).card.count,
            delta.cnt,
            lglavg(delta.sum as libc::c_double, delta.cnt as libc::c_double),
        );
    } else {
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[card-%d] no at-most-one constraint found\0" as *const u8
                as *const libc::c_char,
            (*(*lgl).stats).card.count,
        );
    }
    return delta.cnt;
}
unsafe extern "C" fn lglcard2extractlit(
    mut lgl: *mut LGL,
    mut lit: libc::c_int,
) -> libc::c_int {
    let mut blit: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut other2: libc::c_int = 0;
    let mut other3: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut k: libc::c_int = 0;
    let mut res: libc::c_int = 1 as libc::c_int;
    let ignused: libc::c_int = (*(*lgl).opts).cardignused.val;
    let mut start: libc::c_int = 0;
    let mut size: libc::c_int = 0;
    let mut minlit: libc::c_int = 0;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut w: *const libc::c_int = 0 as *const libc::c_int;
    let mut eow: *const libc::c_int = 0 as *const libc::c_int;
    let mut q: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut card: *mut Card = 0 as *mut Card;
    let mut hts: *mut HTS = 0 as *mut HTS;
    (*(*lgl).stats).card.found.am2.last.cnt = 0 as libc::c_int;
    (*(*lgl).stats).card.found.am2.last.max = 0 as libc::c_int;
    if lglterminate(lgl) != 0 {
        return 0 as libc::c_int;
    }
    (*(*lgl).stats).steps += 1;
    (*(*lgl).stats).steps;
    let fresh261 = (*(*lgl).stats).card.steps;
    (*(*lgl).stats).card.steps = (*(*lgl).stats).card.steps + 1;
    if (*(*lgl).limits).card.steps < fresh261 {
        return 0 as libc::c_int;
    }
    card = (*lgl).c2rust_unnamed.card;
    if ignused != 0 && *((*card).lit2used).offset(lit as isize) as libc::c_int != 0 {
        return 1 as libc::c_int;
    }
    start = lglcntstk(&mut (*card).atmost2) as libc::c_int;
    hts = lglhts(lgl, -lit);
    w = lglhts2wchs(lgl, hts);
    eow = w.offset((*hts).count as isize);
    (*(*lgl).stats).steps += 1;
    (*(*lgl).stats).steps;
    (*(*lgl).stats).card.steps += 1;
    (*(*lgl).stats).card.steps;
    p = w;
    while p < eow {
        blit = *p;
        tag = blit & MASKCS as libc::c_int;
        if tag == TRNCS as libc::c_int || tag == LRGCS as libc::c_int {
            p = p.offset(1);
            p;
        }
        if !(tag != TRNCS as libc::c_int) {
            other = -(blit >> RMSHFT as libc::c_int);
            other2 = -*p;
            if !(*((*card).lit2count).offset(-other as isize) != 0
                || *((*card).lit2count).offset(-other2 as isize) != 0)
            {
                let ref mut fresh262 = *((*card).lit2count).offset(lit as isize);
                let fresh263 = *fresh262;
                *fresh262 = *fresh262 + 1;
                if fresh263 == 0 {
                    lglpushstk(lgl, &mut (*card).atmost2, lit);
                }
                let ref mut fresh264 = *((*card).lit2count).offset(other as isize);
                let fresh265 = *fresh264;
                *fresh264 = *fresh264 + 1;
                if fresh265 == 0 {
                    lglpushstk(lgl, &mut (*card).atmost2, other);
                }
                let ref mut fresh266 = *((*card).lit2count).offset(other2 as isize);
                let fresh267 = *fresh266;
                *fresh266 = *fresh266 + 1;
                if fresh267 == 0 {
                    lglpushstk(lgl, &mut (*card).atmost2, other2);
                }
            }
        }
        p = p.offset(1);
        p;
    }
    q = ((*card).atmost2.start).offset(start as isize);
    p = q;
    while p < (*card).atmost2.top as *const libc::c_int {
        other = *p;
        if *((*card).lit2count).offset(other as isize) > 1 as libc::c_int {
            let fresh268 = q;
            q = q.offset(1);
            *fresh268 = other;
        } else {
            *((*card).lit2count).offset(other as isize) = 0 as libc::c_int;
        }
        p = p.offset(1);
        p;
    }
    (*card).atmost2.top = q;
    size = (lglcntstk(&mut (*card).atmost2)).wrapping_sub(start as size_t)
        as libc::c_int;
    if !(size < 4 as libc::c_int) {
        minlit = 0 as libc::c_int;
        '_RESTART: loop {
            if ignused == 0 {
                let mut subsumed: libc::c_int = 0;
                lglpushstk(lgl, &mut (*card).atmost2, 0 as libc::c_int);
                subsumed = lglcard2sub(
                    lgl,
                    ((*card).atmost2.start).offset(start as isize),
                    &mut minlit,
                );
                lglpopstk(&mut (*card).atmost2);
                if subsumed != 0 {
                    break;
                }
            }
            i = 0 as libc::c_int;
            while i < size - 2 as libc::c_int {
                other = -lglpeek(&mut (*card).atmost2, start + i);
                j = i + 1 as libc::c_int;
                while j < size - 1 as libc::c_int {
                    other2 = -lglpeek(&mut (*card).atmost2, start + j);
                    k = j + 1 as libc::c_int;
                    while k < size {
                        (*(*lgl).stats).steps += 1;
                        (*(*lgl).stats).steps;
                        let fresh269 = (*(*lgl).stats).card.steps;
                        (*(*lgl).stats).card.steps = (*(*lgl).stats).card.steps + 1;
                        if (*(*lgl).limits).card.steps < fresh269 {
                            res = 0 as libc::c_int;
                            break '_RESTART;
                        } else {
                            other3 = -lglpeek(&mut (*card).atmost2, start + k);
                            if lglhastrn(lgl, other, other2, other3) == 0 {
                                if size == 4 as libc::c_int {
                                    break '_RESTART;
                                }
                                let mut l: libc::c_int = 0;
                                let mut tmp: libc::c_int = 0;
                                if k > j + 1 as libc::c_int {
                                    l = k;
                                } else {
                                    let mut occ2: libc::c_int = *((*card).lit2count)
                                        .offset(-other2 as isize);
                                    let mut occ3: libc::c_int = *((*card).lit2count)
                                        .offset(-other3 as isize);
                                    if occ2 > occ3 {
                                        l = k;
                                    } else if occ2 < occ3 {
                                        l = j;
                                    } else {
                                        occ2 = (*lglhts(lgl, other2)).count as libc::c_int;
                                        occ3 = (*lglhts(lgl, other3)).count as libc::c_int;
                                        if occ2 > occ3 {
                                            l = k;
                                        } else if occ2 < occ3 {
                                            l = j;
                                        } else {
                                            l = if lglrand(lgl) & 1 as libc::c_int as libc::c_uint != 0
                                            {
                                                j
                                            } else {
                                                k
                                            };
                                        }
                                    }
                                }
                                tmp = lglpeek(&mut (*card).atmost2, start + l);
                                *((*card).lit2count)
                                    .offset(tmp as isize) = 0 as libc::c_int;
                                while (l + 1 as libc::c_int) < size {
                                    tmp = lglpeek(
                                        &mut (*card).atmost2,
                                        start + l + 1 as libc::c_int,
                                    );
                                    let fresh270 = l;
                                    l = l + 1;
                                    lglpoke(&mut (*card).atmost2, start + fresh270, tmp);
                                }
                                (*card).atmost2.top = ((*card).atmost2.top).offset(-1);
                                (*card).atmost2.top;
                                size -= 1;
                                size;
                                continue '_RESTART;
                            } else {
                                k += 1;
                                k;
                            }
                        }
                    }
                    j += 1;
                    j;
                }
                i += 1;
                i;
            }
            i = start;
            while i < start + size {
                other = lglpeek(&mut (*card).atmost2, i);
                *((*card).lit2count).offset(other as isize) = 0 as libc::c_int;
                *((*card).lit2used)
                    .offset(other as isize) = 1 as libc::c_int as libc::c_char;
                if ignused == 0 {
                    lglpushstk(lgl, &mut *((*card).occs).offset(other as isize), start);
                }
                i += 1;
                i;
            }
            lglpushstk(lgl, &mut (*card).atmost2, 0 as libc::c_int);
            (*(*lgl).stats).card.found.am2.total.sum += size as int64_t;
            (*(*lgl).stats).card.found.am2.total.cnt += 1;
            (*(*lgl).stats).card.found.am2.total.cnt;
            (*(*lgl).stats).card.found.am2.last.cnt += 1;
            (*(*lgl).stats).card.found.am2.last.cnt;
            if (*(*lgl).stats).card.found.am2.total.max < size {
                (*(*lgl).stats).card.found.am2.total.max = size;
            }
            if (*(*lgl).stats).card.found.am2.last.max < size {
                (*(*lgl).stats).card.found.am2.last.max = size;
            }
            return res;
        }
    }
    while lglcntstk(&mut (*card).atmost2) as libc::c_int > start {
        let mut lit_0: libc::c_int = lglpopstk(&mut (*card).atmost2);
        *((*card).lit2count).offset(lit_0 as isize) = 0 as libc::c_int;
    }
    return res;
}
unsafe extern "C" fn lglcard2extract(mut lgl: *mut LGL) -> libc::c_int {
    let mut before: C2RustUnnamed_141 = C2RustUnnamed_141 {
        cnt: 0,
        sum: 0,
    };
    let mut after: C2RustUnnamed_141 = C2RustUnnamed_141 {
        cnt: 0,
        sum: 0,
    };
    let mut delta: C2RustUnnamed_141 = C2RustUnnamed_141 {
        cnt: 0,
        sum: 0,
    };
    let ignused: libc::c_int = (*(*lgl).opts).cardignused.val;
    let mut card: *mut Card = (*lgl).c2rust_unnamed.card;
    lglpushstk(lgl, &mut (*card).atmost2, 0 as libc::c_int);
    (*card)
        .lit2used = lglnew(
        lgl,
        ((2 as libc::c_int * (*lgl).nvars) as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_char>() as libc::c_ulong),
    ) as *mut libc::c_char;
    (*card).lit2used = ((*card).lit2used).offset((*lgl).nvars as isize);
    (*card)
        .lit2count = lglnew(
        lgl,
        ((2 as libc::c_int * (*lgl).nvars) as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
    ) as *mut libc::c_int;
    (*card).lit2count = ((*card).lit2count).offset((*lgl).nvars as isize);
    if ignused == 0 {
        (*card)
            .occs = lglnew(
            lgl,
            ((2 as libc::c_int * (*lgl).nvars) as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<Stk>() as libc::c_ulong),
        ) as *mut Stk;
        (*card).occs = ((*card).occs).offset((*lgl).nvars as isize);
    }
    before.cnt = (*(*lgl).stats).card.found.am2.total.cnt as libc::c_int;
    before.sum = (*(*lgl).stats).card.found.am2.total.sum;
    lglrandlitrav(
        lgl,
        Some(
            lglcard2extractlit
                as unsafe extern "C" fn(*mut LGL, libc::c_int) -> libc::c_int,
        ),
    );
    after.cnt = (*(*lgl).stats).card.found.am2.total.cnt as libc::c_int;
    after.sum = (*(*lgl).stats).card.found.am2.total.sum;
    delta.cnt = after.cnt - before.cnt;
    delta.sum = after.sum - before.sum;
    (*card).lit2used = ((*card).lit2used).offset(-((*lgl).nvars as isize));
    lgldel(
        lgl,
        (*card).lit2used as *mut libc::c_void,
        ((2 as libc::c_int * (*lgl).nvars) as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_char>() as libc::c_ulong),
    );
    (*card).lit2used = 0 as *mut libc::c_char;
    (*card).lit2count = ((*card).lit2count).offset(-((*lgl).nvars as isize));
    lgldel(
        lgl,
        (*card).lit2count as *mut libc::c_void,
        ((2 as libc::c_int * (*lgl).nvars) as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
    );
    (*card).lit2count = 0 as *mut libc::c_int;
    if ignused == 0 {
        lglcardreloccs(lgl);
    }
    if delta.cnt != 0 {
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[card-%d] found %d at-most-two constraints of average size %.1f\0"
                as *const u8 as *const libc::c_char,
            (*(*lgl).stats).card.count,
            delta.cnt,
            lglavg(delta.sum as libc::c_double, delta.cnt as libc::c_double),
        );
    } else {
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[card-%d] no at-most-two constraint found\0" as *const u8
                as *const libc::c_char,
            (*(*lgl).stats).card.count,
        );
    }
    return delta.cnt;
}
unsafe extern "C" fn lglcarduseclswithlit(
    mut lgl: *mut LGL,
    mut lit: libc::c_int,
) -> libc::c_int {
    let mut pos: libc::c_int = (lglmtstk(
        ((*(*lgl).c2rust_unnamed.card).occs).offset(lit as isize),
    ) == 0) as libc::c_int;
    let mut neg: libc::c_int = (lglmtstk(
        ((*(*lgl).c2rust_unnamed.card).occs).offset(-(lit as isize)),
    ) == 0) as libc::c_int;
    let mut level: libc::c_int = (*(*lgl).opts).carduse.val;
    match level {
        0 => return 0 as libc::c_int,
        1 => return (pos != 0 && neg == 0) as libc::c_int,
        2 => return pos,
        _ => return (pos != 0 || neg != 0) as libc::c_int,
    };
}
unsafe extern "C" fn lglcardelim(
    mut lgl: *mut LGL,
    mut count: libc::c_int,
) -> libc::c_int {
    let mut current_block: u64;
    let mut blit: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut other2: libc::c_int = 0;
    let mut bound: libc::c_int = 0;
    let mut used: libc::c_int = 0;
    let mut idx: libc::c_int = 0;
    let mut sign: libc::c_int = 0;
    let mut lit: libc::c_int = 0;
    let mut start: libc::c_int = 0;
    let mut len: libc::c_int = 0;
    let mut res: libc::c_int = 0;
    let mut glue: libc::c_int = 0;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut w: *const libc::c_int = 0 as *const libc::c_int;
    let mut eow: *const libc::c_int = 0 as *const libc::c_int;
    let mut c: *const libc::c_int = 0 as *const libc::c_int;
    let mut q: *const libc::c_int = 0 as *const libc::c_int;
    let mut cardmaxlen: libc::c_int = 0;
    let mut subsumed: libc::c_int = 0 as libc::c_int;
    let mut card: *mut Card = (*lgl).c2rust_unnamed.card;
    let mut clause: [libc::c_int; 4] = [0; 4];
    let mut hts: *mut HTS = 0 as *mut HTS;
    let mut s: *mut Stk = 0 as *mut Stk;
    (*card)
        .occs = lglnew(
        lgl,
        ((2 as libc::c_int * (*lgl).nvars) as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Stk>() as libc::c_ulong),
    ) as *mut Stk;
    (*card)
        .eliminated = lglnew(
        lgl,
        ((*lgl).nvars as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_char>() as libc::c_ulong),
    ) as *mut libc::c_char;
    (*card)
        .count = lglnew(
        lgl,
        ((*lgl).nvars as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_schar>() as libc::c_ulong),
    ) as *mut libc::c_schar;
    (*card).occs = ((*card).occs).offset((*lgl).nvars as isize);
    used = 0 as libc::c_int;
    cardmaxlen = lglfactor(
        lgl,
        (*(*lgl).stats).card.count,
        (*(*lgl).opts).cardmaxlen.val,
    ) as libc::c_int;
    start = 1 as libc::c_int;
    while start < lglcntstk(&mut (*card).atmost1) as libc::c_int {
        len = 0 as libc::c_int;
        while lglpeek(&mut (*card).atmost1, start + len) != 0 {
            len += 1;
            len;
        }
        if len >= (*(*lgl).opts).cardminlen.val && len <= cardmaxlen
            && lgladdcard(
                lgl,
                ((*card).atmost1.start).offset(start as isize),
                1 as libc::c_int,
                &mut subsumed,
            ) != 0
        {
            (*(*lgl).stats).card.used.am1.sum += len as int64_t;
            (*(*lgl).stats).card.used.am1.cnt += 1;
            (*(*lgl).stats).card.used.am1.cnt;
            used += 1;
            used;
        }
        start += len;
        start += 1;
        start;
    }
    start = 1 as libc::c_int;
    while start < lglcntstk(&mut (*card).atmost2) as libc::c_int {
        len = 0 as libc::c_int;
        while lglpeek(&mut (*card).atmost2, start + len) != 0 {
            len += 1;
            len;
        }
        if len >= (*(*lgl).opts).cardminlen.val && len <= cardmaxlen
            && lgladdcard(
                lgl,
                ((*card).atmost2.start).offset(start as isize),
                2 as libc::c_int,
                &mut subsumed,
            ) != 0
        {
            (*(*lgl).stats).card.used.am2.sum += len as int64_t;
            (*(*lgl).stats).card.used.am2.cnt += 1;
            (*(*lgl).stats).card.used.am2.cnt;
            used += 1;
            used;
        }
        start += len;
        start += 1;
        start;
    }
    if used != 0 {
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[card-%d] using %d out of %d constraints (%.0f%%), %d subsumed\0"
                as *const u8 as *const libc::c_char,
            (*(*lgl).stats).card.count,
            used,
            count,
            lglpcnt(used as libc::c_double, count as libc::c_double),
            subsumed,
        );
        idx = 2 as libc::c_int;
        while idx < (*lgl).nvars {
            if !(lglmtstk(((*card).occs).offset(idx as isize)) != 0
                && lglmtstk(((*card).occs).offset(-(idx as isize))) != 0)
            {
                lglpushstk(lgl, &mut (*card).elim, idx);
            }
            idx += 1;
            idx;
        }
        if (*(*lgl).opts).carduse.val == 0 {
            current_block = 11315394027421309500;
        } else {
            idx = 2 as libc::c_int;
            loop {
                if !(idx < (*lgl).nvars) {
                    current_block = 7330218953828964527;
                    break;
                }
                if lglterminate(lgl) != 0
                    || {
                        (*(*lgl).stats).steps += 1;
                        (*(*lgl).stats).steps;
                        let fresh271 = (*(*lgl).stats).card.steps;
                        (*(*lgl).stats).card.steps = (*(*lgl).stats).card.steps + 1;
                        (*(*lgl).limits).card.steps < fresh271
                    }
                {
                    current_block = 11509267742010643223;
                    break;
                }
                sign = -(1 as libc::c_int);
                while sign <= 1 as libc::c_int {
                    lit = sign * idx;
                    if !(lglcarduseclswithlit(lgl, lit) == 0) {
                        hts = lglhts(lgl, lit);
                        w = lglhts2wchs(lgl, hts);
                        eow = w.offset((*hts).count as isize);
                        p = w;
                        while p < eow {
                            blit = *p;
                            tag = blit & MASKCS as libc::c_int;
                            if tag == TRNCS as libc::c_int || tag == LRGCS as libc::c_int
                            {
                                p = p.offset(1);
                                p;
                            }
                            if tag == BINCS as libc::c_int {
                                other = blit >> RMSHFT as libc::c_int;
                                if !(abs(other) < idx) {
                                    clause[0 as libc::c_int as usize] = -lit;
                                    clause[1 as libc::c_int as usize] = -other;
                                    clause[2 as libc::c_int as usize] = 0 as libc::c_int;
                                    lgladdcard(
                                        lgl,
                                        clause.as_mut_ptr(),
                                        1 as libc::c_int,
                                        0 as *mut libc::c_int,
                                    );
                                }
                            } else if tag == TRNCS as libc::c_int {
                                other = blit >> RMSHFT as libc::c_int;
                                if !(abs(other) < idx) {
                                    other2 = *p;
                                    if !(abs(other2) < idx) {
                                        clause[0 as libc::c_int as usize] = -lit;
                                        clause[1 as libc::c_int as usize] = -other;
                                        clause[2 as libc::c_int as usize] = -other2;
                                        clause[3 as libc::c_int as usize] = 0 as libc::c_int;
                                        lgladdcard(
                                            lgl,
                                            clause.as_mut_ptr(),
                                            2 as libc::c_int,
                                            0 as *mut libc::c_int,
                                        );
                                    }
                                }
                            }
                            p = p.offset(1);
                            p;
                        }
                    }
                    sign += 2 as libc::c_int;
                }
                idx += 1;
                idx;
            }
            match current_block {
                11509267742010643223 => {}
                _ => {
                    glue = -(1 as libc::c_int);
                    's_353: loop {
                        if !(glue <= (*(*lgl).opts).cardglue.val) {
                            current_block = 11315394027421309500;
                            break;
                        }
                        s = if glue < 0 as libc::c_int {
                            &mut (*lgl).irr
                        } else {
                            ((*lgl).red).offset(glue as isize)
                        };
                        c = (*s).start;
                        while c < (*s).top as *const libc::c_int {
                            p = c;
                            if !(*p
                                >= 2147483647 as libc::c_int >> RMSHFT as libc::c_int)
                            {
                                p = c;
                                while *p != 0 {
                                    p = p.offset(1);
                                    p;
                                }
                                q = c;
                                loop {
                                    lit = *q;
                                    if !(lit != 0) {
                                        break;
                                    }
                                    if lglcarduseclswithlit(lgl, lit) != 0 {
                                        break;
                                    }
                                    q = q.offset(1);
                                    q;
                                }
                                if !(lit == 0) {
                                    len = p.offset_from(c) as libc::c_long as libc::c_int;
                                    if !(len > cardmaxlen) {
                                        bound = len - 1 as libc::c_int;
                                        q = c;
                                        loop {
                                            lit = *q;
                                            if !(lit != 0) {
                                                break;
                                            }
                                            lglpushstk(lgl, &mut (*lgl).clause, -lit);
                                            q = q.offset(1);
                                            q;
                                        }
                                        lglpushstk(lgl, &mut (*lgl).clause, 0 as libc::c_int);
                                        lgladdcard(
                                            lgl,
                                            (*lgl).clause.start,
                                            bound,
                                            0 as *mut libc::c_int,
                                        );
                                        lglclnstk(&mut (*lgl).clause);
                                        if lglterminate(lgl) != 0
                                            || {
                                                (*(*lgl).stats).steps += 1;
                                                (*(*lgl).stats).steps;
                                                let fresh272 = (*(*lgl).stats).card.steps;
                                                (*(*lgl).stats).card.steps = (*(*lgl).stats).card.steps + 1;
                                                (*(*lgl).limits).card.steps < fresh272
                                            }
                                        {
                                            current_block = 11509267742010643223;
                                            break 's_353;
                                        }
                                    }
                                }
                            }
                            c = p.offset(1 as libc::c_int as isize);
                        }
                        glue += 1;
                        glue;
                    }
                }
            }
        }
        match current_block {
            11509267742010643223 => {}
            _ => {
                lglcardfm(lgl);
            }
        }
    } else {
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[card-%d] no constraint out of %d used (%d subsumed)\0" as *const u8
                as *const libc::c_char,
            (*(*lgl).stats).card.count,
            count,
            subsumed,
        );
    }
    lglcardreloccs(lgl);
    lgldel(
        lgl,
        (*card).count as *mut libc::c_void,
        ((*lgl).nvars as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_schar>() as libc::c_ulong),
    );
    (*card).count = 0 as *mut libc::c_schar;
    lglrelstk(lgl, &mut (*card).cards);
    lglrelstk(lgl, &mut (*card).elim);
    lgldel(
        lgl,
        (*card).eliminated as *mut libc::c_void,
        ((*lgl).nvars as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_char>() as libc::c_ulong),
    );
    (*card).eliminated = 0 as *mut libc::c_char;
    if (*lgl).mt != 0 {
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[card-%d] produced empty clause\0" as *const u8 as *const libc::c_char,
            (*(*lgl).stats).card.count,
        );
    } else if lglmtstk(&mut (*card).units) == 0 {
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[card-%d] found %d units\0" as *const u8 as *const libc::c_char,
            (*(*lgl).stats).card.count,
            lglcntstk(&mut (*card).units),
        );
        while (*lgl).mt == 0 && lglmtstk(&mut (*card).units) == 0 {
            lit = lglpopstk(&mut (*card).units);
            if lglval(lgl, lit) as libc::c_int > 0 as libc::c_int {
                continue;
            }
            if (lglval(lgl, lit) as libc::c_int) < 0 as libc::c_int {
                lglprt(
                    lgl,
                    1 as libc::c_int,
                    b"[card-%d] found inconsistent unit\0" as *const u8
                        as *const libc::c_char,
                    (*(*lgl).stats).card.count,
                );
                lglmt(lgl);
            } else {
                lglunit(lgl, lit);
                if lglbcp(lgl) == 0 {
                    lglprt(
                        lgl,
                        1 as libc::c_int,
                        b"[card-%d] inconsistent unit propagation\0" as *const u8
                            as *const libc::c_char,
                        (*(*lgl).stats).card.count,
                    );
                    lglmt(lgl);
                }
            }
        }
    }
    res = lglcntstk(&mut (*card).units) as libc::c_int;
    lglrelstk(lgl, &mut (*card).units);
    if (*lgl).mt == 0 {
        if res != 0 {
            lglprt(
                lgl,
                1 as libc::c_int,
                b"[card-%d] found %d units\0" as *const u8 as *const libc::c_char,
                (*(*lgl).stats).card.count,
                res,
            );
        } else {
            lglprt(
                lgl,
                1 as libc::c_int,
                b"[card-%d] no units found\0" as *const u8 as *const libc::c_char,
                (*(*lgl).stats).card.count,
            );
        }
        if lglmtstk(&mut (*card).expam1) == 0 {
            let mut generated: libc::c_int = 0 as libc::c_int;
            let mut exported: libc::c_int = 0 as libc::c_int;
            let mut genused: libc::c_int = 0 as libc::c_int;
            c = (*card).expam1.start;
            while c < (*card).expam1.top as *const libc::c_int {
                let mut a: libc::c_int = 0;
                let mut usefull: libc::c_int = 0 as libc::c_int;
                generated += 1;
                generated;
                p = c;
                loop {
                    a = *p;
                    if !(a != 0) {
                        break;
                    }
                    if lglval(lgl, a) != 0 {
                        break;
                    }
                    p = p.offset(1);
                    p;
                }
                if a != 0 {
                    loop {
                        p = p.offset(1);
                        if !(*p != 0) {
                            break;
                        }
                    }
                } else {
                    p = c;
                    loop {
                        a = -*p;
                        if !(a != 0) {
                            break;
                        }
                        let mut b: libc::c_int = 0;
                        q = p.offset(1 as libc::c_int as isize);
                        loop {
                            b = -*q;
                            if !(b != 0) {
                                break;
                            }
                            if lglhasbin(lgl, a, b) == 0 {
                                lglpushstk(lgl, &mut (*lgl).clause, a);
                                lglpushstk(lgl, &mut (*lgl).clause, b);
                                lglpushstk(lgl, &mut (*lgl).clause, 0 as libc::c_int);
                                lgladdcls(
                                    lgl,
                                    REDCS as libc::c_int,
                                    0 as libc::c_int,
                                    1 as libc::c_int,
                                );
                                lglclnstk(&mut (*lgl).clause);
                                (*(*lgl).stats).card.expam1 += 1;
                                (*(*lgl).stats).card.expam1;
                                exported += 1;
                                exported;
                                usefull = 1 as libc::c_int;
                            }
                            q = q.offset(1);
                            q;
                        }
                        p = p.offset(1);
                        p;
                    }
                    if usefull != 0 {
                        genused += 1;
                        genused;
                    }
                }
                c = p.offset(1 as libc::c_int as isize);
            }
            lglprt(
                lgl,
                1 as libc::c_int,
                b"[card-%d] generated %d at-most-one constraints, %d used %.0f%%\0"
                    as *const u8 as *const libc::c_char,
                (*(*lgl).stats).card.count,
                generated,
                genused,
                lglpcnt(genused as libc::c_double, generated as libc::c_double),
            );
            lglprt(
                lgl,
                1 as libc::c_int,
                b"[card-%d] exported %d binary clauses, %.1f per/constraint\0"
                    as *const u8 as *const libc::c_char,
                (*(*lgl).stats).card.count,
                exported,
                lglavg(exported as libc::c_double, genused as libc::c_double),
            );
        } else {
            lglprt(
                lgl,
                1 as libc::c_int,
                b"[card-%d] no at-most-one constraints generated\0" as *const u8
                    as *const libc::c_char,
                (*(*lgl).stats).card.count,
            );
        }
    }
    lglrelstk(lgl, &mut (*card).expam1);
    return res;
}
unsafe extern "C" fn lglcard(mut lgl: *mut LGL) -> libc::c_int {
    let mut success: libc::c_int = 0;
    let mut count: libc::c_int = 0;
    let mut limit: int64_t = 0;
    lglstart(lgl, &mut (*(*lgl).times).card);
    (*(*lgl).stats).card.count += 1;
    (*(*lgl).stats).card.count;
    if (*lgl).level != 0 {
        lglbacktrack(lgl, 0 as libc::c_int);
    }
    limit = lglsetcardlim(lgl);
    (*lgl)
        .c2rust_unnamed
        .card = lglnew(
        lgl,
        (1 as libc::c_int as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Card>() as libc::c_ulong),
    ) as *mut Card;
    count = lglcard1extract(lgl) + lglcard2extract(lgl);
    if lglterminate(lgl) == 0 && count != 0 {
        lglsetcardlimagain(lgl, limit);
        success = lglcardelim(lgl, count);
    } else {
        success = 0 as libc::c_int;
    }
    lglrelstk(lgl, &mut (*(*lgl).c2rust_unnamed.card).atmost1);
    lglrelstk(lgl, &mut (*(*lgl).c2rust_unnamed.card).atmost2);
    lgldel(
        lgl,
        (*lgl).c2rust_unnamed.card as *mut libc::c_void,
        (1 as libc::c_int as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Card>() as libc::c_ulong),
    );
    (*lgl).c2rust_unnamed.card = 0 as *mut Card;
    if success != 0 && (*(*lgl).limits).card.pen != 0 {
        (*(*lgl).limits).card.pen -= 1;
        (*(*lgl).limits).card.pen;
    }
    if success == 0 && (*(*lgl).limits).card.pen < (*(*lgl).opts).penmax.val {
        (*(*lgl).limits).card.pen += 1;
        (*(*lgl).limits).card.pen;
    }
    if success != 0 && (*(*lgl).limits).card.del.cur != 0 {
        (*(*lgl).limits).card.del.cur /= 2 as libc::c_int;
    }
    if success == 0 && (*(*lgl).limits).card.del.cur < (*(*lgl).opts).delmax.val {
        (*(*lgl).limits).card.del.cur += 1;
        (*(*lgl).limits).card.del.cur;
    }
    (*(*lgl).limits).card.del.rem = (*(*lgl).limits).card.del.cur;
    lglstop(lgl);
    return ((*lgl).mt == 0) as libc::c_int;
}
unsafe extern "C" fn lglbcaoccmin(
    mut lgl: *mut LGL,
    mut lit: libc::c_int,
) -> libc::c_int {
    let mut p: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut w: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut eow: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut res: libc::c_int = 0;
    let mut blit: libc::c_int = 0;
    let mut red: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut hts: *mut HTS = 0 as *mut HTS;
    hts = lglhts(lgl, lit);
    w = lglhts2wchs(lgl, hts);
    eow = w.offset((*hts).count as isize);
    res = 0 as libc::c_int;
    p = w;
    while res <= 3 as libc::c_int && p < eow {
        blit = *p;
        tag = blit & MASKCS as libc::c_int;
        red = blit & REDCS as libc::c_int;
        if tag == TRNCS as libc::c_int || tag == LRGCS as libc::c_int {
            p = p.offset(1);
            p;
        }
        if !(tag == LRGCS as libc::c_int) {
            if red == 0 {
                res += 1;
                res;
            }
        }
        p = p.offset(1);
        p;
    }
    return res;
}
unsafe extern "C" fn lglbcaskiplit(
    mut lgl: *mut LGL,
    mut lit: libc::c_int,
) -> libc::c_int {
    let mut pocc: libc::c_int = 0;
    let mut nocc: libc::c_int = 0;
    if (*(*lgl).opts).bca.val >= 2 as libc::c_int {
        return 0 as libc::c_int;
    }
    pocc = lglbcaoccmin(lgl, lit);
    if pocc <= 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    nocc = lglbcaoccmin(lgl, -lit);
    if nocc <= 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    return (pocc == 2 as libc::c_int && nocc == 2 as libc::c_int) as libc::c_int;
}
unsafe extern "C" fn lglbcalitaux(mut lgl: *mut LGL, mut lit: libc::c_int) {
    let mut first: libc::c_int = 0;
    let mut blit: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut red: libc::c_int = 0;
    let mut lidx: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut tmp: libc::c_int = 0;
    let mut found: libc::c_int = 0;
    let mut other2: libc::c_int = 0;
    let mut found2: libc::c_int = 0;
    let mut r: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut w: *const libc::c_int = 0 as *const libc::c_int;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut eow: *const libc::c_int = 0 as *const libc::c_int;
    let mut c: *const libc::c_int = 0 as *const libc::c_int;
    let mut q: *const libc::c_int = 0 as *const libc::c_int;
    let mut covered: *mut Stk = &mut (*(*lgl).c2rust_unnamed.bca).covered;
    let mut round: libc::c_int = 0;
    let mut hts: *mut HTS = 0 as *mut HTS;
    hts = lglhts(lgl, lit);
    if (*hts).count == 0 {
        return;
    }
    if lglbcaskiplit(lgl, lit) != 0 {
        (*(*lgl).stats).bca.skipped += 1;
        (*(*lgl).stats).bca.skipped;
        return;
    }
    first = 1 as libc::c_int;
    w = lglhts2wchs(lgl, hts);
    eow = w.offset((*hts).count as isize);
    round = 0 as libc::c_int;
    while round < 2 as libc::c_int {
        let mut current_block_74: u64;
        p = w;
        while (first != 0 || lglmtstk(covered) == 0) && p < eow {
            blit = *p;
            tag = blit & MASKCS as libc::c_int;
            red = blit & REDCS as libc::c_int;
            if tag == TRNCS as libc::c_int || tag == LRGCS as libc::c_int {
                p = p.offset(1);
                p;
            }
            if !(tag == LRGCS as libc::c_int) {
                if !(round != (tag == OCCS as libc::c_int) as libc::c_int) {
                    (*(*lgl).stats).steps += 1;
                    (*(*lgl).stats).steps;
                    (*(*lgl).stats).bca.steps += 1;
                    (*(*lgl).stats).bca.steps;
                    if tag == BINCS as libc::c_int {
                        other = blit >> RMSHFT as libc::c_int;
                        if lglval(lgl, other) as libc::c_int > 0 as libc::c_int {
                            current_block_74 = 13586036798005543211;
                        } else {
                            found = first;
                            while lglmtstk(covered) == 0 {
                                if other == lglpopstk(covered) {
                                    found = 1 as libc::c_int;
                                }
                            }
                            if found != 0 {
                                lglpushstk(lgl, covered, other);
                            }
                            current_block_74 = 5684854171168229155;
                        }
                    } else if tag == TRNCS as libc::c_int {
                        other = blit >> RMSHFT as libc::c_int;
                        if lglval(lgl, other) as libc::c_int > 0 as libc::c_int {
                            current_block_74 = 13586036798005543211;
                        } else {
                            other2 = *p;
                            if lglval(lgl, other2) as libc::c_int > 0 as libc::c_int {
                                current_block_74 = 13586036798005543211;
                            } else {
                                found2 = first;
                                found = found2;
                                while lglmtstk(covered) == 0 {
                                    tmp = lglpopstk(covered);
                                    if other == tmp {
                                        found = 1 as libc::c_int;
                                    } else if tmp == other2 {
                                        found2 = 1 as libc::c_int;
                                    }
                                }
                                if found != 0 && lglval(lgl, other) == 0 {
                                    lglpushstk(lgl, covered, other);
                                }
                                if found2 != 0 && lglval(lgl, other2) == 0 {
                                    lglpushstk(lgl, covered, other2);
                                }
                                current_block_74 = 5684854171168229155;
                            }
                        }
                    } else {
                        lidx = blit >> RMSHFT as libc::c_int;
                        c = lglidx2lits(lgl, red, lidx);
                        (*(*lgl).stats).steps += 1;
                        (*(*lgl).stats).steps;
                        (*(*lgl).stats).bca.steps += 1;
                        (*(*lgl).stats).bca.steps;
                        q = c;
                        loop {
                            other = *q;
                            if !(other != 0) {
                                break;
                            }
                            if other != lit
                                && lglval(lgl, other) as libc::c_int > 0 as libc::c_int
                            {
                                break;
                            }
                            q = q.offset(1);
                            q;
                        }
                        if other != 0 {
                            current_block_74 = 13586036798005543211;
                        } else {
                            if first != 0 {
                                q = c;
                                loop {
                                    other = *q;
                                    if !(other != 0) {
                                        break;
                                    }
                                    if other != lit && lglval(lgl, other) == 0 {
                                        lglpushstk(lgl, covered, other);
                                    }
                                    q = q.offset(1);
                                    q;
                                }
                            } else {
                                q = (*covered).start;
                                while q < (*covered).top as *const libc::c_int {
                                    lglsignedmark(lgl, *q);
                                    q = q.offset(1);
                                    q;
                                }
                                q = c;
                                loop {
                                    other = *q;
                                    if !(other != 0) {
                                        break;
                                    }
                                    if other != lit && lglsignedmarked(lgl, other) != 0 {
                                        lglsignedunmark(lgl, other);
                                    }
                                    q = q.offset(1);
                                    q;
                                }
                                r = (*covered).start;
                                q = r;
                                while q < (*covered).top as *const libc::c_int {
                                    other = *q;
                                    if lglsignedmarked(lgl, other) != 0 {
                                        lglsignedunmark(lgl, other);
                                    } else {
                                        let fresh273 = r;
                                        r = r.offset(1);
                                        *fresh273 = other;
                                    }
                                    q = q.offset(1);
                                    q;
                                }
                                (*covered).top = r;
                            }
                            current_block_74 = 5684854171168229155;
                        }
                    }
                    match current_block_74 {
                        13586036798005543211 => {}
                        _ => {
                            first = 0 as libc::c_int;
                        }
                    }
                }
            }
            p = p.offset(1);
            p;
        }
        round += 1;
        round;
    }
}
unsafe extern "C" fn lglbcalit(mut lgl: *mut LGL, mut lit: libc::c_int) -> libc::c_int {
    let mut bit: libc::c_uint = 0;
    let mut av: *mut AVar = 0 as *mut AVar;
    let mut other: libc::c_int = 0;
    if (*(*lgl).limits).bca.steps < (*(*lgl).stats).bca.steps {
        return 0 as libc::c_int;
    }
    if (*(*lgl).limits).bca.added < (*(*lgl).stats).bca.added {
        return 0 as libc::c_int;
    }
    if lglterminate(lgl) != 0 {
        return 0 as libc::c_int;
    }
    if lglifrozen(lgl, lit) != 0 {
        return 1 as libc::c_int;
    }
    if lglisfree(lgl, lit) == 0 {
        return 1 as libc::c_int;
    }
    av = lglavar(lgl, lit);
    bit = ((1 as libc::c_int) << (lit < 0 as libc::c_int) as libc::c_int)
        as libc::c_uint;
    if (*av).inred() & bit != 0 {
        return 1 as libc::c_int;
    }
    lglbcalitaux(lgl, lit);
    while lglmtstk(&mut (*(*lgl).c2rust_unnamed.bca).covered) == 0 {
        (*(*lgl).stats).steps += 1;
        (*(*lgl).stats).steps;
        (*(*lgl).stats).bca.steps += 1;
        (*(*lgl).stats).bca.steps;
        other = lglpopstk(&mut (*(*lgl).c2rust_unnamed.bca).covered);
        if lglhasbin(lgl, -lit, -other) != 0 {
            continue;
        }
        lglpushstk(lgl, &mut (*lgl).clause, -lit);
        lglpushstk(lgl, &mut (*lgl).clause, -other);
        lglpushstk(lgl, &mut (*lgl).clause, 0 as libc::c_int);
        lgladdcls(lgl, REDCS as libc::c_int, 0 as libc::c_int, 1 as libc::c_int);
        lglclnstk(&mut (*lgl).clause);
        (*(*lgl).stats).bca.added += 1;
        (*(*lgl).stats).bca.added;
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn lglupdbcadel(mut lgl: *mut LGL, mut success: libc::c_int) {
    if success != 0 && (*(*lgl).limits).bca.del.cur != 0 {
        (*(*lgl).limits).bca.del.cur /= 2 as libc::c_int;
    }
    if success == 0 && (*(*lgl).limits).bca.del.cur < (*(*lgl).opts).delmax.val {
        (*(*lgl).limits).bca.del.cur += 1;
        (*(*lgl).limits).bca.del.cur;
    }
    (*(*lgl).limits).bca.del.rem = (*(*lgl).limits).bca.del.cur;
}
unsafe extern "C" fn lglbca(mut lgl: *mut LGL) {
    let mut oldadded: libc::c_int = (*(*lgl).stats).bca.added as libc::c_int;
    let mut added: libc::c_int = 0;
    let mut limadded: libc::c_int = 0;
    let mut idx: libc::c_int = 0;
    let mut glue: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut inred: libc::c_int = 0;
    let mut usable: libc::c_int = 0;
    let mut scale: libc::c_int = 0;
    let mut c: *const libc::c_int = 0 as *const libc::c_int;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut oldsteps: int64_t = 0;
    let mut lim64: int64_t = 0;
    let mut bit: libc::c_uint = 0;
    let mut av: *mut AVar = 0 as *mut AVar;
    lglstart(lgl, &mut (*(*lgl).times).bca);
    (*lgl)
        .c2rust_unnamed
        .bca = lglnew(
        lgl,
        (1 as libc::c_int as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<BCA>() as libc::c_ulong),
    ) as *mut BCA;
    (*(*lgl).stats).bca.count += 1;
    (*(*lgl).stats).bca.count;
    oldsteps = (*(*lgl).stats).bca.steps;
    (*(*lgl).limits).bca.steps = oldsteps + (*(*lgl).opts).bcamaxeff.val as int64_t;
    limadded = (*(*lgl).stats).irr.clauses.cur;
    scale = (*(*lgl).opts).bcaddlimldscale.val;
    if scale < 0 as libc::c_int {
        limadded >>= -scale;
    } else if 2147483647 as libc::c_int >> scale < limadded {
        limadded = 2147483647 as libc::c_int;
    } else {
        limadded <<= scale;
    }
    lim64 = (*(*lgl).stats).bca.added / 2 as libc::c_int as int64_t;
    lim64 += (limadded / 2 as libc::c_int + 500 as libc::c_int) as int64_t;
    if lim64 > 2147483647 as libc::c_int as int64_t {
        lim64 = 2147483647 as libc::c_int as int64_t;
    }
    (*(*lgl).limits).bca.added = lim64;
    lglprt(
        lgl,
        1 as libc::c_int,
        b"[bca-%d] limit of %d steps and %d added (scaled %d)\0" as *const u8
            as *const libc::c_char,
        (*(*lgl).stats).bca.count,
        (*(*lgl).opts).bcamaxeff.val,
        (*(*lgl).limits).bca.added,
        scale,
    );
    (*lgl).bcaing = 1 as libc::c_int as libc::c_char;
    if (*lgl).level > 0 as libc::c_int {
        lglbacktrack(lgl, 0 as libc::c_int);
    }
    lglgc(lgl);
    idx = 2 as libc::c_int;
    while idx < (*lgl).nvars {
        let ref mut fresh274 = *lglavar(lgl, idx);
        (*fresh274).set_inred(0 as libc::c_int as libc::c_uint);
        idx += 1;
        idx;
    }
    inred = 0 as libc::c_int;
    glue = 0 as libc::c_int;
    while glue <= ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int {
        let mut s: *mut Stk = ((*lgl).red).offset(glue as isize);
        c = (*s).start;
        while c < (*s).top as *const libc::c_int {
            p = c;
            if !(*p >= 2147483647 as libc::c_int >> RMSHFT as libc::c_int) {
                (*(*lgl).stats).steps += 1;
                (*(*lgl).stats).steps;
                (*(*lgl).stats).bca.steps += 1;
                (*(*lgl).stats).bca.steps;
                loop {
                    other = *p;
                    if !(other != 0) {
                        break;
                    }
                    p = p.offset(1);
                    p;
                    bit = ((1 as libc::c_int)
                        << (other < 0 as libc::c_int) as libc::c_int) as libc::c_uint;
                    av = lglavar(lgl, other);
                    if (*av).inred() & bit != 0 {
                        continue;
                    }
                    (*av).set_inred((*av).inred() | bit);
                    inred += 1;
                    inred;
                }
            }
            c = p.offset(1 as libc::c_int as isize);
        }
        glue += 1;
        glue;
    }
    lglprt(
        lgl,
        2 as libc::c_int,
        b"[bca-%d] %d out of %d literals in large redundant clauses %.0f%%\0"
            as *const u8 as *const libc::c_char,
        (*(*lgl).stats).bca.count,
        inred,
        2 as libc::c_int * ((*lgl).nvars - 1 as libc::c_int),
        lglpcnt(
            inred as libc::c_double,
            (2 as libc::c_int * ((*lgl).nvars - 1 as libc::c_int)) as libc::c_double,
        ),
    );
    usable = 0 as libc::c_int;
    idx = 2 as libc::c_int;
    while idx < (*lgl).nvars {
        if !(lglifrozen(lgl, idx) != 0) {
            if !(lglisfree(lgl, idx) == 0) {
                av = lglavar(lgl, idx);
                bit = 1 as libc::c_int as libc::c_uint;
                while bit <= 2 as libc::c_int as libc::c_uint {
                    if (*av).inred() & bit == 0 {
                        usable += 1;
                        usable;
                    }
                    bit = bit.wrapping_add(1);
                    bit;
                }
            }
        }
        idx += 1;
        idx;
    }
    lglprt(
        lgl,
        1 as libc::c_int,
        b"[bca-%d] %d out of %d literals actually usable %.0f%%\0" as *const u8
            as *const libc::c_char,
        (*(*lgl).stats).bca.count,
        usable,
        2 as libc::c_int * ((*lgl).nvars - 1 as libc::c_int),
        lglpcnt(
            usable as libc::c_double,
            (2 as libc::c_int * ((*lgl).nvars - 1 as libc::c_int)) as libc::c_double,
        ),
    );
    if usable < (*(*lgl).opts).bcaminuse.val {
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[bca-%d] not enough literals usable\0" as *const u8 as *const libc::c_char,
            (*(*lgl).stats).bca.count,
        );
    } else {
        lgldense(lgl, 0 as libc::c_int);
        lglrandlitrav(
            lgl,
            Some(lglbcalit as unsafe extern "C" fn(*mut LGL, libc::c_int) -> libc::c_int),
        );
        lglsparse(lgl);
        lglgc(lgl);
    }
    added = ((*(*lgl).stats).bca.added - oldadded as int64_t) as libc::c_int;
    lglprt(
        lgl,
        1 as libc::c_int,
        b"[bca-%d] added %d blocked clauses in %lld steps\0" as *const u8
            as *const libc::c_char,
        (*(*lgl).stats).bca.count,
        added,
        (*(*lgl).stats).bca.steps as libc::c_longlong - oldsteps as libc::c_longlong,
    );
    (*lgl).bcaing = 0 as libc::c_int as libc::c_char;
    lglupdbcadel(lgl, added);
    lglrelstk(lgl, &mut (*(*lgl).c2rust_unnamed.bca).covered);
    lgldel(
        lgl,
        (*lgl).c2rust_unnamed.bca as *mut libc::c_void,
        (1 as libc::c_int as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<BCA>() as libc::c_ulong),
    );
    (*lgl).c2rust_unnamed.bca = 0 as *mut BCA;
    lglstop(lgl);
}
unsafe extern "C" fn lgltreducing(mut lgl: *mut LGL) -> libc::c_int {
    if lgldelaying(
        lgl,
        b"transred\0" as *const u8 as *const libc::c_char,
        &mut (*(*lgl).limits).trd.del.rem,
    ) != 0
    {
        return 0 as libc::c_int;
    }
    if lglwaiting(
        lgl,
        b"transred\0" as *const u8 as *const libc::c_char,
        (*(*lgl).opts).transredwait.val,
    ) != 0
    {
        return 0 as libc::c_int;
    }
    return (*(*lgl).opts).transred.val;
}
unsafe extern "C" fn lglunhiding(mut lgl: *mut LGL) -> libc::c_int {
    if lgldelaying(
        lgl,
        b"unhide\0" as *const u8 as *const libc::c_char,
        &mut (*(*lgl).limits).unhd.del.rem,
    ) != 0
    {
        return 0 as libc::c_int;
    }
    if lglwaiting(
        lgl,
        b"unhide\0" as *const u8 as *const libc::c_char,
        (*(*lgl).opts).unhidewait.val,
    ) != 0
    {
        return 0 as libc::c_int;
    }
    return (*(*lgl).opts).unhide.val;
}
unsafe extern "C" fn lgldecomposing(mut lgl: *mut LGL) -> libc::c_int {
    return (*(*lgl).opts).decompose.val;
}
unsafe extern "C" fn lglblocking(mut lgl: *mut LGL) -> libc::c_int {
    if (*(*lgl).opts).block.val == 0 {
        return 0 as libc::c_int;
    }
    if (*lgl).allfrozen != 0 {
        return 0 as libc::c_int;
    }
    if lgldelaying(
        lgl,
        b"block\0" as *const u8 as *const libc::c_char,
        &mut (*(*lgl).limits).blk.del.rem,
    ) != 0
    {
        return 0 as libc::c_int;
    }
    if (*(*lgl).opts).blockwait.val != 0 && (*lgl).wait != 0
        && ((*(*lgl).opts).elim.val == 0 || (*lgl).elmrtc == 0)
    {
        lglprt(
            lgl,
            2 as libc::c_int,
            b"[block-waiting] for bounded variable elimination to be completed\0"
                as *const u8 as *const libc::c_char,
        );
        return 0 as libc::c_int;
    }
    if lglsmallirr(lgl) == 0 {
        return 0 as libc::c_int;
    }
    if (*lgl).nvars <= 2 as libc::c_int {
        return 0 as libc::c_int;
    }
    if (*lgl).mt != 0 {
        return 0 as libc::c_int;
    }
    if (*lgl).blkrem != 0 {
        return 1 as libc::c_int;
    }
    return ((*(*lgl).stats).irrprgss > (*(*lgl).limits).blk.irrprgss) as libc::c_int;
}
unsafe extern "C" fn lgleliminating(mut lgl: *mut LGL) -> libc::c_int {
    if (*(*lgl).opts).elim.val == 0 {
        return 0 as libc::c_int;
    }
    if (*lgl).allfrozen != 0 {
        return 0 as libc::c_int;
    }
    if lgldelaying(
        lgl,
        b"elim\0" as *const u8 as *const libc::c_char,
        &mut (*(*lgl).limits).elm.del.rem,
    ) != 0
    {
        return 0 as libc::c_int;
    }
    if lglsmallirr(lgl) == 0 {
        return 0 as libc::c_int;
    }
    if (*lgl).nvars <= 2 as libc::c_int {
        return 0 as libc::c_int;
    }
    if (*lgl).mt != 0 {
        return 0 as libc::c_int;
    }
    if (*lgl).elmrem != 0 {
        return 1 as libc::c_int;
    }
    return ((*(*lgl).stats).irrprgss > (*(*lgl).limits).elm.irrprgss) as libc::c_int;
}
unsafe extern "C" fn lglbcaing(mut lgl: *mut LGL) -> libc::c_int {
    if (*(*lgl).opts).bca.val == 0 {
        return 0 as libc::c_int;
    }
    if (*lgl).allfrozen != 0 {
        return 0 as libc::c_int;
    }
    if lgldelaying(
        lgl,
        b"bca\0" as *const u8 as *const libc::c_char,
        &mut (*(*lgl).limits).bca.del.rem,
    ) != 0
    {
        return 0 as libc::c_int;
    }
    if lglwaiting(
        lgl,
        b"bca\0" as *const u8 as *const libc::c_char,
        (*(*lgl).opts).bcawait.val,
    ) != 0
    {
        return 0 as libc::c_int;
    }
    if lglsmallirr(lgl) == 0 {
        return 0 as libc::c_int;
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn lglreducing(mut lgl: *mut LGL) -> libc::c_int {
    let mut reducable: libc::c_int = 0;
    if (*(*lgl).opts).reduce.val == 0 {
        return 0 as libc::c_int;
    }
    reducable = (*(*lgl).stats).red.lrg;
    reducable -= (*lgl).lrgluereasons;
    reducable -= (*(*lgl).stats).lir[0 as libc::c_int as usize].clauses;
    return (reducable >= (*(*lgl).limits).reduce.redlarge) as libc::c_int;
}
unsafe extern "C" fn lgldefragmenting(mut lgl: *mut LGL) -> libc::c_int {
    let mut relfree: libc::c_int = 0;
    if (*(*lgl).stats).pshwchs < (*(*lgl).limits).dfg {
        return 0 as libc::c_int;
    }
    if (*lgl).nvars == 0 {
        return 0 as libc::c_int;
    }
    relfree = (100 as libc::c_int * (*(*lgl).wchs).free + 99 as libc::c_int)
        / (*lgl).nvars;
    return (relfree >= (*(*lgl).opts).defragfree.val) as libc::c_int;
}
unsafe extern "C" fn lglforcerestart(mut lgl: *mut LGL) -> libc::c_int {
    let percent: int64_t = (*(*lgl).opts).restartforcelim.val as int64_t;
    let mut actual: int64_t = 0;
    let mut smoothed: int64_t = 0;
    let mut limit: int64_t = 0;
    let mut forcing: libc::c_int = 0;
    match (*(*lgl).opts).restartforcemode.val {
        1 => {
            actual = (*(*lgl).stats).glue.fast.val;
            smoothed = (*(*lgl).stats).glue.slow.val;
        }
        2 => {
            actual = (*(*lgl).stats).glue.diff.actual;
            smoothed = (*(*lgl).stats).glue.diff.smoothed.val;
        }
        0 | _ => {
            actual = (*(*lgl).stats).glue.fast.val;
            smoothed = (*(*lgl).stats).avglue.val;
        }
    }
    limit = if smoothed < 0 as libc::c_int as int64_t { -smoothed } else { smoothed };
    if lglvalidint64(limit) == 0 {
        return 0 as libc::c_int;
    }
    limit /= 100 as libc::c_int as int64_t;
    if INT64MAX / percent < limit {
        return 0 as libc::c_int;
    }
    limit *= percent;
    forcing = (limit < actual) as libc::c_int;
    return forcing;
}
unsafe extern "C" fn lgldelayrestart(mut lgl: *mut LGL) -> libc::c_int {
    let actual: int64_t = ((*lgl).level as int64_t) << 32 as libc::c_int;
    let smoothed: int64_t = (*(*lgl).stats).jlevel.slow.val;
    let percent: int64_t = (*(*lgl).opts).restartdelaylim.val as int64_t;
    let mut limit: int64_t = 0;
    let mut delaying: libc::c_int = 0;
    limit = if smoothed < 0 as libc::c_int as int64_t { -smoothed } else { smoothed };
    if lglvalidint64(limit) == 0 {
        return 0 as libc::c_int;
    }
    limit /= 100 as libc::c_int as int64_t;
    if INT64MAX / percent < limit {
        return 0 as libc::c_int;
    }
    limit *= percent;
    delaying = (limit > actual) as libc::c_int;
    return delaying;
}
unsafe extern "C" fn lglrestarting(mut lgl: *mut LGL) -> libc::c_int {
    let mut assumptions: libc::c_int = 0;
    if (*(*lgl).stats).confs < (*(*lgl).limits).restart.confs {
        return 0 as libc::c_int;
    }
    if (*(*lgl).opts).restart.val == 0 {
        return 0 as libc::c_int;
    }
    if (*lgl).level == 0 {
        return 0 as libc::c_int;
    }
    assumptions = lglcntstk(&mut (*lgl).assume) as libc::c_int;
    if assumptions != 0 {
        if (*lgl).assumed < assumptions {
            return 0 as libc::c_int;
        }
        if (*lgl).alevel == (*lgl).level {
            return 0 as libc::c_int;
        }
    }
    (*(*lgl).stats).restarts.checked += 1;
    (*(*lgl).stats).restarts.checked;
    (*(*lgl).limits).restart.confs = (*(*lgl).stats).confs + 1 as libc::c_int as int64_t;
    if (*(*lgl).opts).restartfixed.val != 0 {
        return 1 as libc::c_int;
    }
    if (*(*lgl).opts).agility.val != 0
        && 100 as libc::c_int as int64_t * (*(*lgl).stats).agility >> 32 as libc::c_int
            > (*(*lgl).opts).agilitylim.val as int64_t
    {
        (*(*lgl).stats).restarts.agile += 1;
        (*(*lgl).stats).restarts.agile;
    } else if (*(*lgl).opts).restartdelay.val != 0 && lgldelayrestart(lgl) != 0 {
        (*(*lgl).stats).restarts.delayed += 1;
        (*(*lgl).stats).restarts.delayed;
    } else if (*(*lgl).opts).restartblock.val == 2 as libc::c_int
        && lglblockrestart(lgl) != 0
    {
        (*(*lgl).limits)
            .restart
            .confs = (*(*lgl).stats).confs + (*(*lgl).opts).restartint.val as int64_t;
        (*(*lgl).stats).restarts.blocked += 1;
        (*(*lgl).stats).restarts.blocked;
    } else if (*(*lgl).opts).restartcheckforced.val != 0 && lglforcerestart(lgl) == 0 {
        (*(*lgl).stats).restarts.notforced += 1;
        (*(*lgl).stats).restarts.notforced;
    } else {
        (*(*lgl).stats).restarts.forced += 1;
        (*(*lgl).stats).restarts.forced;
        return 1 as libc::c_int;
    }
    (*(*lgl).stats).restarts.skipped += 1;
    (*(*lgl).stats).restarts.skipped;
    lglrep(lgl, 3 as libc::c_int, 'L' as i32 as libc::c_char);
    return 0 as libc::c_int;
}
unsafe extern "C" fn lglpruning(mut lgl: *mut LGL) -> libc::c_int {
    if (*lgl).mt != 0 {
        return 0 as libc::c_int;
    }
    if (*lgl).unassigned == 0 {
        return 0 as libc::c_int;
    }
    if (*(*lgl).opts).prune.val == 0 {
        return 0 as libc::c_int;
    }
    if (*(*lgl).opts).drupligcheck.val != 0 {
        return 0 as libc::c_int;
    }
    if lglmtstk(&mut (*lgl).assume) == 0 {
        return 0 as libc::c_int;
    }
    if (*lgl).level == 0 {
        return 0 as libc::c_int;
    }
    if (*lgl).level > (*(*lgl).opts).prunelevel.val {
        return 0 as libc::c_int;
    }
    return ((*(*lgl).limits).prune.decisions <= (*(*lgl).stats).decisions)
        as libc::c_int;
}
unsafe extern "C" fn lglpruneaddcls(mut state: *mut PruneState, mut red: libc::c_int) {
    let mut sat: libc::c_int = 0 as libc::c_int;
    let mut nfalse: libc::c_int = 0 as libc::c_int;
    let mut ntrue: libc::c_int = 0 as libc::c_int;
    let mut nunassigned: libc::c_int = 0 as libc::c_int;
    let mut size: libc::c_int = 0 as libc::c_int;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut q: *mut libc::c_int = 0 as *mut libc::c_int;
    p = (*state).clause.start;
    while sat == 0 && p < (*state).clause.top as *const libc::c_int {
        let plit: libc::c_int = *p;
        let mut tmp: libc::c_int = lglifixed((*state).parent, plit) as libc::c_int;
        if !(tmp < 0 as libc::c_int) {
            if tmp > 0 as libc::c_int {
                sat = 1 as libc::c_int;
            } else {
                tmp = lglval((*state).parent, plit) as libc::c_int;
                if tmp < 0 as libc::c_int {
                    nfalse += 1;
                    nfalse;
                } else if tmp > 0 as libc::c_int {
                    ntrue += 1;
                    ntrue;
                } else {
                    nunassigned += 1;
                    nunassigned;
                }
                size += 1;
                size;
            }
        }
        p = p.offset(1);
        p;
    }
    if !(sat != 0) {
        if !(size == nunassigned) {
            if !(ntrue == 0) {
                q = (*state).clause.start;
                p = q;
                while p < (*state).clause.top as *const libc::c_int {
                    let mut plit_0: libc::c_int = *p;
                    let mut tmp_0: libc::c_int = lglval((*state).parent, plit_0)
                        as libc::c_int;
                    if tmp_0 != 0 && lglifixed((*state).parent, plit_0) == 0 {
                        let mut pidx: libc::c_int = abs(plit_0);
                        let mut cidx: libc::c_int = *((*state).map)
                            .offset(pidx as isize);
                        let mut clit: libc::c_int = 0;
                        if cidx == 0 {
                            (*state).nvars += 1;
                            cidx = (*state).nvars;
                            *((*state).map).offset(pidx as isize) = cidx;
                        }
                        clit = if plit_0 < 0 as libc::c_int { -cidx } else { cidx };
                        let fresh275 = q;
                        q = q.offset(1);
                        *fresh275 = clit;
                    }
                    p = p.offset(1);
                    p;
                }
                (*state).clause.top = q;
                if red != 0 {
                    (*state).red += 1;
                    (*state).red;
                } else {
                    (*state).irr += 1;
                    (*state).irr;
                }
                p = (*state).clause.start;
                while p < (*state).clause.top as *const libc::c_int {
                    lgladd((*state).child, *p);
                    p = p.offset(1);
                    p;
                }
                lgladd((*state).child, 0 as libc::c_int);
            }
        }
    }
    lglclnstk(&mut (*state).clause);
}
unsafe extern "C" fn lglprunered(mut lgl: *mut LGL) -> libc::c_int {
    if (*(*lgl).opts).block.val != 0 {
        return 1 as libc::c_int;
    }
    if (*(*lgl).opts).prunered.val != 0 {
        return 1 as libc::c_int;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn lglpruneadd(
    mut ptr: *mut libc::c_void,
    mut red: libc::c_int,
    mut lit: libc::c_int,
) {
    let mut state: *mut PruneState = ptr as *mut PruneState;
    if red != 0 && lglprunered((*state).parent) == 0 {
        return;
    }
    if lit != 0 {
        lglpushstk((*state).parent, &mut (*state).clause, lit);
    } else {
        lglpruneaddcls(state, red);
    };
}
unsafe extern "C" fn lglpruneana(mut state: *mut PruneState) {
    let mut parent: *mut LGL = (*state).parent;
    let mut len: libc::c_int = 0;
    let mut c: *mut Ctr = 0 as *mut Ctr;
    c = ((*parent).control.start).offset(1 as libc::c_int as isize);
    while c < (*parent).control.top {
        let mut decision: libc::c_int = (*c).decision();
        lglpushstk(parent, &mut (*parent).clause, -decision);
        lglpushstk(parent, &mut (*parent).seen, decision);
        c = c.offset(1);
        c;
    }
    lglbumpseenlits(parent);
    len = (*parent).level;
    (*(*parent).stats).lits.nonmin += len as int64_t;
    (*(*parent).stats).clauses.glue += (len - 1 as libc::c_int) as int64_t;
    (*(*parent).stats).clauses.realglue += (len - 1 as libc::c_int) as int64_t;
    (*(*parent).stats).lits.learned += len as int64_t;
    (*(*parent).stats).clauses.learned += 1;
    (*(*parent).stats).clauses.learned;
    (*(*parent).stats).mincls.size += 1;
    (*(*parent).stats).mincls.size;
    (*(*parent).stats).decflipped += 1;
    (*(*parent).stats).decflipped;
    (*(*parent).stats).confs += 1;
    (*(*parent).stats).confs;
    lglbacktrack(parent, len - 1 as libc::c_int);
    lglpushstk(parent, &mut (*parent).clause, 0 as libc::c_int);
    lgladdcls(
        parent,
        if lglprunered(parent) != 0 { REDCS as libc::c_int } else { 0 as libc::c_int },
        len - 1 as libc::c_int,
        1 as libc::c_int,
    );
    lglrndcls(parent, len, 1 as libc::c_int);
    lglclnstk(&mut (*parent).clause);
    lglclnstk(&mut (*parent).seen);
}
unsafe extern "C" fn lglsetpruneprefix(
    mut child: *mut LGL,
    mut parent: *mut LGL,
    mut level: libc::c_int,
) {
    let mut len: libc::c_int = strlen((*parent).prefix) as libc::c_int;
    let mut allocated: libc::c_int = len + 80 as libc::c_int;
    let mut prefix: *mut libc::c_char = lglnew(child, allocated as size_t)
        as *mut libc::c_char;
    let mut buffer: [libc::c_char; 80] = [0; 80];
    sprintf(
        buffer.as_mut_ptr(),
        b"[prune-%lld-%lld-%d] .. \0" as *const u8 as *const libc::c_char,
        (*(*parent).stats).prune.decs as libc::c_longlong,
        (*(*parent).stats).prune.calls as libc::c_longlong,
        level,
    );
    strcpy(prefix, (*parent).prefix);
    if len != 0
        && *((*child).prefix).offset((len - 1 as libc::c_int) as isize) as libc::c_int
            != ' ' as i32
    {
        strcat(prefix, b" \0" as *const u8 as *const libc::c_char);
    }
    strcat(prefix, buffer.as_mut_ptr());
    lgldelstr(child, (*child).prefix);
    (*child).prefix = lglstrdup(child, prefix);
    lgldel(child, prefix as *mut libc::c_void, allocated as size_t);
}
unsafe extern "C" fn lglupdprunelim(mut lgl: *mut LGL, mut success: libc::c_int) {
    if success != 0 {
        (*(*lgl).limits).prune.inc /= 2 as libc::c_int as int64_t;
        if (*(*lgl).limits).prune.inc < (*(*lgl).opts).prunemin.val as int64_t {
            (*(*lgl).limits).prune.inc = (*(*lgl).opts).prunemin.val as int64_t;
        }
    } else {
        let mut inc: int64_t = (*(*lgl).limits).prune.inc / 10 as libc::c_int as int64_t;
        if inc == 0 {
            inc = 1 as libc::c_int as int64_t;
        }
        (*(*lgl).limits).prune.inc += inc;
        if (*(*lgl).limits).prune.inc > (*(*lgl).opts).prunemax.val as int64_t {
            (*(*lgl).limits).prune.inc = (*(*lgl).opts).prunemax.val as int64_t;
        }
    }
    (*(*lgl).limits)
        .prune
        .decisions = (*(*lgl).stats).decisions + (*(*lgl).limits).prune.inc;
    lglprt(
        lgl,
        2 as libc::c_int,
        b"[prune-%lld-%lld] %s new decision increment %lld limit %lld\0" as *const u8
            as *const libc::c_char,
        (*(*lgl).stats).prune.decs as libc::c_longlong,
        (*(*lgl).stats).prune.calls as libc::c_longlong,
        if success != 0 {
            b"successful\0" as *const u8 as *const libc::c_char
        } else {
            b"unsuccessful\0" as *const u8 as *const libc::c_char
        },
        (*(*lgl).limits).prune.inc as libc::c_longlong,
        (*(*lgl).limits).prune.decisions as libc::c_longlong,
    );
}
unsafe extern "C" fn lglprunedecidefirst(mut lgl: *mut LGL) -> libc::c_int {
    let mut idx: libc::c_int = 0;
    let mut sign: libc::c_int = 0;
    let mut lit: libc::c_int = 0;
    let mut blit: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut red: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut other2: libc::c_int = 0;
    let mut size: libc::c_int = 0;
    let mut pure_0: libc::c_int = 0;
    let mut tmp: libc::c_int = 0;
    let mut valit: libc::c_int = 0;
    let mut valother: libc::c_int = 0;
    let mut valother2: libc::c_int = 0;
    let mut decision: libc::c_int = 0;
    let mut glue: libc::c_int = 0;
    let mut sat: libc::c_int = 0;
    let skipred: libc::c_int = (lglprunered(lgl) == 0) as libc::c_int;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut w: *const libc::c_int = 0 as *const libc::c_int;
    let mut eow: *const libc::c_int = 0 as *const libc::c_int;
    let mut c: *const libc::c_int = 0 as *const libc::c_int;
    let mut count: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut bestcount: libc::c_int = 0;
    let mut sum: *mut int64_t = 0 as *mut int64_t;
    let mut bestsum: int64_t = 0;
    let mut hts: *mut HTS = 0 as *mut HTS;
    let mut s: *mut Stk = 0 as *mut Stk;
    count = lglnew(
        lgl,
        ((2 as libc::c_int * (*lgl).nvars) as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
    ) as *mut libc::c_int;
    sum = lglnew(
        lgl,
        ((2 as libc::c_int * (*lgl).nvars) as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<int64_t>() as libc::c_ulong),
    ) as *mut int64_t;
    count = count.offset((*lgl).nvars as isize);
    sum = sum.offset((*lgl).nvars as isize);
    idx = 2 as libc::c_int;
    while idx < (*lgl).nvars {
        sign = -(1 as libc::c_int);
        while sign <= 1 as libc::c_int {
            lit = sign * idx;
            valit = lglval(lgl, lit) as libc::c_int;
            if !(valit > 0 as libc::c_int) {
                hts = lglhts(lgl, lit);
                w = lglhts2wchs(lgl, hts);
                eow = w.offset((*hts).count as isize);
                p = w;
                while p < eow {
                    blit = *p;
                    tag = blit & MASKCS as libc::c_int;
                    if tag == TRNCS as libc::c_int || tag == LRGCS as libc::c_int {
                        p = p.offset(1);
                        p;
                    }
                    if !(tag == LRGCS as libc::c_int) {
                        red = blit & REDCS as libc::c_int;
                        if !(skipred != 0 && red != 0) {
                            other = blit >> RMSHFT as libc::c_int;
                            if !(abs(other) < idx) {
                                other2 = if tag == BINCS as libc::c_int {
                                    0 as libc::c_int
                                } else {
                                    *p
                                };
                                if !(other2 != 0 && abs(other2) < idx) {
                                    valother = lglval(lgl, other) as libc::c_int;
                                    if !(valother > 0 as libc::c_int) {
                                        valother2 = if other2 != 0 {
                                            lglval(lgl, other2) as libc::c_int
                                        } else {
                                            -(1 as libc::c_int)
                                        };
                                        if !(valother2 > 0 as libc::c_int) {
                                            size = 0 as libc::c_int;
                                            if valit == 0 {
                                                size += 1;
                                                size;
                                            }
                                            if valother == 0 {
                                                size += 1;
                                                size;
                                            }
                                            if valother2 == 0 {
                                                size += 1;
                                                size;
                                            }
                                            if valit == 0 {
                                                let ref mut fresh276 = *count.offset(lit as isize);
                                                *fresh276 += 1;
                                                *fresh276;
                                                *sum.offset(lit as isize) += size as int64_t;
                                            }
                                            if valother == 0 {
                                                let ref mut fresh277 = *count.offset(other as isize);
                                                *fresh277 += 1;
                                                *fresh277;
                                                *sum.offset(other as isize) += size as int64_t;
                                            }
                                            if valother2 == 0 {
                                                let ref mut fresh278 = *count.offset(other2 as isize);
                                                *fresh278 += 1;
                                                *fresh278;
                                                *sum.offset(other2 as isize) += size as int64_t;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    p = p.offset(1);
                    p;
                }
            }
            sign += 2 as libc::c_int;
        }
        idx += 1;
        idx;
    }
    glue = -(1 as libc::c_int);
    while glue < ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int {
        if glue >= 0 as libc::c_int && skipred != 0 {
            break;
        }
        s = if glue < 0 as libc::c_int {
            &mut (*lgl).irr
        } else {
            &mut *((*lgl).red).offset(glue as isize) as *mut Stk
        };
        c = (*s).start;
        while c < (*s).top as *const libc::c_int {
            p = c;
            if !(*p >= 2147483647 as libc::c_int >> RMSHFT as libc::c_int) {
                sat = 0 as libc::c_int;
                size = sat;
                loop {
                    other = *p;
                    if !(other != 0) {
                        break;
                    }
                    tmp = lglval(lgl, other) as libc::c_int;
                    if tmp > 0 as libc::c_int {
                        sat = 1 as libc::c_int;
                    }
                    if tmp == 0 {
                        size += 1;
                        size;
                    }
                    p = p.offset(1);
                    p;
                }
                if !(sat != 0) {
                    p = c;
                    loop {
                        other = *p;
                        if !(other != 0) {
                            break;
                        }
                        tmp = lglval(lgl, other) as libc::c_int;
                        if tmp == 0 {
                            let ref mut fresh279 = *count.offset(other as isize);
                            *fresh279 += 1;
                            *fresh279;
                            *sum.offset(other as isize) += size as int64_t;
                        }
                        p = p.offset(1);
                        p;
                    }
                }
            }
            c = p.offset(1 as libc::c_int as isize);
        }
        glue += 1;
        glue;
    }
    pure_0 = 0 as libc::c_int;
    if (*(*lgl).opts).prunepure.val != 0 && (*(*lgl).opts).drupligcheck.val == 0
        && skipred == 0
    {
        idx = 2 as libc::c_int;
        while pure_0 == 0 && idx < (*lgl).nvars {
            if !(lglval(lgl, idx) != 0) {
                if !(lglifrozen(lgl, idx) != 0) {
                    sign = 1 as libc::c_int;
                    while pure_0 == 0 && sign >= -(1 as libc::c_int) {
                        lit = sign * idx;
                        if *count.offset(lit as isize) == 0 {
                            pure_0 = -lit;
                        }
                        sign -= 2 as libc::c_int;
                    }
                }
            }
            idx += 1;
            idx;
        }
    }
    if pure_0 != 0 {
        decision = -(2147483647 as libc::c_int) - 1 as libc::c_int;
        lglprt(
            lgl,
            2 as libc::c_int,
            b"[prune-%lld-%lld-%d] found pure literal %d in %d clauses\0" as *const u8
                as *const libc::c_char,
            (*(*lgl).stats).prune.decs as libc::c_longlong,
            (*(*lgl).stats).prune.calls as libc::c_longlong,
            (*lgl).level + 1 as libc::c_int,
            pure_0,
            *count.offset(pure_0 as isize),
        );
        (*(*lgl).stats).prune.pure_0 += 1;
        (*(*lgl).stats).prune.pure_0;
        lglunit(lgl, pure_0);
    } else {
        decision = 0 as libc::c_int;
        bestsum = 0 as libc::c_int as int64_t;
        bestcount = 2147483647 as libc::c_int;
        idx = 2 as libc::c_int;
        while idx < (*lgl).nvars {
            if !(lglval(lgl, idx) != 0) {
                if !(lglifrozen(lgl, idx) != 0) {
                    sign = 1 as libc::c_int;
                    while pure_0 == 0 && sign >= -(1 as libc::c_int) {
                        let mut tmpcount: libc::c_int = 0;
                        let mut update: libc::c_int = 0 as libc::c_int;
                        let mut tmpsum: int64_t = 0;
                        lit = sign * idx;
                        tmpcount = *count.offset(lit as isize);
                        tmpsum = *sum.offset(lit as isize);
                        if tmpcount < bestcount {
                            update = 1 as libc::c_int;
                        } else if tmpcount != 0 && tmpcount == bestcount {
                            let mut L: int64_t = 0;
                            let mut R: int64_t = 0;
                            if 0x7fffffffffffffff as libc::c_longlong
                                / tmpcount as libc::c_longlong
                                <= bestsum as libc::c_longlong
                            {
                                L = 0x7fffffffffffffff as libc::c_longlong as int64_t;
                            } else {
                                L = bestsum * tmpcount as int64_t;
                            }
                            if 0x7fffffffffffffff as libc::c_longlong
                                / bestcount as libc::c_longlong
                                <= tmpsum as libc::c_longlong
                            {
                                R = 0x7fffffffffffffff as libc::c_longlong as int64_t;
                            } else {
                                R = tmpsum * bestcount as int64_t;
                            }
                            update = (L < R) as libc::c_int;
                        }
                        if !(update == 0) {
                            decision = lit;
                            bestcount = tmpcount;
                            bestsum = tmpsum;
                        }
                        sign -= 2 as libc::c_int;
                    }
                }
            }
            idx += 1;
            idx;
        }
        lglprt(
            lgl,
            2 as libc::c_int,
            b"[prune-%lld-%lld-%d] best decision %d with %d occurrences and average length %.3f\0"
                as *const u8 as *const libc::c_char,
            (*(*lgl).stats).prune.decs as libc::c_longlong,
            (*(*lgl).stats).prune.calls as libc::c_longlong,
            (*lgl).level + 1 as libc::c_int,
            decision,
            *count.offset(decision as isize),
            lglavg(
                *sum.offset(decision as isize) as libc::c_double,
                *count.offset(decision as isize) as libc::c_double,
            ),
        );
    }
    sum = sum.offset(-((*lgl).nvars as isize));
    count = count.offset(-((*lgl).nvars as isize));
    lgldel(
        lgl,
        sum as *mut libc::c_void,
        ((2 as libc::c_int * (*lgl).nvars) as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<int64_t>() as libc::c_ulong),
    );
    sum = 0 as *mut int64_t;
    lgldel(
        lgl,
        count as *mut libc::c_void,
        ((2 as libc::c_int * (*lgl).nvars) as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
    );
    count = 0 as *mut libc::c_int;
    return decision;
}
unsafe extern "C" fn lglprunedecidelater(mut lgl: *mut LGL) -> libc::c_int {
    let mut decision: libc::c_int = 0;
    let mut shortest: libc::c_int = 0;
    let mut size: libc::c_int = 0;
    let mut tmp: libc::c_int = 0;
    let mut sat: libc::c_int = 0;
    let mut reduced: libc::c_int = 0;
    let mut lit: libc::c_int = 0;
    let mut glue: libc::c_int = 0;
    let mut idx: libc::c_int = 0;
    let mut sign: libc::c_int = 0;
    let mut blit: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut red: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut other2: libc::c_int = 0;
    let skipred: libc::c_int = (lglprunered(lgl) == 0) as libc::c_int;
    let mut valit: libc::c_int = 0;
    let mut valother: libc::c_int = 0;
    let mut valother2: libc::c_int = 0;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut w: *const libc::c_int = 0 as *const libc::c_int;
    let mut eow: *const libc::c_int = 0 as *const libc::c_int;
    let mut c: *const libc::c_int = 0 as *const libc::c_int;
    let mut hts: *mut HTS = 0 as *mut HTS;
    let mut s: *mut Stk = 0 as *mut Stk;
    decision = 0 as libc::c_int;
    shortest = 2147483647 as libc::c_int;
    idx = 2 as libc::c_int;
    while idx < (*lgl).nvars {
        sign = -(1 as libc::c_int);
        while sign <= 1 as libc::c_int {
            lit = sign * idx;
            valit = lglval(lgl, lit) as libc::c_int;
            if !(valit > 0 as libc::c_int) {
                hts = lglhts(lgl, lit);
                w = lglhts2wchs(lgl, hts);
                eow = w.offset((*hts).count as isize);
                p = w;
                while p < eow {
                    blit = *p;
                    tag = blit & MASKCS as libc::c_int;
                    if !(tag == BINCS as libc::c_int) {
                        if tag == TRNCS as libc::c_int || tag == LRGCS as libc::c_int {
                            p = p.offset(1);
                            p;
                        }
                        if !(tag == LRGCS as libc::c_int) {
                            red = blit & REDCS as libc::c_int;
                            if !(skipred != 0 && red != 0) {
                                other = blit >> RMSHFT as libc::c_int;
                                if !(abs(other) < idx) {
                                    valother = lglval(lgl, other) as libc::c_int;
                                    if !(valother > 0 as libc::c_int) {
                                        other2 = *p;
                                        if !(abs(other2) < idx) {
                                            valother2 = lglval(lgl, other2) as libc::c_int;
                                            if !(valother2 > 0 as libc::c_int) {
                                                size = 0 as libc::c_int;
                                                if valit == 0 {
                                                    size += 1;
                                                    size;
                                                }
                                                if valother == 0 {
                                                    size += 1;
                                                    size;
                                                }
                                                if valother2 == 0 {
                                                    size += 1;
                                                    size;
                                                }
                                                if !(size > 2 as libc::c_int) {
                                                    tmp = 0 as libc::c_int;
                                                    if valit == 0 && lglifrozen(lgl, lit) == 0 {
                                                        tmp = lit;
                                                    }
                                                    if valother == 0 && lglifrozen(lgl, other) == 0 {
                                                        tmp = other;
                                                    }
                                                    if valother2 == 0 && lglifrozen(lgl, other2) == 0 {
                                                        tmp = other2;
                                                    }
                                                    if !(tmp == 0 || abs(tmp) >= abs(decision)) {
                                                        decision = tmp;
                                                        shortest = 2 as libc::c_int;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    p = p.offset(1);
                    p;
                }
            }
            sign += 2 as libc::c_int;
        }
        idx += 1;
        idx;
    }
    if decision == 0 {
        glue = -(1 as libc::c_int);
        while glue < ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int {
            if glue >= 0 as libc::c_int && skipred != 0 {
                break;
            }
            s = if glue < 0 as libc::c_int {
                &mut (*lgl).irr
            } else {
                &mut *((*lgl).red).offset(glue as isize) as *mut Stk
            };
            c = (*s).start;
            while c < (*s).top as *const libc::c_int {
                p = c;
                if !(*p >= 2147483647 as libc::c_int >> RMSHFT as libc::c_int) {
                    size = 0 as libc::c_int;
                    lit = size;
                    sat = lit;
                    reduced = sat;
                    loop {
                        other = *p;
                        if !(other != 0) {
                            break;
                        }
                        tmp = lglval(lgl, other) as libc::c_int;
                        if tmp > 0 as libc::c_int {
                            sat = 1 as libc::c_int;
                        }
                        if tmp == 0 {
                            if lglifrozen(lgl, other) == 0
                                && (lit == 0 || abs(other) < abs(lit))
                            {
                                lit = other;
                            }
                            size += 1;
                            size;
                        } else if lglevel(lgl, other) != 0 {
                            reduced = 1 as libc::c_int;
                        }
                        p = p.offset(1);
                        p;
                    }
                    if !(sat != 0 || lit == 0 || reduced == 0) {
                        if !(size > shortest) {
                            if !(size == shortest && abs(lit) >= abs(decision)) {
                                decision = lit;
                                shortest = size;
                            }
                        }
                    }
                }
                c = p.offset(1 as libc::c_int as isize);
            }
            glue += 1;
            glue;
        }
    }
    lglprt(
        lgl,
        2 as libc::c_int,
        b"[prune-%lld-%lld-%d] best decision %d in shortest reduced clause of size %d\0"
            as *const u8 as *const libc::c_char,
        (*(*lgl).stats).prune.decs as libc::c_longlong,
        (*(*lgl).stats).prune.calls as libc::c_longlong,
        (*lgl).level + 1 as libc::c_int,
        decision,
        shortest,
    );
    return decision;
}
unsafe extern "C" fn lglprunedecide(mut lgl: *mut LGL) -> libc::c_int {
    let mut decision: libc::c_int = 0;
    if (*lgl).mt != 0 {
        return 0 as libc::c_int;
    }
    if (*lgl).unassigned == 0 {
        return 0 as libc::c_int;
    }
    if (*(*lgl).opts).prune.val == 0 {
        return 0 as libc::c_int;
    }
    if (*(*lgl).opts).prunevsids.val != 0 {
        return 0 as libc::c_int;
    }
    if lglmtstk(&mut (*lgl).assume) == 0 {
        return 0 as libc::c_int;
    }
    if (*lgl).level >= (*(*lgl).opts).prunelevel.val {
        return 0 as libc::c_int;
    }
    lglstart(lgl, &mut (*(*lgl).times).prune);
    (*(*lgl).stats).prune.decs += 1;
    (*(*lgl).stats).prune.decs;
    if (*lgl).level == 0 {
        decision = lglprunedecidefirst(lgl);
    } else {
        decision = lglprunedecidelater(lgl);
    }
    lglstop(lgl);
    return decision;
}
unsafe extern "C" fn lglprunecopytrail(
    mut parent: *mut LGL,
    mut map: *mut libc::c_int,
    mut child: *mut LGL,
) {
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut size: libc::c_int = 0 as libc::c_int;
    p = (*parent).trail.start;
    while p < (*parent).trail.top as *const libc::c_int {
        let mut plit: libc::c_int = *p;
        let mut level: libc::c_int = lglevel(parent, plit);
        let mut pidx: libc::c_int = 0;
        let mut cidx: libc::c_int = 0;
        if !(level != 0 && lgldecision(parent, plit) == 0) {
            pidx = abs(plit);
            cidx = *map.offset(pidx as isize);
            if cidx != 0 {
                let mut clit: libc::c_int = if plit < 0 as libc::c_int {
                    -cidx
                } else {
                    cidx
                };
                if level != 0 {
                    lgladd(child, -clit);
                    size += 1;
                    size;
                } else {
                    lgladd(child, clit);
                    lgladd(child, 0 as libc::c_int);
                }
            }
        }
        p = p.offset(1);
        p;
    }
    lgladd(child, 0 as libc::c_int);
}
unsafe extern "C" fn lglprunechild(
    mut parent: *mut LGL,
    mut level: libc::c_int,
    mut state: *mut PruneState,
) -> *mut LGL {
    let mut child: *mut LGL = 0 as *mut LGL;
    child = lglminit(
        (*(*parent).mem).state,
        (*(*parent).mem).alloc,
        (*(*parent).mem).realloc,
        (*(*parent).mem).dealloc,
    );
    lglcopyclonenfork(child, parent);
    lglsetpruneprefix(child, parent, level);
    (*(*child).opts).prune.val = 0 as libc::c_int;
    (*(*child).opts).clim.val = (*(*parent).opts).pruneclim.val;
    (*(*child).opts).trep.val = 0 as libc::c_int;
    (*(*child).opts).druplig.val = 0 as libc::c_int;
    (*(*child).opts).drupligcheck.val = 0 as libc::c_int;
    (*(*child).opts).drupligtrace.val = 0 as libc::c_int;
    (*(*child).opts).drupligtraceorig.val = 0 as libc::c_int;
    if (*(*child).opts).verbose.val > -(1 as libc::c_int)
        && (*(*parent).opts).log.val < 0 as libc::c_int
    {
        (*(*child).opts).verbose.val -= 1;
        (*(*child).opts).verbose.val;
    }
    if (*(*child).opts).plain.val == 0 {
        lglsetplain(child, 1 as libc::c_int);
    }
    memset(
        state as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<PruneState>() as libc::c_ulong,
    );
    (*state).parent = parent;
    (*state).child = child;
    (*state)
        .map = lglnew(
        parent,
        ((*parent).nvars as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
    ) as *mut libc::c_int;
    lglictrav(
        parent,
        1 as libc::c_int,
        1 as libc::c_int,
        state as *mut libc::c_void,
        Some(
            lglpruneadd
                as unsafe extern "C" fn(
                    *mut libc::c_void,
                    libc::c_int,
                    libc::c_int,
                ) -> (),
        ),
    );
    lglrelstk(parent, &mut (*state).clause);
    lglprt(
        parent,
        2 as libc::c_int,
        b"[prune-%lld-%lld-%d] copied %d variables in %d irredundant and %d redundant clauses\0"
            as *const u8 as *const libc::c_char,
        (*(*parent).stats).prune.decs as libc::c_longlong,
        (*(*parent).stats).prune.calls as libc::c_longlong,
        level,
        (*state).nvars,
        (*state).irr,
        (*state).red,
    );
    lglprunecopytrail(parent, (*state).map, child);
    return child;
}
unsafe extern "C" fn lglprunesat(
    mut parent: *mut LGL,
    mut level: libc::c_int,
) -> libc::c_int {
    let mut state: PruneState = PruneState {
        parent: 0 as *mut LGL,
        child: 0 as *mut LGL,
        clause: Stk {
            start: 0 as *mut libc::c_int,
            top: 0 as *mut libc::c_int,
            end: 0 as *mut libc::c_int,
        },
        map: 0 as *mut libc::c_int,
        nvars: 0,
        red: 0,
        irr: 0,
    };
    let mut child: *mut LGL = lglprunechild(parent, level, &mut state);
    let mut res: libc::c_int = lglsat(child);
    (*(*parent).stats).prune.child.confs += (*(*child).stats).confs;
    (*(*parent).stats).prune.child.decs += (*(*child).stats).decisions;
    (*(*parent).stats).prune.child.props += (*(*child).stats).props.search;
    (*(*parent).stats).prune.child.props += (*(*child).stats).props.simp;
    lglprt(
        parent,
        2 as libc::c_int,
        b"[prune-%lld-%lld-%d] result %d in %lld conflicts and %lld decisions\0"
            as *const u8 as *const libc::c_char,
        (*(*parent).stats).prune.decs as libc::c_longlong,
        (*(*parent).stats).prune.calls as libc::c_longlong,
        level,
        res,
        (*(*child).stats).confs as libc::c_longlong,
        (*(*child).stats).decisions as libc::c_longlong,
    );
    if res == 10 as libc::c_int {
        lglpruneana(&mut state);
    }
    lgldel(
        parent,
        state.map as *mut libc::c_void,
        ((*parent).nvars as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
    );
    lglrelease(child);
    return res;
}
unsafe extern "C" fn lglprune(mut lgl: *mut LGL) {
    let mut res: libc::c_int = 0;
    let mut level: libc::c_int = (*lgl).level - (*lgl).alevel;
    let mut reason: *const libc::c_char = 0 as *const libc::c_char;
    lglstart(lgl, &mut (*(*lgl).times).prune);
    (*(*lgl).stats).prune.calls += 1;
    (*(*lgl).stats).prune.calls;
    (*(*lgl).stats).prune.levels += level as int64_t;
    lglprt(
        lgl,
        2 as libc::c_int,
        b"[prune-%lld-%lld-%d] starting pruning after %lld decisions\0" as *const u8
            as *const libc::c_char,
        (*(*lgl).stats).prune.decs as libc::c_longlong,
        (*(*lgl).stats).prune.calls as libc::c_longlong,
        level,
        (*(*lgl).stats).decisions,
    );
    res = lglprunesat(lgl, level);
    if res == 10 as libc::c_int {
        reason = b"satisfiable\0" as *const u8 as *const libc::c_char;
        (*(*lgl).stats).prune.sat += 1;
        (*(*lgl).stats).prune.sat;
    } else if res == 20 as libc::c_int {
        reason = b"unsatisfiable\0" as *const u8 as *const libc::c_char;
        (*(*lgl).stats).prune.uns += 1;
        (*(*lgl).stats).prune.uns;
    } else {
        reason = b"limit reached\0" as *const u8 as *const libc::c_char;
        (*(*lgl).stats).prune.lim += 1;
        (*(*lgl).stats).prune.lim;
    }
    lglprt(
        lgl,
        2 as libc::c_int,
        b"[prune-%lld-%lld-%d] pruning result '%s' (%s)\0" as *const u8
            as *const libc::c_char,
        (*(*lgl).stats).prune.decs as libc::c_longlong,
        (*(*lgl).stats).prune.calls as libc::c_longlong,
        level,
        reason,
        if res == 10 as libc::c_int {
            b"successful\0" as *const u8 as *const libc::c_char
        } else {
            b"unsuccessful\0" as *const u8 as *const libc::c_char
        },
    );
    lglupdprunelim(lgl, (res == 10 as libc::c_int) as libc::c_int);
    lglstop(lgl);
    lglrep(lgl, 2 as libc::c_int, 'P' as i32 as libc::c_char);
}
unsafe extern "C" fn lglquatresolving(mut lgl: *mut LGL) -> libc::c_int {
    if lgldelaying(
        lgl,
        b"quatres\0" as *const u8 as *const libc::c_char,
        &mut (*(*lgl).limits).quatres.del.rem,
    ) != 0
    {
        return 0 as libc::c_int;
    }
    if lglwaiting(
        lgl,
        b"quatres\0" as *const u8 as *const libc::c_char,
        (*(*lgl).opts).quatreswait.val,
    ) != 0
    {
        return 0 as libc::c_int;
    }
    return (*(*lgl).opts).quatres.val;
}
unsafe extern "C" fn lglternresolving(mut lgl: *mut LGL) -> libc::c_int {
    if lgldelaying(
        lgl,
        b"ternres\0" as *const u8 as *const libc::c_char,
        &mut (*(*lgl).limits).ternres.del.rem,
    ) != 0
    {
        return 0 as libc::c_int;
    }
    if lglwaiting(
        lgl,
        b"ternres\0" as *const u8 as *const libc::c_char,
        (*(*lgl).opts).ternreswait.val,
    ) != 0
    {
        return 0 as libc::c_int;
    }
    return (*(*lgl).opts).ternres.val;
}
unsafe extern "C" fn lglgaussing(mut lgl: *mut LGL) -> libc::c_int {
    if lgldelaying(
        lgl,
        b"gauss\0" as *const u8 as *const libc::c_char,
        &mut (*(*lgl).limits).gauss.del.rem,
    ) != 0
    {
        return 0 as libc::c_int;
    }
    if lglwaiting(
        lgl,
        b"gauss\0" as *const u8 as *const libc::c_char,
        (*(*lgl).opts).gausswait.val,
    ) != 0
    {
        return 0 as libc::c_int;
    }
    if lglsmallirr(lgl) == 0 {
        return 0 as libc::c_int;
    }
    return (*(*lgl).opts).gauss.val;
}
unsafe extern "C" fn lglprobing(mut lgl: *mut LGL) -> libc::c_int {
    if (*(*lgl).opts).probe.val == 0 {
        return 0 as libc::c_int;
    }
    if (*(*lgl).opts).prbasic.val != 0 {
        return 1 as libc::c_int;
    }
    if lglsmallirr(lgl) == 0 {
        return 0 as libc::c_int;
    }
    if (*(*lgl).opts).prbsimple.val != 0 {
        return 1 as libc::c_int;
    }
    if (*(*lgl).opts).treelook.val != 0 {
        return 1 as libc::c_int;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn lglcarding(mut lgl: *mut LGL) -> libc::c_int {
    if (*(*lgl).opts).card.val == 0 {
        return 0 as libc::c_int;
    }
    if lgldelaying(
        lgl,
        b"card\0" as *const u8 as *const libc::c_char,
        &mut (*(*lgl).limits).card.del.rem,
    ) != 0
    {
        return 0 as libc::c_int;
    }
    if lglwaiting(
        lgl,
        b"card\0" as *const u8 as *const libc::c_char,
        (*(*lgl).opts).cardwait.val,
    ) != 0
    {
        return 0 as libc::c_int;
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn lglcceing(mut lgl: *mut LGL) -> libc::c_int {
    if (*(*lgl).opts).cce.val == 0 {
        return 0 as libc::c_int;
    }
    if (*lgl).allfrozen != 0 {
        return 0 as libc::c_int;
    }
    if lgldelaying(
        lgl,
        b"cce\0" as *const u8 as *const libc::c_char,
        &mut (*(*lgl).limits).cce.del.rem,
    ) != 0
    {
        return 0 as libc::c_int;
    }
    if lglwaiting(
        lgl,
        b"cce\0" as *const u8 as *const libc::c_char,
        (*(*lgl).opts).ccewait.val,
    ) != 0
    {
        return 0 as libc::c_int;
    }
    if lglsmallirr(lgl) == 0 {
        return 0 as libc::c_int;
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn lglupdlocslim(mut lgl: *mut LGL, mut updconflimtoo: libc::c_int) {
    let mut rem: libc::c_int = lglrem(lgl);
    let mut varslimit: libc::c_int = 0;
    let mut vardelta: libc::c_int = 0;
    vardelta = (rem * (*(*lgl).opts).locsvared.val + 999 as libc::c_int)
        / 1000 as libc::c_int;
    if vardelta > rem {
        vardelta = rem;
    }
    varslimit = rem - vardelta;
    (*(*lgl).limits).locs.vars = varslimit;
    lglprt(
        lgl,
        1 as libc::c_int + ((*(*lgl).opts).locs.val == 0) as libc::c_int,
        b"[locs-lim] next local search variable limit %d = %d - %d\0" as *const u8
            as *const libc::c_char,
        varslimit,
        rem,
        vardelta,
    );
    if updconflimtoo == 0 {
        return;
    }
    (*(*lgl).limits).locs.inc += (*(*lgl).opts).locscint.val as int64_t;
    (*(*lgl).limits).locs.confs = (*(*lgl).stats).confs + (*(*lgl).limits).locs.inc;
    lglprt(
        lgl,
        1 as libc::c_int + ((*(*lgl).opts).locs.val == 0) as libc::c_int,
        b"[locs-lim] next local search conflict limit increased by %d to %lld\0"
            as *const u8 as *const libc::c_char,
        (*(*lgl).limits).locs.inc,
        (*(*lgl).limits).locs.confs,
    );
}
unsafe extern "C" fn lglocsing(mut lgl: *mut LGL) -> libc::c_int {
    return 0 as libc::c_int;
}
unsafe extern "C" fn lglocsaux(
    mut lgl: *mut LGL,
    mut hitlim: libc::c_int,
) -> libc::c_int {
    let mut lkhd: libc::c_int = 0 as libc::c_int;
    return lkhd;
}
unsafe extern "C" fn lglocs(mut lgl: *mut LGL) {
    lglocsaux(lgl, 0 as libc::c_int);
    lglupdlocslim(lgl, 1 as libc::c_int);
}
unsafe extern "C" fn lglocslook(mut lgl: *mut LGL) -> libc::c_int {
    let mut res: libc::c_int = lglocsaux(lgl, 100000 as libc::c_int);
    let mut elit: libc::c_int = 0;
    let mut ext: *mut Ext = 0 as *mut Ext;
    if res != 0 {
        elit = lglexport(lgl, res);
        ext = lglelit2ext(lgl, elit);
        if (*ext).eliminated() == 0 && (*ext).blocking() == 0 {
            lglprt(
                lgl,
                1 as libc::c_int,
                b"[locslook] best local search look-ahead %d\0" as *const u8
                    as *const libc::c_char,
                res,
            );
            if (*ext).melted() != 0 {
                (*ext).set_melted(0 as libc::c_int as libc::c_uint);
            }
        } else {
            lglprt(
                lgl,
                1 as libc::c_int,
                b"[locslook] no valid local search look-ahead\0" as *const u8
                    as *const libc::c_char,
            );
            lglprt(
                lgl,
                1 as libc::c_int,
                b"[locslook] falling back to JWH\0" as *const u8 as *const libc::c_char,
            );
            res = lgljwhlook(lgl);
        }
    }
    return res;
}
unsafe extern "C" fn lglforklit(mut ilit: libc::c_int) -> libc::c_int {
    let mut idx: libc::c_int = abs(ilit);
    let mut res: libc::c_int = 0;
    res = idx - 1 as libc::c_int;
    if ilit < 0 as libc::c_int {
        res = -res;
    }
    return res;
}
unsafe extern "C" fn lglsweeping(mut lgl: *mut LGL) -> libc::c_int {
    if lglsmallirr(lgl) == 0 {
        return 0 as libc::c_int;
    }
    if (*(*lgl).opts).sweep.val == 0 {
        return 0 as libc::c_int;
    }
    if lgldelaying(
        lgl,
        b"sweep\0" as *const u8 as *const libc::c_char,
        &mut (*(*lgl).limits).sweep.del.rem,
    ) != 0
    {
        return 0 as libc::c_int;
    }
    if lglwaiting(
        lgl,
        b"sweep\0" as *const u8 as *const libc::c_char,
        (*(*lgl).opts).sweepwait.val,
    ) != 0
    {
        return 0 as libc::c_int;
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn lglinitsweep(mut lgl: *mut LGL) {
    let mut idx: libc::c_int = 0;
    let mut lit: libc::c_int = 0;
    let mut pos: libc::c_int = 0;
    let mut neg: libc::c_int = 0;
    let mut rem: libc::c_int = 0 as libc::c_int;
    let mut ret: libc::c_int = 0 as libc::c_int;
    let mut av: *mut AVar = 0 as *mut AVar;
    idx = 2 as libc::c_int;
    while idx < (*lgl).nvars {
        if !(lglisfree(lgl, idx) == 0) {
            if (*lglavar(lgl, idx)).donotsweep() != 0 {
                ret += 1;
                ret;
            } else {
                rem += 1;
                rem;
            }
        }
        idx += 1;
        idx;
    }
    if rem == 0 {
        ret = 0 as libc::c_int;
        idx = 2 as libc::c_int;
        while idx < (*lgl).nvars {
            if !(lglisfree(lgl, idx) == 0) {
                let ref mut fresh280 = *lglavar(lgl, idx);
                (*fresh280).set_donotsweep(0 as libc::c_int as libc::c_uint);
                rem += 1;
                rem;
            }
            idx += 1;
            idx;
        }
    }
    neg = 0 as libc::c_int;
    pos = neg;
    idx = 2 as libc::c_int;
    while idx < (*lgl).nvars {
        if !(lglisfree(lgl, idx) == 0) {
            av = lglavar(lgl, idx);
            if !((*av).donotsweep() != 0) {
                if (*av).phase() <= 0 as libc::c_int {
                    lit = -idx;
                    neg += 1;
                    neg;
                } else {
                    lit = idx;
                    pos += 1;
                    pos;
                }
                lglpushstk(lgl, &mut (*(*lgl).c2rust_unnamed.swp).partition, lit);
            }
        }
        idx += 1;
        idx;
    }
    if rem > 1 as libc::c_int {
        lglpushstk(lgl, &mut (*(*lgl).c2rust_unnamed.swp).partition, 0 as libc::c_int);
        (*(*lgl).c2rust_unnamed.swp).partitions += 1;
        (*(*lgl).c2rust_unnamed.swp).partitions;
    } else if rem != 0 {
        lglclnstk(&mut (*(*lgl).c2rust_unnamed.swp).partition);
    }
    lglprt(
        lgl,
        1 as libc::c_int,
        b"[sweep-%d-%d] %d pos %.1f%% + %d neg %.1f%% = %d sched %.1f%% ret %d\0"
            as *const u8 as *const libc::c_char,
        (*(*lgl).stats).sweep.count,
        (*(*lgl).c2rust_unnamed.swp).round,
        pos,
        lglpcnt(pos as libc::c_double, rem as libc::c_double),
        neg,
        lglpcnt(neg as libc::c_double, rem as libc::c_double),
        rem,
        lglpcnt(
            rem as libc::c_double,
            ((*lgl).nvars - 2 as libc::c_int) as libc::c_double,
        ),
        ret,
    );
}
unsafe extern "C" fn lglsweepavgpartitionsize(mut lgl: *mut LGL) -> libc::c_double {
    let mut count: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    let mut res: libc::c_double = 0.;
    if lglmtstk(&mut (*(*lgl).c2rust_unnamed.swp).partition) != 0 {
        return 0 as libc::c_int as libc::c_double;
    }
    count = lglcntstk(&mut (*(*lgl).c2rust_unnamed.swp).partition) as libc::c_int;
    n = (*(*lgl).c2rust_unnamed.swp).partitions;
    res = (count - n) as libc::c_double;
    res /= n as libc::c_double;
    return res;
}
unsafe extern "C" fn lgladdsweepbincls(
    mut lgl: *mut LGL,
    mut a: libc::c_int,
    mut b: libc::c_int,
) {
    lglpushstk(lgl, &mut (*lgl).clause, a);
    lglpushstk(lgl, &mut (*lgl).clause, b);
    lglpushstk(lgl, &mut (*lgl).clause, 0 as libc::c_int);
    lgldrupligaddcls(lgl, REDCS as libc::c_int);
    lgladdcls(lgl, REDCS as libc::c_int, 0 as libc::c_int, 1 as libc::c_int);
    lglclnstk(&mut (*lgl).clause);
}
unsafe extern "C" fn lglsweepsatinitlit(
    mut lgl: *mut LGL,
    mut lit: libc::c_int,
    mut a: libc::c_int,
    mut b: libc::c_int,
) {
    let mut idx: libc::c_int = abs(lit);
    let mut decision: libc::c_int = 0;
    let mut av: *mut AVar = 0 as *mut AVar;
    if a == idx {
        return;
    }
    if b == idx {
        return;
    }
    av = lglavar(lgl, idx);
    if (*av).mark != 0 {
        return;
    }
    (*av).mark = 1 as libc::c_int;
    if lgldefphase(lgl, idx) <= 0 as libc::c_int {
        decision = -idx;
    } else {
        decision = idx;
    }
    lglpushstk(lgl, &mut (*(*lgl).c2rust_unnamed.swp).decision.stk, decision);
}
unsafe extern "C" fn lglsweepsatinit(
    mut lgl: *mut LGL,
    mut a: libc::c_int,
    mut b: libc::c_int,
) {
    let mut i: libc::c_int = 0;
    let mut idx: libc::c_int = 0;
    let mut sign: libc::c_int = 0;
    let mut lit: libc::c_int = 0;
    let mut blit: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut red: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut other2: libc::c_int = 0;
    let mut lidx: libc::c_int = 0;
    let mut old: libc::c_int = 0;
    let mut count: libc::c_int = 0;
    let sweepred: libc::c_int = (*(*lgl).opts).sweepred.val;
    let sweepirr: libc::c_int = (*(*lgl).opts).sweepirr.val;
    let mut w: *const libc::c_int = 0 as *const libc::c_int;
    let mut eow: *const libc::c_int = 0 as *const libc::c_int;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut c: *const libc::c_int = 0 as *const libc::c_int;
    let mut l: *const libc::c_int = 0 as *const libc::c_int;
    let mut hts: *mut HTS = 0 as *mut HTS;
    a = abs(a);
    b = abs(b);
    if b > a {
        let mut TMP: libc::c_int = a;
        a = b;
        b = TMP;
    }
    if a == (*(*lgl).c2rust_unnamed.swp).decision.cached.a
        && b == (*(*lgl).c2rust_unnamed.swp).decision.cached.b
    {
        (*(*lgl).stats).sweep.cached += 1;
        (*(*lgl).stats).sweep.cached;
        count = lglcntstk(&mut (*(*lgl).c2rust_unnamed.swp).decision.stk) as libc::c_int;
    } else {
        lglclnstk(&mut (*(*lgl).c2rust_unnamed.swp).decision.stk);
        i = 0 as libc::c_int;
        while i <= 1 as libc::c_int {
            idx = if i != 0 { b } else { a };
            old = lglcntstk(&mut (*(*lgl).c2rust_unnamed.swp).decision.stk)
                as libc::c_int;
            sign = -(1 as libc::c_int);
            while sign <= 1 as libc::c_int {
                lit = sign * idx;
                hts = lglhts(lgl, lit);
                w = lglhts2wchs(lgl, hts);
                eow = w.offset((*hts).count as isize);
                p = w;
                while p < eow {
                    blit = *p;
                    tag = blit & MASKCS as libc::c_int;
                    if tag == TRNCS as libc::c_int || tag == LRGCS as libc::c_int {
                        p = p.offset(1);
                        p;
                    }
                    red = blit & REDCS as libc::c_int;
                    if tag == BINCS as libc::c_int {
                        if !(red == 0 && sweepirr < 1 as libc::c_int) {
                            if !(red != 0 && sweepred < 1 as libc::c_int) {
                                other = blit >> RMSHFT as libc::c_int;
                                lglsweepsatinitlit(lgl, other, a, b);
                            }
                        }
                    } else if tag == TRNCS as libc::c_int {
                        if !(red == 0 && sweepirr < 2 as libc::c_int) {
                            if !(red != 0 && sweepred < 2 as libc::c_int) {
                                other = blit >> RMSHFT as libc::c_int;
                                lglsweepsatinitlit(lgl, other, a, b);
                                other2 = *p;
                                lglsweepsatinitlit(lgl, other2, a, b);
                            }
                        }
                    } else if !(red == 0 && sweepirr < 3 as libc::c_int) {
                        if !(red != 0 && sweepred < 3 as libc::c_int) {
                            lidx = *p;
                            c = lglidx2lits(lgl, red, lidx);
                            l = c;
                            loop {
                                other = *l;
                                if !(other != 0) {
                                    break;
                                }
                                lglsweepsatinitlit(lgl, other, a, b);
                                l = l.offset(1);
                                l;
                            }
                        }
                    }
                    p = p.offset(1);
                    p;
                }
                sign += 2 as libc::c_int;
            }
            count = (lglcntstk(&mut (*(*lgl).c2rust_unnamed.swp).decision.stk))
                .wrapping_sub(old as size_t) as libc::c_int;
            i += 1;
            i;
        }
        p = (*(*lgl).c2rust_unnamed.swp).decision.stk.start;
        while p < (*(*lgl).c2rust_unnamed.swp).decision.stk.top as *const libc::c_int {
            (*lglavar(lgl, *p)).mark = 0 as libc::c_int;
            p = p.offset(1);
            p;
        }
        (*(*lgl).c2rust_unnamed.swp).decision.cached.a = a;
        (*(*lgl).c2rust_unnamed.swp).decision.cached.b = b;
        count = lglcntstk(&mut (*(*lgl).c2rust_unnamed.swp).decision.stk) as libc::c_int;
        let mut AA: *mut libc::c_int = (*(*lgl).c2rust_unnamed.swp).decision.stk.start;
        let NN: libc::c_int = count;
        let mut L: libc::c_int = 0 as libc::c_int;
        let mut R: libc::c_int = NN - 1 as libc::c_int;
        let mut M: libc::c_int = 0;
        let mut LL: libc::c_int = 0;
        let mut RR: libc::c_int = 0;
        let mut I: libc::c_int = 0;
        if !(R - L <= 10 as libc::c_int) {
            loop {
                M = (L + R) / 2 as libc::c_int;
                let mut TMP_0: libc::c_int = *AA.offset(M as isize);
                *AA.offset(M as isize) = *AA.offset((R - 1 as libc::c_int) as isize);
                *AA.offset((R - 1 as libc::c_int) as isize) = TMP_0;
                if lgldcmp(
                    lgl,
                    *AA.offset((R - 1 as libc::c_int) as isize),
                    *AA.offset(L as isize),
                ) > 0 as libc::c_int
                {
                    let mut TMP_1: libc::c_int = *AA.offset(L as isize);
                    *AA.offset(L as isize) = *AA.offset((R - 1 as libc::c_int) as isize);
                    *AA.offset((R - 1 as libc::c_int) as isize) = TMP_1;
                }
                if lgldcmp(lgl, *AA.offset(R as isize), *AA.offset(L as isize))
                    > 0 as libc::c_int
                {
                    let mut TMP_2: libc::c_int = *AA.offset(L as isize);
                    *AA.offset(L as isize) = *AA.offset(R as isize);
                    *AA.offset(R as isize) = TMP_2;
                }
                if lgldcmp(
                    lgl,
                    *AA.offset(R as isize),
                    *AA.offset((R - 1 as libc::c_int) as isize),
                ) > 0 as libc::c_int
                {
                    let mut TMP_3: libc::c_int = *AA
                        .offset((R - 1 as libc::c_int) as isize);
                    *AA.offset((R - 1 as libc::c_int) as isize) = *AA.offset(R as isize);
                    *AA.offset(R as isize) = TMP_3;
                }
                let mut PIVOT: libc::c_int = 0;
                let mut J: libc::c_int = R - 1 as libc::c_int;
                I = L + 1 as libc::c_int - 1 as libc::c_int;
                PIVOT = *AA.offset(J as isize);
                loop {
                    loop {
                        I += 1;
                        if !(lgldcmp(lgl, PIVOT, *AA.offset(I as isize))
                            < 0 as libc::c_int)
                        {
                            break;
                        }
                    }
                    loop {
                        J -= 1;
                        if !(lgldcmp(lgl, *AA.offset(J as isize), PIVOT)
                            < 0 as libc::c_int)
                        {
                            break;
                        }
                        if J == L + 1 as libc::c_int {
                            break;
                        }
                    }
                    if I >= J {
                        break;
                    }
                    let mut TMP_4: libc::c_int = *AA.offset(I as isize);
                    *AA.offset(I as isize) = *AA.offset(J as isize);
                    *AA.offset(J as isize) = TMP_4;
                }
                let mut TMP_5: libc::c_int = *AA.offset(I as isize);
                *AA.offset(I as isize) = *AA.offset((R - 1 as libc::c_int) as isize);
                *AA.offset((R - 1 as libc::c_int) as isize) = TMP_5;
                if I - L < R - I {
                    LL = I + 1 as libc::c_int;
                    RR = R;
                    R = I - 1 as libc::c_int;
                } else {
                    LL = L;
                    RR = I - 1 as libc::c_int;
                    L = I + 1 as libc::c_int;
                }
                if R - L > 10 as libc::c_int {
                    lglpushstk(lgl, &mut (*lgl).c2rust_unnamed_0.sortstk, LL);
                    lglpushstk(lgl, &mut (*lgl).c2rust_unnamed_0.sortstk, RR);
                } else if RR - LL > 10 as libc::c_int {
                    L = LL;
                    R = RR;
                } else {
                    if !(lglmtstk(&mut (*lgl).c2rust_unnamed_0.sortstk) == 0) {
                        break;
                    }
                    R = lglpopstk(&mut (*lgl).c2rust_unnamed_0.sortstk);
                    L = lglpopstk(&mut (*lgl).c2rust_unnamed_0.sortstk);
                }
            }
        }
        let mut PIVOT_0: libc::c_int = 0;
        let mut L_0: libc::c_int = 0 as libc::c_int;
        let mut R_0: libc::c_int = NN - 1 as libc::c_int;
        let mut I_0: libc::c_int = 0;
        let mut J_0: libc::c_int = 0;
        I_0 = R_0;
        while I_0 > L_0 {
            if lgldcmp(
                lgl,
                *AA.offset(I_0 as isize),
                *AA.offset((I_0 - 1 as libc::c_int) as isize),
            ) > 0 as libc::c_int
            {
                let mut TMP_6: libc::c_int = *AA
                    .offset((I_0 - 1 as libc::c_int) as isize);
                *AA.offset((I_0 - 1 as libc::c_int) as isize) = *AA.offset(I_0 as isize);
                *AA.offset(I_0 as isize) = TMP_6;
            }
            I_0 -= 1;
            I_0;
        }
        I_0 = L_0 + 2 as libc::c_int;
        while I_0 <= R_0 {
            J_0 = I_0;
            PIVOT_0 = *AA.offset(I_0 as isize);
            while lgldcmp(lgl, *AA.offset((J_0 - 1 as libc::c_int) as isize), PIVOT_0)
                < 0 as libc::c_int
            {
                *AA.offset(J_0 as isize) = *AA.offset((J_0 - 1 as libc::c_int) as isize);
                J_0 -= 1;
                J_0;
            }
            *AA.offset(J_0 as isize) = PIVOT_0;
            I_0 += 1;
            I_0;
        }
    }
    (*(*lgl).c2rust_unnamed.swp).sumsize.envs += count as int64_t;
    (*(*lgl).stats).sweep.sumsize.envs += count as int64_t;
}
unsafe extern "C" fn lglsweepdec(mut lgl: *mut LGL) -> libc::c_int {
    let mut i: libc::c_int = 0;
    let mut lit: libc::c_int = 0 as libc::c_int;
    i = 0 as libc::c_int;
    while i < lglcntstk(&mut (*(*lgl).c2rust_unnamed.swp).decision.stk) as libc::c_int {
        lit = lglpeek(&mut (*(*lgl).c2rust_unnamed.swp).decision.stk, i);
        if lglval(lgl, lit) == 0 {
            break;
        }
        i += 1;
        i;
    }
    if i == lglcntstk(&mut (*(*lgl).c2rust_unnamed.swp).decision.stk) as libc::c_int {
        return 0 as libc::c_int;
    }
    lgliassume(lgl, lit);
    (*(*lgl).c2rust_unnamed.swp).decision.count += 1;
    (*(*lgl).c2rust_unnamed.swp).decision.count;
    (*(*lgl).stats).sweep.decs += 1;
    (*(*lgl).stats).sweep.decs;
    return 1 as libc::c_int;
}
unsafe extern "C" fn lglsweepsat(
    mut lgl: *mut LGL,
    mut lim: libc::c_int,
    mut a: libc::c_int,
    mut b: libc::c_int,
) -> libc::c_int {
    let mut n: libc::c_int = 0 as libc::c_int;
    let mut aval: libc::c_int = 0;
    let mut bval: libc::c_int = 0;
    (*(*lgl).stats).sweep.sat += 1;
    (*(*lgl).stats).sweep.sat;
    (*(*lgl).c2rust_unnamed.swp).sat += 1;
    (*(*lgl).c2rust_unnamed.swp).sat;
    loop {
        if lglbcp(lgl) != 0 {
            if (*lgl).mt != 0 {
                return 0 as libc::c_int;
            }
            aval = lglval(lgl, a) as libc::c_int;
            if aval < 0 as libc::c_int {
                return 0 as libc::c_int;
            }
            bval = lglval(lgl, b) as libc::c_int;
            if bval > 0 as libc::c_int {
                return 0 as libc::c_int;
            }
            if aval == 0 {
                lgliassume(lgl, a);
                (*(*lgl).c2rust_unnamed.swp).decision.count += 1;
                (*(*lgl).c2rust_unnamed.swp).decision.count;
                (*(*lgl).stats).sweep.decs += 1;
                (*(*lgl).stats).sweep.decs;
            } else if bval == 0 {
                lgliassume(lgl, -b);
                (*(*lgl).c2rust_unnamed.swp).decision.count += 1;
                (*(*lgl).c2rust_unnamed.swp).decision.count;
                (*(*lgl).stats).sweep.decs += 1;
                (*(*lgl).stats).sweep.decs;
            } else {
                n += 1;
                if n > lim {
                    return 1 as libc::c_int;
                }
                if lglsweepdec(lgl) == 0 {
                    return 1 as libc::c_int;
                }
            }
        } else if lglana(lgl) == 0 {
            return 0 as libc::c_int
        }
    };
}
unsafe extern "C" fn lglsweepliesaux(
    mut lgl: *mut LGL,
    mut a: libc::c_int,
    mut b: libc::c_int,
) -> libc::c_int {
    let mut ok: libc::c_int = 0;
    let mut val: libc::c_int = 0;
    let mut res: libc::c_int = 0;
    let mut dec: libc::c_int = 0;
    if (*lgl).mt != 0 {
        return 0 as libc::c_int;
    }
    if lglifixed(lgl, a) != 0 {
        return 0 as libc::c_int;
    }
    if lglifixed(lgl, b) != 0 {
        return 0 as libc::c_int;
    }
    lgliassume(lgl, a);
    ok = lglbcp(lgl);
    if ok != 0 {
        val = lglval(lgl, b) as libc::c_int;
        if val > 0 as libc::c_int {
            lglbacktrack(lgl, 0 as libc::c_int);
            res = 1 as libc::c_int;
        } else if val < 0 as libc::c_int {
            res = 0 as libc::c_int;
        } else {
            lgliassume(lgl, -b);
            ok = lglbcp(lgl);
            if ok != 0 {
                dec = (*(*lgl).stats).sweep.count - 1 as libc::c_int;
                dec *= (*(*lgl).opts).sweepfacdec.val;
                if dec < (*(*lgl).opts).sweepmindec.val {
                    dec = (*(*lgl).opts).sweepmindec.val;
                }
                if dec > (*(*lgl).opts).sweepmaxdec.val {
                    dec = (*(*lgl).opts).sweepmaxdec.val;
                }
                if dec != 0 {
                    lglsweepsatinit(lgl, a, b);
                    ok = lglsweepsat(lgl, dec, a, b);
                    if ok != 0 {
                        res = 0 as libc::c_int;
                    } else {
                        (*(*lgl).stats).sweep.unsat += 1;
                        (*(*lgl).stats).sweep.unsat;
                        if (*lgl).level != 0 {
                            lglbacktrack(lgl, 0 as libc::c_int);
                        }
                        res = 1 as libc::c_int;
                    }
                } else {
                    res = 0 as libc::c_int;
                }
            } else {
                lglbacktrack(lgl, 0 as libc::c_int);
                lgladdsweepbincls(lgl, -a, b);
                (*(*lgl).stats).sweep.impls += 1;
                (*(*lgl).stats).sweep.impls;
                res = 1 as libc::c_int;
            }
        }
    } else {
        lglbacktrack(lgl, 0 as libc::c_int);
        (*(*lgl).stats).sweep.failed += 1;
        (*(*lgl).stats).sweep.failed;
        lglunit(lgl, -a);
        if lglbcp(lgl) == 0 {
            lglmt(lgl);
        }
        res = 0 as libc::c_int;
    }
    return res;
}
unsafe extern "C" fn lglsweeplies(
    mut lgl: *mut LGL,
    mut a: libc::c_int,
    mut b: libc::c_int,
) -> libc::c_int {
    let mut res: libc::c_int = lglsweepliesaux(lgl, a, b);
    if res == 0 {
        (*(*lgl).stats)
            .sweep
            .queries
            .type_0[(*(*lgl).c2rust_unnamed.swp).type_0 as usize]
            .sat += 1;
        (*(*lgl).stats)
            .sweep
            .queries
            .type_0[(*(*lgl).c2rust_unnamed.swp).type_0 as usize]
            .sat;
    } else {
        (*(*lgl).stats)
            .sweep
            .queries
            .type_0[(*(*lgl).c2rust_unnamed.swp).type_0 as usize]
            .unsat += 1;
        (*(*lgl).stats)
            .sweep
            .queries
            .type_0[(*(*lgl).c2rust_unnamed.swp).type_0 as usize]
            .unsat;
    }
    lglprt(
        lgl,
        2 as libc::c_int,
        b"[sweep-%d-%d-%d] implication check %s\0" as *const u8 as *const libc::c_char,
        (*(*lgl).stats).sweep.count,
        (*(*lgl).c2rust_unnamed.swp).round,
        (*(*lgl).c2rust_unnamed.swp).query,
        if res != 0 {
            b"succeeded\0" as *const u8 as *const libc::c_char
        } else {
            b"failed\0" as *const u8 as *const libc::c_char
        },
    );
    return res;
}
unsafe extern "C" fn lglsweepquery(mut lgl: *mut LGL) {
    let mut count: libc::c_int = lglcntstk(&mut (*(*lgl).c2rust_unnamed.swp).partition)
        as libc::c_int;
    let mut l: libc::c_int = 0;
    let mut r: libc::c_int = 0;
    let mut size: libc::c_int = 0;
    let mut p: libc::c_int = 0;
    let mut q: libc::c_int = 0;
    let mut a: libc::c_int = 0;
    let mut b: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut c: libc::c_int = 0;
    let mut newpartitions: libc::c_int = 0;
    let mut newsize: libc::c_int = 0;
    let mut newtotal: libc::c_int = 0;
    let mut total: libc::c_int = count - (*(*lgl).c2rust_unnamed.swp).partitions;
    let mut remove: libc::c_int = 0;
    let mut val: libc::c_int = 0;
    let mut partition: *mut libc::c_int = (*(*lgl).c2rust_unnamed.swp).partition.start;
    let mut minsize: libc::c_int = 0;
    let mut best: libc::c_int = 0;
    let mut start: libc::c_int = 0;
    let mut bestscore: libc::c_int = 0;
    let mut newpartition: Stk = Stk {
        start: 0 as *mut libc::c_int,
        top: 0 as *mut libc::c_int,
        end: 0 as *mut libc::c_int,
    };
    match (*(*lgl).c2rust_unnamed.swp).query % 5 as libc::c_int {
        1 => {
            (*(*lgl).c2rust_unnamed.swp).type_0 = 2 as libc::c_int;
        }
        2 => {
            (*(*lgl).c2rust_unnamed.swp).type_0 = 1 as libc::c_int;
        }
        3 => {
            (*(*lgl).c2rust_unnamed.swp).type_0 = 2 as libc::c_int;
        }
        4 => {
            (*(*lgl).c2rust_unnamed.swp).type_0 = 1 as libc::c_int;
        }
        0 => {
            (*(*lgl).c2rust_unnamed.swp).type_0 = 0 as libc::c_int;
        }
        _ => {}
    }
    (*(*lgl).stats).sweep.queries.total += 1;
    (*(*lgl).stats).sweep.queries.total;
    (*(*lgl).stats)
        .sweep
        .queries
        .type_0[(*(*lgl).c2rust_unnamed.swp).type_0 as usize]
        .count += 1;
    (*(*lgl).stats)
        .sweep
        .queries
        .type_0[(*(*lgl).c2rust_unnamed.swp).type_0 as usize]
        .count;
    lglprt(
        lgl,
        2 as libc::c_int,
        b"[sweep-%d-%d-%d] %d classes with %d vars of avg size %.1f\0" as *const u8
            as *const libc::c_char,
        (*(*lgl).stats).sweep.count,
        (*(*lgl).c2rust_unnamed.swp).round,
        (*(*lgl).c2rust_unnamed.swp).query,
        (*(*lgl).c2rust_unnamed.swp).partitions,
        total,
        lglsweepavgpartitionsize(lgl),
    );
    l = (lglrand(lgl)).wrapping_rem(count as libc::c_uint) as libc::c_int;
    if *partition.offset(l as isize) == 0 {
        l -= 1;
        l;
    }
    while l > 0 as libc::c_int && *partition.offset((l - 1 as libc::c_int) as isize) != 0
    {
        l -= 1;
        l;
    }
    if (*(*lgl).c2rust_unnamed.swp).type_0 == 1 as libc::c_int {
        (*(*lgl).stats).steps += 1;
        (*(*lgl).stats).steps;
        (*(*lgl).stats).sweep.steps += 1;
        (*(*lgl).stats).sweep.steps;
        start = l;
        best = start;
        minsize = 2147483647 as libc::c_int;
        loop {
            (*(*lgl).stats).steps += 1;
            (*(*lgl).stats).steps;
            (*(*lgl).stats).sweep.steps += 1;
            (*(*lgl).stats).sweep.steps;
            size = 0 as libc::c_int;
            r = l;
            loop {
                a = *partition.offset(r as isize);
                if !(a != 0) {
                    break;
                }
                if lglifixed(lgl, a) == 0 {} else {
                    fprintf(
                        stderr,
                        b"liblgl.a: %s:%d: %s: Coverage target `%s' reached.\0"
                            as *const u8 as *const libc::c_char,
                        (*::core::mem::transmute::<
                            &[u8; 14],
                            &[libc::c_char; 14],
                        >(b"lglsweepquery\0"))
                            .as_ptr(),
                        23185 as libc::c_int,
                        b"lglib.c\0" as *const u8 as *const libc::c_char,
                        b"lglifixed (lgl, a)\0" as *const u8 as *const libc::c_char,
                    );
                    if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
                        fprintf(
                            stderr,
                            b" (tid %d)\0" as *const u8 as *const libc::c_char,
                            (*lgl).tid,
                        );
                    }
                    fputc('\n' as i32, stderr);
                    fflush(stderr);
                    abort();
                }
                if !(lglifixed(lgl, a) != 0) {
                    size += 1;
                    size;
                }
                r += 1;
                r;
            }
            if size < minsize {
                best = l;
                minsize = size;
            }
            l = r + 1 as libc::c_int;
            if l == count {
                l = 0 as libc::c_int;
            }
            if !(l != start) {
                break;
            }
        }
        l = best;
    } else if (*(*lgl).c2rust_unnamed.swp).type_0 == 2 as libc::c_int {
        (*(*lgl).stats).steps += 1;
        (*(*lgl).stats).steps;
        (*(*lgl).stats).sweep.steps += 1;
        (*(*lgl).stats).sweep.steps;
        start = l;
        best = start;
        bestscore = 0 as libc::c_int;
        loop {
            (*(*lgl).stats).steps += 1;
            (*(*lgl).stats).steps;
            (*(*lgl).stats).sweep.steps += 1;
            (*(*lgl).stats).sweep.steps;
            r = l;
            loop {
                a = *partition.offset(r as isize);
                if !(a != 0) {
                    break;
                }
                if !(lglifixed(lgl, a) != 0) {
                    if !(bestscore != 0 && lgldcmp(lgl, a, bestscore) < 0 as libc::c_int)
                    {
                        best = l;
                        bestscore = a;
                    }
                }
                r += 1;
                r;
            }
            l = r + 1 as libc::c_int;
            if l == count {
                l = 0 as libc::c_int;
            }
            if !(l != start) {
                break;
            }
        }
        l = best;
    }
    (*(*lgl).stats).steps += 1;
    (*(*lgl).stats).steps;
    (*(*lgl).stats).sweep.steps += 1;
    (*(*lgl).stats).sweep.steps;
    r = l;
    while *partition.offset(r as isize) != 0 {
        r += 1;
        r;
    }
    size = r - l;
    (*(*lgl).c2rust_unnamed.swp).sumsize.classes += size as int64_t;
    (*(*lgl).stats).sweep.sumsize.classes += size as int64_t;
    lglprt(
        lgl,
        2 as libc::c_int,
        b"[sweep-%d-%d-%d] type %d picked size %d class [%d:%d] %.1f%%\0" as *const u8
            as *const libc::c_char,
        (*(*lgl).stats).sweep.count,
        (*(*lgl).c2rust_unnamed.swp).round,
        (*(*lgl).c2rust_unnamed.swp).query,
        (*(*lgl).c2rust_unnamed.swp).type_0,
        size,
        l,
        r - 1 as libc::c_int,
        lglpcnt(size as libc::c_double, total as libc::c_double),
    );
    p = (lglrand(lgl)).wrapping_rem(size as libc::c_uint) as libc::c_int;
    q = (lglrand(lgl)).wrapping_rem(size as libc::c_uint) as libc::c_int;
    if p == q {
        q = (p == 0) as libc::c_int;
    }
    if p + q >= size {
        q = p + q - size;
    }
    p += l;
    q += l;
    a = *partition.offset(p as isize);
    b = *partition.offset(q as isize);
    i = l;
    while i < r {
        if !(i == p) {
            if !(i == q) {
                c = *partition.offset(i as isize);
                if lgldcmp(lgl, c, a) > 0 as libc::c_int {
                    a = c;
                    p = i;
                }
            }
        }
        i += 1;
        i;
    }
    i = l;
    while i < r {
        if !(i == p) {
            if !(i == q) {
                c = *partition.offset(i as isize);
                if lgldcmp(lgl, c, b) > 0 as libc::c_int {
                    b = c;
                    q = i;
                }
            }
        }
        i += 1;
        i;
    }
    if lglsweeplies(lgl, a, b) != 0 && lglsweeplies(lgl, b, a) != 0 {
        (*(*lgl).stats).sweep.equivs += 1;
        (*(*lgl).stats).sweep.equivs;
        remove = b;
    } else {
        remove = 0 as libc::c_int;
    }
    memset(
        &mut newpartition as *mut Stk as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<Stk>() as libc::c_ulong,
    );
    newpartitions = 0 as libc::c_int;
    newsize = newpartitions;
    if (*lgl).mt == 0 {
        val = -(1 as libc::c_int);
        while val <= 1 as libc::c_int {
            i = 0 as libc::c_int;
            while i < count {
                c = *partition.offset(i as isize);
                if c != 0 {
                    if !(c == remove) {
                        if !(lglifixed(lgl, c) != 0) {
                            if !(lglval(lgl, c) as libc::c_int != val) {
                                lglpushstk(lgl, &mut newpartition, c);
                                newsize += 1;
                                newsize;
                            }
                        }
                    }
                } else if newsize > 1 as libc::c_int {
                    lglpushstk(lgl, &mut newpartition, 0 as libc::c_int);
                    newpartitions += 1;
                    newpartitions;
                    newsize = 0 as libc::c_int;
                } else if newsize != 0 {
                    lglpopstk(&mut newpartition);
                    newsize = 0 as libc::c_int;
                }
                i += 1;
                i;
            }
            val += 1;
            val;
        }
        (*(*lgl).stats).steps += (count >> 3 as libc::c_int) as int64_t;
        (*(*lgl).stats).sweep.steps += (count >> 3 as libc::c_int) as int64_t;
    }
    newtotal = (lglcntstk(&mut newpartition)).wrapping_sub(newpartitions as size_t)
        as libc::c_int;
    if (*lgl).level > 0 as libc::c_int {
        lglbacktrack(lgl, 0 as libc::c_int);
    }
    if (*(*lgl).c2rust_unnamed.swp).partitions >= newpartitions {
        lglprt(
            lgl,
            2 as libc::c_int,
            b"[sweep-%d-%d-%d] removed %d literals and removed %d classes\0" as *const u8
                as *const libc::c_char,
            (*(*lgl).stats).sweep.count,
            (*(*lgl).c2rust_unnamed.swp).round,
            (*(*lgl).c2rust_unnamed.swp).query,
            total - newtotal,
            (*(*lgl).c2rust_unnamed.swp).partitions - newpartitions,
        );
    } else {
        lglprt(
            lgl,
            2 as libc::c_int,
            b"[sweep-%d-%d-%d] removed %d literals and added %d classes\0" as *const u8
                as *const libc::c_char,
            (*(*lgl).stats).sweep.count,
            (*(*lgl).c2rust_unnamed.swp).round,
            (*(*lgl).c2rust_unnamed.swp).query,
            total - newtotal,
            newpartitions - (*(*lgl).c2rust_unnamed.swp).partitions,
        );
    }
    (*(*lgl).c2rust_unnamed.swp).partitions = newpartitions;
    lglfitstk(lgl, &mut newpartition);
    lglrelstk(lgl, &mut (*(*lgl).c2rust_unnamed.swp).partition);
    (*(*lgl).c2rust_unnamed.swp).partition = newpartition;
}
unsafe extern "C" fn lglsetsweeplim(mut lgl: *mut LGL) {
    let mut count: libc::c_int = (*(*lgl).stats).sweep.count
        - (*(*lgl).opts).sweepboostdel.val;
    let mut limit: int64_t = 0;
    let mut irrlim: int64_t = 0;
    let mut pen: libc::c_int = 0;
    let mut szpen: libc::c_int = 0;
    if (*(*lgl).opts).sweeprtc.val > 1 as libc::c_int {
        (*(*lgl).limits).sweep.steps = 0x7fffffffffffffff as libc::c_longlong as int64_t;
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[sweep-%d] really no limit (run to completion)\0" as *const u8
                as *const libc::c_char,
            (*(*lgl).stats).sweep.count,
        );
    } else if (*(*lgl).opts).sweeprtc.val != 0 || (*(*lgl).opts).prbrtc.val != 0
        || count > 0 as libc::c_int && lglrem(lgl) < (*(*lgl).opts).sweeprtcintvlim.val
            && count % (*(*lgl).opts).sweeprtcint.val == 0
    {
        limit = 4000000000 as libc::c_longlong as int64_t;
        (*(*lgl).limits).sweep.steps = (*(*lgl).stats).sweep.steps + limit;
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[sweep-%d] almost no limit of %lld steps\0" as *const u8
                as *const libc::c_char,
            (*(*lgl).stats).sweep.count,
            limit as libc::c_longlong,
        );
    } else {
        limit = (*(*lgl).opts).sweepreleff.val as int64_t * lglvisearch(lgl)
            / 1000 as libc::c_int as int64_t;
        if limit < (*(*lgl).opts).sweepmineff.val as int64_t {
            limit = (*(*lgl).opts).sweepmineff.val as int64_t;
        }
        if (*(*lgl).opts).sweepmaxeff.val >= 0 as libc::c_int
            && limit > (*(*lgl).opts).sweepmaxeff.val as int64_t
        {
            limit = (*(*lgl).opts).sweepmaxeff.val as int64_t;
        }
        if count > 0 as libc::c_int
            && (count <= 1 as libc::c_int
                || count % (*(*lgl).opts).sweepboostint.val == 0)
            && lglrem(lgl) < (*(*lgl).opts).sweepboostvlim.val
            && (*(*lgl).opts).boost.val != 0
            && (*(*lgl).opts).sweepboost.val > 1 as libc::c_int
        {
            lglprt(
                lgl,
                1 as libc::c_int,
                b"[sweep-%d] boosting sweeping limit by %d\0" as *const u8
                    as *const libc::c_char,
                (*(*lgl).stats).sweep.count,
                (*(*lgl).opts).sweepboost.val,
            );
            limit *= (*(*lgl).opts).sweepboost.val as int64_t;
        }
        szpen = lglszpen(lgl);
        pen = (*(*lgl).limits).sweep.pen + szpen;
        limit >>= pen;
        irrlim = (2 as libc::c_int * (*(*lgl).stats).irr.clauses.cur >> szpen)
            as int64_t;
        if (*(*lgl).opts).irrlim.val != 0 && limit < irrlim {
            limit = irrlim;
            lglprt(
                lgl,
                1 as libc::c_int,
                b"[sweep-%d] limit %lld based on %d irredundant clauses penalty %d\0"
                    as *const u8 as *const libc::c_char,
                (*(*lgl).stats).sweep.count,
                limit as libc::c_longlong,
                (*(*lgl).stats).irr.clauses.cur,
                szpen,
            );
        } else {
            lglprt(
                lgl,
                1 as libc::c_int,
                b"[sweep-%d] limit %lld penalty %d = %d + %d\0" as *const u8
                    as *const libc::c_char,
                (*(*lgl).stats).sweep.count,
                limit as libc::c_longlong,
                pen,
                (*(*lgl).limits).sweep.pen,
                szpen,
            );
        }
        (*(*lgl).limits).sweep.steps = (*(*lgl).stats).sweep.steps + limit;
    };
}
unsafe extern "C" fn lglsweepretain(mut lgl: *mut LGL) {
    let mut idx: libc::c_int = 0;
    let mut ret: libc::c_int = 0 as libc::c_int;
    let mut rem: libc::c_int = 0 as libc::c_int;
    let mut sum: libc::c_int = 0;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    idx = 2 as libc::c_int;
    while idx < (*lgl).nvars {
        let ref mut fresh281 = *lglavar(lgl, idx);
        (*fresh281).set_donotsweep(1 as libc::c_int as libc::c_uint);
        idx += 1;
        idx;
    }
    p = (*(*lgl).c2rust_unnamed.swp).partition.start;
    while p < (*(*lgl).c2rust_unnamed.swp).partition.top as *const libc::c_int {
        idx = *p;
        if !(idx == 0) {
            let ref mut fresh282 = *lglavar(lgl, idx);
            (*fresh282).set_donotsweep(0 as libc::c_int as libc::c_uint);
        }
        p = p.offset(1);
        p;
    }
    idx = 2 as libc::c_int;
    while idx < (*lgl).nvars {
        if !(lglisfree(lgl, idx) == 0) {
            if (*lglavar(lgl, idx)).donotsweep() != 0 {
                ret += 1;
                ret;
            } else {
                rem += 1;
                rem;
            }
        }
        idx += 1;
        idx;
    }
    if rem != 0 {
        sum = rem + ret;
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[sweep-%d-%d] %d variables remain %.0f%% (%d retained %.0f%%)\0"
                as *const u8 as *const libc::c_char,
            (*(*lgl).stats).sweep.count,
            (*(*lgl).c2rust_unnamed.swp).round,
            rem,
            lglpcnt(rem as libc::c_double, sum as libc::c_double),
            ret,
            lglpcnt(ret as libc::c_double, sum as libc::c_double),
        );
    } else {
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[sweep-%d-%d] fully completed sweeping round\0" as *const u8
                as *const libc::c_char,
            (*(*lgl).stats).sweep.count,
            (*(*lgl).c2rust_unnamed.swp).round,
        );
        idx = 2 as libc::c_int;
        while idx < (*lgl).nvars {
            let ref mut fresh283 = *lglavar(lgl, idx);
            (*fresh283).set_donotsweep(0 as libc::c_int as libc::c_uint);
            idx += 1;
            idx;
        }
        (*lgl).sweeprtc = 1 as libc::c_int as libc::c_char;
    };
}
unsafe extern "C" fn lglsweep(mut lgl: *mut LGL) -> libc::c_int {
    let mut deltarem: libc::c_int = 0;
    let mut deltafailed: libc::c_int = 0;
    let mut deltaimpls: libc::c_int = 0;
    let mut deltaequivs: libc::c_int = 0;
    let mut deltaorigrem: libc::c_int = 0;
    let mut round: libc::c_int = 0;
    let mut origrem: libc::c_int = 0;
    let mut oldrem: libc::c_int = 0;
    let mut oldfailed: libc::c_int = 0;
    let mut oldimpls: libc::c_int = 0;
    let mut oldequivs: libc::c_int = 0;
    let mut oldsteps: int64_t = 0;
    let mut deltasteps: int64_t = 0;
    let mut origqueries: int64_t = 0;
    let mut deltaqueries: int64_t = 0;
    let mut success: libc::c_int = 0;
    let mut forgive: libc::c_int = 0;
    lglstart(lgl, &mut (*(*lgl).times).sweep);
    if (*lgl).level > 0 as libc::c_int {
        lglbacktrack(lgl, 0 as libc::c_int);
    }
    (*lgl).sweeping = 1 as libc::c_int as libc::c_char;
    (*lgl).simp = (*lgl).sweeping;
    if !(lglbcp(lgl) == 0) {
        lglgc(lgl);
        if !((*lgl).mt != 0) {
            (*(*lgl).stats).sweep.count += 1;
            (*(*lgl).stats).sweep.count;
            lglsetsweeplim(lgl);
            origrem = lglrem(lgl);
            origqueries = (*(*lgl).stats).sweep.queries.total;
            round = 0 as libc::c_int;
            forgive = (*(*lgl).opts).sweepforgive.val;
            loop {
                round += 1;
                round;
                (*(*lgl).stats).sweep.rounds += 1;
                (*(*lgl).stats).sweep.rounds;
                oldrem = lglrem(lgl);
                oldfailed = (*(*lgl).stats).sweep.failed;
                oldimpls = (*(*lgl).stats).sweep.impls;
                oldequivs = (*(*lgl).stats).sweep.equivs;
                oldsteps = (*(*lgl).stats).sweep.steps;
                (*lgl)
                    .c2rust_unnamed
                    .swp = lglnew(
                    lgl,
                    (1 as libc::c_int as libc::c_ulong)
                        .wrapping_mul(::core::mem::size_of::<SWP>() as libc::c_ulong),
                ) as *mut SWP;
                (*(*lgl).c2rust_unnamed.swp).round = round;
                lglinitsweep(lgl);
                (*(*lgl).c2rust_unnamed.swp).query = 1 as libc::c_int;
                while (*lgl).mt == 0
                    && lglmtstk(&mut (*(*lgl).c2rust_unnamed.swp).partition) == 0
                    && (*(*lgl).stats).sweep.steps <= (*(*lgl).limits).sweep.steps
                {
                    lglsweepquery(lgl);
                    (*(*lgl).c2rust_unnamed.swp).query += 1;
                    (*(*lgl).c2rust_unnamed.swp).query;
                }
                deltasteps = (*(*lgl).stats).sweep.steps - oldsteps;
                lglprt(
                    lgl,
                    1 as libc::c_int,
                    b"[sweep-%d-%d] %lld steps %d queries %.2f avg class size\0"
                        as *const u8 as *const libc::c_char,
                    (*(*lgl).stats).sweep.count,
                    round,
                    deltasteps as libc::c_longlong,
                    (*(*lgl).c2rust_unnamed.swp).query,
                    lglavg(
                        (*(*lgl).c2rust_unnamed.swp).sumsize.classes as libc::c_double,
                        (*(*lgl).c2rust_unnamed.swp).query as libc::c_double,
                    ),
                );
                lglprt(
                    lgl,
                    1 as libc::c_int,
                    b"[sweep-%d-%d] %d decisions %d SAT calls %.2f avg env size\0"
                        as *const u8 as *const libc::c_char,
                    (*(*lgl).stats).sweep.count,
                    round,
                    (*(*lgl).c2rust_unnamed.swp).decision.count,
                    (*(*lgl).c2rust_unnamed.swp).sat,
                    lglavg(
                        (*(*lgl).c2rust_unnamed.swp).sumsize.envs as libc::c_double,
                        (*(*lgl).c2rust_unnamed.swp).sat as libc::c_double,
                    ),
                );
                lglrelstk(lgl, &mut (*(*lgl).c2rust_unnamed.swp).decision.stk);
                lglsweepretain(lgl);
                lglrelstk(lgl, &mut (*(*lgl).c2rust_unnamed.swp).partition);
                if (*lgl).mt == 0 {
                    lgldecomp(lgl);
                }
                lgldel(
                    lgl,
                    (*lgl).c2rust_unnamed.swp as *mut libc::c_void,
                    (1 as libc::c_int as libc::c_ulong)
                        .wrapping_mul(::core::mem::size_of::<SWP>() as libc::c_ulong),
                );
                (*lgl).c2rust_unnamed.swp = 0 as *mut SWP;
                (*lgl).c2rust_unnamed.swp = 0 as *mut SWP;
                deltarem = oldrem - lglrem(lgl);
                deltafailed = (*(*lgl).stats).sweep.failed - oldfailed;
                deltaimpls = (*(*lgl).stats).sweep.impls - oldimpls;
                deltaequivs = (*(*lgl).stats).sweep.equivs - oldequivs;
                lglprt(
                    lgl,
                    1 as libc::c_int,
                    b"[sweep-%d-%d] removed %d vars (%d failed, %d eqs, %d impls)\0"
                        as *const u8 as *const libc::c_char,
                    (*(*lgl).stats).sweep.count,
                    round,
                    deltarem,
                    deltafailed,
                    deltaequivs,
                    deltaimpls,
                );
                if !((deltarem != 0 || forgive > 0 as libc::c_int) && (*lgl).mt == 0
                    && ((*(*lgl).opts).sweepmaxround.val < 0 as libc::c_int
                        || round < (*(*lgl).opts).sweepmaxround.val)
                    && (*(*lgl).stats).sweep.steps <= (*(*lgl).limits).sweep.steps)
                {
                    break;
                }
                if deltarem != 0 {
                    forgive = (*(*lgl).opts).sweepforgive.val;
                } else {
                    forgive -= 1;
                    forgive;
                }
            }
            deltaorigrem = origrem - lglrem(lgl);
            if (*lgl).sweeprtc == 0
                && (*(*lgl).stats).sweep.count <= (*(*lgl).opts).sweepsuccessmaxwortc.val
            {
                success = 1 as libc::c_int;
                lglprt(
                    lgl,
                    1 as libc::c_int,
                    b"[sweep-%d] considered successful since not run to completion yet\0"
                        as *const u8 as *const libc::c_char,
                    (*(*lgl).stats).sweep.count,
                );
            } else if deltaorigrem != 0 {
                success = (origrem / (*(*lgl).opts).sweepsuccessrat.val <= deltaorigrem)
                    as libc::c_int;
                if success == 0 {
                    lglprt(
                        lgl,
                        1 as libc::c_int,
                        b"[sweep-%d] %d < 1/%d * %d = %d considered unsuccessful\0"
                            as *const u8 as *const libc::c_char,
                        (*(*lgl).stats).sweep.count,
                        deltaorigrem,
                        (*(*lgl).opts).sweepsuccessrat.val,
                        origrem,
                        origrem / (*(*lgl).opts).sweepsuccessrat.val,
                    );
                }
            } else {
                success = 0 as libc::c_int;
            }
            if success != 0 && (*(*lgl).limits).sweep.pen != 0 {
                (*(*lgl).limits).sweep.pen -= 1;
                (*(*lgl).limits).sweep.pen;
            }
            if success == 0 && (*(*lgl).limits).sweep.pen < (*(*lgl).opts).penmax.val {
                (*(*lgl).limits).sweep.pen += 1;
                (*(*lgl).limits).sweep.pen;
            }
            if success != 0 && (*(*lgl).limits).sweep.del.cur != 0 {
                (*(*lgl).limits).sweep.del.cur /= 2 as libc::c_int;
            }
            if success == 0 && (*(*lgl).limits).sweep.del.cur < (*(*lgl).opts).delmax.val
            {
                (*(*lgl).limits).sweep.del.cur += 1;
                (*(*lgl).limits).sweep.del.cur;
            }
            (*(*lgl).limits).sweep.del.rem = (*(*lgl).limits).sweep.del.cur;
            deltaqueries = (*(*lgl).stats).sweep.queries.total - origqueries;
            lglprt(
                lgl,
                1 as libc::c_int,
                b"[sweep-%d] removed %d vars in TOTAL (%d rounds, %lld queries)\0"
                    as *const u8 as *const libc::c_char,
                (*(*lgl).stats).sweep.count,
                deltaorigrem,
                round,
                deltaqueries as libc::c_longlong,
            );
        }
    }
    (*lgl).sweeping = 0 as libc::c_int as libc::c_char;
    (*lgl).simp = (*lgl).sweeping;
    lglstop(lgl);
    return ((*lgl).mt == 0) as libc::c_int;
}
unsafe extern "C" fn lglqcmp(
    mut lgl: *mut LGL,
    mut a: libc::c_int,
    mut b: libc::c_int,
) -> libc::c_int {
    let mut ascore: Flt = 0;
    let mut bscore: Flt = 0;
    let mut pos: Flt = 0;
    let mut neg: Flt = 0;
    let mut p: *mut QVar = lglqvar(lgl, a);
    let mut q: *mut QVar = lglqvar(lgl, b);
    if (*p).important() == 0 && (*q).important() as libc::c_int != 0 {
        return -(1 as libc::c_int);
    }
    if (*p).important() as libc::c_int != 0 && (*q).important() == 0 {
        return 1 as libc::c_int;
    }
    pos = *((*lgl).jwh).offset(lglulit(a) as isize);
    neg = *((*lgl).jwh).offset(lglulit(-a) as isize);
    ascore = lglmulflt(pos, neg);
    pos = *((*lgl).jwh).offset(lglulit(b) as isize);
    neg = *((*lgl).jwh).offset(lglulit(-b) as isize);
    bscore = lglmulflt(pos, neg);
    if ascore < bscore {
        return -(1 as libc::c_int);
    }
    if ascore > bscore {
        return 1 as libc::c_int;
    }
    return a - b;
}
unsafe extern "C" fn lglqueuesort(mut lgl: *mut LGL) {
    let mut count: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut lit: libc::c_int = 0;
    let mut qv: *mut QVar = 0 as *mut QVar;
    lglstart(lgl, &mut (*(*lgl).times).queuesort);
    if (*lgl).queue.mt != 0 {
        lglqueueflush(lgl);
    }
    (*(*lgl).stats).queue.sorted += 1;
    (*(*lgl).stats).queue.sorted;
    count = lglcntstk(&mut (*lgl).queue.stk) as libc::c_int;
    let mut AA: *mut libc::c_int = (*lgl).queue.stk.start;
    let NN: libc::c_int = count;
    let mut L: libc::c_int = 0 as libc::c_int;
    let mut R: libc::c_int = NN - 1 as libc::c_int;
    let mut M: libc::c_int = 0;
    let mut LL: libc::c_int = 0;
    let mut RR: libc::c_int = 0;
    let mut I: libc::c_int = 0;
    if !(R - L <= 10 as libc::c_int) {
        loop {
            M = (L + R) / 2 as libc::c_int;
            let mut TMP: libc::c_int = *AA.offset(M as isize);
            *AA.offset(M as isize) = *AA.offset((R - 1 as libc::c_int) as isize);
            *AA.offset((R - 1 as libc::c_int) as isize) = TMP;
            if lglqcmp(
                lgl,
                *AA.offset(L as isize),
                *AA.offset((R - 1 as libc::c_int) as isize),
            ) > 0 as libc::c_int
            {
                let mut TMP_0: libc::c_int = *AA.offset(L as isize);
                *AA.offset(L as isize) = *AA.offset((R - 1 as libc::c_int) as isize);
                *AA.offset((R - 1 as libc::c_int) as isize) = TMP_0;
            }
            if lglqcmp(lgl, *AA.offset(L as isize), *AA.offset(R as isize))
                > 0 as libc::c_int
            {
                let mut TMP_1: libc::c_int = *AA.offset(L as isize);
                *AA.offset(L as isize) = *AA.offset(R as isize);
                *AA.offset(R as isize) = TMP_1;
            }
            if lglqcmp(
                lgl,
                *AA.offset((R - 1 as libc::c_int) as isize),
                *AA.offset(R as isize),
            ) > 0 as libc::c_int
            {
                let mut TMP_2: libc::c_int = *AA.offset((R - 1 as libc::c_int) as isize);
                *AA.offset((R - 1 as libc::c_int) as isize) = *AA.offset(R as isize);
                *AA.offset(R as isize) = TMP_2;
            }
            let mut PIVOT: libc::c_int = 0;
            let mut J: libc::c_int = R - 1 as libc::c_int;
            I = L + 1 as libc::c_int - 1 as libc::c_int;
            PIVOT = *AA.offset(J as isize);
            loop {
                loop {
                    I += 1;
                    if !(lglqcmp(lgl, *AA.offset(I as isize), PIVOT) < 0 as libc::c_int)
                    {
                        break;
                    }
                }
                loop {
                    J -= 1;
                    if !(lglqcmp(lgl, PIVOT, *AA.offset(J as isize)) < 0 as libc::c_int)
                    {
                        break;
                    }
                    if J == L + 1 as libc::c_int {
                        break;
                    }
                }
                if I >= J {
                    break;
                }
                let mut TMP_3: libc::c_int = *AA.offset(I as isize);
                *AA.offset(I as isize) = *AA.offset(J as isize);
                *AA.offset(J as isize) = TMP_3;
            }
            let mut TMP_4: libc::c_int = *AA.offset(I as isize);
            *AA.offset(I as isize) = *AA.offset((R - 1 as libc::c_int) as isize);
            *AA.offset((R - 1 as libc::c_int) as isize) = TMP_4;
            if I - L < R - I {
                LL = I + 1 as libc::c_int;
                RR = R;
                R = I - 1 as libc::c_int;
            } else {
                LL = L;
                RR = I - 1 as libc::c_int;
                L = I + 1 as libc::c_int;
            }
            if R - L > 10 as libc::c_int {
                lglpushstk(lgl, &mut (*lgl).c2rust_unnamed_0.sortstk, LL);
                lglpushstk(lgl, &mut (*lgl).c2rust_unnamed_0.sortstk, RR);
            } else if RR - LL > 10 as libc::c_int {
                L = LL;
                R = RR;
            } else {
                if !(lglmtstk(&mut (*lgl).c2rust_unnamed_0.sortstk) == 0) {
                    break;
                }
                R = lglpopstk(&mut (*lgl).c2rust_unnamed_0.sortstk);
                L = lglpopstk(&mut (*lgl).c2rust_unnamed_0.sortstk);
            }
        }
    }
    let mut PIVOT_0: libc::c_int = 0;
    let mut L_0: libc::c_int = 0 as libc::c_int;
    let mut R_0: libc::c_int = NN - 1 as libc::c_int;
    let mut I_0: libc::c_int = 0;
    let mut J_0: libc::c_int = 0;
    I_0 = R_0;
    while I_0 > L_0 {
        if lglqcmp(
            lgl,
            *AA.offset((I_0 - 1 as libc::c_int) as isize),
            *AA.offset(I_0 as isize),
        ) > 0 as libc::c_int
        {
            let mut TMP_5: libc::c_int = *AA.offset((I_0 - 1 as libc::c_int) as isize);
            *AA.offset((I_0 - 1 as libc::c_int) as isize) = *AA.offset(I_0 as isize);
            *AA.offset(I_0 as isize) = TMP_5;
        }
        I_0 -= 1;
        I_0;
    }
    I_0 = L_0 + 2 as libc::c_int;
    while I_0 <= R_0 {
        J_0 = I_0;
        PIVOT_0 = *AA.offset(I_0 as isize);
        while lglqcmp(lgl, PIVOT_0, *AA.offset((J_0 - 1 as libc::c_int) as isize))
            < 0 as libc::c_int
        {
            *AA.offset(J_0 as isize) = *AA.offset((J_0 - 1 as libc::c_int) as isize);
            J_0 -= 1;
            J_0;
        }
        *AA.offset(J_0 as isize) = PIVOT_0;
        I_0 += 1;
        I_0;
    }
    i = 0 as libc::c_int;
    while i < count {
        lit = lglpeek(&mut (*lgl).queue.stk, i);
        qv = lglqvar(lgl, lit);
        (*qv).pos = i;
        i += 1;
        i;
    }
    lglprt(
        lgl,
        2 as libc::c_int,
        b"[sort-queue-%d] sorted %d after %lld conflicts and %lld flushed queues\0"
            as *const u8 as *const libc::c_char,
        (*(*lgl).stats).queue.sorted as libc::c_longlong,
        count,
        (*(*lgl).stats).confs as libc::c_longlong,
        (*(*lgl).stats).queue.flushed as libc::c_longlong,
    );
    (*lgl).queue.next = count - 1 as libc::c_int;
    lglstop(lgl);
}
unsafe extern "C" fn lglqueuesorting(mut lgl: *mut LGL) -> libc::c_int {
    let mut count: libc::c_int = lglcntstk(&mut (*lgl).queue.stk) as libc::c_int;
    if (*lgl).queue.mt >= count {
        return 0 as libc::c_int;
    }
    return (*(*lgl).opts).queuesort.val;
}
unsafe extern "C" fn lglshowscoredist(mut lgl: *mut LGL) {
    let mut idx: libc::c_int = 0;
    let mut pos: libc::c_int = 0 as libc::c_int;
    let mut zero: libc::c_int = 0 as libc::c_int;
    let mut min: libc::c_int = 0 as libc::c_int;
    let mut sum: libc::c_int = 0 as libc::c_int;
    let mut diff: libc::c_int = 0;
    let mut scores: *mut Flt = 0 as *mut Flt;
    let mut q: *mut QVar = 0 as *mut QVar;
    lglstart(lgl, &mut (*(*lgl).times).showscoredist);
    scores = lglnew(
        lgl,
        ((*lgl).nvars as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Flt>() as libc::c_ulong),
    ) as *mut Flt;
    idx = 2 as libc::c_int;
    while idx < (*lgl).nvars {
        if !(lglisfree(lgl, idx) == 0) {
            q = lglqvar(lgl, idx);
            if (*q).score as libc::c_longlong == 0 as libc::c_longlong {
                zero += 1;
                zero;
            } else if (*q).score <= (*lgl).minscore {
                min += 1;
                min;
            } else {
                pos += 1;
                pos;
            }
            let fresh284 = sum;
            sum = sum + 1;
            *scores.offset(fresh284 as isize) = (*q).score;
        }
        idx += 1;
        idx;
    }
    lglprt(
        lgl,
        1 as libc::c_int,
        b"[score-distribution-%d] %d pos %.2f%%, %d min %.2f%%, %d zero %.2f%%\0"
            as *const u8 as *const libc::c_char,
        (*(*lgl).stats).simp.count,
        pos,
        lglpcnt(pos as libc::c_double, sum as libc::c_double),
        min,
        lglpcnt(min as libc::c_double, sum as libc::c_double),
        zero,
        lglpcnt(zero as libc::c_double, sum as libc::c_double),
    );
    let mut AA: *mut Flt = scores;
    let NN: libc::c_int = sum;
    let mut L: libc::c_int = 0 as libc::c_int;
    let mut R: libc::c_int = NN - 1 as libc::c_int;
    let mut M: libc::c_int = 0;
    let mut LL: libc::c_int = 0;
    let mut RR: libc::c_int = 0;
    let mut I: libc::c_int = 0;
    if !(R - L <= 10 as libc::c_int) {
        loop {
            M = (L + R) / 2 as libc::c_int;
            let mut TMP: Flt = *AA.offset(M as isize);
            *AA.offset(M as isize) = *AA.offset((R - 1 as libc::c_int) as isize);
            *AA.offset((R - 1 as libc::c_int) as isize) = TMP;
            if lglscrcmp(
                lgl,
                *AA.offset(L as isize),
                *AA.offset((R - 1 as libc::c_int) as isize),
            ) > 0 as libc::c_int
            {
                let mut TMP_0: Flt = *AA.offset(L as isize);
                *AA.offset(L as isize) = *AA.offset((R - 1 as libc::c_int) as isize);
                *AA.offset((R - 1 as libc::c_int) as isize) = TMP_0;
            }
            if lglscrcmp(lgl, *AA.offset(L as isize), *AA.offset(R as isize))
                > 0 as libc::c_int
            {
                let mut TMP_1: Flt = *AA.offset(L as isize);
                *AA.offset(L as isize) = *AA.offset(R as isize);
                *AA.offset(R as isize) = TMP_1;
            }
            if lglscrcmp(
                lgl,
                *AA.offset((R - 1 as libc::c_int) as isize),
                *AA.offset(R as isize),
            ) > 0 as libc::c_int
            {
                let mut TMP_2: Flt = *AA.offset((R - 1 as libc::c_int) as isize);
                *AA.offset((R - 1 as libc::c_int) as isize) = *AA.offset(R as isize);
                *AA.offset(R as isize) = TMP_2;
            }
            let mut PIVOT: Flt = 0;
            let mut J: libc::c_int = R - 1 as libc::c_int;
            I = L + 1 as libc::c_int - 1 as libc::c_int;
            PIVOT = *AA.offset(J as isize);
            loop {
                loop {
                    I += 1;
                    if !(lglscrcmp(lgl, *AA.offset(I as isize), PIVOT)
                        < 0 as libc::c_int)
                    {
                        break;
                    }
                }
                loop {
                    J -= 1;
                    if !(lglscrcmp(lgl, PIVOT, *AA.offset(J as isize))
                        < 0 as libc::c_int)
                    {
                        break;
                    }
                    if J == L + 1 as libc::c_int {
                        break;
                    }
                }
                if I >= J {
                    break;
                }
                let mut TMP_3: Flt = *AA.offset(I as isize);
                *AA.offset(I as isize) = *AA.offset(J as isize);
                *AA.offset(J as isize) = TMP_3;
            }
            let mut TMP_4: Flt = *AA.offset(I as isize);
            *AA.offset(I as isize) = *AA.offset((R - 1 as libc::c_int) as isize);
            *AA.offset((R - 1 as libc::c_int) as isize) = TMP_4;
            if I - L < R - I {
                LL = I + 1 as libc::c_int;
                RR = R;
                R = I - 1 as libc::c_int;
            } else {
                LL = L;
                RR = I - 1 as libc::c_int;
                L = I + 1 as libc::c_int;
            }
            if R - L > 10 as libc::c_int {
                lglpushstk(lgl, &mut (*lgl).c2rust_unnamed_0.sortstk, LL);
                lglpushstk(lgl, &mut (*lgl).c2rust_unnamed_0.sortstk, RR);
            } else if RR - LL > 10 as libc::c_int {
                L = LL;
                R = RR;
            } else {
                if !(lglmtstk(&mut (*lgl).c2rust_unnamed_0.sortstk) == 0) {
                    break;
                }
                R = lglpopstk(&mut (*lgl).c2rust_unnamed_0.sortstk);
                L = lglpopstk(&mut (*lgl).c2rust_unnamed_0.sortstk);
            }
        }
    }
    let mut PIVOT_0: Flt = 0;
    let mut L_0: libc::c_int = 0 as libc::c_int;
    let mut R_0: libc::c_int = NN - 1 as libc::c_int;
    let mut I_0: libc::c_int = 0;
    let mut J_0: libc::c_int = 0;
    I_0 = R_0;
    while I_0 > L_0 {
        if lglscrcmp(
            lgl,
            *AA.offset((I_0 - 1 as libc::c_int) as isize),
            *AA.offset(I_0 as isize),
        ) > 0 as libc::c_int
        {
            let mut TMP_5: Flt = *AA.offset((I_0 - 1 as libc::c_int) as isize);
            *AA.offset((I_0 - 1 as libc::c_int) as isize) = *AA.offset(I_0 as isize);
            *AA.offset(I_0 as isize) = TMP_5;
        }
        I_0 -= 1;
        I_0;
    }
    I_0 = L_0 + 2 as libc::c_int;
    while I_0 <= R_0 {
        J_0 = I_0;
        PIVOT_0 = *AA.offset(I_0 as isize);
        while lglscrcmp(lgl, PIVOT_0, *AA.offset((J_0 - 1 as libc::c_int) as isize))
            < 0 as libc::c_int
        {
            *AA.offset(J_0 as isize) = *AA.offset((J_0 - 1 as libc::c_int) as isize);
            J_0 -= 1;
            J_0;
        }
        *AA.offset(J_0 as isize) = PIVOT_0;
        I_0 += 1;
        I_0;
    }
    diff = 0 as libc::c_int;
    idx = 0 as libc::c_int;
    while idx < sum {
        if idx == 0
            || lglscrcmp(
                lgl,
                *scores.offset((idx - 1 as libc::c_int) as isize),
                *scores.offset(idx as isize),
            ) != 0
        {
            diff += 1;
            diff;
        }
        idx += 1;
        idx;
    }
    lgldel(
        lgl,
        scores as *mut libc::c_void,
        ((*lgl).nvars as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Flt>() as libc::c_ulong),
    );
    scores = 0 as *mut Flt;
    lglprt(
        lgl,
        1 as libc::c_int,
        b"[score-distribution-%d] %d different %.2f%% out of total %d variables\0"
            as *const u8 as *const libc::c_char,
        (*(*lgl).stats).simp.count,
        diff,
        lglpcnt(diff as libc::c_double, sum as libc::c_double),
        sum,
    );
    lglstop(lgl);
}
unsafe extern "C" fn lglfeatures(mut lgl: *mut LGL) -> Features {
    let mut idx: libc::c_int = 0;
    let mut sign: libc::c_int = 0;
    let mut lit: libc::c_int = 0;
    let mut blit: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut red: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut other1: libc::c_int = 0;
    let mut len: libc::c_int = 0;
    let mut lrg: libc::c_int = 0;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut w: *const libc::c_int = 0 as *const libc::c_int;
    let mut eow: *const libc::c_int = 0 as *const libc::c_int;
    let mut c: *const libc::c_int = 0 as *const libc::c_int;
    let mut hts: *mut HTS = 0 as *mut HTS;
    let mut res: Features = Features {
        n: 0,
        s: 0,
        vo: 0,
        vc: 0,
        co: 0,
        cc: 0,
        b: 0,
        t: 0,
        q: 0,
        c1: 0,
        c2: 0,
        c3: 0,
        c4: 0,
        x: 0,
        a1: 0,
        a2: 0,
        g: 0,
        j: 0,
        c: 0,
        o: 0,
    };
    memset(
        &mut res as *mut Features as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<Features>() as libc::c_ulong,
    );
    res.n = (*(*lgl).stats).features;
    res.s = lglsec(lgl) as libc::c_int;
    res.vo = (*(*lgl).limits).inc.vars.start;
    res.vc = lglrem(lgl);
    res.co = (*(*lgl).limits).inc.clauses.start;
    res.cc = (*(*lgl).stats).irr.clauses.cur;
    res.x = (*(*lgl).stats).gauss.extracted.last as libc::c_int;
    res.a1 = (*(*lgl).stats).card.found.am1.last.cnt;
    res.a2 = (*(*lgl).stats).card.found.am2.last.cnt;
    res.c = ((*(*lgl).stats).confs / 1000 as libc::c_int as int64_t) as libc::c_int;
    res.o = ((*(*lgl).stats).otfs.total / 1000 as libc::c_int as int64_t) as libc::c_int;
    res.g = ((*(*lgl).stats).glue.slow.val >> 32 as libc::c_int) as libc::c_int;
    res.j = ((*(*lgl).stats).jlevel.slow.val >> 32 as libc::c_int) as libc::c_int;
    idx = 2 as libc::c_int;
    while idx < (*lgl).nvars {
        sign = -(1 as libc::c_int);
        while sign <= 1 as libc::c_int {
            lit = sign * idx;
            hts = lglhts(lgl, lit);
            w = lglhts2wchs(lgl, hts);
            eow = w.offset((*hts).count as isize);
            p = w;
            while p < eow {
                blit = *p;
                tag = blit & MASKCS as libc::c_int;
                red = blit & REDCS as libc::c_int;
                if tag == TRNCS as libc::c_int || tag == LRGCS as libc::c_int {
                    p = p.offset(1);
                    p;
                }
                if !(red != 0 || tag == LRGCS as libc::c_int) {
                    other = blit >> RMSHFT as libc::c_int;
                    if !(abs(other) < idx) {
                        if tag == BINCS as libc::c_int {
                            res.b += 1;
                            res.b;
                        } else {
                            other1 = *p;
                            if !(abs(other1) < idx) {
                                res.t += 1;
                                res.t;
                            }
                        }
                    }
                }
                p = p.offset(1);
                p;
            }
            sign += 2 as libc::c_int;
        }
        idx += 1;
        idx;
    }
    lrg = 0 as libc::c_int;
    c = (*lgl).irr.start;
    while c < (*lgl).irr.top as *const libc::c_int {
        p = c;
        if !(*p >= 2147483647 as libc::c_int) {
            loop {
                p = p.offset(1);
                if !(*p != 0) {
                    break;
                }
            }
            len = p.offset_from(c) as libc::c_long as libc::c_int;
            if len <= 4 as libc::c_int {
                res.q += 1;
                res.q;
            } else if len <= 10 as libc::c_int {
                res.c1 += 1;
                res.c1;
            } else if len <= 100 as libc::c_int {
                res.c2 += 1;
                res.c2;
            } else if len <= 1000 as libc::c_int {
                res.c3 += 1;
                res.c3;
            } else if len <= 10000 as libc::c_int {
                res.c4 += 1;
                res.c4;
            } else {
                lrg += 1;
                lrg;
            }
        }
        c = p.offset(1 as libc::c_int as isize);
    }
    return res;
}
unsafe extern "C" fn lglintstrlen(mut i: libc::c_int) -> libc::c_int {
    if i < 10 as libc::c_int {
        return 1 as libc::c_int;
    }
    if i < 100 as libc::c_int {
        return 2 as libc::c_int;
    }
    if i < 1000 as libc::c_int {
        return 3 as libc::c_int;
    }
    if i < 10000 as libc::c_int {
        return 4 as libc::c_int;
    }
    if i < 100000 as libc::c_int {
        return 5 as libc::c_int;
    }
    if i < 1000000 as libc::c_int {
        return 6 as libc::c_int;
    }
    if i < 10000000 as libc::c_int {
        return 7 as libc::c_int;
    }
    if i < 100000000 as libc::c_int {
        return 8 as libc::c_int;
    }
    if i < 1000000000 as libc::c_int {
        return 9 as libc::c_int;
    }
    return 10 as libc::c_int;
}
unsafe extern "C" fn lglshowfeatures(mut lgl: *mut LGL) {
    let mut size: [libc::c_int; 20] = [0; 20];
    let mut i: libc::c_int = 0;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut fmt: [libc::c_char; 20] = [0; 20];
    let mut f: Features = Features {
        n: 0,
        s: 0,
        vo: 0,
        vc: 0,
        co: 0,
        cc: 0,
        b: 0,
        t: 0,
        q: 0,
        c1: 0,
        c2: 0,
        c3: 0,
        c4: 0,
        x: 0,
        a1: 0,
        a2: 0,
        g: 0,
        j: 0,
        c: 0,
        o: 0,
    };
    if (*(*lgl).opts).features.val == 0 {
        return;
    }
    if (*(*lgl).opts).verbose.val <= 0 as libc::c_int {
        return;
    }
    if (*(*lgl).stats).features >= (*(*lgl).opts).features.val {
        return;
    }
    lglstart(lgl, &mut (*(*lgl).times).showfeatures);
    f = lglfeatures(lgl);
    p = &mut f as *mut Features as *mut libc::c_int;
    i = 0 as libc::c_int;
    while i
        < (::core::mem::size_of::<Features>() as libc::c_ulong)
            .wrapping_div(::core::mem::size_of::<libc::c_int>() as libc::c_ulong)
            as libc::c_int
    {
        size[i
            as usize] = lglmax(
            strlen(featurenames[i as usize]) as libc::c_int,
            lglintstrlen(*p.offset(i as isize)),
        );
        i += 1;
        i;
    }
    lglmsgstart(lgl, 0 as libc::c_int);
    fprintf((*lgl).out, b"[heatures-%d]\0" as *const u8 as *const libc::c_char, f.n);
    i = 0 as libc::c_int;
    while i
        < (::core::mem::size_of::<Features>() as libc::c_ulong)
            .wrapping_div(::core::mem::size_of::<libc::c_int>() as libc::c_ulong)
            as libc::c_int
    {
        sprintf(
            fmt.as_mut_ptr(),
            b" %%%ds\0" as *const u8 as *const libc::c_char,
            size[i as usize],
        );
        fprintf((*lgl).out, fmt.as_mut_ptr(), featurenames[i as usize]);
        i += 1;
        i;
    }
    lglmsgend(lgl);
    lglmsgstart(lgl, 0 as libc::c_int);
    fprintf((*lgl).out, b"[features-%d]\0" as *const u8 as *const libc::c_char, f.n);
    i = 0 as libc::c_int;
    while i
        < (::core::mem::size_of::<Features>() as libc::c_ulong)
            .wrapping_div(::core::mem::size_of::<libc::c_int>() as libc::c_ulong)
            as libc::c_int
    {
        sprintf(
            fmt.as_mut_ptr(),
            b" %%%dd\0" as *const u8 as *const libc::c_char,
            size[i as usize],
        );
        fprintf((*lgl).out, fmt.as_mut_ptr(), *p.offset(i as isize));
        i += 1;
        i;
    }
    lglmsgend(lgl);
    (*(*lgl).stats).features += 1;
    (*(*lgl).stats).features;
    lglstop(lgl);
}
unsafe extern "C" fn lglisimp(mut lgl: *mut LGL) -> libc::c_int {
    if (*(*lgl).opts).simplify.val == 0 {
        return 1 as libc::c_int;
    }
    if lglquatresolving(lgl) != 0 {
        lglquatres(lgl);
    }
    if lglterminate(lgl) != 0 {
        return 1 as libc::c_int;
    }
    if lglternresolving(lgl) != 0 && lglternres(lgl) == 0 {
        return 0 as libc::c_int;
    }
    if lglterminate(lgl) != 0 {
        return 1 as libc::c_int;
    }
    if lglcarding(lgl) != 0 && lglcard(lgl) == 0 {
        return 0 as libc::c_int;
    }
    if lglterminate(lgl) != 0 {
        return 1 as libc::c_int;
    }
    if lglgaussing(lgl) != 0 && lglgauss(lgl) == 0 {
        return 0 as libc::c_int;
    }
    if lglterminate(lgl) != 0 {
        return 1 as libc::c_int;
    }
    if lgldecomposing(lgl) != 0 && lgldecomp(lgl) == 0 {
        return 0 as libc::c_int;
    }
    if lglterminate(lgl) != 0 {
        return 1 as libc::c_int;
    }
    if lglprobing(lgl) != 0 && lglprobe(lgl) == 0 {
        return 0 as libc::c_int;
    }
    if lglterminate(lgl) != 0 {
        return 1 as libc::c_int;
    }
    if lglunhiding(lgl) != 0 && lglunhide(lgl) == 0 {
        return 0 as libc::c_int;
    }
    if lglterminate(lgl) != 0 {
        return 1 as libc::c_int;
    }
    if lgltreducing(lgl) != 0 && lgltrd(lgl) == 0 {
        return 0 as libc::c_int;
    }
    if lglterminate(lgl) != 0 {
        return 1 as libc::c_int;
    }
    if lglblocking(lgl) != 0 {
        lglblock(lgl);
    }
    if lglterminate(lgl) != 0 {
        return 1 as libc::c_int;
    }
    if lglcceing(lgl) != 0 && lglcce(lgl) == 0 {
        return 0 as libc::c_int;
    }
    if lglterminate(lgl) != 0 {
        return 1 as libc::c_int;
    }
    if lgleliminating(lgl) != 0 && lglelim(lgl) == 0 {
        return 0 as libc::c_int;
    }
    if lglterminate(lgl) != 0 {
        return 1 as libc::c_int;
    }
    if lgltopgc(lgl) == 0 {
        return 0 as libc::c_int;
    }
    if lglterminate(lgl) != 0 {
        return 1 as libc::c_int;
    }
    if lglbcaing(lgl) != 0 {
        lglbca(lgl);
    }
    if lglterminate(lgl) != 0 {
        return 1 as libc::c_int;
    }
    if lglsweeping(lgl) != 0 && lglsweep(lgl) == 0 {
        return 0 as libc::c_int;
    }
    if lglterminate(lgl) != 0 {
        return 1 as libc::c_int;
    }
    if (*lgl).allphaseset == 0 {
        lglphase(lgl);
    }
    if lglterminate(lgl) != 0 {
        return 1 as libc::c_int;
    }
    if lglqueuesorting(lgl) != 0 {
        lglqueuesort(lgl);
    }
    if lglterminate(lgl) != 0 {
        return 1 as libc::c_int;
    }
    lgldefrag(lgl);
    if lglterminate(lgl) != 0 {
        return 1 as libc::c_int;
    }
    lglshowscoredist(lgl);
    lglshowfeatures(lgl);
    return 1 as libc::c_int;
}
unsafe extern "C" fn lglupdsimpcinc(
    mut lgl: *mut LGL,
    mut red: libc::c_int,
    mut success: libc::c_int,
) {
    let mut type_0: *const libc::c_char = b"no\0" as *const u8 as *const libc::c_char;
    let mut inc: libc::c_int = 0 as libc::c_int;
    let mut div: libc::c_int = 1 as libc::c_int;
    let mut res: libc::c_int = 0;
    if red <= 100 as libc::c_int {
        if red > 0 as libc::c_int {
            match (*(*lgl).opts).simpcintincdiv.val {
                3 => {
                    if red >= 50 as libc::c_int {
                        div = 4 as libc::c_int;
                    } else if red >= 20 as libc::c_int {
                        div = 3 as libc::c_int;
                    } else if red >= 10 as libc::c_int {
                        div = 2 as libc::c_int;
                    }
                }
                2 => {
                    div = red / 2 as libc::c_int + 1 as libc::c_int;
                }
                1 => {
                    div = red / 1 as libc::c_int + 1 as libc::c_int;
                }
                0 | _ => {}
            }
        }
        inc = (*(*lgl).opts).simpcintinc.val;
        if (*(*lgl).opts).simplify.val == 1 as libc::c_int {
            type_0 = b"arithmetic\0" as *const u8 as *const libc::c_char;
        } else if (*(*lgl).opts).simplify.val == 2 as libc::c_int {
            if inc < (*(*lgl).limits).simp.cinc {
                inc = (*(*lgl).limits).simp.cinc;
            }
            type_0 = b"geometric\0" as *const u8 as *const libc::c_char;
        } else {
            inc = 0 as libc::c_int;
        }
    }
    res = inc / div;
    if (*(*lgl).limits).simp.cinc - res <= 2147483647 as libc::c_int {
        (*(*lgl).limits).simp.cinc += res;
    }
    lglprt(
        lgl,
        2 as libc::c_int,
        b"[simplification-%d] new lgl->limits->simp.cinc %d\0" as *const u8
            as *const libc::c_char,
        (*(*lgl).stats).simp.count,
        (*(*lgl).limits).simp.cinc,
    );
    if div > 1 as libc::c_int {
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[simplification-%d] %s conflict interval increment %d = %d / %d\0"
                as *const u8 as *const libc::c_char,
            (*(*lgl).stats).simp.count,
            type_0,
            res,
            inc,
            div,
        );
    } else {
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[simplification-%d] full %s conflict interval increment %d\0" as *const u8
                as *const libc::c_char,
            (*(*lgl).stats).simp.count,
            type_0,
            res,
        );
    }
    if success != 0 && (*(*lgl).opts).simpcintmaxsoft.val >= 0 as libc::c_int
        && (*(*lgl).limits).simp.cinc >= (*(*lgl).opts).simpcintmaxsoft.val
    {
        (*(*lgl).limits).simp.cinc = (*(*lgl).opts).simpcintmaxsoft.val;
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[simplification-%d] conflict interval soft limit %d reached\0" as *const u8
                as *const libc::c_char,
            (*(*lgl).stats).simp.count,
            (*(*lgl).limits).simp.cinc,
        );
    } else if (*(*lgl).opts).simpcintmaxhard.val >= 0 as libc::c_int
        && (*(*lgl).limits).simp.cinc >= (*(*lgl).opts).simpcintmaxhard.val
    {
        (*(*lgl).limits).simp.cinc = (*(*lgl).opts).simpcintmaxhard.val;
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[simplification-%d] conflict interval hard limit %d reached\0" as *const u8
                as *const libc::c_char,
            (*(*lgl).stats).simp.count,
            (*(*lgl).limits).simp.cinc,
        );
    }
}
unsafe extern "C" fn lglsethardsimplim(mut lgl: *mut LGL) {
    let mut hard: int64_t = 0;
    let mut delta: int64_t = 0;
    delta = (*(*lgl).limits).simp.confs - (*(*lgl).stats).confs;
    if delta < 0 as libc::c_int as int64_t {
        delta = 0 as libc::c_int as int64_t;
    }
    delta *= (*(*lgl).opts).simpincdelmaxfact.val as int64_t;
    delta /= 100 as libc::c_int as int64_t;
    if delta < (*(*lgl).opts).simpincdelmaxmin.val as int64_t {
        delta = (*(*lgl).opts).simpincdelmaxmin.val as int64_t;
    }
    if (0x7fffffffffffffff as libc::c_longlong - delta as libc::c_longlong)
        < (*(*lgl).limits).simp.confs as libc::c_longlong
    {
        hard = 0x7fffffffffffffff as libc::c_longlong as int64_t;
    } else {
        hard = (*(*lgl).limits).simp.confs + delta;
    }
    (*(*lgl).limits).simp.hard = hard;
    lglprt(
        lgl,
        1 as libc::c_int,
        b"[simplification-%d] hard conflict limit %lld (soft %lld + delta %lld)\0"
            as *const u8 as *const libc::c_char,
        (*(*lgl).stats).simp.count,
        (*(*lgl).limits).simp.hard as libc::c_longlong,
        (*(*lgl).limits).simp.confs as libc::c_longlong,
        delta as libc::c_longlong,
    );
}
unsafe extern "C" fn lglupdsimpint(
    mut lgl: *mut LGL,
    mut oldrem: libc::c_int,
    mut oldirr: libc::c_int,
    mut forced: libc::c_int,
) {
    let mut remvar: libc::c_int = 0;
    let mut remirr: libc::c_int = 0;
    let mut pcntred: libc::c_int = 0;
    let mut simpcinc: libc::c_int = 0;
    let mut pcntremvar64: int64_t = 0;
    let mut pcntremirr64: int64_t = 0;
    let mut pcntremvar: libc::c_int = 0;
    let mut pcntremirr: libc::c_int = 0;
    remvar = oldrem - lglrem(lgl);
    if remvar < 0 as libc::c_int {
        remvar = 0 as libc::c_int;
    }
    pcntremvar64 = (if remvar > 0 as libc::c_int {
        (1000 as libc::c_longlong * remvar as libc::c_longlong
            / oldrem as libc::c_longlong + 5 as libc::c_int as libc::c_longlong)
            / 10 as libc::c_int as libc::c_longlong
    } else {
        0 as libc::c_longlong
    }) as int64_t;
    pcntremvar = pcntremvar64 as libc::c_int;
    lglprt(
        lgl,
        1 as libc::c_int,
        b"[simplification-%d] removed %d variables %.1f%% (%d remain %0.f%%)\0"
            as *const u8 as *const libc::c_char,
        (*(*lgl).stats).simp.count,
        remvar,
        lglpcnt(remvar as libc::c_double, oldrem as libc::c_double),
        lglrem(lgl),
        lglpcnt(
            lglrem(lgl) as libc::c_double,
            (*(*lgl).limits).inc.vars.start as libc::c_double,
        ),
    );
    remirr = oldirr - (*(*lgl).stats).irr.clauses.cur;
    if remirr < 0 as libc::c_int {
        remirr = 0 as libc::c_int;
    }
    pcntremirr64 = (if remirr > 0 as libc::c_int {
        (1000 as libc::c_longlong * remirr as libc::c_longlong
            / oldirr as libc::c_longlong + 5 as libc::c_int as libc::c_longlong)
            / 10 as libc::c_int as libc::c_longlong
    } else {
        0 as libc::c_longlong
    }) as int64_t;
    pcntremirr = pcntremirr64 as libc::c_int;
    lglprt(
        lgl,
        1 as libc::c_int,
        b"[simplification-%d] removed %d irredundant clauses %.1f%% (%d remain %.0f%%)\0"
            as *const u8 as *const libc::c_char,
        (*(*lgl).stats).simp.count,
        remirr,
        lglpcnt(remirr as libc::c_double, oldirr as libc::c_double),
        (*(*lgl).stats).irr.clauses.cur,
        lglpcnt(
            (*(*lgl).stats).irr.clauses.cur as libc::c_double,
            (*(*lgl).limits).inc.clauses.start as libc::c_double,
        ),
    );
    pcntred = lglmax(pcntremvar, pcntremirr);
    lglprt(
        lgl,
        1 as libc::c_int,
        b"[simplification-%d] maximum reduction of %d%% = max (%d%%, %d%%)\0"
            as *const u8 as *const libc::c_char,
        (*(*lgl).stats).simp.count,
        pcntred,
        pcntremvar,
        pcntremirr,
    );
    if forced != 0 {
        simpcinc = 0 as libc::c_int;
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[simplification-%d] forced so keeping old conflict interval %d\0"
                as *const u8 as *const libc::c_char,
            (*(*lgl).stats).simp.count,
            (*(*lgl).limits).simp.cinc,
        );
    } else if (*(*lgl).stats).confs < (*(*lgl).limits).simp.confs
        && {
            simpcinc = (*(*lgl).limits).simp.cinc;
            simpcinc != 0
        }
    {
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[simplification-%d] keeping old conflict interval %d (non-conflict triggered simplification)\0"
                as *const u8 as *const libc::c_char,
            (*(*lgl).stats).simp.count,
            (*(*lgl).limits).simp.cinc,
        );
    } else if remvar > 0 as libc::c_int && pcntred >= (*(*lgl).opts).simprtc.val {
        let mut scaledcinc: int64_t = 0;
        let mut factor: libc::c_int = 0;
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[simplification-%d] large reduction %d%% >= %d%% limit\0" as *const u8
                as *const libc::c_char,
            (*(*lgl).stats).simp.count,
            pcntred,
            (*(*lgl).opts).simprtc.val,
        );
        factor = (*(*lgl).opts).simpidiv.val - (*(*lgl).stats).simp.count;
        if factor <= 0 as libc::c_int {
            factor = 1 as libc::c_int;
        }
        simpcinc = (*(*lgl).opts).simpcintdelay.val / factor;
        scaledcinc = (*(*lgl).stats).confs / (*(*lgl).opts).simpiscale.val as int64_t;
        if scaledcinc > (*(*lgl).limits).simp.cinc as int64_t {
            scaledcinc = (*(*lgl).limits).simp.cinc as int64_t;
        }
        if scaledcinc < simpcinc as int64_t {
            lglprt(
                lgl,
                1 as libc::c_int,
                b"[simplification-%d] next conflict interval %d = %d/%d\0" as *const u8
                    as *const libc::c_char,
                (*(*lgl).stats).simp.count,
                simpcinc,
                (*(*lgl).opts).simpcintdelay.val,
                factor,
            );
        } else {
            simpcinc = scaledcinc as libc::c_int;
            lglprt(
                lgl,
                1 as libc::c_int,
                b"[simplification-%d] next conflict interval %d = min (%lld/%d, %d)\0"
                    as *const u8 as *const libc::c_char,
                (*(*lgl).stats).simp.count,
                simpcinc,
                (*(*lgl).stats).confs as libc::c_longlong,
                (*(*lgl).opts).simpiscale.val,
                (*(*lgl).limits).simp.cinc,
            );
        }
    } else {
        lglupdsimpcinc(lgl, pcntred, (remvar != 0 || remirr != 0) as libc::c_int);
        simpcinc = (*(*lgl).limits).simp.cinc;
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[simplification-%d] new conflict interval %d\0" as *const u8
                as *const libc::c_char,
            (*(*lgl).stats).simp.count,
            simpcinc,
        );
    }
    if forced != 0 {
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[simplification-%d] conflict limit remains at %lld (hard %lld)\0"
                as *const u8 as *const libc::c_char,
            (*(*lgl).stats).simp.count,
            (*(*lgl).limits).simp.confs as libc::c_longlong,
            (*(*lgl).limits).simp.hard as libc::c_longlong,
        );
    } else {
        let mut penalty: libc::c_int = 0;
        let mut pensimpcinc: libc::c_int = 0;
        if (*(*lgl).opts).simpintsizepen.val == 0
            || (*(*lgl).stats).irr.clauses.cur < 1000000 as libc::c_int
        {
            penalty = 1 as libc::c_int;
        } else if (*(*lgl).stats).irr.clauses.cur < 10000000 as libc::c_int {
            penalty = 2 as libc::c_int;
        } else {
            penalty = 4 as libc::c_int;
        }
        if 2147483647 as libc::c_int / penalty < simpcinc {
            pensimpcinc = 2147483647 as libc::c_int;
        } else {
            pensimpcinc = penalty * simpcinc;
        }
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[simplification-%d] penalized conflict interval %d = %d * %d\0"
                as *const u8 as *const libc::c_char,
            (*(*lgl).stats).simp.count,
            pensimpcinc,
            penalty,
            simpcinc,
        );
        (*(*lgl).limits).simp.confs = (*(*lgl).stats).confs + pensimpcinc as int64_t;
        lglsethardsimplim(lgl);
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[simplification-%d] new conflict limit %lld (hard %lld)\0" as *const u8
                as *const libc::c_char,
            (*(*lgl).stats).simp.count,
            (*(*lgl).limits).simp.confs as libc::c_longlong,
            (*(*lgl).limits).simp.hard as libc::c_longlong,
        );
    }
    if (*(*lgl).stats).confs >= (*(*lgl).limits).simp.confs {
        (*(*lgl).limits)
            .simp
            .confs = (*(*lgl).stats).confs + 1 as libc::c_int as int64_t;
        if (*(*lgl).limits).simp.hard < (*(*lgl).limits).simp.confs {
            (*(*lgl).limits).simp.hard = (*(*lgl).limits).simp.confs;
        }
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[simplification-%d] fixed conflict limit %d (wait at least for one conflict)\0"
                as *const u8 as *const libc::c_char,
            (*(*lgl).stats).simp.count,
            (*(*lgl).stats).confs,
        );
    }
    if forced == 1 as libc::c_int
        && (*(*lgl).limits).simp.itinc < (*(*lgl).opts).simpitintinclim.val
    {
        if (*(*lgl).limits).simp.itinc < 2147483647 as libc::c_int / 10 as libc::c_int {
            (*(*lgl).limits).simp.itinc *= 10 as libc::c_int;
        } else {
            (*(*lgl).limits).simp.itinc = 2147483647 as libc::c_int;
        }
        if (*(*lgl).limits).simp.itinc > (*(*lgl).opts).simpitintinclim.val {
            (*(*lgl).limits).simp.itinc = (*(*lgl).opts).simpitintinclim.val;
        }
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[simplification-%d] new iteration interval %d\0" as *const u8
                as *const libc::c_char,
            (*(*lgl).stats).simp.count,
            (*(*lgl).limits).simp.itinc,
        );
    }
    (*(*lgl).limits)
        .simp
        .its = ((*(*lgl).stats).its.count + (*(*lgl).limits).simp.itinc) as int64_t;
    if forced == 2 as libc::c_int
        && (*(*lgl).limits).simp.binc < (*(*lgl).opts).simpbintinclim.val
    {
        if (*(*lgl).limits).simp.binc < 2147483647 as libc::c_int / 10 as libc::c_int {
            (*(*lgl).limits).simp.binc *= 10 as libc::c_int;
        } else {
            (*(*lgl).limits).simp.binc = 2147483647 as libc::c_int;
        }
        if (*(*lgl).limits).simp.binc > (*(*lgl).opts).simpbintinclim.val {
            (*(*lgl).limits).simp.binc = (*(*lgl).opts).simpbintinclim.val;
        }
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[simplification-%d] new binary interval %d\0" as *const u8
                as *const libc::c_char,
            (*(*lgl).stats).simp.count,
            (*(*lgl).limits).simp.binc,
        );
    }
    (*(*lgl).limits)
        .simp
        .bin = (*(*lgl).stats).bins + (*(*lgl).limits).simp.binc as int64_t;
    if forced == 3 as libc::c_int
        && (*(*lgl).limits).simp.tinc < (*(*lgl).opts).simptintinclim.val
    {
        if (*(*lgl).limits).simp.tinc < 2147483647 as libc::c_int / 10 as libc::c_int {
            (*(*lgl).limits).simp.tinc *= 10 as libc::c_int;
        } else {
            (*(*lgl).limits).simp.tinc = 2147483647 as libc::c_int;
        }
        if (*(*lgl).limits).simp.tinc > (*(*lgl).opts).simptintinclim.val {
            (*(*lgl).limits).simp.tinc = (*(*lgl).opts).simptintinclim.val;
        }
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[simplification-%d] new ternary interval %d\0" as *const u8
                as *const libc::c_char,
            (*(*lgl).stats).simp.count,
            (*(*lgl).limits).simp.tinc,
        );
    }
    (*(*lgl).limits)
        .simp
        .trn = (*(*lgl).stats).trns + (*(*lgl).limits).simp.tinc as int64_t;
    (*(*lgl).limits).simp.vars = lglrem(lgl) as int64_t;
    (*lgl).repforcehead = 1 as libc::c_int as libc::c_char;
    if (*lgl).wait > 0 as libc::c_int {
        (*lgl).wait -= 1;
        (*lgl).wait;
    }
}
unsafe extern "C" fn lglpreprocessing(
    mut lgl: *mut LGL,
    mut forced: libc::c_int,
) -> libc::c_int {
    let mut res: libc::c_int = 0;
    let mut oldrem: libc::c_int = 0;
    let mut oldirr: libc::c_int = 0;
    if (*lgl).mt != 0 {
        return 0 as libc::c_int;
    }
    (*(*lgl).stats).simp.count += 1;
    (*(*lgl).stats).simp.count;
    oldrem = lglrem(lgl);
    oldirr = (*(*lgl).stats).irr.clauses.cur;
    res = lglisimp(lgl);
    lglupdsimpint(lgl, oldrem, oldirr, forced);
    return res;
}
unsafe extern "C" fn lglsimplimhit(
    mut lgl: *mut LGL,
    mut forcedptr: *mut libc::c_int,
) -> libc::c_int {
    let mut n: int64_t = 0;
    let mut o: int64_t = 0;
    let mut d: int64_t = 0;
    let mut a: libc::c_int = 0;
    let mut r: libc::c_int = 0;
    let mut res: libc::c_int = 0 as libc::c_int;
    if (*(*lgl).opts).simplify.val == 0 {
        return 0 as libc::c_int;
    }
    if (*(*lgl).opts).inprocessing.val == 0 && (*(*lgl).stats).simp.count != 0 {
        return 0 as libc::c_int;
    }
    if (*(*lgl).stats).confs < (*(*lgl).limits).simp.hard {
        if (*(*lgl).opts).simpitintdecdelay.val != 0
            && (*(*lgl).stats).its.avg.diff.smoothed.val < 0 as libc::c_int as int64_t
        {
            return 0 as libc::c_int;
        }
        if (*(*lgl).opts).simpjleveldecdelay.val != 0
            && (*(*lgl).stats).jlevel.diff.smoothed.val < 0 as libc::c_int as int64_t
        {
            return 0 as libc::c_int;
        }
    }
    if (*(*lgl).stats).confs >= (*(*lgl).limits).simp.confs {
        lglprt(lgl, 1 as libc::c_int, b"\0" as *const u8 as *const libc::c_char);
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[simplification-%d] limit %lld conflicts (hard %lld) hit after %lld conflicts\0"
                as *const u8 as *const libc::c_char,
            (*(*lgl).stats).simp.count + 1 as libc::c_int,
            (*(*lgl).limits).simp.confs as libc::c_longlong,
            (*(*lgl).limits).simp.hard as libc::c_longlong,
            (*(*lgl).stats).confs as libc::c_longlong,
        );
        (*(*lgl).stats).simp.limhit.confs += 1;
        (*(*lgl).stats).simp.limhit.confs;
        *forcedptr = 0 as libc::c_int;
        res = 1 as libc::c_int;
    }
    if res == 0 && (*(*lgl).stats).trns >= (*(*lgl).limits).simp.trn {
        lglprt(lgl, 1 as libc::c_int, b"\0" as *const u8 as *const libc::c_char);
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[simplification-%d] limit of %lld ternary hit after %lld ternaries\0"
                as *const u8 as *const libc::c_char,
            (*(*lgl).stats).simp.count + 1 as libc::c_int,
            (*(*lgl).limits).simp.trn as libc::c_longlong,
            (*(*lgl).stats).trns as libc::c_longlong,
        );
        (*(*lgl).stats).simp.limhit.trn += 1;
        (*(*lgl).stats).simp.limhit.trn;
        *forcedptr = 3 as libc::c_int;
        res = 1 as libc::c_int;
    }
    if res == 0 && (*(*lgl).stats).bins >= (*(*lgl).limits).simp.bin {
        lglprt(lgl, 1 as libc::c_int, b"\0" as *const u8 as *const libc::c_char);
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[simplification-%d] limit of %lld binary hit after %lld binaries\0"
                as *const u8 as *const libc::c_char,
            (*(*lgl).stats).simp.count + 1 as libc::c_int,
            (*(*lgl).limits).simp.bin as libc::c_longlong,
            (*(*lgl).stats).bins as libc::c_longlong,
        );
        (*(*lgl).stats).simp.limhit.bin += 1;
        (*(*lgl).stats).simp.limhit.bin;
        *forcedptr = 2 as libc::c_int;
        res = 1 as libc::c_int;
    }
    if res == 0 && (*(*lgl).stats).its.count as int64_t >= (*(*lgl).limits).simp.its {
        lglprt(lgl, 1 as libc::c_int, b"\0" as *const u8 as *const libc::c_char);
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[simplification-%d] limit of %lld iterations hit after %d iterations\0"
                as *const u8 as *const libc::c_char,
            (*(*lgl).stats).simp.count + 1 as libc::c_int,
            (*(*lgl).limits).simp.its as libc::c_longlong,
            (*(*lgl).stats).its.count,
        );
        (*(*lgl).stats).simp.limhit.its += 1;
        (*(*lgl).stats).simp.limhit.its;
        *forcedptr = 1 as libc::c_int;
        res = 1 as libc::c_int;
    }
    if res == 0
        && {
            o = (*(*lgl).limits).simp.vars;
            o != 0
        }
        && {
            n = lglrem(lgl) as int64_t;
            n >= (*(*lgl).opts).simpvarlim.val as int64_t
        }
    {
        d = n - o;
        r = (100 as libc::c_int as int64_t * d) as libc::c_int;
        r = (r as int64_t / o) as libc::c_int;
        if r <= -(2147483647 as libc::c_int) - 1 as libc::c_int
            || r > 2147483647 as libc::c_int
        {
            a = 2147483647 as libc::c_int;
        } else if r < 0 as libc::c_int {
            a = -r;
        } else {
            a = r;
        }
        if a >= (*(*lgl).opts).simpvarchg.val {
            lglprt(lgl, 1 as libc::c_int, b"\0" as *const u8 as *const libc::c_char);
            lglprt(
                lgl,
                1 as libc::c_int,
                b"[simplification-%d] limit hit: remaining variables changed from %lld to %lld by %d%%\0"
                    as *const u8 as *const libc::c_char,
                (*(*lgl).stats).simp.count + 1 as libc::c_int,
                o as libc::c_longlong,
                n as libc::c_longlong,
                r,
            );
            (*(*lgl).stats).simp.limhit.vars += 1;
            (*(*lgl).stats).simp.limhit.vars;
            *forcedptr = -(1 as libc::c_int);
            res = 1 as libc::c_int;
        }
    }
    return res;
}
unsafe extern "C" fn lglinprocessing(mut lgl: *mut LGL) -> libc::c_int {
    let mut res: libc::c_int = 0;
    let mut oldrem: libc::c_int = 0;
    let mut oldirr: libc::c_int = 0;
    let mut forced: libc::c_int = 0;
    if lglsimplimhit(lgl, &mut forced) == 0 {
        return ((*lgl).mt == 0) as libc::c_int;
    }
    (*(*lgl).stats).simp.count += 1;
    (*(*lgl).stats).simp.count;
    lglstart(lgl, &mut (*(*lgl).times).inprocessing);
    oldrem = lglrem(lgl);
    oldirr = (*(*lgl).stats).irr.clauses.cur;
    res = lglisimp(lgl);
    lglupdsimpint(lgl, oldrem, oldirr, forced);
    lglstop(lgl);
    return res;
}
unsafe extern "C" fn lglbcptop(mut lgl: *mut LGL) -> libc::c_int {
    let mut res: libc::c_int = 0;
    if lglbcp(lgl) != 0 {
        res = 1 as libc::c_int;
    } else {
        lglana(lgl);
        if (*lgl).conf.lit != 0 {
            lglmt(lgl);
        }
        res = 0 as libc::c_int;
    }
    return res;
}
unsafe extern "C" fn lglimhit(mut lgl: *mut LGL, mut lim: *mut Lim) -> libc::c_int {
    if lim.is_null() {
        return 0 as libc::c_int;
    }
    if (*lim).decs >= 0 as libc::c_int as int64_t
        && (*(*lgl).stats).decisions >= (*lim).decs
    {
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[limits] decision limit %lld hit at %lld decisions\0" as *const u8
                as *const libc::c_char,
            (*lim).decs as libc::c_longlong,
            (*(*lgl).stats).decisions as libc::c_longlong,
        );
        return 1 as libc::c_int;
    }
    if (*lim).confs >= 0 as libc::c_int as int64_t
        && (*(*lgl).stats).confs >= (*lim).confs
    {
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[limits] conflict limit %lld hit at %lld conflicts\0" as *const u8
                as *const libc::c_char,
            (*lim).confs as libc::c_longlong,
            (*(*lgl).stats).confs as libc::c_longlong,
        );
        return 1 as libc::c_int;
    }
    if (*lim).props >= 0 as libc::c_int as int64_t
        && (*(*lgl).stats).props.search >= (*lim).props
    {
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[limits] propagation limit %lld hit at %lld propagations\0" as *const u8
                as *const libc::c_char,
            (*lim).props as libc::c_longlong,
            (*(*lgl).stats).props.search as libc::c_longlong,
        );
        return 1 as libc::c_int;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn lgloop(mut lgl: *mut LGL, mut lim: *mut Lim) -> libc::c_int {
    let mut confs: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    loop {
        if lglbcpsearch(lgl) != 0 && lglinprocessing(lgl) != 0 {
            if lglterminate(lgl) != 0 {
                return 0 as libc::c_int;
            }
            if lglsyncunits(lgl) == 0 {
                return 20 as libc::c_int;
            }
            if lglsyncls(lgl) == 0 {
                continue;
            }
            if lglfailedass(lgl) != 0 {
                return 20 as libc::c_int;
            }
            if lglreducing(lgl) != 0 {
                lglreduce(lgl, 0 as libc::c_int);
            }
            if lgldefragmenting(lgl) != 0 {
                lgldefrag(lgl);
            }
            if lglimhit(lgl, lim) != 0 {
                return 0 as libc::c_int;
            }
            if lglocsing(lgl) != 0 {
                lglocs(lgl);
            }
            if lglrestarting(lgl) != 0 {
                lglrestart(lgl);
            } else if lglpruning(lgl) != 0 {
                lglprune(lgl);
            } else if lgldecide(lgl) == 0 {
                return 10 as libc::c_int
            }
        } else if lglana(lgl) == 0 {
            return 20 as libc::c_int
        } else {
            confs = confs.wrapping_add(1);
            if confs & 15 as libc::c_int as libc::c_uint == 0 && lglterminate(lgl) != 0 {
                return 0 as libc::c_int;
            }
        }
    };
}
unsafe extern "C" fn lglsearch(mut lgl: *mut LGL, mut lim: *mut Lim) -> libc::c_int {
    let mut res: libc::c_int = 0;
    (*lgl).searching = 1 as libc::c_int as libc::c_char;
    lglstart(lgl, &mut (*(*lgl).times).search);
    res = lgloop(lgl, lim);
    (*lgl).searching = 0 as libc::c_int as libc::c_char;
    lglstop(lgl);
    return res;
}
unsafe extern "C" fn lgltopsimp(
    mut lgl: *mut LGL,
    mut forcesimp: libc::c_int,
) -> libc::c_int {
    if (*lgl).mt != 0 {
        return 20 as libc::c_int;
    }
    if lglfailedass(lgl) != 0 {
        return 20 as libc::c_int;
    }
    if lglbcptop(lgl) == 0 {
        return 20 as libc::c_int;
    }
    if (*lgl).mt != 0 || lglfailedass(lgl) != 0 {
        return 20 as libc::c_int;
    }
    if lglterminate(lgl) != 0 {
        return 0 as libc::c_int;
    }
    lglshowfeatures(lgl);
    if (forcesimp != 0 || lglsimplimhit(lgl, &mut forcesimp) != 0)
        && lglpreprocessing(lgl, forcesimp) == 0
    {
        return 20 as libc::c_int;
    }
    if lglfailedass(lgl) != 0 {
        return 20 as libc::c_int;
    }
    lglrep(lgl, 2 as libc::c_int, 's' as i32 as libc::c_char);
    return 0 as libc::c_int;
}
unsafe extern "C" fn lglsolve(
    mut lgl: *mut LGL,
    mut lim: *mut Lim,
    mut forcesimp: libc::c_int,
) -> libc::c_int {
    let mut res: libc::c_int = 0;
    lglstart(lgl, &mut (*(*lgl).times).preprocessing);
    res = lgltopsimp(lgl, forcesimp);
    lglstop(lgl);
    if res != 0 {
        return res;
    }
    return lglsearch(lgl, lim);
}
unsafe extern "C" fn lglincsetup(mut lgl: *mut LGL) {
    if (*(*lgl).opts).incsavevisits.val != 0 {
        (*(*lgl).limits).inc.visits = (*(*lgl).stats).visits.search;
    }
    if (*(*lgl).limits).inc.clauses.add < (*(*lgl).stats).irr.clauses.add {
        (*(*lgl).limits).inc.clauses.add = (*(*lgl).stats).irr.clauses.add;
        (*lgl).ccertc = 0 as libc::c_int as libc::c_char;
        (*lgl).blkrtc = (*lgl).ccertc;
        (*lgl).elmrtc = (*lgl).blkrtc;
        (*lgl).wait = (*(*lgl).opts).waitmax.val;
    }
    (*(*lgl).limits).inc.clauses.start = (*(*lgl).stats).irr.clauses.cur;
    (*(*lgl).limits).inc.vars.start = lglrem(lgl);
    (*(*lgl).limits)
        .prune
        .decisions = (*(*lgl).stats).decisions + (*(*lgl).limits).prune.inc;
    lglinitredl(lgl);
    (*(*lgl).stats).locs.min = 2147483647 as libc::c_int;
    lglupdlocslim(lgl, 0 as libc::c_int);
    memset(
        &mut (*(*lgl).limits).restart as *mut C2RustUnnamed_30 as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<C2RustUnnamed_30>() as libc::c_ulong,
    );
    (*(*lgl).limits).restart.confs = (*(*lgl).stats).confs;
    if (*(*lgl).opts).incredcint.val > 1 as libc::c_int {
        (*(*lgl).limits).simp.cinc /= (*(*lgl).opts).incredcint.val;
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[incremental-setup] conflict interval increment reduced to %d\0"
                as *const u8 as *const libc::c_char,
            (*(*lgl).limits).simp.cinc,
        );
    }
    if (*(*lgl).opts).incredconfslim.val != 0 {
        (*(*lgl).limits)
            .simp
            .confs = (100 as libc::c_int - (*(*lgl).opts).incredconfslim.val) as int64_t
            * (*(*lgl).limits).simp.confs / 100 as libc::c_int as int64_t;
        lglsethardsimplim(lgl);
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[incremental-setup] conflict limit reduced to %lld (hard %lld)\0"
                as *const u8 as *const libc::c_char,
            (*(*lgl).limits).simp.confs as libc::c_longlong,
            (*(*lgl).limits).simp.hard as libc::c_longlong,
        );
    }
    if (*(*lgl).limits).simp.itinc == 0 {
        (*(*lgl).limits).simp.itinc = (*(*lgl).opts).simpitintinc.val;
    }
    (*(*lgl).limits)
        .simp
        .its = ((*(*lgl).stats).its.count + (*(*lgl).opts).simpitintinc.val) as int64_t;
    if (*(*lgl).limits).simp.binc == 0 {
        (*(*lgl).limits).simp.binc = (*(*lgl).opts).simpbintinc.val;
    }
    (*(*lgl).limits)
        .simp
        .bin = (*(*lgl).stats).bins + (*(*lgl).opts).simpbintinc.val as int64_t;
    if (*(*lgl).limits).simp.tinc == 0 {
        (*(*lgl).limits).simp.tinc = (*(*lgl).opts).simptintinc.val;
    }
    (*(*lgl).limits)
        .simp
        .trn = (*(*lgl).stats).trns + (*(*lgl).opts).simptintinc.val as int64_t;
    lglinitmacd(
        lgl,
        &mut (*(*lgl).stats).jlevel,
        (*(*lgl).opts).jlevelmacdfast.val,
        (*(*lgl).opts).jlevelmacdslow.val,
        (*(*lgl).opts).jlevelmacdsmooth.val,
    );
    lglinitema(lgl, &mut (*(*lgl).stats).tlevel, (*(*lgl).opts).tlevelema.val);
    lglinitmacd(
        lgl,
        &mut (*(*lgl).stats).glue,
        (*(*lgl).opts).gluemacdfast.val,
        (*(*lgl).opts).gluemacdslow.val,
        (*(*lgl).opts).gluemacdsmooth.val,
    );
    lglinitavg(&mut (*(*lgl).stats).avglue);
    lglinitmacd(
        lgl,
        &mut (*(*lgl).stats).its.avg,
        (*(*lgl).opts).itsmacdfast.val,
        (*(*lgl).opts).itsmacdslow.val,
        (*(*lgl).opts).itsmacdsmooth.val,
    );
    lglinitema(lgl, &mut (*(*lgl).stats).stability.avg, (*(*lgl).opts).stabema.val);
    memset(
        &mut (*(*lgl).limits).elm.del as *mut Del as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<Del>() as libc::c_ulong,
    );
    memset(
        &mut (*(*lgl).limits).blk.del as *mut Del as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<Del>() as libc::c_ulong,
    );
    memset(
        &mut (*(*lgl).limits).trd.del as *mut Del as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<Del>() as libc::c_ulong,
    );
    memset(
        &mut (*(*lgl).limits).unhd.del as *mut Del as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<Del>() as libc::c_ulong,
    );
    memset(
        &mut (*(*lgl).limits).ternres.del as *mut Del as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<Del>() as libc::c_ulong,
    );
    memset(
        &mut (*(*lgl).limits).cce.del as *mut Del as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<Del>() as libc::c_ulong,
    );
    memset(
        &mut (*(*lgl).limits).card.del as *mut Del as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<Del>() as libc::c_ulong,
    );
    memset(
        &mut (*(*lgl).limits).gauss.del as *mut Del as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<Del>() as libc::c_ulong,
    );
    memset(
        &mut (*(*lgl).limits).prb.simple.del as *mut Del as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<Del>() as libc::c_ulong,
    );
    memset(
        &mut (*(*lgl).limits).prb.basic.del as *mut Del as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<Del>() as libc::c_ulong,
    );
    memset(
        &mut (*(*lgl).limits).prb.treelook.del as *mut Del as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<Del>() as libc::c_ulong,
    );
    memset(
        &mut (*(*lgl).limits).bca.del as *mut Del as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<Del>() as libc::c_ulong,
    );
}
unsafe extern "C" fn lglsetup(mut lgl: *mut LGL) {
    if !((*lgl).setuponce != 0) {
        (*(*lgl).limits)
            .dfg = (*(*lgl).stats).pshwchs + (*(*lgl).opts).defragint.val as int64_t;
        (*(*lgl).limits).blk.irrprgss = -(1 as libc::c_int) as int64_t;
        (*(*lgl).limits).elm.irrprgss = -(1 as libc::c_int) as int64_t;
        (*(*lgl).limits).term.steps = -(1 as libc::c_int) as int64_t;
        (*(*lgl).limits).prune.inc = (*(*lgl).opts).pruneinit.val as int64_t;
        (*lgl).rng.w = (*(*lgl).opts).seed.val as libc::c_uint;
        (*lgl).rng.z = !(*lgl).rng.w;
        (*lgl).rng.w <<= 1 as libc::c_int;
        (*lgl).rng.z <<= 1 as libc::c_int;
        (*lgl).rng.w = ((*lgl).rng.w).wrapping_add(1 as libc::c_int as libc::c_uint);
        (*lgl).rng.z = ((*lgl).rng.z).wrapping_add(1 as libc::c_int as libc::c_uint);
        (*lgl).rng.w = ((*lgl).rng.w).wrapping_mul(2019164533 as libc::c_uint);
        (*lgl).rng.z = ((*lgl).rng.z).wrapping_mul(1000632769 as libc::c_uint);
        (*(*lgl).limits).randec
            += ((*(*lgl).opts).randecint.val / 2 as libc::c_int) as int64_t;
        (*(*lgl).limits).randec
            += (lglrand(lgl)).wrapping_rem((*(*lgl).opts).randecint.val as libc::c_uint)
                as int64_t;
        (*(*lgl).limits).randphase
            += ((*(*lgl).opts).randphaseint.val / 2 as libc::c_int) as int64_t;
        (*(*lgl).limits).randphase
            += (lglrand(lgl))
                .wrapping_rem((*(*lgl).opts).randphaseint.val as libc::c_uint)
                as int64_t;
        (*(*lgl).limits).simp.vars = lglrem(lgl) as int64_t;
        (*lgl).setuponce = 1 as libc::c_int as libc::c_char;
        lglchkenv(lgl);
    }
    lglinitscores(lgl);
    lglincsetup(lgl);
    (*lgl).state = READY;
}
unsafe extern "C" fn lglinitsolve(mut lgl: *mut LGL) {
    if (*lgl).state as libc::c_uint != READY as libc::c_int as libc::c_uint {
        lglsetup(lgl);
    }
    lglredvars(lgl);
    lglfitstk(lgl, &mut (*lgl).irr);
    lglrep(lgl, 1 as libc::c_int, '*' as i32 as libc::c_char);
}
unsafe extern "C" fn lgleassign(mut lgl: *mut LGL, mut lit: libc::c_int) {
    let mut ext: *mut Ext = 0 as *mut Ext;
    ext = lglelit2ext(lgl, lit);
    (*ext).set_val(lglsgn(lit));
}
unsafe extern "C" fn lglcomputechanged(mut lgl: *mut LGL) {
    let mut ext: *mut Ext = 0 as *mut Ext;
    let mut eidx: libc::c_int = 0;
    (*lgl).changed = 0 as libc::c_int;
    eidx = 1 as libc::c_int;
    while eidx <= (*lgl).maxext {
        ext = lglelit2ext(lgl, eidx);
        if (*ext).oldval() != 0 && (*ext).oldval() != (*ext).val() {
            (*lgl).changed += 1;
            (*lgl).changed;
        }
        (*ext).set_oldval((*ext).val());
        eidx += 1;
        eidx;
    }
}
unsafe extern "C" fn lglextend(mut lgl: *mut LGL) {
    let mut p: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut lit: libc::c_int = 0;
    let mut eidx: libc::c_int = 0;
    let mut ilit: libc::c_int = 0;
    let mut next: libc::c_int = 0;
    let mut satisfied: libc::c_int = 0;
    let mut val: libc::c_int = 0;
    let mut start: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut erepr: libc::c_int = 0;
    let mut equiv: libc::c_int = 0;
    let mut ext: *mut Ext = 0 as *mut Ext;
    let mut extrepr: *mut Ext = 0 as *mut Ext;
    lgleunassignall(lgl);
    equiv = 0 as libc::c_int;
    while equiv <= 1 as libc::c_int {
        equiv != 0;
        eidx = 1 as libc::c_int;
        while eidx <= (*lgl).maxext {
            ext = lglelit2ext(lgl, eidx);
            if !((*ext).imported() == 0) {
                if !(equiv != (*ext).equiv() as libc::c_int) {
                    if (*ext).equiv() != 0 {
                        erepr = lglerepr(lgl, eidx);
                        extrepr = lglelit2ext(lgl, erepr);
                        val = (*extrepr).val();
                        if val == 0 {
                            ilit = (*extrepr).repr;
                            if ilit != 0 {
                                val = lglcval(lgl, ilit);
                            }
                        }
                        if erepr < 0 as libc::c_int {
                            val = -val;
                        }
                    } else {
                        ilit = (*ext).repr;
                        if ilit != 0 {
                            val = lglcval(lgl, ilit);
                        } else {
                            val = 0 as libc::c_int;
                        }
                    }
                    lit = if val > 0 as libc::c_int { eidx } else { -eidx };
                    lgleassign(lgl, lit);
                }
            }
            eidx += 1;
            eidx;
        }
        equiv += 1;
        equiv;
    }
    start = (*lgl).extend.start;
    p = (*lgl).extend.top;
    if !(p == start) {
        p = p.offset(-1);
        p;
        while p > start {
            satisfied = 0 as libc::c_int;
            next = 0 as libc::c_int;
            loop {
                lit = next;
                if p == start {
                    next = 0 as libc::c_int;
                } else {
                    p = p.offset(-1);
                    next = *p;
                }
                if !(lit == 0 || satisfied != 0) {
                    val = lglederef(lgl, lit);
                    if val > 0 as libc::c_int {
                        satisfied = 1 as libc::c_int;
                    }
                }
                if !(next != 0) {
                    break;
                }
            }
            if satisfied != 0 {
                continue;
            }
            lgleassign(lgl, lit);
        }
    }
    lglcomputechanged(lgl);
    (*lgl).state = EXTENDED;
}
#[no_mangle]
pub unsafe extern "C" fn lglsetphases(mut lgl: *mut LGL) {
    let mut elit: libc::c_int = 0;
    let mut phase: libc::c_int = 0;
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<
                &[u8; 13],
                &[libc::c_char; 13],
            >(b"lglsetphases\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).forked == 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<
                &[u8; 13],
                &[libc::c_char; 13],
            >(b"lglsetphases\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"forked manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if !((*lgl).apitrace).is_null() {
        lgltrapi(lgl, b"setphases\0" as *const u8 as *const libc::c_char);
    }
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<
                &[u8; 13],
                &[libc::c_char; 13],
            >(b"lglsetphases\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).state as libc::c_uint
        & (SATISFIED as libc::c_int | EXTENDED as libc::c_int) as libc::c_uint != 0
    {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<
                &[u8; 13],
                &[libc::c_char; 13],
            >(b"lglsetphases\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(
            stderr,
            b"!(%s)\0" as *const u8 as *const libc::c_char,
            b"SATISFIED | EXTENDED\0" as *const u8 as *const libc::c_char,
        );
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).state as libc::c_uint & EXTENDED as libc::c_int as libc::c_uint == 0 {
        lglextend(lgl);
    }
    elit = 1 as libc::c_int;
    while elit <= (*lgl).maxext {
        phase = lglederef(lgl, elit);
        lglesetphase(lgl, elit, phase);
        elit += 1;
        elit;
    }
    if !((*lgl).clone).is_null() {
        lglsetphases((*lgl).clone);
    }
}
unsafe extern "C" fn lglclass(mut lgl: *mut LGL, mut from: *mut LGL) {
    let mut extfrom: *mut Ext = 0 as *mut Ext;
    let mut extlgl: *mut Ext = 0 as *mut Ext;
    let mut eidx: libc::c_int = 0;
    let mut cloned: libc::c_int = 0;
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 9], &[libc::c_char; 9]>(b"lglclass\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).forked == 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 9], &[libc::c_char; 9]>(b"lglclass\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"forked manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).mt == 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 9], &[libc::c_char; 9]>(b"lglclass\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(
            stderr,
            b"can not clone assignment into inconsistent manager\0" as *const u8
                as *const libc::c_char,
        );
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if !from.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 9], &[libc::c_char; 9]>(b"lglclass\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(
            stderr,
            b"uninitialized 'from' solver\0" as *const u8 as *const libc::c_char,
        );
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*from).state as libc::c_uint
        & (SATISFIED as libc::c_int | EXTENDED as libc::c_int) as libc::c_uint != 0
    {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 9], &[libc::c_char; 9]>(b"lglclass\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(
            stderr,
            b"require 'from' state to be (SATISFIED | EXTENDED)\0" as *const u8
                as *const libc::c_char,
        );
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if !((*from).maxext != (*lgl).maxext) {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 9], &[libc::c_char; 9]>(b"lglclass\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(
            stderr,
            b"can not clone assignments for different sets of variables\0" as *const u8
                as *const libc::c_char,
        );
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*from).state as libc::c_uint & EXTENDED as libc::c_int as libc::c_uint == 0 {
        lglextend(from);
    }
    lglreset(lgl);
    lgleunassignall(lgl);
    (*lgl).changed = 0 as libc::c_int;
    cloned = (*lgl).changed;
    eidx = 1 as libc::c_int;
    while eidx <= (*lgl).maxext {
        extlgl = lglelit2ext(lgl, eidx);
        if !((*extlgl).imported() == 0) {
            extfrom = lglelit2ext(from, eidx);
            if (*extfrom).imported() != 0 {} else {
                fprintf(
                    stderr,
                    b"*** API usage error of '%s' in '%s'\0" as *const u8
                        as *const libc::c_char,
                    b"lglib.c\0" as *const u8 as *const libc::c_char,
                    (*::core::mem::transmute::<
                        &[u8; 9],
                        &[libc::c_char; 9],
                    >(b"lglclass\0"))
                        .as_ptr(),
                );
                if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
                    fprintf(
                        stderr,
                        b" (tid %d)\0" as *const u8 as *const libc::c_char,
                        (*lgl).tid,
                    );
                }
                fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
                fprintf(
                    stderr,
                    b"can not clone assignment of literal imported only by 'to'\0"
                        as *const u8 as *const libc::c_char,
                );
                fputc('\n' as i32, stderr);
                fflush(stderr);
                lglabort(lgl);
                exit(1 as libc::c_int);
            }
            lgleassign(lgl, (*extfrom).val() * eidx);
            cloned += 1;
            cloned;
        }
        eidx += 1;
        eidx;
    }
    lglcomputechanged(lgl);
    lglprt(
        lgl,
        1 as libc::c_int,
        b"[class] cloned %d assignments (%d changed)\0" as *const u8
            as *const libc::c_char,
        cloned,
        (*lgl).changed,
    );
    (*lgl).state = EXTENDED;
}
unsafe extern "C" fn lglnegass(mut lgl: *mut LGL) {
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut eassume: Stk = Stk {
        start: 0 as *mut libc::c_int,
        top: 0 as *mut libc::c_int,
        end: 0 as *mut libc::c_int,
    };
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 10], &[libc::c_char; 10]>(b"lglnegass\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).forked == 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 10], &[libc::c_char; 10]>(b"lglnegass\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"forked manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if !((*lgl).apitrace).is_null() {
        lgltrapi(lgl, b"negass\0" as *const u8 as *const libc::c_char);
    }
    if (*lgl).mt != 0 {
        return;
    }
    memset(
        &mut eassume as *mut Stk as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<Stk>() as libc::c_ulong,
    );
    p = (*lgl).eassume.start;
    while p < (*lgl).eassume.top as *const libc::c_int {
        lglpushstk(lgl, &mut eassume, *p);
        p = p.offset(1);
        p;
    }
    p = eassume.start;
    while p < eassume.top as *const libc::c_int {
        lgleadd(lgl, -*p);
        p = p.offset(1);
        p;
    }
    lgleadd(lgl, 0 as libc::c_int);
    p = eassume.start;
    while p < eassume.top as *const libc::c_int {
        lglassume(lgl, *p);
        p = p.offset(1);
        p;
    }
    lglrelstk(lgl, &mut eassume);
    lgluse(lgl);
    if !((*lgl).clone).is_null() {
        lglnegass((*lgl).clone);
    }
}
unsafe extern "C" fn lglcompactify(
    mut lgl: *mut LGL,
    mut res: libc::c_int,
) -> libc::c_int {
    if (*(*lgl).opts).compact.val == 0 {
        return 0 as libc::c_int;
    }
    if res == 0 {
        return 1 as libc::c_int;
    }
    if res == 20 as libc::c_int {
        return 1 as libc::c_int;
    }
    return ((*(*lgl).opts).compact.val >= 2 as libc::c_int) as libc::c_int;
}
unsafe extern "C" fn lglisat(
    mut lgl: *mut LGL,
    mut lim: *mut Lim,
    mut simpits: libc::c_int,
) -> libc::c_int {
    let mut res: libc::c_int = 0;
    let mut count: libc::c_int = 0;
    let mut reported: libc::c_int = (*(*lgl).stats).reported;
    lglreset(lgl);
    lglinitsolve(lgl);
    res = lglsolve(lgl, lim, 0 as libc::c_int);
    count = 0 as libc::c_int;
    while res == 0 && count < simpits {
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[simplification-%d] next forced simplification iteration %d\0" as *const u8
                as *const libc::c_char,
            (*(*lgl).stats).simp.count + 1 as libc::c_int,
            count + 1 as libc::c_int,
        );
        res = lglsolve(lgl, lim, 1 as libc::c_int);
        count += 1;
        count;
    }
    if lglcompactify(lgl, res) != 0 {
        lglcompact(lgl);
    }
    if res == 0 {
        (*lgl).state = UNKNOWN;
        lglrep(lgl, 1 as libc::c_int, '?' as i32 as libc::c_char);
    }
    if res == 10 as libc::c_int {
        (*lgl).state = SATISFIED;
        lglrep(lgl, 1 as libc::c_int, '1' as i32 as libc::c_char);
    }
    if res == 20 as libc::c_int {
        (*lgl).state = UNSATISFIED;
        (*lgl).level == 0 && (*lgl).mt == 0;
        lglrep(lgl, 1 as libc::c_int, '0' as i32 as libc::c_char);
    }
    if reported != (*(*lgl).stats).reported {
        lglflshrep(lgl);
    }
    if res == 10 as libc::c_int {
        lglextend(lgl);
    }
    return res;
}
#[no_mangle]
pub unsafe extern "C" fn lglunclone(
    mut lgl: *mut LGL,
    mut from: *mut LGL,
) -> libc::c_int {
    let mut res: libc::c_int = 0;
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 11], &[libc::c_char; 11]>(b"lglunclone\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).forked == 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 11], &[libc::c_char; 11]>(b"lglunclone\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"forked manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).mt != 0 {
        return 20 as libc::c_int;
    }
    if !from.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 11], &[libc::c_char; 11]>(b"lglunclone\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(
            stderr,
            b"uninitialized 'from' solver\0" as *const u8 as *const libc::c_char,
        );
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*from).mt != 0
        || (*from).state as libc::c_uint & UNSATISFIED as libc::c_int as libc::c_uint
            != 0
    {
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[unclone] unsatisfied state\0" as *const u8 as *const libc::c_char,
        );
        lglnegass(lgl);
        res = lglisat(lgl, 0 as *mut Lim, 0 as libc::c_int);
    } else if (*from).state as libc::c_uint
        & (SATISFIED as libc::c_int | EXTENDED as libc::c_int) as libc::c_uint != 0
    {
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[unclone] satisfied state\0" as *const u8 as *const libc::c_char,
        );
        lglclass(lgl, from);
        res = 10 as libc::c_int;
    } else {
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[unclone] unknown state\0" as *const u8 as *const libc::c_char,
        );
        lglreset(lgl);
        (*lgl).state = UNKNOWN;
        res = 0 as libc::c_int;
    }
    return res;
}
unsafe extern "C" fn lglchkclonesamestats(mut orig: *mut LGL) {}
unsafe extern "C" fn lglsetlim(mut lgl: *mut LGL, mut lim: *mut Lim) {
    let mut clim: int64_t = 0;
    let mut dlim: int64_t = 0;
    let mut plim: int64_t = 0;
    let mut confs: int64_t = 0;
    let mut decs: int64_t = 0;
    let mut props: int64_t = 0;
    let mut delay: int64_t = 0;
    let mut delayed: int64_t = 0;
    dlim = (*(*lgl).opts).dlim.val as int64_t;
    if dlim < 0 as libc::c_int as int64_t {
        (*lim).decs = -(1 as libc::c_int) as int64_t;
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[limits] no decision limit\0" as *const u8 as *const libc::c_char,
        );
    } else {
        decs = (*(*lgl).stats).decisions;
        (*lim)
            .decs = (if decs as libc::c_longlong
            >= 0x7fffffffffffffff as libc::c_longlong - dlim as libc::c_longlong
        {
            0x7fffffffffffffff as libc::c_longlong
        } else {
            (decs + dlim) as libc::c_longlong
        }) as int64_t;
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[limits] decision limit %lld after %lld decisions\0" as *const u8
                as *const libc::c_char,
            (*lim).decs as libc::c_longlong,
            decs as libc::c_longlong,
        );
    }
    clim = (*(*lgl).opts).clim.val as int64_t;
    if clim < 0 as libc::c_int as int64_t {
        (*lim).confs = -(1 as libc::c_int) as int64_t;
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[limits] no conflict limit\0" as *const u8 as *const libc::c_char,
        );
    } else {
        confs = (*(*lgl).stats).confs;
        (*lim)
            .confs = (if confs as libc::c_longlong
            >= 0x7fffffffffffffff as libc::c_longlong - clim as libc::c_longlong
        {
            0x7fffffffffffffff as libc::c_longlong
        } else {
            (confs + clim) as libc::c_longlong
        }) as int64_t;
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[limits] conflict limit %lld after %lld conflicts\0" as *const u8
                as *const libc::c_char,
            (*lim).confs as libc::c_longlong,
            confs as libc::c_longlong,
        );
    }
    plim = (*(*lgl).opts).plim.val as int64_t;
    if plim < 0 as libc::c_int as int64_t {
        (*lim).props = -(1 as libc::c_int) as int64_t;
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[limits] no propagation limit\0" as *const u8 as *const libc::c_char,
        );
    } else {
        plim *= 1000 as libc::c_int as int64_t;
        props = (*(*lgl).stats).props.search;
        (*lim)
            .props = (if props as libc::c_longlong
            >= 0x7fffffffffffffff as libc::c_longlong - plim as libc::c_longlong
        {
            0x7fffffffffffffff as libc::c_longlong
        } else {
            (props + plim) as libc::c_longlong
        }) as int64_t;
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[limits] propagation limit %lld after %lld propagations\0" as *const u8
                as *const libc::c_char,
            (*lim).props as libc::c_longlong,
            props as libc::c_longlong,
        );
    }
    delay = (*(*lgl).opts).simpinitdelay.val as int64_t;
    if delay > 0 as libc::c_int as int64_t {
        delayed = (*(*lgl).stats).confs + delay;
        if delayed > (*(*lgl).limits).simp.confs {
            (*(*lgl).limits).simp.confs = delayed;
            lglsethardsimplim(lgl);
            lglprt(
                lgl,
                1 as libc::c_int,
                b"[limits] simplification delayed by %lld to %lld conflicts (hard %lld)\0"
                    as *const u8 as *const libc::c_char,
                delay as libc::c_longlong,
                (*(*lgl).limits).simp.confs as libc::c_longlong,
                (*(*lgl).limits).simp.hard as libc::c_longlong,
            );
        } else {
            lglprt(
                lgl,
                1 as libc::c_int,
                b"[limits] simplification conflict limit already exceeds delay\0"
                    as *const u8 as *const libc::c_char,
            );
        }
    } else {
        lglprt(
            lgl,
            1 as libc::c_int,
            b"[limits] simplification not delayed since 'simpdelay' zero\0" as *const u8
                as *const libc::c_char,
        );
    };
}
#[no_mangle]
pub unsafe extern "C" fn lglsat(mut lgl: *mut LGL) -> libc::c_int {
    let mut res: libc::c_int = 0;
    let mut lim: Lim = Lim { confs: 0, decs: 0, props: 0 };
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 7], &[libc::c_char; 7]>(b"lglsat\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).forked == 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 7], &[libc::c_char; 7]>(b"lglsat\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"forked manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if !((*lgl).apitrace).is_null() {
        lgltrapi(lgl, b"sat\0" as *const u8 as *const libc::c_char);
    }
    lglstart(lgl, &mut (*(*lgl).times).all);
    (*(*lgl).stats).calls.sat += 1;
    (*(*lgl).stats).calls.sat;
    if lglmtstk(&mut (*lgl).clause) != 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 7], &[libc::c_char; 7]>(b"lglsat\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(
            stderr,
            b"clause terminating zero missing\0" as *const u8 as *const libc::c_char,
        );
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    lglfreezer(lgl);
    lglsetlim(lgl, &mut lim);
    res = lglisat(lgl, &mut lim, 0 as libc::c_int);
    lglstop(lgl);
    if !((*lgl).apitrace).is_null() {
        lgltrapi(lgl, b"return %d\0" as *const u8 as *const libc::c_char, res);
    }
    let mut CLONERES: libc::c_int = 0;
    if !((*lgl).clone).is_null() {
        CLONERES = lglsat((*lgl).clone);
        if !(CLONERES != res) {} else {
            fprintf(
                stderr,
                b"*** API usage error of '%s' in '%s'\0" as *const u8
                    as *const libc::c_char,
                b"lglib.c\0" as *const u8 as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 7], &[libc::c_char; 7]>(b"lglsat\0"))
                    .as_ptr(),
            );
            if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
                fprintf(
                    stderr,
                    b" (tid %d)\0" as *const u8 as *const libc::c_char,
                    (*lgl).tid,
                );
            }
            fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
            fprintf(
                stderr,
                b"%s (lgl->clone) = %d differs from %s (lgl) = %d\0" as *const u8
                    as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 7], &[libc::c_char; 7]>(b"lglsat\0"))
                    .as_ptr(),
                CLONERES,
                (*::core::mem::transmute::<&[u8; 7], &[libc::c_char; 7]>(b"lglsat\0"))
                    .as_ptr(),
                res,
            );
            fputc('\n' as i32, stderr);
            fflush(stderr);
            lglabort(lgl);
            exit(1 as libc::c_int);
        }
        if !((*lgl).clone).is_null() {
            lglchkclonesamestats(lgl);
        }
    }
    return res;
}
#[no_mangle]
pub unsafe extern "C" fn lglookahead(mut lgl: *mut LGL) -> libc::c_int {
    let mut ilit: libc::c_int = 0;
    let mut res: libc::c_int = 0;
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 12], &[libc::c_char; 12]>(b"lglookahead\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).forked == 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 12], &[libc::c_char; 12]>(b"lglookahead\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"forked manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if !((*lgl).apitrace).is_null() {
        lgltrapi(lgl, b"lkhd\0" as *const u8 as *const libc::c_char);
    }
    if lglmtstk(&mut (*lgl).eassume) != 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 12], &[libc::c_char; 12]>(b"lglookahead\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(
            stderr,
            b"imcompatible with 'lglassume'\0" as *const u8 as *const libc::c_char,
        );
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if lglmtstk(&mut (*lgl).clause) != 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 12], &[libc::c_char; 12]>(b"lglookahead\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(
            stderr,
            b"clause terminating zero missing\0" as *const u8 as *const libc::c_char,
        );
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if !((*(*lgl).opts).druplig.val != 0 && (*(*lgl).opts).lkhd.val == 2 as libc::c_int)
    {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 12], &[libc::c_char; 12]>(b"lglookahead\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(
            stderr,
            b"can not use tree based look ahead while Druplig is enabled\0" as *const u8
                as *const libc::c_char,
        );
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    lglstart(lgl, &mut (*(*lgl).times).all);
    lglstart(lgl, &mut (*(*lgl).times).lookahead);
    (*(*lgl).stats).calls.lkhd += 1;
    (*(*lgl).stats).calls.lkhd;
    lglreset(lgl);
    (*lgl).lkhd = 1 as libc::c_int as libc::c_char;
    lglfreezer(lgl);
    if (*lgl).level != 0 {
        lglbacktrack(lgl, 0 as libc::c_int);
    }
    if (*lgl).mt == 0 && lglbcp(lgl) != 0 {
        ilit = 0 as libc::c_int;
        if (*(*lgl).opts).lkhd.val == 2 as libc::c_int && lglsmallirr(lgl) == 0 {
            ilit = lgljwhlook(lgl);
        } else {
            match (*(*lgl).opts).lkhd.val {
                -1 => {
                    ilit = lglocslook(lgl);
                }
                0 => {
                    ilit = lglislook(lgl);
                }
                1 => {
                    ilit = lgljwhlook(lgl);
                }
                2 => {
                    lgltreelookaux(lgl, &mut ilit) == 0;
                }
                3 => {
                    ilit = lglsumlenlook(lgl);
                }
                4 | _ => {
                    ilit = lglrelevancelook(lgl);
                }
            }
        }
        res = if (*lgl).mt == 0 && ilit != 0 {
            lglexport(lgl, ilit)
        } else {
            0 as libc::c_int
        };
    } else {
        lglmt(lgl);
        res = 0 as libc::c_int;
    }
    (*lgl).lkhd = 0 as libc::c_int as libc::c_char;
    lglstop(lgl);
    lglstop(lgl);
    (*lgl).state = LOOKED;
    if !((*lgl).apitrace).is_null() {
        lgltrapi(lgl, b"return %d\0" as *const u8 as *const libc::c_char, res);
    }
    let mut CLONERES: libc::c_int = 0;
    if !((*lgl).clone).is_null() {
        CLONERES = lglookahead((*lgl).clone);
        if !(CLONERES != res) {} else {
            fprintf(
                stderr,
                b"*** API usage error of '%s' in '%s'\0" as *const u8
                    as *const libc::c_char,
                b"lglib.c\0" as *const u8 as *const libc::c_char,
                (*::core::mem::transmute::<
                    &[u8; 12],
                    &[libc::c_char; 12],
                >(b"lglookahead\0"))
                    .as_ptr(),
            );
            if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
                fprintf(
                    stderr,
                    b" (tid %d)\0" as *const u8 as *const libc::c_char,
                    (*lgl).tid,
                );
            }
            fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
            fprintf(
                stderr,
                b"%s (lgl->clone) = %d differs from %s (lgl) = %d\0" as *const u8
                    as *const libc::c_char,
                (*::core::mem::transmute::<
                    &[u8; 12],
                    &[libc::c_char; 12],
                >(b"lglookahead\0"))
                    .as_ptr(),
                CLONERES,
                (*::core::mem::transmute::<
                    &[u8; 12],
                    &[libc::c_char; 12],
                >(b"lglookahead\0"))
                    .as_ptr(),
                res,
            );
            fputc('\n' as i32, stderr);
            fflush(stderr);
            lglabort(lgl);
            exit(1 as libc::c_int);
        }
        if !((*lgl).clone).is_null() {
            lglchkclonesamestats(lgl);
        }
    }
    return res;
}
#[no_mangle]
pub unsafe extern "C" fn lglchanged(mut lgl: *mut LGL) -> libc::c_int {
    let mut res: libc::c_int = 0;
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 11], &[libc::c_char; 11]>(b"lglchanged\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).forked == 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 11], &[libc::c_char; 11]>(b"lglchanged\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"forked manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if !((*lgl).apitrace).is_null() {
        lgltrapi(lgl, b"changed\0" as *const u8 as *const libc::c_char);
    }
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 11], &[libc::c_char; 11]>(b"lglchanged\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).state as libc::c_uint & EXTENDED as libc::c_int as libc::c_uint != 0
    {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 11], &[libc::c_char; 11]>(b"lglchanged\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(
            stderr,
            b"!(%s)\0" as *const u8 as *const libc::c_char,
            b"EXTENDED\0" as *const u8 as *const libc::c_char,
        );
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    res = (*lgl).changed;
    if !((*lgl).apitrace).is_null() {
        lgltrapi(lgl, b"return %d\0" as *const u8 as *const libc::c_char, res);
    }
    let mut CLONERES: libc::c_int = 0;
    if !((*lgl).clone).is_null() {
        CLONERES = lglchanged((*lgl).clone);
        if !(CLONERES != res) {} else {
            fprintf(
                stderr,
                b"*** API usage error of '%s' in '%s'\0" as *const u8
                    as *const libc::c_char,
                b"lglib.c\0" as *const u8 as *const libc::c_char,
                (*::core::mem::transmute::<
                    &[u8; 11],
                    &[libc::c_char; 11],
                >(b"lglchanged\0"))
                    .as_ptr(),
            );
            if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
                fprintf(
                    stderr,
                    b" (tid %d)\0" as *const u8 as *const libc::c_char,
                    (*lgl).tid,
                );
            }
            fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
            fprintf(
                stderr,
                b"%s (lgl->clone) = %d differs from %s (lgl) = %d\0" as *const u8
                    as *const libc::c_char,
                (*::core::mem::transmute::<
                    &[u8; 11],
                    &[libc::c_char; 11],
                >(b"lglchanged\0"))
                    .as_ptr(),
                CLONERES,
                (*::core::mem::transmute::<
                    &[u8; 11],
                    &[libc::c_char; 11],
                >(b"lglchanged\0"))
                    .as_ptr(),
                res,
            );
            fputc('\n' as i32, stderr);
            fflush(stderr);
            lglabort(lgl);
            exit(1 as libc::c_int);
        }
        if !((*lgl).clone).is_null() {
            lglchkclonesamestats(lgl);
        }
    }
    return res;
}
#[no_mangle]
pub unsafe extern "C" fn lglsimp(
    mut lgl: *mut LGL,
    mut iterations: libc::c_int,
) -> libc::c_int {
    let mut lim: Lim = Lim { confs: 0, decs: 0, props: 0 };
    let mut res: libc::c_int = 0;
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 8], &[libc::c_char; 8]>(b"lglsimp\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).forked == 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 8], &[libc::c_char; 8]>(b"lglsimp\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"forked manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if !((*lgl).apitrace).is_null() {
        lgltrapi(lgl, b"simp %d\0" as *const u8 as *const libc::c_char, iterations);
    }
    if !(iterations < 0 as libc::c_int) {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 8], &[libc::c_char; 8]>(b"lglsimp\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(
            stderr,
            b"negative number of simplification iterations\0" as *const u8
                as *const libc::c_char,
        );
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if lglmtstk(&mut (*lgl).clause) != 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 8], &[libc::c_char; 8]>(b"lglsimp\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(
            stderr,
            b"clause terminating zero missing\0" as *const u8 as *const libc::c_char,
        );
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    lglstart(lgl, &mut (*(*lgl).times).all);
    (*(*lgl).stats).calls.simp += 1;
    (*(*lgl).stats).calls.simp;
    lglfreezer(lgl);
    memset(
        &mut lim as *mut Lim as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<Lim>() as libc::c_ulong,
    );
    lim.decs = (*(*lgl).stats).decisions;
    res = lglisat(lgl, &mut lim, iterations);
    lglstop(lgl);
    if !((*lgl).apitrace).is_null() {
        lgltrapi(lgl, b"return %d\0" as *const u8 as *const libc::c_char, res);
    }
    let mut CLONERES: libc::c_int = 0;
    if !((*lgl).clone).is_null() {
        CLONERES = lglsimp((*lgl).clone, iterations);
        if !(CLONERES != res) {} else {
            fprintf(
                stderr,
                b"*** API usage error of '%s' in '%s'\0" as *const u8
                    as *const libc::c_char,
                b"lglib.c\0" as *const u8 as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 8], &[libc::c_char; 8]>(b"lglsimp\0"))
                    .as_ptr(),
            );
            if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
                fprintf(
                    stderr,
                    b" (tid %d)\0" as *const u8 as *const libc::c_char,
                    (*lgl).tid,
                );
            }
            fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
            fprintf(
                stderr,
                b"%s (lgl->clone, %d) = %d differs from %s (lgl, %d) = %d\0" as *const u8
                    as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 8], &[libc::c_char; 8]>(b"lglsimp\0"))
                    .as_ptr(),
                iterations,
                CLONERES,
                (*::core::mem::transmute::<&[u8; 8], &[libc::c_char; 8]>(b"lglsimp\0"))
                    .as_ptr(),
                iterations,
                res,
            );
            fputc('\n' as i32, stderr);
            fflush(stderr);
            lglabort(lgl);
            exit(1 as libc::c_int);
        }
        if !((*lgl).clone).is_null() {
            lglchkclonesamestats(lgl);
        }
    }
    return res;
}
#[no_mangle]
pub unsafe extern "C" fn lglmaxvar(mut lgl: *mut LGL) -> libc::c_int {
    let mut res: libc::c_int = 0;
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 10], &[libc::c_char; 10]>(b"lglmaxvar\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).forked == 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 10], &[libc::c_char; 10]>(b"lglmaxvar\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"forked manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if !((*lgl).apitrace).is_null() {
        lgltrapi(lgl, b"maxvar\0" as *const u8 as *const libc::c_char);
    }
    res = (*lgl).maxext;
    if !((*lgl).apitrace).is_null() {
        lgltrapi(lgl, b"return %d\0" as *const u8 as *const libc::c_char, res);
    }
    let mut CLONERES: libc::c_int = 0;
    if !((*lgl).clone).is_null() {
        CLONERES = lglmaxvar((*lgl).clone);
        if !(CLONERES != res) {} else {
            fprintf(
                stderr,
                b"*** API usage error of '%s' in '%s'\0" as *const u8
                    as *const libc::c_char,
                b"lglib.c\0" as *const u8 as *const libc::c_char,
                (*::core::mem::transmute::<
                    &[u8; 10],
                    &[libc::c_char; 10],
                >(b"lglmaxvar\0"))
                    .as_ptr(),
            );
            if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
                fprintf(
                    stderr,
                    b" (tid %d)\0" as *const u8 as *const libc::c_char,
                    (*lgl).tid,
                );
            }
            fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
            fprintf(
                stderr,
                b"%s (lgl->clone) = %d differs from %s (lgl) = %d\0" as *const u8
                    as *const libc::c_char,
                (*::core::mem::transmute::<
                    &[u8; 10],
                    &[libc::c_char; 10],
                >(b"lglmaxvar\0"))
                    .as_ptr(),
                CLONERES,
                (*::core::mem::transmute::<
                    &[u8; 10],
                    &[libc::c_char; 10],
                >(b"lglmaxvar\0"))
                    .as_ptr(),
                res,
            );
            fputc('\n' as i32, stderr);
            fflush(stderr);
            lglabort(lgl);
            exit(1 as libc::c_int);
        }
        if !((*lgl).clone).is_null() {
            lglchkclonesamestats(lgl);
        }
    }
    return res;
}
#[no_mangle]
pub unsafe extern "C" fn lglincvar(mut lgl: *mut LGL) -> libc::c_int {
    let mut res: libc::c_int = 0;
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 10], &[libc::c_char; 10]>(b"lglincvar\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).forked == 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 10], &[libc::c_char; 10]>(b"lglincvar\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"forked manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if !((*lgl).apitrace).is_null() {
        lgltrapi(lgl, b"incvar\0" as *const u8 as *const libc::c_char);
    }
    res = (*lgl).maxext + 1 as libc::c_int;
    lglimport(lgl, res);
    if !((*lgl).apitrace).is_null() {
        lgltrapi(lgl, b"return %d\0" as *const u8 as *const libc::c_char, res);
    }
    let mut CLONERES: libc::c_int = 0;
    if !((*lgl).clone).is_null() {
        CLONERES = lglincvar((*lgl).clone);
        if !(CLONERES != res) {} else {
            fprintf(
                stderr,
                b"*** API usage error of '%s' in '%s'\0" as *const u8
                    as *const libc::c_char,
                b"lglib.c\0" as *const u8 as *const libc::c_char,
                (*::core::mem::transmute::<
                    &[u8; 10],
                    &[libc::c_char; 10],
                >(b"lglincvar\0"))
                    .as_ptr(),
            );
            if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
                fprintf(
                    stderr,
                    b" (tid %d)\0" as *const u8 as *const libc::c_char,
                    (*lgl).tid,
                );
            }
            fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
            fprintf(
                stderr,
                b"%s (lgl->clone) = %d differs from %s (lgl) = %d\0" as *const u8
                    as *const libc::c_char,
                (*::core::mem::transmute::<
                    &[u8; 10],
                    &[libc::c_char; 10],
                >(b"lglincvar\0"))
                    .as_ptr(),
                CLONERES,
                (*::core::mem::transmute::<
                    &[u8; 10],
                    &[libc::c_char; 10],
                >(b"lglincvar\0"))
                    .as_ptr(),
                res,
            );
            fputc('\n' as i32, stderr);
            fflush(stderr);
            lglabort(lgl);
            exit(1 as libc::c_int);
        }
        if !((*lgl).clone).is_null() {
            lglchkclonesamestats(lgl);
        }
    }
    return res;
}
#[no_mangle]
pub unsafe extern "C" fn lglderef(
    mut lgl: *mut LGL,
    mut elit: libc::c_int,
) -> libc::c_int {
    let mut res: libc::c_int = 0;
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 9], &[libc::c_char; 9]>(b"lglderef\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if !((*lgl).apitrace).is_null() {
        lgltrapi(lgl, b"deref %d\0" as *const u8 as *const libc::c_char, elit);
    }
    (*(*lgl).stats).calls.deref += 1;
    (*(*lgl).stats).calls.deref;
    if elit != 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 9], &[libc::c_char; 9]>(b"lglderef\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(
            stderr,
            b"can not deref zero literal\0" as *const u8 as *const libc::c_char,
        );
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 9], &[libc::c_char; 9]>(b"lglderef\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).state as libc::c_uint
        & (SATISFIED as libc::c_int | EXTENDED as libc::c_int) as libc::c_uint != 0
    {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 9], &[libc::c_char; 9]>(b"lglderef\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(
            stderr,
            b"!(%s)\0" as *const u8 as *const libc::c_char,
            b"SATISFIED | EXTENDED\0" as *const u8 as *const libc::c_char,
        );
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).state as libc::c_uint & EXTENDED as libc::c_int as libc::c_uint == 0 {
        lglextend(lgl);
    }
    res = lglederef(lgl, elit);
    if !((*lgl).apitrace).is_null() {
        lgltrapi(lgl, b"return %d\0" as *const u8 as *const libc::c_char, res);
    }
    let mut CLONERES: libc::c_int = 0;
    if !((*lgl).clone).is_null() {
        CLONERES = lglderef((*lgl).clone, elit);
        if !(CLONERES != res) {} else {
            fprintf(
                stderr,
                b"*** API usage error of '%s' in '%s'\0" as *const u8
                    as *const libc::c_char,
                b"lglib.c\0" as *const u8 as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 9], &[libc::c_char; 9]>(b"lglderef\0"))
                    .as_ptr(),
            );
            if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
                fprintf(
                    stderr,
                    b" (tid %d)\0" as *const u8 as *const libc::c_char,
                    (*lgl).tid,
                );
            }
            fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
            fprintf(
                stderr,
                b"%s (lgl->clone, %d) = %d differs from %s (lgl, %d) = %d\0" as *const u8
                    as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 9], &[libc::c_char; 9]>(b"lglderef\0"))
                    .as_ptr(),
                elit,
                CLONERES,
                (*::core::mem::transmute::<&[u8; 9], &[libc::c_char; 9]>(b"lglderef\0"))
                    .as_ptr(),
                elit,
                res,
            );
            fputc('\n' as i32, stderr);
            fflush(stderr);
            lglabort(lgl);
            exit(1 as libc::c_int);
        }
        if !((*lgl).clone).is_null() {
            lglchkclonesamestats(lgl);
        }
    }
    return res;
}
#[no_mangle]
pub unsafe extern "C" fn lglfailed(
    mut lgl: *mut LGL,
    mut elit: libc::c_int,
) -> libc::c_int {
    let mut bit: libc::c_uint = 0;
    let mut ext: *mut Ext = 0 as *mut Ext;
    let mut res: libc::c_int = 0;
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 10], &[libc::c_char; 10]>(b"lglfailed\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).forked == 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 10], &[libc::c_char; 10]>(b"lglfailed\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"forked manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if !((*lgl).apitrace).is_null() {
        lgltrapi(lgl, b"failed %d\0" as *const u8 as *const libc::c_char, elit);
    }
    (*(*lgl).stats).calls.failed += 1;
    (*(*lgl).stats).calls.failed;
    if elit != 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 10], &[libc::c_char; 10]>(b"lglfailed\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(
            stderr,
            b"can not check zero failed literal\0" as *const u8 as *const libc::c_char,
        );
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 10], &[libc::c_char; 10]>(b"lglfailed\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).state as libc::c_uint
        & (UNSATISFIED as libc::c_int | FAILED as libc::c_int) as libc::c_uint != 0
    {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 10], &[libc::c_char; 10]>(b"lglfailed\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(
            stderr,
            b"!(%s)\0" as *const u8 as *const libc::c_char,
            b"UNSATISFIED | FAILED\0" as *const u8 as *const libc::c_char,
        );
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if !(abs(elit) > (*lgl).maxext) {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 10], &[libc::c_char; 10]>(b"lglfailed\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(
            stderr,
            b"can not check unimported failed literal\0" as *const u8
                as *const libc::c_char,
        );
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    ext = lglelit2ext(lgl, elit);
    bit = (1 as libc::c_uint) << (elit < 0 as libc::c_int) as libc::c_int;
    if (*ext).assumed() & bit != 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 10], &[libc::c_char; 10]>(b"lglfailed\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(
            stderr,
            b"can not check unassumed failed literal\0" as *const u8
                as *const libc::c_char,
        );
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).state as libc::c_uint & FAILED as libc::c_int as libc::c_uint == 0 {
        lglstart(lgl, &mut (*(*lgl).times).all);
        lglanafailed(lgl);
        lglstop(lgl);
    }
    res = ((*ext).failed() & bit != 0 as libc::c_int as libc::c_uint) as libc::c_int;
    if !((*lgl).apitrace).is_null() {
        lgltrapi(lgl, b"return %d\0" as *const u8 as *const libc::c_char, res);
    }
    let mut CLONERES: libc::c_int = 0;
    if !((*lgl).clone).is_null() {
        CLONERES = lglfailed((*lgl).clone, elit);
        if !(CLONERES != res) {} else {
            fprintf(
                stderr,
                b"*** API usage error of '%s' in '%s'\0" as *const u8
                    as *const libc::c_char,
                b"lglib.c\0" as *const u8 as *const libc::c_char,
                (*::core::mem::transmute::<
                    &[u8; 10],
                    &[libc::c_char; 10],
                >(b"lglfailed\0"))
                    .as_ptr(),
            );
            if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
                fprintf(
                    stderr,
                    b" (tid %d)\0" as *const u8 as *const libc::c_char,
                    (*lgl).tid,
                );
            }
            fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
            fprintf(
                stderr,
                b"%s (lgl->clone, %d) = %d differs from %s (lgl, %d) = %d\0" as *const u8
                    as *const libc::c_char,
                (*::core::mem::transmute::<
                    &[u8; 10],
                    &[libc::c_char; 10],
                >(b"lglfailed\0"))
                    .as_ptr(),
                elit,
                CLONERES,
                (*::core::mem::transmute::<
                    &[u8; 10],
                    &[libc::c_char; 10],
                >(b"lglfailed\0"))
                    .as_ptr(),
                elit,
                res,
            );
            fputc('\n' as i32, stderr);
            fflush(stderr);
            lglabort(lgl);
            exit(1 as libc::c_int);
        }
        if !((*lgl).clone).is_null() {
            lglchkclonesamestats(lgl);
        }
    }
    return res;
}
#[no_mangle]
pub unsafe extern "C" fn lglinconsistent(mut lgl: *mut LGL) -> libc::c_int {
    let mut res: libc::c_int = 0;
    if !((*lgl).apitrace).is_null() {
        lgltrapi(lgl, b"inconsistent\0" as *const u8 as *const libc::c_char);
    }
    res = ((*lgl).mt != 0 as libc::c_int) as libc::c_int;
    if !((*lgl).apitrace).is_null() {
        lgltrapi(lgl, b"return %d\0" as *const u8 as *const libc::c_char, res);
    }
    let mut CLONERES: libc::c_int = 0;
    if !((*lgl).clone).is_null() {
        CLONERES = lglinconsistent((*lgl).clone);
        if !(CLONERES != res) {} else {
            fprintf(
                stderr,
                b"*** API usage error of '%s' in '%s'\0" as *const u8
                    as *const libc::c_char,
                b"lglib.c\0" as *const u8 as *const libc::c_char,
                (*::core::mem::transmute::<
                    &[u8; 16],
                    &[libc::c_char; 16],
                >(b"lglinconsistent\0"))
                    .as_ptr(),
            );
            if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
                fprintf(
                    stderr,
                    b" (tid %d)\0" as *const u8 as *const libc::c_char,
                    (*lgl).tid,
                );
            }
            fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
            fprintf(
                stderr,
                b"%s (lgl->clone) = %d differs from %s (lgl) = %d\0" as *const u8
                    as *const libc::c_char,
                (*::core::mem::transmute::<
                    &[u8; 16],
                    &[libc::c_char; 16],
                >(b"lglinconsistent\0"))
                    .as_ptr(),
                CLONERES,
                (*::core::mem::transmute::<
                    &[u8; 16],
                    &[libc::c_char; 16],
                >(b"lglinconsistent\0"))
                    .as_ptr(),
                res,
            );
            fputc('\n' as i32, stderr);
            fflush(stderr);
            lglabort(lgl);
            exit(1 as libc::c_int);
        }
        if !((*lgl).clone).is_null() {
            lglchkclonesamestats(lgl);
        }
    }
    return res;
}
unsafe extern "C" fn lglefixed(mut lgl: *mut LGL, mut elit: libc::c_int) -> libc::c_int {
    let mut res: libc::c_int = 0;
    let mut ilit: libc::c_int = 0;
    if abs(elit) > (*lgl).maxext {
        return 0 as libc::c_int;
    }
    ilit = lglimport(lgl, elit);
    if ilit == 0 {
        res = 0 as libc::c_int;
    } else if abs(ilit) == 1 as libc::c_int {
        res = ilit;
    } else {
        res = lglifixed(lgl, ilit) as libc::c_int;
    }
    return res;
}
#[no_mangle]
pub unsafe extern "C" fn lglfixed(
    mut lgl: *mut LGL,
    mut elit: libc::c_int,
) -> libc::c_int {
    let mut res: libc::c_int = 0;
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 9], &[libc::c_char; 9]>(b"lglfixed\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).forked == 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 9], &[libc::c_char; 9]>(b"lglfixed\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"forked manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if !((*lgl).apitrace).is_null() {
        lgltrapi(lgl, b"fixed %d\0" as *const u8 as *const libc::c_char, elit);
    }
    (*(*lgl).stats).calls.fixed += 1;
    (*(*lgl).stats).calls.fixed;
    if elit != 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 9], &[libc::c_char; 9]>(b"lglfixed\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(
            stderr,
            b"can not deref zero literal\0" as *const u8 as *const libc::c_char,
        );
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    res = lglefixed(lgl, elit);
    if !((*lgl).apitrace).is_null() {
        lgltrapi(lgl, b"return %d\0" as *const u8 as *const libc::c_char, res);
    }
    let mut CLONERES: libc::c_int = 0;
    if !((*lgl).clone).is_null() {
        CLONERES = lglfixed((*lgl).clone, elit);
        if !(CLONERES != res) {} else {
            fprintf(
                stderr,
                b"*** API usage error of '%s' in '%s'\0" as *const u8
                    as *const libc::c_char,
                b"lglib.c\0" as *const u8 as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 9], &[libc::c_char; 9]>(b"lglfixed\0"))
                    .as_ptr(),
            );
            if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
                fprintf(
                    stderr,
                    b" (tid %d)\0" as *const u8 as *const libc::c_char,
                    (*lgl).tid,
                );
            }
            fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
            fprintf(
                stderr,
                b"%s (lgl->clone, %d) = %d differs from %s (lgl, %d) = %d\0" as *const u8
                    as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 9], &[libc::c_char; 9]>(b"lglfixed\0"))
                    .as_ptr(),
                elit,
                CLONERES,
                (*::core::mem::transmute::<&[u8; 9], &[libc::c_char; 9]>(b"lglfixed\0"))
                    .as_ptr(),
                elit,
                res,
            );
            fputc('\n' as i32, stderr);
            fflush(stderr);
            lglabort(lgl);
            exit(1 as libc::c_int);
        }
        if !((*lgl).clone).is_null() {
            lglchkclonesamestats(lgl);
        }
    }
    return res;
}
#[no_mangle]
pub unsafe extern "C" fn lglrepr(
    mut lgl: *mut LGL,
    mut elit: libc::c_int,
) -> libc::c_int {
    let mut res: libc::c_int = 0;
    let mut eidx: libc::c_int = abs(elit);
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 8], &[libc::c_char; 8]>(b"lglrepr\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).forked == 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 8], &[libc::c_char; 8]>(b"lglrepr\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"forked manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if !((*lgl).apitrace).is_null() {
        lgltrapi(lgl, b"repr %d\0" as *const u8 as *const libc::c_char, elit);
    }
    (*(*lgl).stats).calls.repr += 1;
    (*(*lgl).stats).calls.repr;
    if eidx > (*lgl).maxext {
        res = elit;
    } else {
        res = lglerepr(lgl, elit);
    }
    if !((*lgl).apitrace).is_null() {
        lgltrapi(lgl, b"return %d\0" as *const u8 as *const libc::c_char, res);
    }
    let mut CLONERES: libc::c_int = 0;
    if !((*lgl).clone).is_null() {
        CLONERES = lglrepr((*lgl).clone, elit);
        if !(CLONERES != res) {} else {
            fprintf(
                stderr,
                b"*** API usage error of '%s' in '%s'\0" as *const u8
                    as *const libc::c_char,
                b"lglib.c\0" as *const u8 as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 8], &[libc::c_char; 8]>(b"lglrepr\0"))
                    .as_ptr(),
            );
            if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
                fprintf(
                    stderr,
                    b" (tid %d)\0" as *const u8 as *const libc::c_char,
                    (*lgl).tid,
                );
            }
            fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
            fprintf(
                stderr,
                b"%s (lgl->clone, %d) = %d differs from %s (lgl, %d) = %d\0" as *const u8
                    as *const libc::c_char,
                (*::core::mem::transmute::<&[u8; 8], &[libc::c_char; 8]>(b"lglrepr\0"))
                    .as_ptr(),
                elit,
                CLONERES,
                (*::core::mem::transmute::<&[u8; 8], &[libc::c_char; 8]>(b"lglrepr\0"))
                    .as_ptr(),
                elit,
                res,
            );
            fputc('\n' as i32, stderr);
            fflush(stderr);
            lglabort(lgl);
            exit(1 as libc::c_int);
        }
        if !((*lgl).clone).is_null() {
            lglchkclonesamestats(lgl);
        }
    }
    return res;
}
#[no_mangle]
pub unsafe extern "C" fn lglfreeze(mut lgl: *mut LGL, mut elit: libc::c_int) {
    let mut ext: *mut Ext = 0 as *mut Ext;
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 10], &[libc::c_char; 10]>(b"lglfreeze\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).forked == 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 10], &[libc::c_char; 10]>(b"lglfreeze\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"forked manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if !((*lgl).apitrace).is_null() {
        lgltrapi(lgl, b"freeze %d\0" as *const u8 as *const libc::c_char, elit);
    }
    (*(*lgl).stats).calls.freeze += 1;
    (*(*lgl).stats).calls.freeze;
    if elit != 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 10], &[libc::c_char; 10]>(b"lglfreeze\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(
            stderr,
            b"can not freeze zero literal\0" as *const u8 as *const libc::c_char,
        );
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 10], &[libc::c_char; 10]>(b"lglfreeze\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).state as libc::c_uint
        & (UNUSED as libc::c_int | OPTSET as libc::c_int | USED as libc::c_int
            | RESET as libc::c_int | SATISFIED as libc::c_int
            | UNSATISFIED as libc::c_int | FAILED as libc::c_int | LOOKED as libc::c_int
            | UNKNOWN as libc::c_int | EXTENDED as libc::c_int) as libc::c_uint != 0
    {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 10], &[libc::c_char; 10]>(b"lglfreeze\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(
            stderr,
            b"!(%s)\0" as *const u8 as *const libc::c_char,
            b"UNUSED|OPTSET|USED|RESET|SATISFIED|UNSATISFIED|FAILED|LOOKED| UNKNOWN|EXTENDED\0"
                as *const u8 as *const libc::c_char,
        );
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    lglimport(lgl, elit);
    ext = lglelit2ext(lgl, elit);
    if (*ext).melted() == 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 10], &[libc::c_char; 10]>(b"lglfreeze\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(
            stderr,
            b"freezing melted literal %d\0" as *const u8 as *const libc::c_char,
            elit,
        );
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if !((*ext).frozen == 2147483647 as libc::c_int) {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 10], &[libc::c_char; 10]>(b"lglfreeze\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(
            stderr,
            b"literal %d frozen too often\0" as *const u8 as *const libc::c_char,
            elit,
        );
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    (*ext).frozen += 1;
    (*ext).frozen;
    if (*ext).frozen == 0 {
        (*(*lgl).stats).irrprgss += 1;
        (*(*lgl).stats).irrprgss;
        lglmelter(lgl);
    }
    if !((*lgl).clone).is_null() {
        lglfreeze((*lgl).clone, elit);
    }
}
#[no_mangle]
pub unsafe extern "C" fn lglfrozen(
    mut lgl: *mut LGL,
    mut elit: libc::c_int,
) -> libc::c_int {
    let mut ext: *mut Ext = 0 as *mut Ext;
    let mut res: libc::c_int = 0;
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 10], &[libc::c_char; 10]>(b"lglfrozen\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).forked == 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 10], &[libc::c_char; 10]>(b"lglfrozen\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"forked manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if !((*lgl).apitrace).is_null() {
        lgltrapi(lgl, b"frozen %d\0" as *const u8 as *const libc::c_char, elit);
    }
    if elit != 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 10], &[libc::c_char; 10]>(b"lglfrozen\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(
            stderr,
            b"can not check zero literal for being frozen\0" as *const u8
                as *const libc::c_char,
        );
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if abs(elit) > (*lgl).maxext {
        res = 2147483647 as libc::c_int;
    } else {
        ext = lglelit2ext(lgl, elit);
        if (*ext).imported() == 0 {
            res = 2147483647 as libc::c_int;
        } else {
            res = (*ext).frozen;
        }
    }
    if !((*lgl).apitrace).is_null() {
        lgltrapi(lgl, b"return %d\0" as *const u8 as *const libc::c_char, res);
    }
    let mut CLONERES: libc::c_int = 0;
    if !((*lgl).clone).is_null() {
        CLONERES = lglfrozen((*lgl).clone, elit);
        if !(CLONERES != res) {} else {
            fprintf(
                stderr,
                b"*** API usage error of '%s' in '%s'\0" as *const u8
                    as *const libc::c_char,
                b"lglib.c\0" as *const u8 as *const libc::c_char,
                (*::core::mem::transmute::<
                    &[u8; 10],
                    &[libc::c_char; 10],
                >(b"lglfrozen\0"))
                    .as_ptr(),
            );
            if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
                fprintf(
                    stderr,
                    b" (tid %d)\0" as *const u8 as *const libc::c_char,
                    (*lgl).tid,
                );
            }
            fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
            fprintf(
                stderr,
                b"%s (lgl->clone, %d) = %d differs from %s (lgl, %d) = %d\0" as *const u8
                    as *const libc::c_char,
                (*::core::mem::transmute::<
                    &[u8; 10],
                    &[libc::c_char; 10],
                >(b"lglfrozen\0"))
                    .as_ptr(),
                elit,
                CLONERES,
                (*::core::mem::transmute::<
                    &[u8; 10],
                    &[libc::c_char; 10],
                >(b"lglfrozen\0"))
                    .as_ptr(),
                elit,
                res,
            );
            fputc('\n' as i32, stderr);
            fflush(stderr);
            lglabort(lgl);
            exit(1 as libc::c_int);
        }
        if !((*lgl).clone).is_null() {
            lglchkclonesamestats(lgl);
        }
    }
    return res;
}
#[no_mangle]
pub unsafe extern "C" fn lglusable(
    mut lgl: *mut LGL,
    mut elit: libc::c_int,
) -> libc::c_int {
    let mut ext: *mut Ext = 0 as *mut Ext;
    let mut res: libc::c_int = 0;
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 10], &[libc::c_char; 10]>(b"lglusable\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).forked == 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 10], &[libc::c_char; 10]>(b"lglusable\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"forked manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if !((*lgl).apitrace).is_null() {
        lgltrapi(lgl, b"usable %d\0" as *const u8 as *const libc::c_char, elit);
    }
    if elit != 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 10], &[libc::c_char; 10]>(b"lglusable\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(
            stderr,
            b"can not check zero literal for being usable\0" as *const u8
                as *const libc::c_char,
        );
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if abs(elit) > (*lgl).maxext {
        res = 1 as libc::c_int;
    } else {
        ext = lglelit2ext(lgl, elit);
        if (*ext).imported() == 0 {
            res = 1 as libc::c_int;
        } else {
            res = ((*ext).melted() == 0) as libc::c_int;
        }
    }
    if !((*lgl).apitrace).is_null() {
        lgltrapi(lgl, b"return %d\0" as *const u8 as *const libc::c_char, res);
    }
    let mut CLONERES: libc::c_int = 0;
    if !((*lgl).clone).is_null() {
        CLONERES = lglusable((*lgl).clone, elit);
        if !(CLONERES != res) {} else {
            fprintf(
                stderr,
                b"*** API usage error of '%s' in '%s'\0" as *const u8
                    as *const libc::c_char,
                b"lglib.c\0" as *const u8 as *const libc::c_char,
                (*::core::mem::transmute::<
                    &[u8; 10],
                    &[libc::c_char; 10],
                >(b"lglusable\0"))
                    .as_ptr(),
            );
            if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
                fprintf(
                    stderr,
                    b" (tid %d)\0" as *const u8 as *const libc::c_char,
                    (*lgl).tid,
                );
            }
            fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
            fprintf(
                stderr,
                b"%s (lgl->clone, %d) = %d differs from %s (lgl, %d) = %d\0" as *const u8
                    as *const libc::c_char,
                (*::core::mem::transmute::<
                    &[u8; 10],
                    &[libc::c_char; 10],
                >(b"lglusable\0"))
                    .as_ptr(),
                elit,
                CLONERES,
                (*::core::mem::transmute::<
                    &[u8; 10],
                    &[libc::c_char; 10],
                >(b"lglusable\0"))
                    .as_ptr(),
                elit,
                res,
            );
            fputc('\n' as i32, stderr);
            fflush(stderr);
            lglabort(lgl);
            exit(1 as libc::c_int);
        }
        if !((*lgl).clone).is_null() {
            lglchkclonesamestats(lgl);
        }
    }
    return res;
}
unsafe extern "C" fn lglereusable(
    mut lgl: *mut LGL,
    mut elit: libc::c_int,
) -> libc::c_int {
    let mut ext: *mut Ext = 0 as *mut Ext;
    let mut res: libc::c_int = 0;
    if abs(elit) > (*lgl).maxext {
        res = 1 as libc::c_int;
    } else {
        ext = lglelit2ext(lgl, elit);
        if (*ext).imported() == 0 {
            res = 1 as libc::c_int;
        } else if (*ext).blocking() != 0 {
            res = 0 as libc::c_int;
        } else if (*ext).eliminated() != 0 {
            res = 0 as libc::c_int;
        } else if (*ext).equiv() != 0 {
            res = 0 as libc::c_int;
        } else if abs((*ext).repr) == 1 as libc::c_int {
            res = 0 as libc::c_int;
        } else {
            res = 1 as libc::c_int;
        }
    }
    return res;
}
#[no_mangle]
pub unsafe extern "C" fn lglreusable(
    mut lgl: *mut LGL,
    mut elit: libc::c_int,
) -> libc::c_int {
    let mut res: libc::c_int = 0;
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 12], &[libc::c_char; 12]>(b"lglreusable\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).forked == 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 12], &[libc::c_char; 12]>(b"lglreusable\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"forked manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if !((*lgl).apitrace).is_null() {
        lgltrapi(lgl, b"reusable %d\0" as *const u8 as *const libc::c_char, elit);
    }
    if elit != 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 12], &[libc::c_char; 12]>(b"lglreusable\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(
            stderr,
            b"can not check zero literal for being reusable\0" as *const u8
                as *const libc::c_char,
        );
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    res = lglereusable(lgl, elit);
    if !((*lgl).apitrace).is_null() {
        lgltrapi(lgl, b"return %d\0" as *const u8 as *const libc::c_char, res);
    }
    let mut CLONERES: libc::c_int = 0;
    if !((*lgl).clone).is_null() {
        CLONERES = lglreusable((*lgl).clone, elit);
        if !(CLONERES != res) {} else {
            fprintf(
                stderr,
                b"*** API usage error of '%s' in '%s'\0" as *const u8
                    as *const libc::c_char,
                b"lglib.c\0" as *const u8 as *const libc::c_char,
                (*::core::mem::transmute::<
                    &[u8; 12],
                    &[libc::c_char; 12],
                >(b"lglreusable\0"))
                    .as_ptr(),
            );
            if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
                fprintf(
                    stderr,
                    b" (tid %d)\0" as *const u8 as *const libc::c_char,
                    (*lgl).tid,
                );
            }
            fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
            fprintf(
                stderr,
                b"%s (lgl->clone, %d) = %d differs from %s (lgl, %d) = %d\0" as *const u8
                    as *const libc::c_char,
                (*::core::mem::transmute::<
                    &[u8; 12],
                    &[libc::c_char; 12],
                >(b"lglreusable\0"))
                    .as_ptr(),
                elit,
                CLONERES,
                (*::core::mem::transmute::<
                    &[u8; 12],
                    &[libc::c_char; 12],
                >(b"lglreusable\0"))
                    .as_ptr(),
                elit,
                res,
            );
            fputc('\n' as i32, stderr);
            fflush(stderr);
            lglabort(lgl);
            exit(1 as libc::c_int);
        }
        if !((*lgl).clone).is_null() {
            lglchkclonesamestats(lgl);
        }
    }
    return res;
}
#[no_mangle]
pub unsafe extern "C" fn lglreuse(mut lgl: *mut LGL, mut elit: libc::c_int) {
    let mut ext: *mut Ext = 0 as *mut Ext;
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 9], &[libc::c_char; 9]>(b"lglreuse\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).forked == 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 9], &[libc::c_char; 9]>(b"lglreuse\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"forked manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if !((*lgl).apitrace).is_null() {
        lgltrapi(lgl, b"reuse %d\0" as *const u8 as *const libc::c_char, elit);
    }
    if elit != 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 9], &[libc::c_char; 9]>(b"lglreuse\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(
            stderr,
            b"can not reuse zero literal\0" as *const u8 as *const libc::c_char,
        );
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if lglereusable(lgl, elit) != 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 9], &[libc::c_char; 9]>(b"lglreuse\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(
            stderr,
            b"can not reuse non-reusable literal\0" as *const u8 as *const libc::c_char,
        );
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if abs(elit) <= (*lgl).maxext {
        ext = lglelit2ext(lgl, elit);
        if (*ext).imported() != 0 {
            if (*ext).melted() != 0 {
                (*ext).set_melted(0 as libc::c_int as libc::c_uint);
                lglmelter(lgl);
            }
        }
    }
    if !((*lgl).clone).is_null() {
        lglreuse((*lgl).clone, elit);
    }
}
#[no_mangle]
pub unsafe extern "C" fn lglmeltall(mut lgl: *mut LGL) {
    let mut idx: libc::c_int = 0;
    let mut melted: libc::c_int = 0;
    let mut ext: *mut Ext = 0 as *mut Ext;
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 11], &[libc::c_char; 11]>(b"lglmeltall\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).forked == 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 11], &[libc::c_char; 11]>(b"lglmeltall\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"forked manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if !((*lgl).apitrace).is_null() {
        lgltrapi(lgl, b"meltall\0" as *const u8 as *const libc::c_char);
    }
    melted = 0 as libc::c_int;
    idx = 1 as libc::c_int;
    while idx <= (*lgl).maxext {
        ext = lglelit2ext(lgl, idx);
        (*ext).set_melted(0 as libc::c_int as libc::c_uint);
        if !((*ext).frozen == 0) {
            (*(*lgl).stats).irrprgss += 1;
            (*(*lgl).stats).irrprgss;
            (*ext).frozen = 0 as libc::c_int;
            melted += 1;
            melted;
        }
        idx += 1;
        idx;
    }
    lglprt(
        lgl,
        1 as libc::c_int,
        b"[meltall] melted %d frozen literals\0" as *const u8 as *const libc::c_char,
        melted,
    );
    lglmelter(lgl);
    if !((*lgl).clone).is_null() {
        lglmeltall((*lgl).clone);
    }
}
#[no_mangle]
pub unsafe extern "C" fn lglmelt(mut lgl: *mut LGL, mut elit: libc::c_int) {
    let mut ext: *mut Ext = 0 as *mut Ext;
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 8], &[libc::c_char; 8]>(b"lglmelt\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).forked == 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 8], &[libc::c_char; 8]>(b"lglmelt\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"forked manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if !((*lgl).apitrace).is_null() {
        lgltrapi(lgl, b"melt %d\0" as *const u8 as *const libc::c_char, elit);
    }
    (*(*lgl).stats).calls.melt += 1;
    (*(*lgl).stats).calls.melt;
    if elit != 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 8], &[libc::c_char; 8]>(b"lglmelt\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(
            stderr,
            b"can not melt zero literal\0" as *const u8 as *const libc::c_char,
        );
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 8], &[libc::c_char; 8]>(b"lglmelt\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).state as libc::c_uint
        & (UNUSED as libc::c_int | OPTSET as libc::c_int | USED as libc::c_int
            | RESET as libc::c_int | SATISFIED as libc::c_int
            | UNSATISFIED as libc::c_int | FAILED as libc::c_int | UNKNOWN as libc::c_int
            | LOOKED as libc::c_int | EXTENDED as libc::c_int) as libc::c_uint != 0
    {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 8], &[libc::c_char; 8]>(b"lglmelt\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(
            stderr,
            b"!(%s)\0" as *const u8 as *const libc::c_char,
            b"UNUSED|OPTSET|USED|RESET| SATISFIED|UNSATISFIED|FAILED|UNKNOWN|LOOKED| EXTENDED\0"
                as *const u8 as *const libc::c_char,
        );
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    lglimport(lgl, elit);
    ext = lglelit2ext(lgl, elit);
    if (*ext).frozen != 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 8], &[libc::c_char; 8]>(b"lglmelt\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(
            stderr,
            b"can not melt fully unfrozen literal %d\0" as *const u8
                as *const libc::c_char,
            elit,
        );
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    (*ext).frozen -= 1;
    (*ext).frozen;
    lglmelter(lgl);
    if !((*lgl).clone).is_null() {
        lglmelt((*lgl).clone, elit);
    }
}
#[no_mangle]
pub unsafe extern "C" fn lglreconstk(
    mut lgl: *mut LGL,
    mut startptr: *mut *mut libc::c_int,
    mut toptr: *mut *mut libc::c_int,
) {
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 12], &[libc::c_char; 12]>(b"lglreconstk\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).forked == 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 12], &[libc::c_char; 12]>(b"lglreconstk\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"forked manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if !((*lgl).apitrace).is_null() {
        lgltrapi(lgl, b"reconstk\0" as *const u8 as *const libc::c_char);
    }
    lglfitstk(lgl, &mut (*lgl).extend);
    if !startptr.is_null() {
        *startptr = (*lgl).extend.start;
    }
    if !toptr.is_null() {
        *toptr = (*lgl).extend.top;
    }
    if !((*lgl).clone).is_null() {
        lglreconstk(
            (*lgl).clone,
            0 as *mut *mut libc::c_int,
            0 as *mut *mut libc::c_int,
        );
    }
}
unsafe extern "C" fn lglprstart(mut lgl: *mut LGL) {
    fputs((*lgl).prefix, (*lgl).out);
    if (*lgl).tid >= 0 as libc::c_int {
        fprintf((*lgl).out, b"%d \0" as *const u8 as *const libc::c_char, (*lgl).tid);
    }
}
unsafe extern "C" fn lglprs(
    mut lgl: *mut LGL,
    mut fmt: *const libc::c_char,
    mut args: ...
) {
    let mut ap: ::core::ffi::VaListImpl;
    lglprstart(lgl);
    ap = args.clone();
    vfprintf((*lgl).out, fmt, ap.as_va_list());
    fputc('\n' as i32, (*lgl).out);
}
unsafe extern "C" fn lglprsline(mut lgl: *mut LGL) {
    lglprstart(lgl);
    fputc('\n' as i32, (*lgl).out);
}
unsafe extern "C" fn lglsqr(mut a: libc::c_double) -> libc::c_double {
    return a * a;
}
unsafe extern "C" fn lglgluestats(mut lgl: *mut LGL) {
    let mut added: int64_t = 0;
    let mut reduced: int64_t = 0;
    let mut retired: int64_t = 0;
    let mut forcing: int64_t = 0;
    let mut resolved: int64_t = 0;
    let mut conflicts: int64_t = 0;
    let mut wadded: int64_t = 0;
    let mut wreduced: int64_t = 0;
    let mut wretired: int64_t = 0;
    let mut wforcing: int64_t = 0;
    let mut wresolved: int64_t = 0;
    let mut wconflicts: int64_t = 0;
    let mut avgadded: int64_t = 0;
    let mut avgreduced: int64_t = 0;
    let mut avgretired: int64_t = 0;
    let mut avgforcing: int64_t = 0;
    let mut avgresolved: int64_t = 0;
    let mut avgconflicts: int64_t = 0;
    let mut madded: libc::c_double = 0.;
    let mut mreduced: libc::c_double = 0.;
    let mut mretired: libc::c_double = 0.;
    let mut mforcing: libc::c_double = 0.;
    let mut mresolved: libc::c_double = 0.;
    let mut mconflicts: libc::c_double = 0.;
    let mut vadded: libc::c_double = 0.;
    let mut vreduced: libc::c_double = 0.;
    let mut vretired: libc::c_double = 0.;
    let mut vforcing: libc::c_double = 0.;
    let mut vresolved: libc::c_double = 0.;
    let mut vconflicts: libc::c_double = 0.;
    let mut sadded: libc::c_double = 0.;
    let mut sreduced: libc::c_double = 0.;
    let mut sretired: libc::c_double = 0.;
    let mut sforcing: libc::c_double = 0.;
    let mut sresolved: libc::c_double = 0.;
    let mut sconflicts: libc::c_double = 0.;
    let mut s: *mut Stats = (*lgl).stats;
    let mut glue: libc::c_int = 0;
    let mut maxglue: libc::c_int = 0;
    lglprs(
        lgl,
        b"scaled glue%11s %3s %9s %3s %9s %3s %9s %3s %9s %3s %9s %7s\0" as *const u8
            as *const libc::c_char,
        b"added\0" as *const u8 as *const libc::c_char,
        b"\0" as *const u8 as *const libc::c_char,
        b"reduced\0" as *const u8 as *const libc::c_char,
        b"\0" as *const u8 as *const libc::c_char,
        b"retired\0" as *const u8 as *const libc::c_char,
        b"\0" as *const u8 as *const libc::c_char,
        b"forcing\0" as *const u8 as *const libc::c_char,
        b"\0" as *const u8 as *const libc::c_char,
        b"resolved\0" as *const u8 as *const libc::c_char,
        b"\0" as *const u8 as *const libc::c_char,
        b"conflicts\0" as *const u8 as *const libc::c_char,
        b"maxmb\0" as *const u8 as *const libc::c_char,
    );
    conflicts = 0 as libc::c_int as int64_t;
    resolved = conflicts;
    forcing = resolved;
    retired = forcing;
    reduced = retired;
    added = reduced;
    wconflicts = 0 as libc::c_int as int64_t;
    wresolved = wconflicts;
    wforcing = wresolved;
    wretired = wforcing;
    wreduced = wretired;
    wadded = wreduced;
    glue = 0 as libc::c_int;
    while glue <= ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int {
        added += (*s).lir[glue as usize].added;
        reduced += (*s).lir[glue as usize].reduced;
        retired += (*s).lir[glue as usize].retired;
        forcing += (*s).lir[glue as usize].forcing;
        resolved += (*s).lir[glue as usize].resolved;
        conflicts += (*s).lir[glue as usize].conflicts;
        wadded += glue as int64_t * (*s).lir[glue as usize].added;
        wreduced += glue as int64_t * (*s).lir[glue as usize].reduced;
        wretired += glue as int64_t * (*s).lir[glue as usize].retired;
        wforcing += glue as int64_t * (*s).lir[glue as usize].forcing;
        wresolved += glue as int64_t * (*s).lir[glue as usize].resolved;
        wconflicts += glue as int64_t * (*s).lir[glue as usize].conflicts;
        glue += 1;
        glue;
    }
    avgadded = if added != 0 {
        (10 as libc::c_int as int64_t * wadded / added + 5 as libc::c_int as int64_t)
            / 10 as libc::c_int as int64_t
    } else {
        0 as libc::c_int as int64_t
    };
    avgreduced = if reduced != 0 {
        (10 as libc::c_int as int64_t * wreduced / reduced + 5 as libc::c_int as int64_t)
            / 10 as libc::c_int as int64_t
    } else {
        0 as libc::c_int as int64_t
    };
    avgretired = if retired != 0 {
        (10 as libc::c_int as int64_t * wretired / retired + 5 as libc::c_int as int64_t)
            / 10 as libc::c_int as int64_t
    } else {
        0 as libc::c_int as int64_t
    };
    avgforcing = if forcing != 0 {
        (10 as libc::c_int as int64_t * wforcing / forcing + 5 as libc::c_int as int64_t)
            / 10 as libc::c_int as int64_t
    } else {
        0 as libc::c_int as int64_t
    };
    avgresolved = if resolved != 0 {
        (10 as libc::c_int as int64_t * wresolved / resolved
            + 5 as libc::c_int as int64_t) / 10 as libc::c_int as int64_t
    } else {
        0 as libc::c_int as int64_t
    };
    avgconflicts = if conflicts != 0 {
        (10 as libc::c_int as int64_t * wconflicts / conflicts
            + 5 as libc::c_int as int64_t) / 10 as libc::c_int as int64_t
    } else {
        0 as libc::c_int as int64_t
    };
    lglprsline(lgl);
    lglprs(
        lgl,
        b"all %14lld %13lld %13lld %13lld %13lld %13lld\0" as *const u8
            as *const libc::c_char,
        added as libc::c_longlong,
        reduced as libc::c_longlong,
        retired as libc::c_longlong,
        forcing as libc::c_longlong,
        resolved as libc::c_longlong,
        conflicts as libc::c_longlong,
    );
    lglprsline(lgl);
    if (*(*lgl).opts).verbose.val < 2 as libc::c_int {
        maxglue = ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int;
        while maxglue >= 1 as libc::c_int {
            if (*s).lir[maxglue as usize].added != 0 {
                break;
            }
            maxglue -= 1;
            maxglue;
        }
        if maxglue + 1 as libc::c_int
            == ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int
        {
            maxglue = ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int;
        }
    } else {
        maxglue = ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int;
    }
    glue = 0 as libc::c_int;
    while glue <= maxglue {
        lglprs(
            lgl,
            b"%2d %-5d %9lld %3.0f%c%9lld %3.0f%c%9lld %3.0f%c%9lld %3.0f%c%9lld %3.0f%c%9lld %3.0f%c %6.1f\0"
                as *const u8 as *const libc::c_char,
            glue,
            lglunscaleglue(lgl, glue),
            (*s).lir[glue as usize].added as libc::c_longlong,
            lglpcnt(
                (*s).lir[glue as usize].added as libc::c_double,
                added as libc::c_double,
            ),
            if glue as int64_t == avgadded { '<' as i32 } else { ' ' as i32 },
            (*s).lir[glue as usize].reduced as libc::c_longlong,
            lglpcnt(
                (*s).lir[glue as usize].reduced as libc::c_double,
                reduced as libc::c_double,
            ),
            if glue as int64_t == avgreduced { '<' as i32 } else { ' ' as i32 },
            (*s).lir[glue as usize].retired as libc::c_longlong,
            lglpcnt(
                (*s).lir[glue as usize].retired as libc::c_double,
                retired as libc::c_double,
            ),
            if glue as int64_t == avgretired { '<' as i32 } else { ' ' as i32 },
            (*s).lir[glue as usize].forcing as libc::c_longlong,
            lglpcnt(
                (*s).lir[glue as usize].forcing as libc::c_double,
                forcing as libc::c_double,
            ),
            if glue as int64_t == avgforcing { '<' as i32 } else { ' ' as i32 },
            (*s).lir[glue as usize].resolved as libc::c_longlong,
            lglpcnt(
                (*s).lir[glue as usize].resolved as libc::c_double,
                resolved as libc::c_double,
            ),
            if glue as int64_t == avgresolved { '<' as i32 } else { ' ' as i32 },
            (*s).lir[glue as usize].conflicts as libc::c_longlong,
            lglpcnt(
                (*s).lir[glue as usize].conflicts as libc::c_double,
                conflicts as libc::c_double,
            ),
            if glue as int64_t == avgconflicts { '<' as i32 } else { ' ' as i32 },
            (*s).lir[glue as usize].maxbytes as libc::c_double
                / ((1 as libc::c_int) << 20 as libc::c_int) as libc::c_double,
        );
        glue += 1;
        glue;
    }
    lglprsline(lgl);
    madded = lglavg(wadded as libc::c_double, added as libc::c_double);
    mreduced = lglavg(wreduced as libc::c_double, reduced as libc::c_double);
    mretired = lglavg(wretired as libc::c_double, retired as libc::c_double);
    mforcing = lglavg(wforcing as libc::c_double, forcing as libc::c_double);
    mresolved = lglavg(wresolved as libc::c_double, resolved as libc::c_double);
    mconflicts = lglavg(wconflicts as libc::c_double, conflicts as libc::c_double);
    lglprs(
        lgl,
        b"avg  %19.1f%14.1f%14.1f%14.1f%14.1f%14.1f\0" as *const u8
            as *const libc::c_char,
        madded,
        mreduced,
        mretired,
        mforcing,
        mresolved,
        mconflicts,
    );
    vconflicts = 0 as libc::c_int as libc::c_double;
    vresolved = vconflicts;
    vforcing = vresolved;
    vretired = vforcing;
    vreduced = vretired;
    vadded = vreduced;
    glue = 0 as libc::c_int;
    while glue <= ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int {
        vadded
            += (*s).lir[glue as usize].added as libc::c_double
                * lglsqr(glue as libc::c_double - madded);
        vreduced
            += (*s).lir[glue as usize].reduced as libc::c_double
                * lglsqr(glue as libc::c_double - mreduced);
        vretired
            += (*s).lir[glue as usize].retired as libc::c_double
                * lglsqr(glue as libc::c_double - mretired);
        vforcing
            += (*s).lir[glue as usize].forcing as libc::c_double
                * lglsqr(glue as libc::c_double - mforcing);
        vresolved
            += (*s).lir[glue as usize].resolved as libc::c_double
                * lglsqr(glue as libc::c_double - mresolved);
        vconflicts
            += (*s).lir[glue as usize].conflicts as libc::c_double
                * lglsqr(glue as libc::c_double - mconflicts);
        glue += 1;
        glue;
    }
    sadded = sqrt(lglavg(vadded, added as libc::c_double));
    sreduced = sqrt(lglavg(vreduced, reduced as libc::c_double));
    sretired = sqrt(lglavg(vretired, retired as libc::c_double));
    sforcing = sqrt(lglavg(vforcing, forcing as libc::c_double));
    sresolved = sqrt(lglavg(vresolved, resolved as libc::c_double));
    sconflicts = sqrt(lglavg(vconflicts, conflicts as libc::c_double));
    lglprs(
        lgl,
        b"std  %19.1f%14.1f%14.1f%14.1f%14.1f%14.1f\0" as *const u8
            as *const libc::c_char,
        sadded,
        sreduced,
        sretired,
        sforcing,
        sresolved,
        sconflicts,
    );
}
unsafe extern "C" fn lglcmptn(mut a: *const TN, mut b: *const TN) -> libc::c_int {
    if (*a).t > (*b).t {
        return -(1 as libc::c_int);
    }
    if (*a).t < (*b).t {
        return 1 as libc::c_int;
    }
    return strcmp((*a).n, (*b).n);
}
unsafe extern "C" fn lglprofsort(mut lgl: *mut LGL) {
    let mut i: libc::c_int = 0;
    let mut ntns: libc::c_int = 0;
    let mut nimportant: libc::c_int = 0;
    let mut nprint: libc::c_int = 0;
    let mut ts: *mut Times = (*lgl).times;
    let sztns: libc::c_int = 100 as libc::c_int;
    let vla = sztns as usize;
    let mut tns: Vec::<TN> = ::std::vec::from_elem(
        TN {
            t: 0.,
            n: 0 as *const libc::c_char,
        },
        vla,
    );
    let mut sum: libc::c_double = 0.;
    ntns = 0 as libc::c_int;
    let mut tn: *mut TN = 0 as *mut TN;
    if !(lglignprofptr(lgl, &mut (*ts).analysis) != 0) {
        let fresh285 = ntns;
        ntns = ntns + 1;
        tn = tns.as_mut_ptr().offset(fresh285 as isize);
        (*tn).t = (*ts).analysis;
        (*tn).n = b"analysis\0" as *const u8 as *const libc::c_char;
    }
    let mut tn_0: *mut TN = 0 as *mut TN;
    if !(lglignprofptr(lgl, &mut (*ts).backward) != 0) {
        let fresh286 = ntns;
        ntns = ntns + 1;
        tn_0 = tns.as_mut_ptr().offset(fresh286 as isize);
        (*tn_0).t = (*ts).backward;
        (*tn_0).n = b"backward\0" as *const u8 as *const libc::c_char;
    }
    let mut tn_1: *mut TN = 0 as *mut TN;
    if !(lglignprofptr(lgl, &mut (*ts).bca) != 0) {
        let fresh287 = ntns;
        ntns = ntns + 1;
        tn_1 = tns.as_mut_ptr().offset(fresh287 as isize);
        (*tn_1).t = (*ts).bca;
        (*tn_1).n = b"bca\0" as *const u8 as *const libc::c_char;
    }
    let mut tn_2: *mut TN = 0 as *mut TN;
    if !(lglignprofptr(lgl, &mut (*ts).block) != 0) {
        let fresh288 = ntns;
        ntns = ntns + 1;
        tn_2 = tns.as_mut_ptr().offset(fresh288 as isize);
        (*tn_2).t = (*ts).block;
        (*tn_2).n = b"block\0" as *const u8 as *const libc::c_char;
    }
    let mut tn_3: *mut TN = 0 as *mut TN;
    if !(lglignprofptr(lgl, &mut (*ts).bump) != 0) {
        let fresh289 = ntns;
        ntns = ntns + 1;
        tn_3 = tns.as_mut_ptr().offset(fresh289 as isize);
        (*tn_3).t = (*ts).bump;
        (*tn_3).n = b"bump\0" as *const u8 as *const libc::c_char;
    }
    let mut tn_4: *mut TN = 0 as *mut TN;
    if !(lglignprofptr(lgl, &mut (*ts).card) != 0) {
        let fresh290 = ntns;
        ntns = ntns + 1;
        tn_4 = tns.as_mut_ptr().offset(fresh290 as isize);
        (*tn_4).t = (*ts).card;
        (*tn_4).n = b"card\0" as *const u8 as *const libc::c_char;
    }
    let mut tn_5: *mut TN = 0 as *mut TN;
    if !(lglignprofptr(lgl, &mut (*ts).cce) != 0) {
        let fresh291 = ntns;
        ntns = ntns + 1;
        tn_5 = tns.as_mut_ptr().offset(fresh291 as isize);
        (*tn_5).t = (*ts).cce;
        (*tn_5).n = b"cce\0" as *const u8 as *const libc::c_char;
    }
    let mut tn_6: *mut TN = 0 as *mut TN;
    if !(lglignprofptr(lgl, &mut (*ts).decide) != 0) {
        let fresh292 = ntns;
        ntns = ntns + 1;
        tn_6 = tns.as_mut_ptr().offset(fresh292 as isize);
        (*tn_6).t = (*ts).decide;
        (*tn_6).n = b"decide\0" as *const u8 as *const libc::c_char;
    }
    let mut tn_7: *mut TN = 0 as *mut TN;
    if !(lglignprofptr(lgl, &mut (*ts).decompose) != 0) {
        let fresh293 = ntns;
        ntns = ntns + 1;
        tn_7 = tns.as_mut_ptr().offset(fresh293 as isize);
        (*tn_7).t = (*ts).decompose;
        (*tn_7).n = b"decompose\0" as *const u8 as *const libc::c_char;
    }
    let mut tn_8: *mut TN = 0 as *mut TN;
    if !(lglignprofptr(lgl, &mut (*ts).defrag) != 0) {
        let fresh294 = ntns;
        ntns = ntns + 1;
        tn_8 = tns.as_mut_ptr().offset(fresh294 as isize);
        (*tn_8).t = (*ts).defrag;
        (*tn_8).n = b"defrag\0" as *const u8 as *const libc::c_char;
    }
    let mut tn_9: *mut TN = 0 as *mut TN;
    if !(lglignprofptr(lgl, &mut (*ts).druplig) != 0) {
        let fresh295 = ntns;
        ntns = ntns + 1;
        tn_9 = tns.as_mut_ptr().offset(fresh295 as isize);
        (*tn_9).t = (*ts).druplig;
        (*tn_9).n = b"druplig\0" as *const u8 as *const libc::c_char;
    }
    let mut tn_10: *mut TN = 0 as *mut TN;
    if !(lglignprofptr(lgl, &mut (*ts).elim) != 0) {
        let fresh296 = ntns;
        ntns = ntns + 1;
        tn_10 = tns.as_mut_ptr().offset(fresh296 as isize);
        (*tn_10).t = (*ts).elim;
        (*tn_10).n = b"elim\0" as *const u8 as *const libc::c_char;
    }
    let mut tn_11: *mut TN = 0 as *mut TN;
    if !(lglignprofptr(lgl, &mut (*ts).gauss) != 0) {
        let fresh297 = ntns;
        ntns = ntns + 1;
        tn_11 = tns.as_mut_ptr().offset(fresh297 as isize);
        (*tn_11).t = (*ts).gauss;
        (*tn_11).n = b"gauss\0" as *const u8 as *const libc::c_char;
    }
    let mut tn_12: *mut TN = 0 as *mut TN;
    if !(lglignprofptr(lgl, &mut (*ts).gc) != 0) {
        let fresh298 = ntns;
        ntns = ntns + 1;
        tn_12 = tns.as_mut_ptr().offset(fresh298 as isize);
        (*tn_12).t = (*ts).gc;
        (*tn_12).n = b"gc\0" as *const u8 as *const libc::c_char;
    }
    let mut tn_13: *mut TN = 0 as *mut TN;
    if !(lglignprofptr(lgl, &mut (*ts).heapdecision) != 0) {
        let fresh299 = ntns;
        ntns = ntns + 1;
        tn_13 = tns.as_mut_ptr().offset(fresh299 as isize);
        (*tn_13).t = (*ts).heapdecision;
        (*tn_13).n = b"heapdecision\0" as *const u8 as *const libc::c_char;
    }
    let mut tn_14: *mut TN = 0 as *mut TN;
    if !(lglignprofptr(lgl, &mut (*ts).locs) != 0) {
        let fresh300 = ntns;
        ntns = ntns + 1;
        tn_14 = tns.as_mut_ptr().offset(fresh300 as isize);
        (*tn_14).t = (*ts).locs;
        (*tn_14).n = b"locs\0" as *const u8 as *const libc::c_char;
    }
    let mut tn_15: *mut TN = 0 as *mut TN;
    if !(lglignprofptr(lgl, &mut (*ts).mincls) != 0) {
        let fresh301 = ntns;
        ntns = ntns + 1;
        tn_15 = tns.as_mut_ptr().offset(fresh301 as isize);
        (*tn_15).t = (*ts).mincls;
        (*tn_15).n = b"mincls\0" as *const u8 as *const libc::c_char;
    }
    let mut tn_16: *mut TN = 0 as *mut TN;
    if !(lglignprofptr(lgl, &mut (*ts).phase) != 0) {
        let fresh302 = ntns;
        ntns = ntns + 1;
        tn_16 = tns.as_mut_ptr().offset(fresh302 as isize);
        (*tn_16).t = (*ts).phase;
        (*tn_16).n = b"phase\0" as *const u8 as *const libc::c_char;
    }
    let mut tn_17: *mut TN = 0 as *mut TN;
    if !(lglignprofptr(lgl, &mut (*ts).probe) != 0) {
        let fresh303 = ntns;
        ntns = ntns + 1;
        tn_17 = tns.as_mut_ptr().offset(fresh303 as isize);
        (*tn_17).t = (*ts).probe;
        (*tn_17).n = b"probe\0" as *const u8 as *const libc::c_char;
    }
    let mut tn_18: *mut TN = 0 as *mut TN;
    if !(lglignprofptr(lgl, &mut (*ts).prune) != 0) {
        let fresh304 = ntns;
        ntns = ntns + 1;
        tn_18 = tns.as_mut_ptr().offset(fresh304 as isize);
        (*tn_18).t = (*ts).prune;
        (*tn_18).n = b"prune\0" as *const u8 as *const libc::c_char;
    }
    let mut tn_19: *mut TN = 0 as *mut TN;
    if !(lglignprofptr(lgl, &mut (*ts).quatres1) != 0) {
        let fresh305 = ntns;
        ntns = ntns + 1;
        tn_19 = tns.as_mut_ptr().offset(fresh305 as isize);
        (*tn_19).t = (*ts).quatres1;
        (*tn_19).n = b"quatres1\0" as *const u8 as *const libc::c_char;
    }
    let mut tn_20: *mut TN = 0 as *mut TN;
    if !(lglignprofptr(lgl, &mut (*ts).quatres2) != 0) {
        let fresh306 = ntns;
        ntns = ntns + 1;
        tn_20 = tns.as_mut_ptr().offset(fresh306 as isize);
        (*tn_20).t = (*ts).quatres2;
        (*tn_20).n = b"quatres2\0" as *const u8 as *const libc::c_char;
    }
    let mut tn_21: *mut TN = 0 as *mut TN;
    if !(lglignprofptr(lgl, &mut (*ts).quatres) != 0) {
        let fresh307 = ntns;
        ntns = ntns + 1;
        tn_21 = tns.as_mut_ptr().offset(fresh307 as isize);
        (*tn_21).t = (*ts).quatres;
        (*tn_21).n = b"quatres\0" as *const u8 as *const libc::c_char;
    }
    let mut tn_22: *mut TN = 0 as *mut TN;
    if !(lglignprofptr(lgl, &mut (*ts).queuedecision) != 0) {
        let fresh308 = ntns;
        ntns = ntns + 1;
        tn_22 = tns.as_mut_ptr().offset(fresh308 as isize);
        (*tn_22).t = (*ts).queuedecision;
        (*tn_22).n = b"queuedecision\0" as *const u8 as *const libc::c_char;
    }
    let mut tn_23: *mut TN = 0 as *mut TN;
    if !(lglignprofptr(lgl, &mut (*ts).queuesort) != 0) {
        let fresh309 = ntns;
        ntns = ntns + 1;
        tn_23 = tns.as_mut_ptr().offset(fresh309 as isize);
        (*tn_23).t = (*ts).queuesort;
        (*tn_23).n = b"queuesort\0" as *const u8 as *const libc::c_char;
    }
    let mut tn_24: *mut TN = 0 as *mut TN;
    if !(lglignprofptr(lgl, &mut (*ts).redcls) != 0) {
        let fresh310 = ntns;
        ntns = ntns + 1;
        tn_24 = tns.as_mut_ptr().offset(fresh310 as isize);
        (*tn_24).t = (*ts).redcls;
        (*tn_24).n = b"redcls\0" as *const u8 as *const libc::c_char;
    }
    let mut tn_25: *mut TN = 0 as *mut TN;
    if !(lglignprofptr(lgl, &mut (*ts).reduce) != 0) {
        let fresh311 = ntns;
        ntns = ntns + 1;
        tn_25 = tns.as_mut_ptr().offset(fresh311 as isize);
        (*tn_25).t = (*ts).reduce;
        (*tn_25).n = b"reduce\0" as *const u8 as *const libc::c_char;
    }
    let mut tn_26: *mut TN = 0 as *mut TN;
    if !(lglignprofptr(lgl, &mut (*ts).restart) != 0) {
        let fresh312 = ntns;
        ntns = ntns + 1;
        tn_26 = tns.as_mut_ptr().offset(fresh312 as isize);
        (*tn_26).t = (*ts).restart;
        (*tn_26).n = b"restart\0" as *const u8 as *const libc::c_char;
    }
    let mut tn_27: *mut TN = 0 as *mut TN;
    if !(lglignprofptr(lgl, &mut (*ts).showfeatures) != 0) {
        let fresh313 = ntns;
        ntns = ntns + 1;
        tn_27 = tns.as_mut_ptr().offset(fresh313 as isize);
        (*tn_27).t = (*ts).showfeatures;
        (*tn_27).n = b"showfeatures\0" as *const u8 as *const libc::c_char;
    }
    let mut tn_28: *mut TN = 0 as *mut TN;
    if !(lglignprofptr(lgl, &mut (*ts).showscoredist) != 0) {
        let fresh314 = ntns;
        ntns = ntns + 1;
        tn_28 = tns.as_mut_ptr().offset(fresh314 as isize);
        (*tn_28).t = (*ts).showscoredist;
        (*tn_28).n = b"showscoredist\0" as *const u8 as *const libc::c_char;
    }
    let mut tn_29: *mut TN = 0 as *mut TN;
    if !(lglignprofptr(lgl, &mut (*ts).subl) != 0) {
        let fresh315 = ntns;
        ntns = ntns + 1;
        tn_29 = tns.as_mut_ptr().offset(fresh315 as isize);
        (*tn_29).t = (*ts).subl;
        (*tn_29).n = b"subl\0" as *const u8 as *const libc::c_char;
    }
    let mut tn_30: *mut TN = 0 as *mut TN;
    if !(lglignprofptr(lgl, &mut (*ts).sweep) != 0) {
        let fresh316 = ntns;
        ntns = ntns + 1;
        tn_30 = tns.as_mut_ptr().offset(fresh316 as isize);
        (*tn_30).t = (*ts).sweep;
        (*tn_30).n = b"sweep\0" as *const u8 as *const libc::c_char;
    }
    let mut tn_31: *mut TN = 0 as *mut TN;
    if !(lglignprofptr(lgl, &mut (*ts).ternres) != 0) {
        let fresh317 = ntns;
        ntns = ntns + 1;
        tn_31 = tns.as_mut_ptr().offset(fresh317 as isize);
        (*tn_31).t = (*ts).ternres;
        (*tn_31).n = b"ternres\0" as *const u8 as *const libc::c_char;
    }
    let mut tn_32: *mut TN = 0 as *mut TN;
    if !(lglignprofptr(lgl, &mut (*ts).transred) != 0) {
        let fresh318 = ntns;
        ntns = ntns + 1;
        tn_32 = tns.as_mut_ptr().offset(fresh318 as isize);
        (*tn_32).t = (*ts).transred;
        (*tn_32).n = b"transred\0" as *const u8 as *const libc::c_char;
    }
    let mut tn_33: *mut TN = 0 as *mut TN;
    if !(lglignprofptr(lgl, &mut (*ts).unhide) != 0) {
        let fresh319 = ntns;
        ntns = ntns + 1;
        tn_33 = tns.as_mut_ptr().offset(fresh319 as isize);
        (*tn_33).t = (*ts).unhide;
        (*tn_33).n = b"unhide\0" as *const u8 as *const libc::c_char;
    }
    let mut PIVOT: TN = TN {
        t: 0.,
        n: 0 as *const libc::c_char,
    };
    let mut L: libc::c_int = 0 as libc::c_int;
    let mut R: libc::c_int = ntns - 1 as libc::c_int;
    let mut I: libc::c_int = 0;
    let mut J: libc::c_int = 0;
    I = R;
    while I > L {
        if lglcmptn(
            &mut *tns.as_mut_ptr().offset((I - 1 as libc::c_int) as isize),
            &mut *tns.as_mut_ptr().offset(I as isize),
        ) > 0 as libc::c_int
        {
            let mut TMP: TN = *tns.as_mut_ptr().offset((I - 1 as libc::c_int) as isize);
            *tns
                .as_mut_ptr()
                .offset(
                    (I - 1 as libc::c_int) as isize,
                ) = *tns.as_mut_ptr().offset(I as isize);
            *tns.as_mut_ptr().offset(I as isize) = TMP;
        }
        I -= 1;
        I;
    }
    I = L + 2 as libc::c_int;
    while I <= R {
        J = I;
        PIVOT = *tns.as_mut_ptr().offset(I as isize);
        while lglcmptn(
            &mut PIVOT,
            &mut *tns.as_mut_ptr().offset((J - 1 as libc::c_int) as isize),
        ) < 0 as libc::c_int
        {
            *tns
                .as_mut_ptr()
                .offset(
                    J as isize,
                ) = *tns.as_mut_ptr().offset((J - 1 as libc::c_int) as isize);
            J -= 1;
            J;
        }
        *tns.as_mut_ptr().offset(J as isize) = PIVOT;
        I += 1;
        I;
    }
    sum = 0 as libc::c_int as libc::c_double;
    nimportant = ntns - 1 as libc::c_int;
    while nimportant > 3 as libc::c_int {
        sum += (*tns.as_mut_ptr().offset(nimportant as isize)).t;
        if lglpcnt(sum, (*ts).all) >= 1.0f64 {
            break;
        }
        nimportant -= 1;
        nimportant;
    }
    if nimportant == ntns - 1 as libc::c_int {
        nimportant += 1;
        nimportant;
    }
    if (*(*lgl).opts).profilelong.val == 0
        && (*(*lgl).opts).verbose.val < 2 as libc::c_int
    {
        nprint = nimportant;
    } else {
        nprint = ntns;
    }
    i = 0 as libc::c_int;
    while i < nprint {
        if i == nimportant {
            if i != 0 {
                lglprs(lgl, b"\0" as *const u8 as *const libc::c_char);
            }
            lglprs(
                lgl,
                b"%8.3f < 1%% rest (below)\0" as *const u8 as *const libc::c_char,
                sum,
            );
            if (i + 1 as libc::c_int) < nprint {
                lglprs(lgl, b"\0" as *const u8 as *const libc::c_char);
            }
        }
        lglprs(
            lgl,
            b"%8.3f %3.0f%% %s\0" as *const u8 as *const libc::c_char,
            (*tns.as_mut_ptr().offset(i as isize)).t,
            lglpcnt((*tns.as_mut_ptr().offset(i as isize)).t, (*ts).all),
            (*tns.as_mut_ptr().offset(i as isize)).n,
        );
        i += 1;
        i;
    }
    if nimportant == nprint && nprint < ntns {
        if nprint != 0 {
            lglprs(lgl, b"\0" as *const u8 as *const libc::c_char);
        }
        lglprs(
            lgl,
            b"%8.3f < 1%% rest (not shown)\0" as *const u8 as *const libc::c_char,
            sum,
        );
    }
}
unsafe extern "C" fn lglprof(mut lgl: *mut LGL) {
    let mut ts: *mut Times = (*lgl).times;
    let mut t: libc::c_double = (*ts).all;
    let mut simp: libc::c_double = 0.;
    let mut search: libc::c_double = 0.;
    simp = (*ts).preprocessing + (*ts).inprocessing;
    if !((*(*lgl).opts).verbose.val == 0 || (*(*lgl).opts).profile.val == 0) {
        lglprofsort(lgl);
        if lglignprofptr(lgl, &mut (*ts).prb.simple) == 0
            && ((*(*lgl).opts).profilelong.val != 0
                || (*(*lgl).opts).verbose.val >= 2 as libc::c_int
                || (*ts).prb.simple != 0. || (*ts).prb.basic != 0.
                || (*ts).prb.treelook != 0.)
        {
            lglprs(
                lgl,
                b"----------------------------------\0" as *const u8
                    as *const libc::c_char,
            );
            lglprs(
                lgl,
                b"%8.3f %3.0f%% probe simple    %3.0f%%\0" as *const u8
                    as *const libc::c_char,
                (*ts).prb.simple,
                lglpcnt((*ts).prb.simple, t),
                lglpcnt((*ts).prb.simple, (*ts).probe),
            );
            lglprs(
                lgl,
                b"%8.3f %3.0f%% probe basic     %3.0f%%\0" as *const u8
                    as *const libc::c_char,
                (*ts).prb.basic,
                lglpcnt((*ts).prb.basic, t),
                lglpcnt((*ts).prb.basic, (*ts).probe),
            );
            lglprs(
                lgl,
                b"%8.3f %3.0f%% probe tree-look %3.0f%%\0" as *const u8
                    as *const libc::c_char,
                (*ts).prb.treelook,
                lglpcnt((*ts).prb.treelook, t),
                lglpcnt((*ts).prb.treelook, (*ts).probe),
            );
        }
        lglprs(
            lgl,
            b"==================================\0" as *const u8 as *const libc::c_char,
        );
        lglprs(
            lgl,
            b"%8.3f %3.0f%% preprocessing   %3.0f%%\0" as *const u8
                as *const libc::c_char,
            (*ts).preprocessing,
            lglpcnt((*ts).preprocessing, t),
            lglpcnt((*ts).preprocessing, simp),
        );
        lglprs(
            lgl,
            b"%8.3f %3.0f%% inprocessing    %3.0f%%\0" as *const u8
                as *const libc::c_char,
            (*ts).inprocessing,
            lglpcnt((*ts).inprocessing, t),
            lglpcnt((*ts).inprocessing, simp),
        );
        lglprs(
            lgl,
            b"==================================\0" as *const u8 as *const libc::c_char,
        );
    }
    lglprs(
        lgl,
        b"%8.3f %3.0f%% simplifying\0" as *const u8 as *const libc::c_char,
        simp,
        lglpcnt(simp, t),
    );
    if (*(*lgl).stats).calls.lkhd != 0 {
        lglprs(
            lgl,
            b"%8.3f %3.0f%% lookahead\0" as *const u8 as *const libc::c_char,
            (*ts).lookahead,
            lglpcnt((*ts).lookahead, t),
        );
    }
    search = (*ts).search - (*ts).inprocessing;
    lglprs(
        lgl,
        b"%8.3f %3.0f%% search\0" as *const u8 as *const libc::c_char,
        search,
        lglpcnt(search, t),
    );
    lglprs(
        lgl,
        b"==================================\0" as *const u8 as *const libc::c_char,
    );
    lglprs(lgl, b"%8.3f %3.0f%% all\0" as *const u8 as *const libc::c_char, t, 100.0f64);
}
#[no_mangle]
pub unsafe extern "C" fn lglstats(mut lgl: *mut LGL) {
    let mut visits: libc::c_longlong = 0;
    let mut min: libc::c_longlong = 0;
    let mut p: libc::c_longlong = 0;
    let mut steps: libc::c_longlong = 0;
    let mut sum: libc::c_longlong = 0;
    let mut remaining: libc::c_int = 0;
    let mut removed: libc::c_int = 0;
    let mut s: *mut Stats = 0 as *mut Stats;
    let mut t: libc::c_double = 0.;
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 9], &[libc::c_char; 9]>(b"lglstats\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).forked == 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 9], &[libc::c_char; 9]>(b"lglstats\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"forked manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*(*lgl).opts).verbose.val < 0 as libc::c_int {
        return;
    }
    lglflushtimers(lgl);
    s = (*lgl).stats;
    t = (*(*lgl).times).all;
    p = ((*s).props.search + (*s).props.simp + (*s).props.lkhd) as libc::c_longlong;
    if !((*(*lgl).opts).verbose.val == 0) {
        lglprs(
            lgl,
            b"agil: %.2f%% agility\0" as *const u8 as *const libc::c_char,
            100.0f64
                * ((*s).agility as libc::c_double
                    / ((1 as libc::c_longlong) << 32 as libc::c_int) as libc::c_double),
        );
        sum = ((*s).prb.basic.ate.trnr + (*s).prb.basic.ate.lrg) as libc::c_longlong;
        lglprs(
            lgl,
            b"bate: %lld basic ate = %d trn %.0f%% + %d lrg %.0f%% in %d updates\0"
                as *const u8 as *const libc::c_char,
            sum,
            (*s).prb.basic.ate.trnr,
            lglpcnt((*s).prb.basic.ate.trnr as libc::c_double, sum as libc::c_double),
            (*s).prb.basic.ate.lrg,
            lglpcnt((*s).prb.basic.ate.lrg as libc::c_double, sum as libc::c_double),
            (*s).prb.basic.ate.count,
        );
        lglprs(
            lgl,
            b"bcas: %d count, %lld added (%lld skipped), %lld steps\0" as *const u8
                as *const libc::c_char,
            (*s).bca.count,
            (*s).bca.added as libc::c_longlong,
            (*s).bca.skipped,
            (*s).bca.steps as libc::c_longlong,
        );
        lglprs(
            lgl,
            b"bkwd: tried %lld clauses, %lld lits, %.2f lits/clause\0" as *const u8
                as *const libc::c_char,
            (*s).bkwd.tried.clauses as libc::c_longlong,
            (*s).bkwd.tried.lits as libc::c_longlong,
            lglavg(
                (*s).bkwd.tried.lits as libc::c_double,
                (*s).bkwd.tried.clauses as libc::c_double,
            ),
        );
        lglprs(
            lgl,
            b"bkwd: checked %lld occs, %.2f occs/clause, %.2f occs/lit\0" as *const u8
                as *const libc::c_char,
            (*s).bkwd.tried.occs as libc::c_longlong,
            lglavg(
                (*s).bkwd.tried.occs as libc::c_double,
                (*s).bkwd.tried.clauses as libc::c_double,
            ),
            lglavg(
                (*s).bkwd.tried.occs as libc::c_double,
                (*s).bkwd.tried.lits as libc::c_double,
            ),
        );
        lglprs(
            lgl,
            b"bkwd: subsumed %d binary, %d ternary, %d large\0" as *const u8
                as *const libc::c_char,
            (*s).bkwd.sub2,
            (*s).bkwd.sub3,
            (*s).bkwd.subl,
        );
        lglprs(
            lgl,
            b"bkwd: strengthened %d binary, %d ternary (%.0f%% self), %d large (%.0f%% self)\0"
                as *const u8 as *const libc::c_char,
            (*s).bkwd.str2,
            (*s).bkwd.str3,
            lglpcnt(
                (*s).bkwd.str3self as libc::c_double,
                (*s).bkwd.str3 as libc::c_double,
            ),
            (*s).bkwd.strl,
            lglpcnt(
                (*s).bkwd.strlself as libc::c_double,
                (*s).bkwd.strl as libc::c_double,
            ),
        );
        lglprs(
            lgl,
            b"blkd: %d bces, %d removed, %lld resolutions, %lld steps\0" as *const u8
                as *const libc::c_char,
            (*s).blk.count,
            (*s).blk.clauses,
            (*s).blk.res as libc::c_longlong,
            (*s).blk.steps as libc::c_longlong,
        );
        lglprs(
            lgl,
            b"blkd: %d blocking literals %.0f%%, %d pure\0" as *const u8
                as *const libc::c_char,
            (*s).blk.lits,
            lglpcnt(
                (*s).blk.lits as libc::c_double,
                (2 as libc::c_int * (*lgl).maxext) as libc::c_double,
            ),
            (*s).blk.pure_0,
        );
        lglprs(
            lgl,
            b"bump: %lld bumped seen, %lld lits %.1f on average\0" as *const u8
                as *const libc::c_char,
            (*s).bump.count,
            (*s).bump.lits as libc::c_longlong,
            lglavg((*s).bump.lits as libc::c_double, (*s).bump.count as libc::c_double),
        );
        lglprs(
            lgl,
            b"card: %d count, %d units, %d am1, %lld steps\0" as *const u8
                as *const libc::c_char,
            (*s).card.count,
            (*s).card.units,
            (*s).card.expam1,
            (*s).card.steps as libc::c_longlong,
        );
        lglprs(
            lgl,
            b"card: %d rescheduled, %lld eliminated, %lld resolved, %lld subsumed\0"
                as *const u8 as *const libc::c_char,
            (*s).card.resched,
            (*s).card.eliminated as libc::c_longlong,
            (*s).card.resolved as libc::c_longlong,
            (*s).card.subsumed as libc::c_longlong,
        );
        lglprs(
            lgl,
            b"card: %d at-most-one constraints found, average size %.2f\0" as *const u8
                as *const libc::c_char,
            (*s).card.found.am1.total.cnt,
            lglavg(
                (*s).card.found.am1.total.sum as libc::c_double,
                (*s).card.found.am1.total.cnt as libc::c_double,
            ),
        );
        lglprs(
            lgl,
            b"card: %d at-most-one constraints used %.0f%%, average size %.2f\0"
                as *const u8 as *const libc::c_char,
            (*s).card.used.am1.cnt,
            lglpcnt(
                (*s).card.used.am1.cnt as libc::c_double,
                (*s).card.found.am1.total.cnt as libc::c_double,
            ),
            lglavg(
                (*s).card.used.am1.sum as libc::c_double,
                (*s).card.used.am1.cnt as libc::c_double,
            ),
        );
        lglprs(
            lgl,
            b"card: %d at-most-two constraints found, average size %.2f\0" as *const u8
                as *const libc::c_char,
            (*s).card.found.am2.total.cnt,
            lglavg(
                (*s).card.found.am2.total.sum as libc::c_double,
                (*s).card.found.am2.total.cnt as libc::c_double,
            ),
        );
        lglprs(
            lgl,
            b"card: %d at-most-two constraints used %.0f%%, average size %.2f\0"
                as *const u8 as *const libc::c_char,
            (*s).card.used.am2.cnt,
            lglpcnt(
                (*s).card.used.am2.cnt as libc::c_double,
                (*s).card.found.am2.total.cnt as libc::c_double,
            ),
            lglavg(
                (*s).card.used.am2.sum as libc::c_double,
                (*s).card.used.am2.cnt as libc::c_double,
            ),
        );
        lglprs(
            lgl,
            b"cces: %d cces, %d eliminated, %d ate %.0f%%, %d abce %.0f%%\0" as *const u8
                as *const libc::c_char,
            (*s).cce.count,
            (*s).cce.eliminated,
            (*s).cce.ate,
            lglpcnt(
                (*s).cce.ate as libc::c_double,
                (*s).cce.eliminated as libc::c_double,
            ),
            (*s).cce.abce,
            lglpcnt(
                (*s).cce.abce as libc::c_double,
                (*s).cce.eliminated as libc::c_double,
            ),
        );
        lglprs(
            lgl,
            b"cces: %lld probed, %d lifted, %d failed\0" as *const u8
                as *const libc::c_char,
            (*s).cce.probed as libc::c_longlong,
            (*s).cce.lifted,
            (*s).cce.failed,
        );
        lglprs(
            lgl,
            b"cces: %lld cached, %lld rsz, %lld cols %.0f%%, %lld srch, %lld hits %.0f%%\0"
                as *const u8 as *const libc::c_char,
            (*s).cce.cache.ins as libc::c_longlong,
            (*s).cce.cache.rsz as libc::c_longlong,
            (*s).cce.cache.cols as libc::c_longlong,
            lglpcnt(
                (*s).cce.cache.cols as libc::c_double,
                (*s).cce.cache.ins as libc::c_double,
            ),
            (*s).cce.cache.search as libc::c_longlong,
            (*s).cce.cache.hits as libc::c_longlong,
            lglpcnt(
                (*s).cce.cache.hits as libc::c_double,
                (*s).cce.cache.search as libc::c_double,
            ),
        );
        lglprs(
            lgl,
            b"clls: %lld sat, %lld simp, %lld freeze, %lld melt\0" as *const u8
                as *const libc::c_char,
            (*s).calls.sat as libc::c_longlong,
            (*s).calls.simp as libc::c_longlong,
            (*s).calls.freeze as libc::c_longlong,
            (*s).calls.melt as libc::c_longlong,
        );
        lglprs(
            lgl,
            b"clls: %lld add, %lld assume, %lld deref, %lld failed\0" as *const u8
                as *const libc::c_char,
            (*s).calls.add as libc::c_longlong,
            (*s).calls.assume as libc::c_longlong,
            (*s).calls.deref as libc::c_longlong,
            (*s).calls.failed as libc::c_longlong,
        );
        lglprs(
            lgl,
            b"clls: %lld lkhd, %lld cassume, %lld mosat\0" as *const u8
                as *const libc::c_char,
            (*s).calls.lkhd as libc::c_longlong,
            (*s).calls.cassume as libc::c_longlong,
            (*s).calls.mosat as libc::c_longlong,
        );
        lglprs(
            lgl,
            b"coll: %d gcs, %d rescored clauses, %d rescored vars\0" as *const u8
                as *const libc::c_char,
            (*s).gcs,
            (*s).rescored.clauses,
            (*s).rescored.vars,
        );
        lglprs(
            lgl,
            b"dcps: %d decompositions, %d equivalent %.0f%%\0" as *const u8
                as *const libc::c_char,
            (*s).decomps,
            (*s).equiv.sum,
            lglpcnt((*s).equiv.sum as libc::c_double, (*lgl).maxext as libc::c_double),
        );
        lglprs(
            lgl,
            b"deco: %lld decision-only clauses %.0f%%, %.0f%% reduction\0" as *const u8
                as *const libc::c_char,
            (*s).mincls.deco,
            lglpcnt(
                (*s).mincls.deco as libc::c_double,
                (*s).clauses.learned as libc::c_double,
            ),
            lglpcnt(
                ((*s).deco.sum.orig - (*s).deco.sum.red) as libc::c_double,
                (*s).deco.sum.orig as libc::c_double,
            ),
        );
        lglprs(
            lgl,
            b"decs: %lld total, %lld rnd %.3f%%, %lld heap %.3f%, %lld queue %.3f%%\0"
                as *const u8 as *const libc::c_char,
            (*s).decisions as libc::c_longlong,
            (*s).randecs as libc::c_longlong,
            lglpcnt((*s).randecs as libc::c_double, (*s).decisions as libc::c_double),
            (*s).hdecs as libc::c_longlong,
            lglpcnt((*s).hdecs as libc::c_double, (*s).decisions as libc::c_double),
            (*s).qdecs as libc::c_longlong,
            lglpcnt((*s).qdecs as libc::c_double, (*s).decisions as libc::c_double),
        );
        lglprs(
            lgl,
            b"elms: %d elims, %d eliminated %.0f%%, %d pure %.0f%%\0" as *const u8
                as *const libc::c_char,
            (*s).elm.count,
            (*s).elm.elmd,
            lglpcnt((*s).elm.elmd as libc::c_double, (*lgl).maxext as libc::c_double),
            (*s).elm.pure_0,
            lglpcnt((*s).elm.pure_0 as libc::c_double, (*s).elm.elmd as libc::c_double),
        );
        lglprs(
            lgl,
            b"elms: %d rounds, %.1f rounds/bve\0" as *const u8 as *const libc::c_char,
            (*s).elm.rounds,
            lglavg((*s).elm.rounds as libc::c_double, (*s).elm.count as libc::c_double),
        );
        lglprs(
            lgl,
            b"elms: %d small %.0f%%, %d large %.0f%%\0" as *const u8
                as *const libc::c_char,
            (*s).elm.small.elm,
            lglpcnt(
                (*s).elm.small.elm as libc::c_double,
                (*s).elm.elmd as libc::c_double,
            ),
            (*s).elm.large,
            lglpcnt((*s).elm.large as libc::c_double, (*s).elm.elmd as libc::c_double),
        );
        lglprs(
            lgl,
            b"elms: %d tried small, %d succeeded %.0f%%, %d failed %.0f%%\0" as *const u8
                as *const libc::c_char,
            (*s).elm.small.tried,
            (*s).elm.small.tried - (*s).elm.small.failed,
            lglpcnt(
                ((*s).elm.small.tried - (*s).elm.small.failed) as libc::c_double,
                (*s).elm.small.tried as libc::c_double,
            ),
            (*s).elm.small.failed,
            lglpcnt(
                (*s).elm.small.failed as libc::c_double,
                (*s).elm.small.tried as libc::c_double,
            ),
        );
        lglprs(
            lgl,
            b"elms: %d subsumed, %d strengthened, %d blocked\0" as *const u8
                as *const libc::c_char,
            (*s).elm.sub,
            (*s).elm.str_0,
            (*s).elm.blkd,
        );
        lglprs(
            lgl,
            b"elms: %lld copies, %lld resolutions, %lld ipos\0" as *const u8
                as *const libc::c_char,
            (*s).elm.copies as libc::c_longlong,
            (*s).elm.resolutions as libc::c_longlong,
            (*s).elm.ipos as libc::c_longlong,
        );
        lglprs(
            lgl,
            b"elms: %lld subchks, %lld strchks\0" as *const u8 as *const libc::c_char,
            (*s).elm.subchks as libc::c_longlong,
            (*s).elm.strchks as libc::c_longlong,
        );
        lglprs(
            lgl,
            b"gaus: %d extractions, %lld extracted, %.1f size, %d max\0" as *const u8
                as *const libc::c_char,
            (*s).gauss.count,
            (*s).gauss.extracted.total,
            lglavg(
                (*s).gauss.arity.sum.total as libc::c_double,
                (*s).gauss.extracted.total as libc::c_double,
            ),
            (*s).gauss.arity.max,
        );
        lglprs(
            lgl,
            b"gaus: %lld exactly-1 constraints of average arity %.1f\0" as *const u8
                as *const libc::c_char,
            (*s).gauss.extracted.exactly1,
            lglavg(
                (*s).gauss.arity.sum.exactly1 as libc::c_double,
                (*s).gauss.extracted.exactly1 as libc::c_double,
            ),
        );
        lglprs(
            lgl,
            b"gaus: exported %d units, %d binary and %d ternary equations\0" as *const u8
                as *const libc::c_char,
            (*s).gauss.units,
            (*s).gauss.equivs,
            (*s).gauss.trneqs,
        );
        steps = ((*s).gauss.steps.extr + (*s).gauss.steps.extr) as libc::c_longlong;
        lglprs(
            lgl,
            b"gaus: %d gc, %lld steps, %lld extr %.0f%%, %lld elim %.0f%%\0" as *const u8
                as *const libc::c_char,
            (*s).gauss.gcs,
            steps,
            (*s).gauss.steps.extr,
            lglpcnt((*s).gauss.steps.extr as libc::c_double, steps as libc::c_double),
            (*s).gauss.steps.elim,
            lglpcnt((*s).gauss.steps.elim as libc::c_double, steps as libc::c_double),
        );
        lglprs(
            lgl,
            b"glue: %.1f orig avg, %.1f real avg, %.1f scaled avg\0" as *const u8
                as *const libc::c_char,
            lglavg(
                (*s).clauses.glue as libc::c_double,
                (*s).clauses.learned as libc::c_double,
            ),
            lglavg(
                (*s).clauses.realglue as libc::c_double,
                (*s).clauses.learned as libc::c_double,
            ),
            lglavg(
                (*s).clauses.scglue as libc::c_double,
                (*s).clauses.learned as libc::c_double,
            ),
        );
        lglprs(
            lgl,
            b"glue: %lld maxscaledglue=%d (%.0f%%), %lld kept %.0f%%\0" as *const u8
                as *const libc::c_char,
            (*s).clauses.maxglue.count as libc::c_longlong,
            ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int,
            lglpcnt(
                (*s).clauses.maxglue.count as libc::c_double,
                (*s).clauses.learned as libc::c_double,
            ),
            (*s).clauses.maxglue.kept as libc::c_longlong,
            lglpcnt(
                (*s).clauses.maxglue.kept as libc::c_double,
                (*s).clauses.learned as libc::c_double,
            ),
        );
        lglprs(
            lgl,
            b"hbrs: %d = %d simple %.0f%% + %d trn %.0f%% + %d lrg %.0f%%, %d sub %.0f%%\0"
                as *const u8 as *const libc::c_char,
            (*s).hbr.cnt,
            (*s).hbr.simple,
            lglpcnt((*s).hbr.simple as libc::c_double, (*s).hbr.cnt as libc::c_double),
            (*s).hbr.trn,
            lglpcnt((*s).hbr.trn as libc::c_double, (*s).hbr.cnt as libc::c_double),
            (*s).hbr.lrg,
            lglpcnt((*s).hbr.lrg as libc::c_double, (*s).hbr.cnt as libc::c_double),
            (*s).hbr.sub,
            lglpcnt((*s).hbr.sub as libc::c_double, (*s).hbr.cnt as libc::c_double),
        );
        lglprs(
            lgl,
            b"locs: %d count, %lld flips, %lld mems, %d minimun\0" as *const u8
                as *const libc::c_char,
            (*s).locs.count,
            (*s).locs.flips as libc::c_longlong,
            (*s).locs.mems as libc::c_longlong,
            (*s).locs.min,
        );
        min = ((*s).lits.nonmin - (*s).lits.learned) as libc::c_longlong;
        lglprs(
            lgl,
            b"lrnd: %lld clauses, %.1f length\0" as *const u8 as *const libc::c_char,
            (*s).clauses.learned as libc::c_longlong,
            lglavg(
                (*s).lits.learned as libc::c_double,
                (*s).clauses.learned as libc::c_double,
            ),
        );
        lglprs(
            lgl,
            b"lrnd: %lld lits = %lld orig - %lld removed %.0f%%\0" as *const u8
                as *const libc::c_char,
            (*s).lits.learned as libc::c_longlong,
            (*s).lits.nonmin as libc::c_longlong,
            min,
            lglpcnt(min as libc::c_double, (*s).lits.nonmin as libc::c_double),
        );
        lglprs(
            lgl,
            b"lrnd: %lld uips %.0f%%, %lld flips %.0f%%\0" as *const u8
                as *const libc::c_char,
            (*s).uips as libc::c_longlong,
            lglpcnt((*s).uips as libc::c_double, (*s).clauses.learned as libc::c_double),
            (*s).decflipped as libc::c_longlong,
            lglpcnt(
                (*s).decflipped as libc::c_double,
                (*s).clauses.learned as libc::c_double,
            ),
        );
        sum = ((*s).mincls.min + (*s).mincls.bin + (*s).mincls.size + (*s).mincls.deco)
            as libc::c_longlong;
        lglprs(
            lgl,
            b"mins: %lld mins %.0f%%, %lld bin %.0f%%, %lld size %.0f%%\0" as *const u8
                as *const libc::c_char,
            (*s).mincls.min as libc::c_longlong,
            lglpcnt((*s).mincls.min as libc::c_double, sum as libc::c_double),
            (*s).mincls.bin as libc::c_longlong,
            lglpcnt((*s).mincls.bin as libc::c_double, sum as libc::c_double),
            (*s).mincls.size as libc::c_longlong,
            lglpcnt((*s).mincls.size as libc::c_double, sum as libc::c_double),
            (*s).mincls.deco as libc::c_longlong,
            lglpcnt((*s).mincls.deco as libc::c_double, sum as libc::c_double),
        );
        lglprs(
            lgl,
            b"mins: %lld poisoned searches, %lld hits, %.0f%% hit rate\0" as *const u8
                as *const libc::c_char,
            (*s).mincls.poison.search as libc::c_longlong,
            (*s).mincls.poison.hits as libc::c_longlong,
            lglpcnt(
                (*s).mincls.poison.hits as libc::c_double,
                (*s).mincls.poison.search as libc::c_double,
            ),
        );
        lglprs(
            lgl,
            b"mins: %lld used twice searches, %lld hits, %.0f%% hit rate\0" as *const u8
                as *const libc::c_char,
            (*s).mincls.usedtwice.search as libc::c_longlong,
            (*s).mincls.usedtwice.hits as libc::c_longlong,
            lglpcnt(
                (*s).mincls.usedtwice.hits as libc::c_double,
                (*s).mincls.usedtwice.search as libc::c_double,
            ),
        );
        sum = ((*s).moved.bin + (*s).moved.trn) as libc::c_longlong;
        lglprs(
            lgl,
            b"move: moved %lld, %lld bin %.0f%%, %lld trn %.0f%%\0" as *const u8
                as *const libc::c_char,
            sum,
            (*s).moved.bin as libc::c_longlong,
            lglpcnt((*s).moved.bin as libc::c_double, sum as libc::c_double),
            (*s).moved.trn as libc::c_longlong,
            lglpcnt((*s).moved.trn as libc::c_double, sum as libc::c_double),
        );
        sum = ((*s).otfs.str_0.red + (*s).otfs.str_0.irr) as libc::c_longlong;
        lglprs(
            lgl,
            b"otfs: %lld driving %.0f%%, %lld restarting %.0f%%\0" as *const u8
                as *const libc::c_char,
            (*s).otfs.driving as libc::c_longlong,
            lglpcnt((*s).otfs.driving as libc::c_double, sum as libc::c_double),
            (*s).otfs.restarting as libc::c_longlong,
            lglpcnt((*s).otfs.restarting as libc::c_double, sum as libc::c_double),
        );
        lglprs(
            lgl,
            b"otfs: str %lld, %lld red %.0f%%, %lld irr %.0f%%\0" as *const u8
                as *const libc::c_char,
            sum,
            (*s).otfs.str_0.red as libc::c_longlong,
            lglpcnt((*s).otfs.str_0.red as libc::c_double, sum as libc::c_double),
            (*s).otfs.str_0.irr as libc::c_longlong,
            lglpcnt((*s).otfs.str_0.irr as libc::c_double, sum as libc::c_double),
        );
        lglprs(
            lgl,
            b"otfs: str %lld, %lld bin %.0f%%, %lld trn %.0f%%, %lld lrg %.0f%%\0"
                as *const u8 as *const libc::c_char,
            sum,
            (*s).otfs.str_0.bin as libc::c_longlong,
            lglpcnt((*s).otfs.str_0.bin as libc::c_double, sum as libc::c_double),
            (*s).otfs.str_0.trn as libc::c_longlong,
            lglpcnt((*s).otfs.str_0.trn as libc::c_double, sum as libc::c_double),
            (*s).otfs.str_0.lrg as libc::c_longlong,
            lglpcnt((*s).otfs.str_0.lrg as libc::c_double, sum as libc::c_double),
        );
        sum = ((*s).otfs.sub.red + (*s).otfs.sub.irr) as libc::c_longlong;
        lglprs(
            lgl,
            b"otfs: sub %lld, %lld red %.0f%%, %lld irr %.0f%%\0" as *const u8
                as *const libc::c_char,
            sum,
            (*s).otfs.sub.red as libc::c_longlong,
            lglpcnt((*s).otfs.sub.red as libc::c_double, sum as libc::c_double),
            (*s).otfs.sub.irr as libc::c_longlong,
            lglpcnt((*s).otfs.sub.irr as libc::c_double, sum as libc::c_double),
        );
        lglprs(
            lgl,
            b"otfs: sub %lld, %lld bin %.0f%%, %lld trn %.0f%%, %lld lrg %.0f%%\0"
                as *const u8 as *const libc::c_char,
            sum,
            (*s).otfs.sub.bin as libc::c_longlong,
            lglpcnt((*s).otfs.sub.bin as libc::c_double, sum as libc::c_double),
            (*s).otfs.sub.trn as libc::c_longlong,
            lglpcnt((*s).otfs.sub.trn as libc::c_double, sum as libc::c_double),
            (*s).otfs.sub.lrg as libc::c_longlong,
            lglpcnt((*s).otfs.sub.lrg as libc::c_double, sum as libc::c_double),
        );
        lglprs(
            lgl,
            b"phas: %lld computed, %lld set, %lld pos (%.0f%%), %lld neg (%.0f%%)\0"
                as *const u8 as *const libc::c_char,
            (*s).phase.count as libc::c_longlong,
            (*s).phase.set as libc::c_longlong,
            (*s).phase.pos as libc::c_longlong,
            lglpcnt((*s).phase.pos as libc::c_double, (*s).phase.set as libc::c_double),
            (*s).phase.neg as libc::c_longlong,
            lglpcnt((*s).phase.neg as libc::c_double, (*s).phase.set as libc::c_double),
        );
        lglprs(
            lgl,
            b"phas: %lld flipped decision phases randomly %.0f%%\0" as *const u8
                as *const libc::c_char,
            (*s).randphases as libc::c_longlong,
            lglpcnt((*s).randphases as libc::c_double, (*s).decisions as libc::c_double),
        );
        lglprs(
            lgl,
            b"prbs: %d basic, %lld probed, %d failed, %d lifted\0" as *const u8
                as *const libc::c_char,
            (*s).prb.basic.count,
            (*s).prb.basic.probed as libc::c_longlong,
            (*s).prb.basic.failed,
            (*s).prb.basic.lifted,
        );
        lglprs(
            lgl,
            b"prbs: %d simple, %lld probed, %d failed, %d eqs\0" as *const u8
                as *const libc::c_char,
            (*s).prb.simple.count,
            (*s).prb.simple.probed as libc::c_longlong,
            (*s).prb.simple.failed,
            (*s).prb.simple.eqs,
        );
        lglprs(
            lgl,
            b"prbs: %d treelook, %lld probed, %d failed, %d lifted\0" as *const u8
                as *const libc::c_char,
            (*s).prb.treelook.count,
            (*s).prb.treelook.probed as libc::c_longlong,
            (*s).prb.treelook.failed,
            (*s).prb.treelook.lifted,
        );
        lglprs(
            lgl,
            b"prom: %lld locked %.0f%% out of %lld tried\0" as *const u8
                as *const libc::c_char,
            (*s).promote.locked as libc::c_longlong,
            lglpcnt(
                (*s).promote.locked as libc::c_double,
                (*s).promote.tried as libc::c_double,
            ),
            (*s).promote.tried as libc::c_longlong,
        );
        lglprs(
            lgl,
            b"prps: %lld props, %.0f props/dec\0" as *const u8 as *const libc::c_char,
            p,
            lglavg((*s).props.search as libc::c_double, (*s).decisions as libc::c_double),
        );
        lglprs(
            lgl,
            b"prps: %.0f%% srch, %.0f%% simp, %.0f%% lkhd\0" as *const u8
                as *const libc::c_char,
            lglpcnt((*s).props.search as libc::c_double, p as libc::c_double),
            lglpcnt((*s).props.simp as libc::c_double, p as libc::c_double),
            lglpcnt((*s).props.lkhd as libc::c_double, p as libc::c_double),
        );
        lglprs(
            lgl,
            b"prun: %lld decisions, %lld pure %.2f%%\0" as *const u8
                as *const libc::c_char,
            (*s).prune.decs as libc::c_longlong,
            (*s).prune.pure_0 as libc::c_longlong,
            lglpcnt(
                (*s).prune.pure_0 as libc::c_double,
                (*s).prune.decs as libc::c_double,
            ),
        );
        lglprs(
            lgl,
            b"prun: %lld calls, %.1f%% per decision on level %.3f\0" as *const u8
                as *const libc::c_char,
            (*s).prune.calls as libc::c_longlong,
            lglavg(
                (*s).prune.calls as libc::c_double,
                (*s).prune.decs as libc::c_double,
            ),
            lglavg(
                (*s).prune.levels as libc::c_double,
                (*s).prune.calls as libc::c_double,
            ),
        );
        lglprs(
            lgl,
            b"prun: %lld sat %.0f%%, %lld unsat %.0f%%, %lld lim %.0f%%\0" as *const u8
                as *const libc::c_char,
            (*s).prune.sat as libc::c_longlong,
            lglpcnt(
                (*s).prune.sat as libc::c_double,
                (*s).prune.calls as libc::c_double,
            ),
            (*s).prune.uns as libc::c_longlong,
            lglpcnt(
                (*s).prune.uns as libc::c_double,
                (*s).prune.calls as libc::c_double,
            ),
            (*s).prune.lim as libc::c_longlong,
            lglpcnt((*s).prune.lim as libc::c_double, (*s).prune.calls as libc::c_double),
        );
        lglprs(
            lgl,
            b"prun: %lld child conflicts, %lld decisions, %lld propagations\0"
                as *const u8 as *const libc::c_char,
            (*s).prune.child.confs as libc::c_longlong,
            (*s).prune.child.decs as libc::c_longlong,
            (*s).prune.child.props as libc::c_longlong,
        );
        lglprs(
            lgl,
            b"quat: %d count, %lld quat, %lld self1, %lld self2, %lld dup\0" as *const u8
                as *const libc::c_char,
            (*s).quatres.count,
            (*s).quatres.quat as libc::c_longlong,
            (*s).quatres.self1 as libc::c_longlong,
            (*s).quatres.self2 as libc::c_longlong,
            (*s).quatres.dup as libc::c_longlong,
        );
        lglprs(
            lgl,
            b"queu: %lld flushed, %lld sorted, %lld decisions %.3f%%\0" as *const u8
                as *const libc::c_char,
            (*s).queue.flushed as libc::c_longlong,
            (*s).queue.sorted as libc::c_longlong,
            (*s).qdecs as libc::c_longlong,
            lglpcnt((*s).qdecs as libc::c_double, (*s).decisions as libc::c_double),
        );
        lglprs(
            lgl,
            b"redc: %lld clauses %.0f%%, %lld tried %.0f%%, %lld sat %.0f%%\0"
                as *const u8 as *const libc::c_char,
            (*s).redcls.cls.red as libc::c_longlong,
            lglpcnt(
                (*s).redcls.cls.red as libc::c_double,
                (*s).redcls.cls.tried as libc::c_double,
            ),
            (*s).redcls.cls.tried as libc::c_longlong,
            lglpcnt(
                (*s).redcls.cls.tried as libc::c_double,
                (*s).confs as libc::c_double,
            ),
            (*s).redcls.cls.sat as libc::c_longlong,
            lglpcnt(
                (*s).redcls.cls.sat as libc::c_double,
                (*s).redcls.cls.tried as libc::c_double,
            ),
        );
        lglprs(
            lgl,
            b"redc: %lld lits %.0f%%, %lld tried %.0f%%, %lld sat %.0f%%\0" as *const u8
                as *const libc::c_char,
            (*s).redcls.lits.red as libc::c_longlong,
            lglpcnt(
                (*s).redcls.lits.red as libc::c_double,
                (*s).redcls.lits.tried as libc::c_double,
            ),
            (*s).redcls.lits.tried as libc::c_longlong,
            lglpcnt(
                (*s).redcls.lits.tried as libc::c_double,
                (*s).lits.nonmin as libc::c_double,
            ),
            (*s).redcls.lits.sat as libc::c_longlong,
            lglpcnt(
                (*s).redcls.lits.sat as libc::c_double,
                (*s).redcls.lits.tried as libc::c_double,
            ),
        );
        lglprs(
            lgl,
            b"redc: %lld times jump level reduced, %.1f levels on average\0" as *const u8
                as *const libc::c_char,
            (*s).redcls.jlevel.red as libc::c_longlong,
            lglavg(
                (*s).redcls.jlevel.sum as libc::c_double,
                (*s).redcls.jlevel.red as libc::c_double,
            ),
        );
        lglprs(
            lgl,
            b"reds: %d count, %.1f conflicts per reduce, %d reset\0" as *const u8
                as *const libc::c_char,
            (*s).reduced.count,
            lglavg((*s).confs as libc::c_double, (*s).reduced.count as libc::c_double),
            (*s).reduced.reset,
        );
        lglprs(
            lgl,
            b"reds: %d memlim %.0f%%, %d arith %.0f%%\0" as *const u8
                as *const libc::c_char,
            (*s).reduced.memlim,
            lglpcnt(
                (*s).reduced.memlim as libc::c_double,
                (*s).reduced.count as libc::c_double,
            ),
            (*s).reduced.arith,
            lglpcnt(
                (*s).reduced.arith as libc::c_double,
                (*s).reduced.count as libc::c_double,
            ),
        );
        sum = ((*s).reduced.collected + (*s).reduced.retired) as libc::c_longlong;
        lglprs(
            lgl,
            b"reds: %lld collected %.0f%%, %lld retired %.0f%%\0" as *const u8
                as *const libc::c_char,
            (*s).reduced.collected,
            lglpcnt((*s).reduced.collected as libc::c_double, sum as libc::c_double),
            (*s).reduced.retired,
            lglpcnt((*s).reduced.retired as libc::c_double, sum as libc::c_double),
        );
        lglprs(
            lgl,
            b"rmbd: %d removed, %d red %.0f%%\0" as *const u8 as *const libc::c_char,
            (*s).bindup.removed,
            (*s).bindup.red,
            lglpcnt(
                (*s).bindup.red as libc::c_double,
                (*s).bindup.removed as libc::c_double,
            ),
        );
        lglprs(
            lgl,
            b"rsts: %lld restarts %.0f%% of checked, %lld skipped %.0f%%\0" as *const u8
                as *const libc::c_char,
            (*s).restarts.count as libc::c_longlong,
            lglpcnt(
                (*s).restarts.count as libc::c_double,
                (*s).restarts.checked as libc::c_double,
            ),
            (*s).restarts.skipped as libc::c_longlong,
            lglpcnt(
                (*s).restarts.skipped as libc::c_double,
                (*s).restarts.checked as libc::c_double,
            ),
        );
        lglprs(
            lgl,
            b"rsts: %lld checks %.0f%%, %lld forced %.0f%%\0" as *const u8
                as *const libc::c_char,
            (*s).restarts.checked as libc::c_longlong,
            lglpcnt(
                (*s).restarts.checked as libc::c_double,
                (*s).confs as libc::c_double,
            ),
            (*s).restarts.forced as libc::c_longlong,
            lglpcnt(
                (*s).restarts.forced as libc::c_double,
                (*s).restarts.checked as libc::c_double,
            ),
        );
        lglprs(
            lgl,
            b"rsts: %lld not forced (%.0f%% of checked, %.0f%% of skipped)\0"
                as *const u8 as *const libc::c_char,
            (*s).restarts.notforced as libc::c_longlong,
            lglpcnt(
                (*s).restarts.notforced as libc::c_double,
                (*s).restarts.checked as libc::c_double,
            ),
            lglpcnt(
                (*s).restarts.notforced as libc::c_double,
                (*s).restarts.skipped as libc::c_double,
            ),
        );
        lglprs(
            lgl,
            b"rsts: %lld agile %.0f%% of skipped, %lld delayed %.0f%%\0" as *const u8
                as *const libc::c_char,
            (*s).restarts.agile as libc::c_longlong,
            lglpcnt(
                (*s).restarts.agile as libc::c_double,
                (*s).restarts.skipped as libc::c_double,
            ),
            (*s).restarts.delayed as libc::c_longlong,
            lglpcnt(
                (*s).restarts.delayed as libc::c_double,
                (*s).restarts.skipped as libc::c_double,
            ),
        );
        lglprs(
            lgl,
            b"rsts: %lld blocked %.2f%% restart, %lld reused %.0f%%\0" as *const u8
                as *const libc::c_char,
            (*s).restarts.blocked as libc::c_longlong,
            lglpcnt(
                (*s).restarts.blocked as libc::c_double,
                (*s).restarts.count as libc::c_double,
            ),
            (*s).restarts.reused as libc::c_longlong,
            lglpcnt(
                (*s).restarts.reused as libc::c_double,
                (*s).restarts.skipped as libc::c_double,
            ),
        );
        lglprs(
            lgl,
            b"rsts: %lld partial reuse %.1f%% of restarts, kept %.1f%%\0" as *const u8
                as *const libc::c_char,
            (*s).restarts.kept.count as libc::c_longlong,
            lglpcnt(
                (*s).restarts.kept.count as libc::c_double,
                (*s).restarts.count as libc::c_double,
            ),
            lglavg(
                (*s).restarts.kept.sum as libc::c_double,
                (*s).restarts.kept.count as libc::c_double,
            ),
        );
        lglprs(
            lgl,
            b"rsts: %lld delta %.1f avg, %lld penalty %.1f avg\0" as *const u8
                as *const libc::c_char,
            (*s).restarts.delta.delta as libc::c_longlong,
            lglavg(
                (*s).restarts.delta.delta as libc::c_double,
                (*s).restarts.delta.count as libc::c_double,
            ),
            (*s).restarts.delta.pen as libc::c_longlong,
            lglavg(
                (*s).restarts.delta.pen as libc::c_double,
                (*s).restarts.delta.count as libc::c_double,
            ),
        );
        lglprs(
            lgl,
            b"scic: %lld set, %.1f%% min, %.1f%% max\0" as *const u8
                as *const libc::c_char,
            (*s).setscincf.count as libc::c_longlong,
            (*s).setscincf.min as libc::c_double / 10.0f64,
            (*s).setscincf.max as libc::c_double / 10.0f64,
        );
        lglprs(
            lgl,
            b"simp: %d count, %d confs %0.f%%, %d vars %.0f%%\0" as *const u8
                as *const libc::c_char,
            (*s).simp.count,
            (*s).simp.limhit.confs,
            lglpcnt(
                (*s).simp.limhit.confs as libc::c_double,
                (*s).simp.count as libc::c_double,
            ),
            (*s).simp.limhit.vars,
            lglpcnt(
                (*s).simp.limhit.vars as libc::c_double,
                (*s).simp.count as libc::c_double,
            ),
        );
        lglprs(
            lgl,
            b"simp: %d its %0.f%%, %d bin %.0f%%, %d trns %.0f%%\0" as *const u8
                as *const libc::c_char,
            (*s).simp.limhit.its,
            lglpcnt(
                (*s).simp.limhit.its as libc::c_double,
                (*s).simp.count as libc::c_double,
            ),
            (*s).simp.limhit.bin,
            lglpcnt(
                (*s).simp.limhit.bin as libc::c_double,
                (*s).simp.count as libc::c_double,
            ),
            (*s).simp.limhit.trn,
            lglpcnt(
                (*s).simp.limhit.trn as libc::c_double,
                (*s).simp.count as libc::c_double,
            ),
        );
        lglprs(
            lgl,
            b"subl: %lld count (%lld tried %.1f), %lld sub out of %lld (%.1f%%)\0"
                as *const u8 as *const libc::c_char,
            (*s).subl.count,
            (*s).subl.tried,
            lglavg((*s).subl.tried as libc::c_double, (*s).subl.count as libc::c_double),
            (*s).subl.sub,
            (*s).subl.cands,
            lglpcnt((*s).subl.sub as libc::c_double, (*s).subl.cands as libc::c_double),
        );
        lglprs(
            lgl,
            b"swps: %d count, %lld rounds, %lld queries (%.1f/round)\0" as *const u8
                as *const libc::c_char,
            (*s).sweep.count,
            (*s).sweep.rounds as libc::c_longlong,
            (*s).sweep.queries.total as libc::c_longlong,
            lglavg(
                (*s).sweep.queries.total as libc::c_double,
                (*s).sweep.rounds as libc::c_double,
            ),
        );
        lglprs(
            lgl,
            b"swps: %lld sat calls, %lld unsat (%.1f%% success rate)\0" as *const u8
                as *const libc::c_char,
            (*s).sweep.sat,
            (*s).sweep.unsat,
            lglavg((*s).sweep.confs as libc::c_double, (*s).sweep.sat as libc::c_double),
        );
        lglprs(
            lgl,
            b"swps: %lld decisions %.1f, %lld conflicts %.1f\0" as *const u8
                as *const libc::c_char,
            (*s).sweep.decs as libc::c_longlong,
            lglavg((*s).sweep.decs as libc::c_double, (*s).sweep.sat as libc::c_double),
            (*s).sweep.confs as libc::c_longlong,
            lglavg((*s).sweep.confs as libc::c_double, (*s).sweep.sat as libc::c_double),
        );
        lglprs(
            lgl,
            b"swps; %.1f avg class size, %.1f avg environment size\0" as *const u8
                as *const libc::c_char,
            lglavg(
                (*s).sweep.sumsize.classes as libc::c_double,
                (*s).sweep.queries.total as libc::c_double,
            ),
            lglavg(
                (*s).sweep.sumsize.envs as libc::c_double,
                (*s).sweep.sat as libc::c_double,
            ),
        );
        lglprs(
            lgl,
            b"swps: %d failed, %d impls, %d equivs\0" as *const u8
                as *const libc::c_char,
            (*s).sweep.failed,
            (*s).sweep.impls,
            (*s).sweep.equivs,
        );
        lglprs(
            lgl,
            b"swp0: %lld type 0 queries, %lld unsat (%.1f%%), %lld sat (%.1f%%)\0"
                as *const u8 as *const libc::c_char,
            (*s).sweep.queries.type_0[0 as libc::c_int as usize].count
                as libc::c_longlong,
            (*s).sweep.queries.type_0[0 as libc::c_int as usize].unsat
                as libc::c_longlong,
            lglpcnt(
                (*s).sweep.queries.type_0[0 as libc::c_int as usize].unsat
                    as libc::c_double,
                (*s).sweep.queries.type_0[0 as libc::c_int as usize].count
                    as libc::c_double,
            ),
            (*s).sweep.queries.type_0[0 as libc::c_int as usize].sat as libc::c_longlong,
            lglpcnt(
                (*s).sweep.queries.type_0[0 as libc::c_int as usize].sat
                    as libc::c_double,
                (*s).sweep.queries.type_0[0 as libc::c_int as usize].count
                    as libc::c_double,
            ),
        );
        lglprs(
            lgl,
            b"swp1: %lld type 1 queries, %lld unsat (%.1f%%), %lld sat (%.1f%%)\0"
                as *const u8 as *const libc::c_char,
            (*s).sweep.queries.type_0[1 as libc::c_int as usize].count
                as libc::c_longlong,
            (*s).sweep.queries.type_0[1 as libc::c_int as usize].unsat
                as libc::c_longlong,
            lglpcnt(
                (*s).sweep.queries.type_0[1 as libc::c_int as usize].unsat
                    as libc::c_double,
                (*s).sweep.queries.type_0[1 as libc::c_int as usize].count
                    as libc::c_double,
            ),
            (*s).sweep.queries.type_0[1 as libc::c_int as usize].sat as libc::c_longlong,
            lglpcnt(
                (*s).sweep.queries.type_0[1 as libc::c_int as usize].sat
                    as libc::c_double,
                (*s).sweep.queries.type_0[1 as libc::c_int as usize].count
                    as libc::c_double,
            ),
        );
        lglprs(
            lgl,
            b"swp2: %lld type 2 queries, %lld unsat (%.1f%%), %lld sat (%.1f%%)\0"
                as *const u8 as *const libc::c_char,
            (*s).sweep.queries.type_0[2 as libc::c_int as usize].count
                as libc::c_longlong,
            (*s).sweep.queries.type_0[2 as libc::c_int as usize].unsat
                as libc::c_longlong,
            lglpcnt(
                (*s).sweep.queries.type_0[2 as libc::c_int as usize].unsat
                    as libc::c_double,
                (*s).sweep.queries.type_0[2 as libc::c_int as usize].count
                    as libc::c_double,
            ),
            (*s).sweep.queries.type_0[2 as libc::c_int as usize].sat as libc::c_longlong,
            lglpcnt(
                (*s).sweep.queries.type_0[2 as libc::c_int as usize].sat
                    as libc::c_double,
                (*s).sweep.queries.type_0[2 as libc::c_int as usize].count
                    as libc::c_double,
            ),
        );
        lglprs(
            lgl,
            b"sync: %lld produced units, %lld successful consumptions %.0f%%\0"
                as *const u8 as *const libc::c_char,
            (*s).sync.units.produced,
            (*s).sync.units.consumed.actual,
            lglpcnt(
                (*s).sync.units.consumed.actual as libc::c_double,
                (*s).sync.units.produced as libc::c_double,
            ),
        );
        lglprs(
            lgl,
            b"sync: %lld consume units calls, %lld tried %.0f%%, %lld success %.0f%%\0"
                as *const u8 as *const libc::c_char,
            (*s).sync.units.consumed.calls,
            (*s).sync.units.consumed.tried,
            lglpcnt(
                (*s).sync.units.consumed.tried as libc::c_double,
                (*s).sync.units.consumed.calls as libc::c_double,
            ),
            (*s).sync.units.consumed.actual,
            lglpcnt(
                (*s).sync.units.consumed.actual as libc::c_double,
                (*s).sync.units.consumed.calls as libc::c_double,
            ),
        );
        lglprs(
            lgl,
            b"sync: %lld produced clauses, %lld successful consumptions %.0f%%\0"
                as *const u8 as *const libc::c_char,
            (*s).sync.cls.produced,
            (*s).sync.cls.consumed.actual,
            lglpcnt(
                (*s).sync.cls.consumed.actual as libc::c_double,
                (*s).sync.cls.produced as libc::c_double,
            ),
        );
        lglprs(
            lgl,
            b"sync: %lld consume clause calls, %lld tried %.0f%%, %lld success %.0f%%\0"
                as *const u8 as *const libc::c_char,
            (*s).sync.cls.consumed.calls,
            (*s).sync.cls.consumed.tried,
            lglpcnt(
                (*s).sync.cls.consumed.tried as libc::c_double,
                (*s).sync.cls.consumed.calls as libc::c_double,
            ),
            (*s).sync.cls.consumed.actual,
            lglpcnt(
                (*s).sync.cls.consumed.actual as libc::c_double,
                (*s).sync.cls.consumed.calls as libc::c_double,
            ),
        );
        lglprs(
            lgl,
            b"time: %lld calls to obtain time\0" as *const u8 as *const libc::c_char,
            (*s).times as libc::c_longlong,
        );
        lglprs(
            lgl,
            b"tops: %d fixed %.0f%%, %d its, %.2f confs/it\0" as *const u8
                as *const libc::c_char,
            (*s).fixed.sum,
            lglpcnt((*s).fixed.sum as libc::c_double, (*lgl).maxext as libc::c_double),
            (*s).its.count,
            lglavg((*s).confs as libc::c_double, (*s).its.count as libc::c_double),
        );
        lglprs(
            lgl,
            b"trds: %d transitive reductions, %d removed, %d failed\0" as *const u8
                as *const libc::c_char,
            (*s).trd.count,
            (*s).trd.red,
            (*s).trd.failed,
        );
        lglprs(
            lgl,
            b"trds: %lld nodes, %lld edges, %lld steps\0" as *const u8
                as *const libc::c_char,
            (*s).trd.lits as libc::c_longlong,
            (*s).trd.bins as libc::c_longlong,
            (*s).trd.steps as libc::c_longlong,
        );
        lglprs(
            lgl,
            b"trim: %lld words, %.1f MB\0" as *const u8 as *const libc::c_char,
            (*s).trims as libc::c_longlong,
            ((*s).trims as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong)
                as libc::c_double
                / ((1 as libc::c_int) << 20 as libc::c_int) as libc::c_double,
        );
        lglprs(
            lgl,
            b"trnr: %d count, %d bin, %d trn, %lld steps\0" as *const u8
                as *const libc::c_char,
            (*s).ternres.count,
            (*s).ternres.bin,
            (*s).ternres.trn,
            (*s).ternres.steps as libc::c_longlong,
        );
        lglprs(
            lgl,
            b"unhd: %d count, %d rounds, %lld steps\0" as *const u8
                as *const libc::c_char,
            (*s).unhd.count,
            (*s).unhd.rounds,
            (*s).unhd.steps as libc::c_longlong,
        );
        lglprs(
            lgl,
            b"unhd: %d non-trivial sccs of average size %.1f\0" as *const u8
                as *const libc::c_char,
            (*s).unhd.stamp.sccs,
            lglavg(
                (*s).unhd.stamp.sumsccsizes as libc::c_double,
                (*s).unhd.stamp.sccs as libc::c_double,
            ),
        );
        sum = lglunhdunits(lgl) as libc::c_longlong;
        lglprs(
            lgl,
            b"unhd: %lld units, %d bin, %d trn, %d lrg\0" as *const u8
                as *const libc::c_char,
            sum,
            (*s).unhd.units.bin,
            (*s).unhd.units.trn,
            (*s).unhd.units.lrg,
        );
        sum = lglunhdfailed(lgl) as libc::c_longlong;
        lglprs(
            lgl,
            b"unhd: %lld failed, %d stamp, %d lits, %d bin, %d trn, %d lrg\0"
                as *const u8 as *const libc::c_char,
            sum,
            (*s).unhd.stamp.failed,
            (*s).unhd.failed.lits,
            (*s).unhd.failed.bin,
            (*s).unhd.failed.trn,
            (*s).unhd.units.lrg,
        );
        sum = lglunhdtauts(lgl) as libc::c_longlong;
        lglprs(
            lgl,
            b"unhd: %lld tauts, %d bin %.0f%%, %d trn %.0f%%, %d lrg %.0f%%\0"
                as *const u8 as *const libc::c_char,
            sum,
            (*s).unhd.tauts.bin,
            lglpcnt((*s).unhd.tauts.bin as libc::c_double, sum as libc::c_double),
            (*s).unhd.tauts.trn,
            lglpcnt((*s).unhd.tauts.trn as libc::c_double, sum as libc::c_double),
            (*s).unhd.tauts.lrg,
            lglpcnt((*s).unhd.tauts.lrg as libc::c_double, sum as libc::c_double),
        );
        lglprs(
            lgl,
            b"unhd: %lld tauts, %d stamp %.0f%%, %d red %.0f%%\0" as *const u8
                as *const libc::c_char,
            sum,
            (*s).unhd.stamp.trds,
            lglpcnt((*s).unhd.stamp.trds as libc::c_double, sum as libc::c_double),
            (*s).unhd.tauts.red,
            lglpcnt((*s).unhd.tauts.red as libc::c_double, sum as libc::c_double),
        );
        sum = lglunhdhbrs(lgl) as libc::c_longlong;
        lglprs(
            lgl,
            b"unhd: %lld hbrs, %d trn %.0f%%, %d lrg %.0f%%, %d red %.0f%%\0"
                as *const u8 as *const libc::c_char,
            sum,
            (*s).unhd.hbrs.trn,
            lglpcnt((*s).unhd.hbrs.trn as libc::c_double, sum as libc::c_double),
            (*s).unhd.hbrs.lrg,
            lglpcnt((*s).unhd.hbrs.lrg as libc::c_double, sum as libc::c_double),
            (*s).unhd.hbrs.red,
            lglpcnt((*s).unhd.hbrs.red as libc::c_double, sum as libc::c_double),
        );
        sum = lglunhdstrd(lgl) as libc::c_longlong;
        lglprs(
            lgl,
            b"unhd: %lld str, %d bin %.0f%%, %d trn %.0f%%, %d lrg %.0f%%, %d red %.0f%%\0"
                as *const u8 as *const libc::c_char,
            sum,
            (*s).unhd.units.bin,
            lglpcnt((*s).unhd.units.bin as libc::c_double, sum as libc::c_double),
            (*s).unhd.str_0.trn,
            lglpcnt((*s).unhd.str_0.trn as libc::c_double, sum as libc::c_double),
            (*s).unhd.str_0.lrg,
            lglpcnt((*s).unhd.str_0.lrg as libc::c_double, sum as libc::c_double),
            (*s).unhd.str_0.red,
            lglpcnt((*s).unhd.str_0.red as libc::c_double, sum as libc::c_double),
        );
        removed = (*s).fixed.sum + (*s).elm.elmd + (*s).equiv.sum;
        remaining = (*lgl).maxext - removed;
        lglprs(
            lgl,
            b"vars: %d remaining %.0f%% and %d removed %.0f%% out of %d\0" as *const u8
                as *const libc::c_char,
            remaining,
            lglpcnt(remaining as libc::c_double, (*lgl).maxext as libc::c_double),
            removed,
            lglpcnt(removed as libc::c_double, (*lgl).maxext as libc::c_double),
            (*lgl).maxext,
        );
        lglprs(
            lgl,
            b"vars: %d fixed %.0f%%, %d eliminated %.0f%%, %d equivalent %.0f%%\0"
                as *const u8 as *const libc::c_char,
            (*s).fixed.sum,
            lglpcnt((*s).fixed.sum as libc::c_double, (*lgl).maxext as libc::c_double),
            (*s).elm.elmd,
            lglpcnt((*s).elm.elmd as libc::c_double, (*lgl).maxext as libc::c_double),
            (*s).equiv.sum,
            lglpcnt((*s).equiv.sum as libc::c_double, (*lgl).maxext as libc::c_double),
        );
        visits = ((*s).visits.search + (*s).visits.simp + (*s).visits.lkhd)
            as libc::c_longlong;
        lglprs(
            lgl,
            b"vsts: %lld visits, %.0f%% srch, %.0f%% simp, %.0f%% lkhd\0" as *const u8
                as *const libc::c_char,
            visits,
            lglpcnt((*s).visits.search as libc::c_double, visits as libc::c_double),
            lglpcnt((*s).visits.simp as libc::c_double, visits as libc::c_double),
            lglpcnt((*s).visits.lkhd as libc::c_double, visits as libc::c_double),
        );
        lglprs(
            lgl,
            b"vsts: %.1f search visits per propagation, %.1f per conflict\0" as *const u8
                as *const libc::c_char,
            lglavg(
                (*s).visits.search as libc::c_double,
                (*s).props.search as libc::c_double,
            ),
            lglavg((*s).visits.search as libc::c_double, (*s).confs as libc::c_double),
        );
        lglprs(
            lgl,
            b"wchs: %lld pushed, %lld enlarged, %d defrags\0" as *const u8
                as *const libc::c_char,
            (*s).pshwchs as libc::c_longlong,
            (*s).enlwchs as libc::c_longlong,
            (*s).defrags,
        );
        lglprsline(lgl);
        lglgluestats(lgl);
        lglprsline(lgl);
    }
    lglprof(lgl);
    lglprsline(lgl);
    lglprs(
        lgl,
        b"%13lld conflicts,    %10.1f confs/sec\0" as *const u8 as *const libc::c_char,
        (*s).confs as libc::c_longlong,
        lglavg((*s).confs as libc::c_double, t),
    );
    lglprs(
        lgl,
        b"%13lld ternaries,    %10.1f confs/ternary\0" as *const u8
            as *const libc::c_char,
        (*s).trns as libc::c_longlong,
        lglavg((*s).confs as libc::c_double, (*s).trns as libc::c_double),
    );
    lglprs(
        lgl,
        b"%13lld binaries,     %10.1f confs/binary\0" as *const u8
            as *const libc::c_char,
        (*s).bins as libc::c_longlong,
        lglavg((*s).confs as libc::c_double, (*s).bins as libc::c_double),
    );
    lglprs(
        lgl,
        b"%13lld iterations,   %10.1f confs/iteration\0" as *const u8
            as *const libc::c_char,
        (*s).its.count as libc::c_longlong,
        lglavg((*s).confs as libc::c_double, (*s).its.count as libc::c_double),
    );
    lglprsline(lgl);
    lglprs(
        lgl,
        b"%13lld reductions,   %10.1f redus/sec, %8.1f confs/reduction\0" as *const u8
            as *const libc::c_char,
        (*s).reduced.count as libc::c_longlong,
        lglavg((*s).reduced.count as libc::c_double, t),
        lglavg((*s).confs as libc::c_double, (*s).reduced.count as libc::c_double),
    );
    lglprs(
        lgl,
        b"%13lld restarts,     %10.1f rests/sec, %8.1f confs/restart\0" as *const u8
            as *const libc::c_char,
        (*s).restarts.count as libc::c_longlong,
        lglavg((*s).restarts.count as libc::c_double, t),
        lglavg((*s).confs as libc::c_double, (*s).restarts.count as libc::c_double),
    );
    lglprs(
        lgl,
        b"%13lld decisions,    %10.1f decis/sec, %8.1f decis/conflict\0" as *const u8
            as *const libc::c_char,
        (*s).decisions as libc::c_longlong,
        lglavg((*s).decisions as libc::c_double, t),
        lglavg((*s).decisions as libc::c_double, (*s).confs as libc::c_double),
    );
    lglprs(
        lgl,
        b"%13lld propagations, %10.1f props/sec, %8.1f props/decision\0" as *const u8
            as *const libc::c_char,
        p,
        lglavg(p as libc::c_double, t),
        lglavg(p as libc::c_double, (*s).decisions as libc::c_double),
    );
    lglprsline(lgl);
    lglprs(
        lgl,
        b"%.1f seconds, %.1f MB\0" as *const u8 as *const libc::c_char,
        t,
        lglmaxmb(lgl),
    );
    fflush((*lgl).out);
}
#[no_mangle]
pub unsafe extern "C" fn lglgetprops(mut lgl: *mut LGL) -> int64_t {
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 12], &[libc::c_char; 12]>(b"lglgetprops\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).forked == 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 12], &[libc::c_char; 12]>(b"lglgetprops\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"forked manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    return (*(*lgl).stats).props.search + (*(*lgl).stats).props.simp;
}
#[no_mangle]
pub unsafe extern "C" fn lglgetconfs(mut lgl: *mut LGL) -> int64_t {
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 12], &[libc::c_char; 12]>(b"lglgetconfs\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).forked == 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 12], &[libc::c_char; 12]>(b"lglgetconfs\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"forked manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    return (*(*lgl).stats).confs;
}
#[no_mangle]
pub unsafe extern "C" fn lglgetdecs(mut lgl: *mut LGL) -> int64_t {
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 11], &[libc::c_char; 11]>(b"lglgetdecs\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).forked == 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 11], &[libc::c_char; 11]>(b"lglgetdecs\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"forked manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    return (*(*lgl).stats).decisions;
}
#[no_mangle]
pub unsafe extern "C" fn lglsizes(mut lgl: *mut LGL) {
    lglprt(
        lgl,
        0 as libc::c_int,
        b"sizeof (int) == %ld\0" as *const u8 as *const libc::c_char,
        ::core::mem::size_of::<libc::c_int>() as libc::c_ulong as libc::c_long,
    );
    lglprt(
        lgl,
        0 as libc::c_int,
        b"sizeof (unsigned) == %ld\0" as *const u8 as *const libc::c_char,
        ::core::mem::size_of::<libc::c_uint>() as libc::c_ulong as libc::c_long,
    );
    lglprt(
        lgl,
        0 as libc::c_int,
        b"sizeof (void*) == %ld\0" as *const u8 as *const libc::c_char,
        ::core::mem::size_of::<*mut libc::c_void>() as libc::c_ulong as libc::c_long,
    );
    lglprt(
        lgl,
        0 as libc::c_int,
        b"sizeof (Stk) == %ld\0" as *const u8 as *const libc::c_char,
        ::core::mem::size_of::<Stk>() as libc::c_ulong as libc::c_long,
    );
    lglprt(
        lgl,
        0 as libc::c_int,
        b"sizeof (Fun) == %ld\0" as *const u8 as *const libc::c_char,
        ::core::mem::size_of::<Fun>() as libc::c_ulong as libc::c_long,
    );
    lglprt(
        lgl,
        0 as libc::c_int,
        b"sizeof (AVar) == %ld\0" as *const u8 as *const libc::c_char,
        ::core::mem::size_of::<AVar>() as libc::c_ulong as libc::c_long,
    );
    lglprt(
        lgl,
        0 as libc::c_int,
        b"sizeof (DVar) == %ld\0" as *const u8 as *const libc::c_char,
        ::core::mem::size_of::<DVar>() as libc::c_ulong as libc::c_long,
    );
    lglprt(
        lgl,
        0 as libc::c_int,
        b"sizeof (QVar) == %ld\0" as *const u8 as *const libc::c_char,
        ::core::mem::size_of::<QVar>() as libc::c_ulong as libc::c_long,
    );
    lglprt(
        lgl,
        0 as libc::c_int,
        b"sizeof (EVar) == %ld\0" as *const u8 as *const libc::c_char,
        ::core::mem::size_of::<EVar>() as libc::c_ulong as libc::c_long,
    );
    lglprt(
        lgl,
        0 as libc::c_int,
        b"sizeof (Stats.lir) == %ld\0" as *const u8 as *const libc::c_char,
        ::core::mem::size_of::<[C2RustUnnamed_84; 16]>() as libc::c_ulong as libc::c_long,
    );
    lglprt(
        lgl,
        0 as libc::c_int,
        b"sizeof (Stats) == %ld\0" as *const u8 as *const libc::c_char,
        ::core::mem::size_of::<Stats>() as libc::c_ulong as libc::c_long,
    );
    lglprt(
        lgl,
        0 as libc::c_int,
        b"sizeof (LGL) == %ld\0" as *const u8 as *const libc::c_char,
        ::core::mem::size_of::<LGL>() as libc::c_ulong as libc::c_long,
    );
    lglprt(
        lgl,
        0 as libc::c_int,
        b"MAXVAR == %ld\0" as *const u8 as *const libc::c_char,
        ((2147483647 as libc::c_int >> RMSHFT as libc::c_int) - 2 as libc::c_int)
            as libc::c_long,
    );
    lglprt(
        lgl,
        0 as libc::c_int,
        b"MAXREDLIDX == %ld\0" as *const u8 as *const libc::c_char,
        (((1 as libc::c_int) << 31 as libc::c_int - 4 as libc::c_int) - 2 as libc::c_int)
            as libc::c_long,
    );
    lglprt(
        lgl,
        0 as libc::c_int,
        b"MAXIRRLIDX == %ld\0" as *const u8 as *const libc::c_char,
        (((1 as libc::c_int) << 31 as libc::c_int - RMSHFT as libc::c_int)
            - 2 as libc::c_int) as libc::c_long,
    );
}
#[no_mangle]
pub unsafe extern "C" fn lglrelease(mut lgl: *mut LGL) {
    let mut dealloc: lgldealloc = None;
    let mut i: libc::c_int = 0;
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 11], &[libc::c_char; 11]>(b"lglrelease\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if !((*lgl).clone).is_null() {
        lglrelease((*lgl).clone);
        (*lgl).clone = 0 as *mut LGL;
    }
    if !((*lgl).apitrace).is_null() {
        lgltrapi(lgl, b"release\0" as *const u8 as *const libc::c_char);
    }
    lgldel(
        lgl,
        (*lgl).avars as *mut libc::c_void,
        ((*lgl).szvars as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<AVar>() as libc::c_ulong),
    );
    (*lgl).avars = 0 as *mut AVar;
    lgldel(
        lgl,
        (*lgl).doms as *mut libc::c_void,
        ((2 as libc::c_int * (*lgl).szvars) as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
    );
    (*lgl).doms = 0 as *mut libc::c_int;
    lgldel(
        lgl,
        (*lgl).drail as *mut libc::c_void,
        ((*lgl).szdrail as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<TD>() as libc::c_ulong),
    );
    (*lgl).drail = 0 as *mut TD;
    lgldel(
        lgl,
        (*lgl).dvars as *mut libc::c_void,
        ((*lgl).szvars as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<DVar>() as libc::c_ulong),
    );
    (*lgl).dvars = 0 as *mut DVar;
    lgldel(
        lgl,
        (*lgl).ext as *mut libc::c_void,
        ((*lgl).szext as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Ext>() as libc::c_ulong),
    );
    (*lgl).ext = 0 as *mut Ext;
    lgldel(
        lgl,
        (*lgl).i2e as *mut libc::c_void,
        ((*lgl).szvars as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
    );
    (*lgl).i2e = 0 as *mut libc::c_int;
    lgldel(
        lgl,
        (*lgl).jwh as *mut libc::c_void,
        ((2 as libc::c_int * (*lgl).szvars) as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Flt>() as libc::c_ulong),
    );
    (*lgl).jwh = 0 as *mut Flt;
    lgldel(
        lgl,
        (*lgl).qvars as *mut libc::c_void,
        ((*lgl).szvars as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<QVar>() as libc::c_ulong),
    );
    (*lgl).qvars = 0 as *mut QVar;
    lgldel(
        lgl,
        (*lgl).vals as *mut libc::c_void,
        ((*lgl).szvars as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Val>() as libc::c_ulong),
    );
    (*lgl).vals = 0 as *mut Val;
    lglrelctk(lgl, &mut (*lgl).control);
    lglrelstk(lgl, &mut (*lgl).assume);
    lglrelstk(lgl, &mut (*lgl).clause);
    lglrelstk(lgl, &mut (*lgl).dsched);
    lglrelstk(lgl, &mut (*lgl).queue.stk);
    lglrelstk(lgl, &mut (*lgl).eassume);
    lglrelstk(lgl, &mut (*lgl).eclause);
    lglrelstk(lgl, &mut (*lgl).extend);
    lglrelstk(lgl, &mut (*lgl).learned);
    lglrelstk(lgl, &mut (*lgl).frames);
    lglrelstk(lgl, &mut (*lgl).promote);
    lglrelstk(lgl, &mut (*lgl).trail);
    lglrelstk(lgl, &mut (*(*lgl).wchs).stk);
    lglrelstk(lgl, &mut (*lgl).irr);
    i = 0 as libc::c_int;
    while i <= ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int {
        lglrelstk(lgl, &mut *((*lgl).red).offset(i as isize));
        i += 1;
        i;
    }
    lglrelstk(lgl, &mut (*lgl).c2rust_unnamed_0.lcaseen);
    lglrelstk(lgl, &mut (*lgl).resolvent);
    lglrelstk(lgl, &mut (*lgl).minstk);
    lglrelstk(lgl, &mut (*lgl).poisoned);
    lglrelstk(lgl, &mut (*lgl).seen);
    lglrelstk(lgl, &mut (*lgl).saved.bin);
    lglrelstk(lgl, &mut (*lgl).saved.trn);
    lgldel(
        lgl,
        (*lgl).limits as *mut libc::c_void,
        (1 as libc::c_int as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Limits>() as libc::c_ulong),
    );
    (*lgl).limits = 0 as *mut Limits;
    lgldel(
        lgl,
        (*lgl).times as *mut libc::c_void,
        (1 as libc::c_int as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Times>() as libc::c_ulong),
    );
    (*lgl).times = 0 as *mut Times;
    lgldel(
        lgl,
        (*lgl).timers as *mut libc::c_void,
        (1 as libc::c_int as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Timers>() as libc::c_ulong),
    );
    (*lgl).timers = 0 as *mut Timers;
    lgldel(
        lgl,
        (*lgl).red as *mut libc::c_void,
        ((((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int + 1 as libc::c_int)
            as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Stk>() as libc::c_ulong),
    );
    (*lgl).red = 0 as *mut Stk;
    lgldel(
        lgl,
        (*lgl).wchs as *mut libc::c_void,
        (1 as libc::c_int as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Wchs>() as libc::c_ulong),
    );
    (*lgl).wchs = 0 as *mut Wchs;
    if !((*lgl).fltstr).is_null() {
        lgldel(
            lgl,
            (*lgl).fltstr as *mut libc::c_void,
            (1 as libc::c_int as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<FltStr>() as libc::c_ulong),
        );
        (*lgl).fltstr = 0 as *mut FltStr;
    }
    if !((*lgl).cbs).is_null() {
        lgldel(
            lgl,
            (*lgl).cbs as *mut libc::c_void,
            (1 as libc::c_int as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<Cbs>() as libc::c_ulong),
        );
        (*lgl).cbs = 0 as *mut Cbs;
    }
    lgldelstr(lgl, (*lgl).prefix);
    lgldec(lgl, ::core::mem::size_of::<Stats>() as libc::c_ulong);
    lgldec(lgl, ::core::mem::size_of::<Opts>() as libc::c_ulong);
    lgldec(lgl, ::core::mem::size_of::<Mem>() as libc::c_ulong);
    lgldec(lgl, ::core::mem::size_of::<LGL>() as libc::c_ulong);
    if (*lgl).closeapitrace as libc::c_int == 1 as libc::c_int {
        fclose((*lgl).apitrace);
    }
    if (*lgl).closeapitrace as libc::c_int == 2 as libc::c_int {
        pclose((*lgl).apitrace);
    }
    dealloc = (*(*lgl).mem).dealloc;
    if dealloc.is_some() {
        let mut memstate: *mut libc::c_void = (*(*lgl).mem).state;
        if !((*lgl).stats).is_null() {
            dealloc
                .expect(
                    "non-null function pointer",
                )(
                memstate,
                (*lgl).stats as *mut libc::c_void,
                ::core::mem::size_of::<Stats>() as libc::c_ulong,
            );
        }
        if !((*lgl).times).is_null() {
            dealloc
                .expect(
                    "non-null function pointer",
                )(
                memstate,
                (*lgl).times as *mut libc::c_void,
                ::core::mem::size_of::<Times>() as libc::c_ulong,
            );
        }
        if !((*lgl).opts).is_null() {
            dealloc
                .expect(
                    "non-null function pointer",
                )(
                memstate,
                (*lgl).opts as *mut libc::c_void,
                ::core::mem::size_of::<Opts>() as libc::c_ulong,
            );
        }
        dealloc
            .expect(
                "non-null function pointer",
            )(
            memstate,
            (*lgl).mem as *mut libc::c_void,
            ::core::mem::size_of::<Mem>() as libc::c_ulong,
        );
        dealloc
            .expect(
                "non-null function pointer",
            )(
            memstate,
            lgl as *mut libc::c_void,
            ::core::mem::size_of::<LGL>() as libc::c_ulong,
        );
    } else {
        free((*lgl).stats as *mut libc::c_void);
        free((*lgl).times as *mut libc::c_void);
        free((*lgl).opts as *mut libc::c_void);
        free((*lgl).mem as *mut libc::c_void);
        free(lgl as *mut libc::c_void);
    };
}
#[no_mangle]
pub unsafe extern "C" fn lglutrav(
    mut lgl: *mut LGL,
    mut state: *mut libc::c_void,
    mut trav: Option::<unsafe extern "C" fn(*mut libc::c_void, libc::c_int) -> ()>,
) {
    let mut elit: libc::c_int = 0;
    let mut val: libc::c_int = 0;
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 9], &[libc::c_char; 9]>(b"lglutrav\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).forked == 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 9], &[libc::c_char; 9]>(b"lglutrav\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"forked manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).mt == 0 && lglbcp(lgl) == 0 {
        lglmt(lgl);
    }
    if (*lgl).mt == 0 {
        lglgc(lgl);
    }
    if (*lgl).mt != 0 {
        return;
    }
    if (*lgl).level > 0 as libc::c_int {
        lglbacktrack(lgl, 0 as libc::c_int);
    }
    elit = 1 as libc::c_int;
    while elit <= (*lgl).maxext {
        val = lglefixed(lgl, elit);
        if !(val == 0) {
            trav
                .expect(
                    "non-null function pointer",
                )(state, if val < 0 as libc::c_int { -elit } else { elit });
        }
        elit += 1;
        elit;
    }
}
#[no_mangle]
pub unsafe extern "C" fn lgletrav(
    mut lgl: *mut LGL,
    mut state: *mut libc::c_void,
    mut trav: Option::<
        unsafe extern "C" fn(*mut libc::c_void, libc::c_int, libc::c_int) -> (),
    >,
) {
    let mut elit: libc::c_int = 0;
    let mut erepr: libc::c_int = 0;
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 9], &[libc::c_char; 9]>(b"lgletrav\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).forked == 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 9], &[libc::c_char; 9]>(b"lgletrav\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"forked manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).mt == 0 && lglbcp(lgl) == 0 {
        lglmt(lgl);
    }
    if (*lgl).mt == 0 {
        lglgc(lgl);
    }
    if (*lgl).mt != 0 {
        return;
    }
    if (*lgl).level > 0 as libc::c_int {
        lglbacktrack(lgl, 0 as libc::c_int);
    }
    elit = 1 as libc::c_int;
    while elit <= (*lgl).maxext {
        if !(lglefixed(lgl, elit) != 0) {
            erepr = lglerepr(lgl, elit);
            if !(erepr == elit) {
                trav.expect("non-null function pointer")(state, elit, erepr);
            }
        }
        elit += 1;
        elit;
    }
}
unsafe extern "C" fn lglictrav(
    mut lgl: *mut LGL,
    mut internal: libc::c_int,
    mut redtoo: libc::c_int,
    mut state: *mut libc::c_void,
    mut trav: Option::<
        unsafe extern "C" fn(*mut libc::c_void, libc::c_int, libc::c_int) -> (),
    >,
) {
    let mut idx: libc::c_int = 0;
    let mut sign: libc::c_int = 0;
    let mut lit: libc::c_int = 0;
    let mut blit: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut red: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut other2: libc::c_int = 0;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut w: *const libc::c_int = 0 as *const libc::c_int;
    let mut eow: *const libc::c_int = 0 as *const libc::c_int;
    let mut c: *const libc::c_int = 0 as *const libc::c_int;
    let mut glue: libc::c_int = 0;
    let mut hts: *mut HTS = 0 as *mut HTS;
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 10], &[libc::c_char; 10]>(b"lglictrav\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).forked == 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 10], &[libc::c_char; 10]>(b"lglictrav\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"forked manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).mt != 0 {
        trav
            .expect(
                "non-null function pointer",
            )(state, 0 as libc::c_int, 0 as libc::c_int);
        return;
    }
    idx = 2 as libc::c_int;
    while idx < (*lgl).nvars {
        sign = -(1 as libc::c_int);
        while sign <= 1 as libc::c_int {
            lit = sign * idx;
            hts = lglhts(lgl, lit);
            w = lglhts2wchs(lgl, hts);
            eow = w.offset((*hts).count as isize);
            let mut current_block_47: u64;
            p = w;
            while p < eow {
                blit = *p;
                tag = blit & MASKCS as libc::c_int;
                red = blit & REDCS as libc::c_int;
                if tag == TRNCS as libc::c_int || tag == LRGCS as libc::c_int {
                    p = p.offset(1);
                    p;
                }
                if !(redtoo == 0 && red != 0) {
                    if !(tag != BINCS as libc::c_int && tag != TRNCS as libc::c_int) {
                        other = blit >> RMSHFT as libc::c_int;
                        if !(abs(other) < idx) {
                            if tag == TRNCS as libc::c_int {
                                other2 = *p;
                                if abs(other2) < idx {
                                    current_block_47 = 2569451025026770673;
                                } else {
                                    current_block_47 = 2480299350034459858;
                                }
                            } else {
                                other2 = 0 as libc::c_int;
                                current_block_47 = 2480299350034459858;
                            }
                            match current_block_47 {
                                2569451025026770673 => {}
                                _ => {
                                    trav
                                        .expect(
                                            "non-null function pointer",
                                        )(
                                        state,
                                        red,
                                        if internal != 0 { lit } else { lglexport(lgl, lit) },
                                    );
                                    trav
                                        .expect(
                                            "non-null function pointer",
                                        )(
                                        state,
                                        red,
                                        if internal != 0 { other } else { lglexport(lgl, other) },
                                    );
                                    if other2 != 0 {
                                        trav
                                            .expect(
                                                "non-null function pointer",
                                            )(
                                            state,
                                            red,
                                            if internal != 0 { other2 } else { lglexport(lgl, other2) },
                                        );
                                    }
                                    trav
                                        .expect(
                                            "non-null function pointer",
                                        )(state, red, 0 as libc::c_int);
                                }
                            }
                        }
                    }
                }
                p = p.offset(1);
                p;
            }
            sign += 2 as libc::c_int;
        }
        idx += 1;
        idx;
    }
    glue = -(1 as libc::c_int);
    while glue < ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int {
        let mut start: *const libc::c_int = if glue < 0 as libc::c_int {
            (*lgl).irr.start
        } else {
            (*((*lgl).red).offset(glue as isize)).start
        };
        let mut top: *const libc::c_int = if glue < 0 as libc::c_int {
            (*lgl).irr.top
        } else {
            (*((*lgl).red).offset(glue as isize)).top
        };
        let red_0: libc::c_int = (glue >= 0 as libc::c_int) as libc::c_int;
        if redtoo == 0 && red_0 != 0 {
            break;
        }
        c = start;
        while c < top {
            p = c;
            if !(*p >= 2147483647 as libc::c_int >> RMSHFT as libc::c_int) {
                loop {
                    other = *p;
                    if !(other != 0) {
                        break;
                    }
                    trav
                        .expect(
                            "non-null function pointer",
                        )(
                        state,
                        red_0,
                        if internal != 0 { other } else { lglexport(lgl, other) },
                    );
                    p = p.offset(1);
                    p;
                }
                trav.expect("non-null function pointer")(state, red_0, 0 as libc::c_int);
            }
            c = p.offset(1 as libc::c_int as isize);
        }
        glue += 1;
        glue;
    }
}
unsafe extern "C" fn lglirrtrav(
    mut state: *mut libc::c_void,
    mut red: libc::c_int,
    mut lit: libc::c_int,
) {
    let mut irrtrav: *mut IrrTrav = state as *mut IrrTrav;
    ((*irrtrav).trav).expect("non-null function pointer")((*irrtrav).state, lit);
}
#[no_mangle]
pub unsafe extern "C" fn lglctrav(
    mut lgl: *mut LGL,
    mut state: *mut libc::c_void,
    mut trav: Option::<unsafe extern "C" fn(*mut libc::c_void, libc::c_int) -> ()>,
) {
    let mut irrtrav: IrrTrav = IrrTrav {
        state: 0 as *mut libc::c_void,
        trav: None,
    };
    irrtrav.state = state;
    irrtrav.trav = trav;
    if (*lgl).level != 0 {
        lglbacktrack(lgl, 0 as libc::c_int);
    }
    if (*lgl).mt == 0 && lglbcp(lgl) == 0 {
        lglmt(lgl);
    }
    if (*lgl).mt == 0 {
        lglgc(lgl);
    }
    lglictrav(
        lgl,
        0 as libc::c_int,
        0 as libc::c_int,
        &mut irrtrav as *mut IrrTrav as *mut libc::c_void,
        Some(
            lglirrtrav
                as unsafe extern "C" fn(
                    *mut libc::c_void,
                    libc::c_int,
                    libc::c_int,
                ) -> (),
        ),
    );
}
unsafe extern "C" fn lgltravcounter(
    mut voidptr: *mut libc::c_void,
    mut lit: libc::c_int,
) {
    let mut cntptr: *mut libc::c_int = voidptr as *mut libc::c_int;
    if lit == 0 {
        *cntptr += 1 as libc::c_int;
    }
}
unsafe extern "C" fn lgltravprinter(
    mut voidptr: *mut libc::c_void,
    mut lit: libc::c_int,
) {
    let mut out: *mut FILE = voidptr as *mut FILE;
    if lit != 0 {
        fprintf(out, b"%d \0" as *const u8 as *const libc::c_char, lit);
    } else {
        fprintf(out, b"0\n\0" as *const u8 as *const libc::c_char);
    };
}
#[no_mangle]
pub unsafe extern "C" fn lglprint(mut lgl: *mut LGL, mut file: *mut FILE) {
    let mut count: libc::c_int = 0 as libc::c_int;
    lglctrav(
        lgl,
        &mut count as *mut libc::c_int as *mut libc::c_void,
        Some(
            lgltravcounter as unsafe extern "C" fn(*mut libc::c_void, libc::c_int) -> (),
        ),
    );
    fprintf(
        file,
        b"p cnf %d %d\n\0" as *const u8 as *const libc::c_char,
        lglmaxvar(lgl),
        count,
    );
    lglctrav(
        lgl,
        file as *mut libc::c_void,
        Some(
            lgltravprinter as unsafe extern "C" fn(*mut libc::c_void, libc::c_int) -> (),
        ),
    );
}
#[no_mangle]
pub unsafe extern "C" fn lglprintall(mut lgl: *mut LGL, mut file: *mut FILE) {
    let mut count: libc::c_int = 0 as libc::c_int;
    lgltravall(
        lgl,
        &mut count as *mut libc::c_int as *mut libc::c_void,
        Some(
            lgltravcounter as unsafe extern "C" fn(*mut libc::c_void, libc::c_int) -> (),
        ),
    );
    fprintf(
        file,
        b"p cnf %d %d\n\0" as *const u8 as *const libc::c_char,
        lglmaxvar(lgl),
        count,
    );
    lgltravall(
        lgl,
        file as *mut libc::c_void,
        Some(
            lgltravprinter as unsafe extern "C" fn(*mut libc::c_void, libc::c_int) -> (),
        ),
    );
}
#[no_mangle]
pub unsafe extern "C" fn lglrtrav(
    mut lgl: *mut LGL,
    mut state: *mut libc::c_void,
    mut trav: Option::<
        unsafe extern "C" fn(*mut libc::c_void, libc::c_int, libc::c_int) -> (),
    >,
) {
    let mut idx: libc::c_int = 0;
    let mut sign: libc::c_int = 0;
    let mut lit: libc::c_int = 0;
    let mut blit: libc::c_int = 0;
    let mut tag: libc::c_int = 0;
    let mut red: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut other2: libc::c_int = 0;
    let mut glue: libc::c_int = 0;
    let mut p: *const libc::c_int = 0 as *const libc::c_int;
    let mut c: *const libc::c_int = 0 as *const libc::c_int;
    let mut w: *const libc::c_int = 0 as *const libc::c_int;
    let mut eow: *const libc::c_int = 0 as *const libc::c_int;
    let mut lir: *mut Stk = 0 as *mut Stk;
    let mut hts: *mut HTS = 0 as *mut HTS;
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 9], &[libc::c_char; 9]>(b"lglrtrav\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).forked == 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 9], &[libc::c_char; 9]>(b"lglrtrav\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"forked manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*lgl).mt != 0 {
        return;
    }
    lglgc(lgl);
    if (*lgl).level > 0 as libc::c_int {
        lglbacktrack(lgl, 0 as libc::c_int);
    }
    idx = 2 as libc::c_int;
    while idx < (*lgl).nvars {
        if !(lglval(lgl, idx) != 0) {
            sign = -(1 as libc::c_int);
            while sign <= 1 as libc::c_int {
                lit = sign * idx;
                hts = lglhts(lgl, lit);
                w = lglhts2wchs(lgl, hts);
                eow = w.offset((*hts).count as isize);
                let mut current_block_50: u64;
                p = w;
                while p < eow {
                    blit = *p;
                    tag = blit & MASKCS as libc::c_int;
                    red = blit & REDCS as libc::c_int;
                    if tag == TRNCS as libc::c_int || tag == LRGCS as libc::c_int {
                        p = p.offset(1);
                        p;
                    }
                    if !(red == 0) {
                        if !(tag != BINCS as libc::c_int && tag != TRNCS as libc::c_int)
                        {
                            other = blit >> RMSHFT as libc::c_int;
                            if !(abs(other) < idx) {
                                if tag == TRNCS as libc::c_int {
                                    other2 = *p;
                                    if abs(other2) < idx {
                                        current_block_50 = 17500079516916021833;
                                    } else {
                                        current_block_50 = 2122094917359643297;
                                    }
                                } else {
                                    other2 = 0 as libc::c_int;
                                    current_block_50 = 2122094917359643297;
                                }
                                match current_block_50 {
                                    17500079516916021833 => {}
                                    _ => {
                                        trav
                                            .expect(
                                                "non-null function pointer",
                                            )(state, lglexport(lgl, lit), 0 as libc::c_int);
                                        trav
                                            .expect(
                                                "non-null function pointer",
                                            )(state, lglexport(lgl, other), 0 as libc::c_int);
                                        if other2 != 0 {
                                            trav
                                                .expect(
                                                    "non-null function pointer",
                                                )(state, lglexport(lgl, other2), 0 as libc::c_int);
                                        }
                                        trav
                                            .expect(
                                                "non-null function pointer",
                                            )(state, 0 as libc::c_int, 0 as libc::c_int);
                                    }
                                }
                            }
                        }
                    }
                    p = p.offset(1);
                    p;
                }
                sign += 2 as libc::c_int;
            }
        }
        idx += 1;
        idx;
    }
    glue = 0 as libc::c_int;
    while glue < ((1 as libc::c_int) << 4 as libc::c_int) - 1 as libc::c_int {
        lir = ((*lgl).red).offset(glue as isize);
        c = (*lir).start;
        while c < (*lir).top as *const libc::c_int {
            p = c;
            if !(*p >= 2147483647 as libc::c_int >> RMSHFT as libc::c_int) {
                loop {
                    other = *p;
                    if !(other != 0) {
                        break;
                    }
                    trav
                        .expect(
                            "non-null function pointer",
                        )(state, lglexport(lgl, other), 0 as libc::c_int);
                    p = p.offset(1);
                    p;
                }
                trav
                    .expect(
                        "non-null function pointer",
                    )(state, 0 as libc::c_int, 0 as libc::c_int);
            }
            c = p.offset(1 as libc::c_int as isize);
        }
        glue += 1;
        glue;
    }
}
unsafe extern "C" fn lgltravallu(mut voidptr: *mut libc::c_void, mut unit: libc::c_int) {
    let mut state: *mut Trv = voidptr as *mut Trv;
    ((*state).trav).expect("non-null function pointer")((*state).state, unit);
    ((*state).trav)
        .expect("non-null function pointer")((*state).state, 0 as libc::c_int);
}
unsafe extern "C" fn lgltravalle(
    mut voidptr: *mut libc::c_void,
    mut lit: libc::c_int,
    mut repr: libc::c_int,
) {
    let mut state: *mut Trv = voidptr as *mut Trv;
    ((*state).trav).expect("non-null function pointer")((*state).state, -lit);
    ((*state).trav).expect("non-null function pointer")((*state).state, repr);
    ((*state).trav)
        .expect("non-null function pointer")((*state).state, 0 as libc::c_int);
    ((*state).trav).expect("non-null function pointer")((*state).state, lit);
    ((*state).trav).expect("non-null function pointer")((*state).state, -repr);
    ((*state).trav)
        .expect("non-null function pointer")((*state).state, 0 as libc::c_int);
}
#[no_mangle]
pub unsafe extern "C" fn lgltravall(
    mut lgl: *mut LGL,
    mut state: *mut libc::c_void,
    mut trav: Option::<unsafe extern "C" fn(*mut libc::c_void, libc::c_int) -> ()>,
) {
    let mut travstate: Trv = Trv {
        state: 0 as *mut libc::c_void,
        trav: None,
    };
    travstate.state = state;
    travstate.trav = trav;
    lglutrav(
        lgl,
        &mut travstate as *mut Trv as *mut libc::c_void,
        Some(lgltravallu as unsafe extern "C" fn(*mut libc::c_void, libc::c_int) -> ()),
    );
    lgletrav(
        lgl,
        &mut travstate as *mut Trv as *mut libc::c_void,
        Some(
            lgltravalle
                as unsafe extern "C" fn(
                    *mut libc::c_void,
                    libc::c_int,
                    libc::c_int,
                ) -> (),
        ),
    );
    lglctrav(lgl, state, trav);
}
unsafe extern "C" fn lglforkadd(
    mut ptr: *mut libc::c_void,
    mut red: libc::c_int,
    mut lit: libc::c_int,
) {
    lgladd(ptr as *mut LGL, if lit != 0 { lglforklit(lit) } else { 0 as libc::c_int });
}
#[no_mangle]
pub unsafe extern "C" fn lglfork(mut parent: *mut LGL) -> *mut LGL {
    let mut child: *mut LGL = 0 as *mut LGL;
    let mut lgl: *mut LGL = parent;
    if !lgl.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 8], &[libc::c_char; 8]>(b"lglfork\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(stderr, b"uninitialized manager\0" as *const u8 as *const libc::c_char);
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if lglmtstk(&mut (*parent).eassume) != 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 8], &[libc::c_char; 8]>(b"lglfork\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(
            stderr,
            b"can not fork under assumptions\0" as *const u8 as *const libc::c_char,
        );
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if !((*parent).forked == 2147483647 as libc::c_int) {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 8], &[libc::c_char; 8]>(b"lglfork\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(
            stderr,
            b"parent forked too often\0" as *const u8 as *const libc::c_char,
        );
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*parent).level > 0 as libc::c_int {
        lglbacktrack(parent, 0 as libc::c_int);
    }
    lglbcp(parent);
    lglgc(parent);
    child = lglminit(
        (*(*parent).mem).state,
        (*(*parent).mem).alloc,
        (*(*parent).mem).realloc,
        (*(*parent).mem).dealloc,
    );
    (*child).parent = parent;
    lglcopyclonenfork(child, parent);
    if (*parent).level != 0 {
        lglbacktrack(parent, 0 as libc::c_int);
    }
    if (*parent).mt == 0 && lglbcp(parent) == 0 {
        lglmt(parent);
    }
    if (*parent).mt == 0 {
        lglgc(parent);
    }
    lglictrav(
        parent,
        1 as libc::c_int,
        0 as libc::c_int,
        child as *mut libc::c_void,
        Some(
            lglforkadd
                as unsafe extern "C" fn(
                    *mut libc::c_void,
                    libc::c_int,
                    libc::c_int,
                ) -> (),
        ),
    );
    (*parent).forked += 1;
    (*parent).forked;
    lglprt(
        parent,
        1 as libc::c_int,
        b"forked-%d\0" as *const u8 as *const libc::c_char,
        (*parent).forked,
    );
    return child;
}
unsafe extern "C" fn lglflass(mut lgl: *mut LGL, mut from: *mut LGL) {
    let mut idx: libc::c_int = 0;
    let mut copied: libc::c_int = 0 as libc::c_int;
    (*lgl).nvars != 0;
    lglreset(lgl);
    idx = 2 as libc::c_int;
    while idx < (*lgl).nvars {
        let mut val: libc::c_int = lglderef(from, idx - 1 as libc::c_int);
        let mut lit: libc::c_int = if val < 0 as libc::c_int { -idx } else { idx };
        lgldassume(lgl, lit);
        copied += 1;
        copied;
        idx += 1;
        idx;
    }
    lglprt(
        lgl,
        1 as libc::c_int,
        b"[flass] copied %d internal assignments\0" as *const u8 as *const libc::c_char,
        copied,
    );
    (*lgl).state = SATISFIED;
    lglextend(lgl);
}
#[no_mangle]
pub unsafe extern "C" fn lgljoin(
    mut parent: *mut LGL,
    mut child: *mut LGL,
) -> libc::c_int {
    let mut res: libc::c_int = 0;
    let mut lgl: *mut LGL = parent;
    if !parent.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 8], &[libc::c_char; 8]>(b"lgljoin\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(
            stderr,
            b"uninitialized parent manager\0" as *const u8 as *const libc::c_char,
        );
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if !child.is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 8], &[libc::c_char; 8]>(b"lgljoin\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(
            stderr,
            b"uninitialized child manager\0" as *const u8 as *const libc::c_char,
        );
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*parent).forked != 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 8], &[libc::c_char; 8]>(b"lgljoin\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(
            stderr,
            b"parent manager not forked\0" as *const u8 as *const libc::c_char,
        );
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if !((*child).parent).is_null() {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 8], &[libc::c_char; 8]>(b"lgljoin\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(
            stderr,
            b"child manager has not parent\0" as *const u8 as *const libc::c_char,
        );
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if !((*child).parent != parent) {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 8], &[libc::c_char; 8]>(b"lgljoin\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(
            stderr,
            b"child manager has different parent\0" as *const u8 as *const libc::c_char,
        );
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if lglmtstk(&mut (*child).eassume) != 0 {} else {
        fprintf(
            stderr,
            b"*** API usage error of '%s' in '%s'\0" as *const u8 as *const libc::c_char,
            b"lglib.c\0" as *const u8 as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 8], &[libc::c_char; 8]>(b"lgljoin\0"))
                .as_ptr(),
        );
        if !lgl.is_null() && (*lgl).tid >= 0 as libc::c_int {
            fprintf(
                stderr,
                b" (tid %d)\0" as *const u8 as *const libc::c_char,
                (*lgl).tid,
            );
        }
        fputs(b": \0" as *const u8 as *const libc::c_char, stderr);
        fprintf(
            stderr,
            b"child manager with assumptions not supported yet\0" as *const u8
                as *const libc::c_char,
        );
        fputc('\n' as i32, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1 as libc::c_int);
    }
    if (*child).mt != 0
        || (*child).state as libc::c_uint & UNSATISFIED as libc::c_int as libc::c_uint
            != 0
    {
        lglprt(
            parent,
            1 as libc::c_int,
            b"[join] unsatisfied state\0" as *const u8 as *const libc::c_char,
        );
        if (*parent).mt == 0 {
            (*parent).mt = 1 as libc::c_int;
        }
        res = 20 as libc::c_int;
    } else if (*child).state as libc::c_uint
        & (SATISFIED as libc::c_int | EXTENDED as libc::c_int) as libc::c_uint != 0
    {
        lglprt(
            parent,
            1 as libc::c_int,
            b"[join] satisfied state\0" as *const u8 as *const libc::c_char,
        );
        lglflass(parent, child);
        res = 10 as libc::c_int;
    } else {
        lglprt(
            parent,
            1 as libc::c_int,
            b"[join] unknown state\0" as *const u8 as *const libc::c_char,
        );
        lglreset(parent);
        let mut lgl_0: *mut LGL = parent;
        (*lgl_0).state = UNKNOWN;
        res = 0 as libc::c_int;
    }
    return res;
}
unsafe extern "C" fn lglnextch(
    mut in_0: *mut FILE,
    mut linenoptr: *mut libc::c_int,
) -> libc::c_int {
    let mut res: libc::c_int = getc(in_0);
    if res == '\n' as i32 {
        *linenoptr += 1 as libc::c_int;
    }
    return res;
}
static mut isoptchartab: [libc::c_char; 256] = [0; 256];
static mut isoptchartabinitialized: libc::c_int = 0;
unsafe extern "C" fn isoptchar(mut uch: libc::c_uchar) -> libc::c_int {
    let mut i: libc::c_int = 0;
    if isoptchartabinitialized == 0 {
        i = 'a' as i32;
        while i <= 'z' as i32 {
            isoptchartab[i as usize] = 1 as libc::c_int as libc::c_char;
            i += 1;
            i;
        }
        i = 'A' as i32;
        while i <= 'Z' as i32 {
            isoptchartab[i as usize] = 1 as libc::c_int as libc::c_char;
            i += 1;
            i;
        }
        i = '0' as i32;
        while i <= '9' as i32 {
            isoptchartab[i as usize] = 1 as libc::c_int as libc::c_char;
            i += 1;
            i;
        }
        isoptchartab['_' as i32 as usize] = 1 as libc::c_int as libc::c_char;
        isoptchartab['-' as i32 as usize] = isoptchartab['_' as i32 as usize];
        isoptchartabinitialized = 1 as libc::c_int;
    }
    return isoptchartab[uch as usize] as libc::c_int;
}
unsafe extern "C" fn lglenlbuf(mut lgl: *mut LGL, mut b: *mut Buf) {
    let mut new_size: size_t = if (*b).size != 0 {
        2 as libc::c_int as size_t * (*b).size
    } else {
        2 as libc::c_int as size_t
    };
    (*b)
        .start = lglrsz(
        lgl,
        (*b).start as *mut libc::c_void,
        ((*b).size)
            .wrapping_mul(::core::mem::size_of::<libc::c_char>() as libc::c_ulong),
        new_size.wrapping_mul(::core::mem::size_of::<libc::c_char>() as libc::c_ulong),
    ) as *mut libc::c_char;
    (*b).size = new_size;
}
unsafe extern "C" fn lglpushbuf(
    mut lgl: *mut LGL,
    mut buf: *mut Buf,
    mut ch: libc::c_int,
) {
    if ((*buf).count).wrapping_add(1 as libc::c_int as size_t) >= (*buf).size {
        lglenlbuf(lgl, buf);
    }
    let fresh320 = (*buf).count;
    (*buf).count = ((*buf).count).wrapping_add(1);
    *((*buf).start).offset(fresh320 as isize) = ch as libc::c_char;
    *((*buf).start).offset((*buf).count as isize) = 0 as libc::c_int as libc::c_char;
}
#[no_mangle]
pub unsafe extern "C" fn lglparsefile(
    mut lgl: *mut LGL,
    mut in_0: *mut FILE,
    mut force: libc::c_int,
    mut lp: *mut libc::c_int,
    mut mp: *mut libc::c_int,
) -> *const libc::c_char {
    let mut current_block: u64;
    let mut ch: libc::c_int = 0;
    let mut prev: libc::c_int = 0;
    let mut m: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    let mut v: libc::c_int = 0;
    let mut c: libc::c_int = 0;
    let mut l: libc::c_int = 0;
    let mut lit: libc::c_int = 0;
    let mut sign: libc::c_int = 0;
    let mut val: libc::c_int = 0;
    let mut embedded: libc::c_int = 0 as libc::c_int;
    let mut header: libc::c_int = 0;
    let mut section: libc::c_int = 0;
    let mut buf: Buf = Buf {
        start: 0 as *mut libc::c_char,
        size: 0,
        count: 0,
    };
    memset(
        &mut buf as *mut Buf as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<Buf>() as libc::c_ulong,
    );
    loop {
        ch = lglnextch(in_0, lp);
        if ch == ' ' as i32 || ch == '\t' as i32 || ch == '\n' as i32
            || ch == '\r' as i32
        {
            continue;
        }
        if !(ch == 'c' as i32) {
            break;
        }
        ch = lglnextch(in_0, lp);
        while ch != '\n' as i32 {
            if ch == -(1 as libc::c_int) {
                return b"end of file in comment\0" as *const u8 as *const libc::c_char;
            }
            prev = ch;
            ch = lglnextch(in_0, lp);
            if prev != '-' as i32 {
                continue;
            }
            if ch != '-' as i32 {
                continue;
            }
            ch = lglnextch(in_0, lp);
            while isoptchar(ch as libc::c_uchar) != 0 {
                lglpushbuf(lgl, &mut buf, ch);
                ch = lglnextch(in_0, lp);
            }
            buf.count = 0 as libc::c_int as size_t;
            if ch != '=' as i32 {
                continue;
            }
            ch = lglnextch(in_0, lp);
            if ch == '-' as i32 {
                sign = -(1 as libc::c_int);
                ch = lglnextch(in_0, lp);
            } else {
                sign = 1 as libc::c_int;
            }
            if *(*__ctype_b_loc()).offset(ch as isize) as libc::c_int
                & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int == 0
            {
                continue;
            }
            val = ch - '0' as i32;
            loop {
                ch = lglnextch(in_0, lp);
                if !(*(*__ctype_b_loc()).offset(ch as isize) as libc::c_int
                    & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int != 0)
                {
                    break;
                }
                val = 10 as libc::c_int * val + (ch - '0' as i32);
            }
            if lglhasopt(lgl, buf.start) == 0 {
                lglwrn(
                    lgl,
                    b"parsed invalid embedded option '--%s'\n\0" as *const u8
                        as *const libc::c_char,
                    buf.start,
                );
            } else {
                val *= sign;
                let fresh321 = embedded;
                embedded = embedded + 1;
                if fresh321 == 0 {
                    lglprt(
                        lgl,
                        1 as libc::c_int,
                        b"\0" as *const u8 as *const libc::c_char,
                    );
                    lglprt(
                        lgl,
                        1 as libc::c_int,
                        b"embedded options\0" as *const u8 as *const libc::c_char,
                    );
                    lglprt(
                        lgl,
                        1 as libc::c_int,
                        b"\0" as *const u8 as *const libc::c_char,
                    );
                }
                if strcmp(buf.start, b"verbose\0" as *const u8 as *const libc::c_char)
                    == 0
                {
                    (*(*lgl).opts).verbose.val = val;
                }
                lglprt(
                    lgl,
                    1 as libc::c_int,
                    b"--%s=%d\n\0" as *const u8 as *const libc::c_char,
                    buf.start,
                    val,
                );
                lglsetopt(lgl, buf.start, val);
            }
        }
    }
    lgldel(
        lgl,
        buf.start as *mut libc::c_void,
        (buf.size).wrapping_mul(::core::mem::size_of::<libc::c_char>() as libc::c_ulong),
    );
    buf.start = 0 as *mut libc::c_char;
    if (*(*lgl).opts).verbose.val >= 0 as libc::c_int {
        if embedded != 0 {
            lglprt(lgl, 1 as libc::c_int, b"\0" as *const u8 as *const libc::c_char);
        } else {
            lglprt(
                lgl,
                1 as libc::c_int,
                b"no embedded options\0" as *const u8 as *const libc::c_char,
            );
        }
    }
    c = 0 as libc::c_int;
    l = c;
    v = l;
    n = v;
    m = n;
    section = m;
    header = section;
    if force != 0 {
        if ch == 'p' as i32 {
            lglprt(
                lgl,
                1 as libc::c_int,
                b"will not read header\0" as *const u8 as *const libc::c_char,
            );
            loop {
                ch = lglnextch(in_0, lp);
                if !(ch != '\n' as i32 && ch != -(1 as libc::c_int)) {
                    break;
                }
            }
        } else {
            lglprt(
                lgl,
                1 as libc::c_int,
                b"skipping missing header\0" as *const u8 as *const libc::c_char,
            );
        }
        current_block = 5885025795279782672;
    } else {
        if ch != 'p' as i32 {
            return b"missing 'p ...' header\0" as *const u8 as *const libc::c_char;
        }
        if lglnextch(in_0, lp) != ' ' as i32 {
            return b"invalid header: expected ' ' after 'p'\0" as *const u8
                as *const libc::c_char;
        }
        loop {
            ch = lglnextch(in_0, lp);
            if !(ch == ' ' as i32) {
                break;
            }
        }
        if ch != 'c' as i32 {
            return b"invalid header: expected 'c' after ' '\0" as *const u8
                as *const libc::c_char;
        }
        if lglnextch(in_0, lp) != 'n' as i32 {
            return b"invalid header: expected 'n' after 'c'\0" as *const u8
                as *const libc::c_char;
        }
        if lglnextch(in_0, lp) != 'f' as i32 {
            return b"invalid header: expected 'f' after 'n'\0" as *const u8
                as *const libc::c_char;
        }
        if lglnextch(in_0, lp) != ' ' as i32 {
            return b"invalid header: expected ' ' after 'f'\0" as *const u8
                as *const libc::c_char;
        }
        loop {
            ch = lglnextch(in_0, lp);
            if !(ch == ' ' as i32) {
                break;
            }
        }
        if *(*__ctype_b_loc()).offset(ch as isize) as libc::c_int
            & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int == 0
        {
            return b"invalid header: expected digit after 'p cnf '\0" as *const u8
                as *const libc::c_char;
        }
        m = ch - '0' as i32;
        loop {
            ch = lglnextch(in_0, lp);
            if !(*(*__ctype_b_loc()).offset(ch as isize) as libc::c_int
                & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int != 0)
            {
                break;
            }
            m = 10 as libc::c_int * m + (ch - '0' as i32);
        }
        if ch != ' ' as i32 {
            return b"invalid header: expected ' ' after 'p cnf <m>'\0" as *const u8
                as *const libc::c_char;
        }
        loop {
            ch = lglnextch(in_0, lp);
            if !(ch == ' ' as i32) {
                break;
            }
        }
        if *(*__ctype_b_loc()).offset(ch as isize) as libc::c_int
            & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int == 0
        {
            return b"invalid header: expected digit after 'p cnf <m> '\0" as *const u8
                as *const libc::c_char;
        }
        n = ch - '0' as i32;
        loop {
            ch = lglnextch(in_0, lp);
            if !(*(*__ctype_b_loc()).offset(ch as isize) as libc::c_int
                & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int != 0)
            {
                break;
            }
            n = 10 as libc::c_int * n + (ch - '0' as i32);
        }
        while ch == ' ' as i32 {
            ch = lglnextch(in_0, lp);
        }
        if ch == '\r' as i32 {
            ch = lglnextch(in_0, lp);
        }
        if ch != '\n' as i32 {
            return b"invalid header: expected new line after header\0" as *const u8
                as *const libc::c_char;
        }
        lglprt(
            lgl,
            1 as libc::c_int,
            b"found 'p cnf %d %d' header\0" as *const u8 as *const libc::c_char,
            m,
            n,
        );
        *mp = m;
        header = 1 as libc::c_int;
        current_block = 12930462527839722677;
    }
    loop {
        match current_block {
            12930462527839722677 => {
                ch = lglnextch(in_0, lp);
                current_block = 5885025795279782672;
            }
            _ => {
                if ch == ' ' as i32 || ch == '\t' as i32 || ch == '\n' as i32
                    || ch == '\r' as i32
                {
                    current_block = 12930462527839722677;
                    continue;
                }
                if ch == 'c' as i32 {
                    loop {
                        ch = lglnextch(in_0, lp);
                        if !(ch != '\n' as i32 && ch != -(1 as libc::c_int)) {
                            break;
                        }
                    }
                    if ch != -(1 as libc::c_int) {
                        current_block = 12930462527839722677;
                        continue;
                    }
                }
                if ch == 'o' as i32 {
                    if section != 0 {
                        return b"two section headers in a row\0" as *const u8
                            as *const libc::c_char;
                    }
                    section = ch;
                    current_block = 12930462527839722677;
                } else if ch == -(1 as libc::c_int) {
                    if header != 0 && c + 1 as libc::c_int == n {
                        return b"clause missing\0" as *const u8 as *const libc::c_char;
                    }
                    if header != 0 && c < n {
                        return b"clauses missing\0" as *const u8 as *const libc::c_char;
                    }
                    break;
                } else {
                    if ch == '-' as i32 {
                        ch = lglnextch(in_0, lp);
                        if ch == '0' as i32 {
                            return b"expected positive digit after '-'\0" as *const u8
                                as *const libc::c_char;
                        }
                        sign = -(1 as libc::c_int);
                    } else {
                        sign = 1 as libc::c_int;
                    }
                    if *(*__ctype_b_loc()).offset(ch as isize) as libc::c_int
                        & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int == 0
                    {
                        return b"expected digit\0" as *const u8 as *const libc::c_char;
                    }
                    if header != 0 && section == 0 && c == n {
                        return b"too many clauses\0" as *const u8 as *const libc::c_char;
                    }
                    lit = ch - '0' as i32;
                    loop {
                        ch = lglnextch(in_0, lp);
                        if !(*(*__ctype_b_loc()).offset(ch as isize) as libc::c_int
                            & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int
                            != 0)
                        {
                            break;
                        }
                        lit = 10 as libc::c_int * lit + (ch - '0' as i32);
                    }
                    if header != 0 && lit > m {
                        return b"maxium variable index exceeded\0" as *const u8
                            as *const libc::c_char;
                    }
                    if lit > v {
                        v = lit;
                    }
                    if lit != 0 {
                        l += 1;
                        l;
                    } else {
                        c += 1;
                        c;
                    }
                    lit *= sign;
                    if section != 0 {
                        lglsetimportant(lgl, lit);
                        section = 0 as libc::c_int;
                        current_block = 12930462527839722677;
                    } else {
                        lgladd(lgl, lit);
                        if lit == 0 && force != 0 && c == n {
                            break;
                        } else {
                            current_block = 12930462527839722677;
                        }
                    }
                }
            }
        }
    }
    lglprt(
        lgl,
        1 as libc::c_int,
        b"read %d variables, %d clauses, %d literals in %.2f seconds\0" as *const u8
            as *const libc::c_char,
        v,
        c,
        l,
        lglsec(lgl),
    );
    return 0 as *const libc::c_char;
}
#[no_mangle]
pub unsafe extern "C" fn lglparsepath(
    mut lgl: *mut LGL,
    mut path: *const libc::c_char,
    mut force: libc::c_int,
    mut lp: *mut libc::c_int,
    mut mp: *mut libc::c_int,
) -> *const libc::c_char {
    let mut res: *const libc::c_char = 0 as *const libc::c_char;
    let mut len: size_t = 0;
    let mut in_0: *mut FILE = 0 as *mut FILE;
    let mut clin: libc::c_int = 0;
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    lglprt(
        lgl,
        1 as libc::c_int,
        b"reading DIMACS file '%s'\0" as *const u8 as *const libc::c_char,
        path,
    );
    len = strlen(path);
    if len >= 3 as libc::c_int as size_t
        && strcmp(
            path.offset(len as isize).offset(-(3 as libc::c_int as isize)),
            b".gz\0" as *const u8 as *const libc::c_char,
        ) == 0
    {
        lglprt(
            lgl,
            1 as libc::c_int,
            b"piping '%s' through 'gzip'\0" as *const u8 as *const libc::c_char,
            path,
        );
        tmp = malloc(len.wrapping_add(20 as libc::c_int as size_t)) as *mut libc::c_char;
        sprintf(tmp, b"gzip -c -d %s\0" as *const u8 as *const libc::c_char, path);
        in_0 = popen(tmp, b"r\0" as *const u8 as *const libc::c_char);
        if !in_0.is_null() {
            clin = 2 as libc::c_int;
        }
        free(tmp as *mut libc::c_void);
    } else if len >= 3 as libc::c_int as size_t
        && strcmp(
            path.offset(len as isize).offset(-(3 as libc::c_int as isize)),
            b".xz\0" as *const u8 as *const libc::c_char,
        ) == 0
    {
        lglprt(
            lgl,
            1 as libc::c_int,
            b"piping '%s' through 'xz'\0" as *const u8 as *const libc::c_char,
            path,
        );
        tmp = malloc(len.wrapping_add(20 as libc::c_int as size_t)) as *mut libc::c_char;
        sprintf(tmp, b"xz -c -d  %s\0" as *const u8 as *const libc::c_char, path);
        in_0 = popen(tmp, b"r\0" as *const u8 as *const libc::c_char);
        if !in_0.is_null() {
            clin = 2 as libc::c_int;
        }
        free(tmp as *mut libc::c_void);
    } else if len >= 4 as libc::c_int as size_t
        && strcmp(
            path.offset(len as isize).offset(-(4 as libc::c_int as isize)),
            b".bz2\0" as *const u8 as *const libc::c_char,
        ) == 0
    {
        lglprt(
            lgl,
            1 as libc::c_int,
            b"piping '%s' through 'bzip2'\0" as *const u8 as *const libc::c_char,
            path,
        );
        tmp = malloc(len.wrapping_add(20 as libc::c_int as size_t)) as *mut libc::c_char;
        sprintf(tmp, b"bzip2 -c -d %s\0" as *const u8 as *const libc::c_char, path);
        in_0 = popen(tmp, b"r\0" as *const u8 as *const libc::c_char);
        if !in_0.is_null() {
            clin = 2 as libc::c_int;
        }
        free(tmp as *mut libc::c_void);
    } else if len >= 4 as libc::c_int as size_t
        && strcmp(
            path.offset(len as isize).offset(-(4 as libc::c_int as isize)),
            b".zip\0" as *const u8 as *const libc::c_char,
        ) == 0
    {
        lglprt(
            lgl,
            1 as libc::c_int,
            b"piping '%s' through 'unzip'\0" as *const u8 as *const libc::c_char,
            path,
        );
        tmp = malloc(len.wrapping_add(20 as libc::c_int as size_t)) as *mut libc::c_char;
        sprintf(tmp, b"unzip -p %s\0" as *const u8 as *const libc::c_char, path);
        in_0 = popen(tmp, b"r\0" as *const u8 as *const libc::c_char);
        if !in_0.is_null() {
            clin = 2 as libc::c_int;
        }
        free(tmp as *mut libc::c_void);
    } else if len >= 3 as libc::c_int as size_t
        && strcmp(
            path.offset(len as isize).offset(-(3 as libc::c_int as isize)),
            b".7z\0" as *const u8 as *const libc::c_char,
        ) == 0
    {
        lglprt(
            lgl,
            1 as libc::c_int,
            b"piping '%s' through '7z'\0" as *const u8 as *const libc::c_char,
            path,
        );
        tmp = malloc(len.wrapping_add(40 as libc::c_int as size_t)) as *mut libc::c_char;
        sprintf(
            tmp,
            b"7z x -so %s 2>/dev/null\0" as *const u8 as *const libc::c_char,
            path,
        );
        in_0 = popen(tmp, b"r\0" as *const u8 as *const libc::c_char);
        if !in_0.is_null() {
            clin = 2 as libc::c_int;
        }
        free(tmp as *mut libc::c_void);
    } else {
        in_0 = fopen(path, b"r\0" as *const u8 as *const libc::c_char);
        if !in_0.is_null() {
            clin = 1 as libc::c_int;
        }
    }
    *lp = 0 as libc::c_int;
    if in_0.is_null() {
        return b"can not read\0" as *const u8 as *const libc::c_char;
    }
    res = lglparsefile(lgl, in_0, force, lp, mp);
    if clin == 1 as libc::c_int {
        fclose(in_0);
    }
    if clin == 2 as libc::c_int {
        pclose(in_0);
    }
    return res;
}
